<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>附录：蜂窝移动电话网演进</title>
    <link href="/2022/07/03/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/%E9%99%84%E5%BD%95%EF%BC%9A%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F%E6%BC%94%E8%BF%9B/"/>
    <url>/2022/07/03/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/%E9%99%84%E5%BD%95%EF%BC%9A%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F%E6%BC%94%E8%BF%9B/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="de6d973ced0e740c62b71153d5196eb6854d9e7b22c314bf736c17f260bddfef">d23a4056e39b7e810998c80d99c7e17f86f9f2d02bab1f8b5f4197996369e4ef35fe438151888b19329619ee5fb8c6350114a8368169e5f8b3078b8558900e997ba6944a52881d53d553f28ab5f2db865abe2b5a363d7d598309fefa80f0014ce3fe25890715409a22e6b19584d1d28945930fb53e95dbf1065524a4df9890ebebae658fcf3c816d0394342ea7c57a253a8b00e5583f34f28d3f3bd33cf70cb2d63b7c844fb7661bbb45a9478ab976d02d0e65cb7f44ed061a1bca48e87926f27cf9fbc39149298d2d2e3183cc91c8512c98ddba6e89d7ab3160b44fc2ea28f86462c1f18a872459bd1a49c02f49dccdf0eef436a1c10c5eb655ce6c5d95b7b2d74a1e0cfc006a246294f80a87520d6f06cd127edde563a11ad7972b4e3f51c7a824ac381fc1b0c4c75aaf4aedb663c085f733b9f038011a63918e944d7b195f3aec2d7efe8d019a4ae853e8a6465e340564c3bc21d821bfc639e862261ae1be06c5ea1d4811a39bc1e5d2059d0e5e8140700363557adf3d8e5c96011368d72c9b22ee3fe1118da443b60165f4e51dbfd54b656606d3841c34269fcd2014150abac201545a990dd531b8c2796086daf0c6c3fbce47637366b9212ef1a2d0c7828bb94f6e4eb152d3daad195dea109e6259c3ba5016354592fa5818349934d108c6bc920892dc9c5992ea8865196d3d0451955b659cc38443bafaab057899dd3180165bc57987bc7597242b6691c2c6bd0990682f00b19b531e2ea9c339480ec7eda588772b17bb85e4b89555f0c54e8659afbbf37d364569b281e712d8ccd3b44187ff5b0194eccab0b902f96ad313bd1b4e524ac6e35915a4eaf805b22a9f413fc7c27adc7ac4c2fdfc8b3947efecc42f1f609432747d342dffcd46c0a094d947cd4bdef0f1545e34a397acfa5faad72431c1168e5404c583f1f920e6a8636828af771698073159fb3a42836a8e0b2240e8508e8ff878e0a7e901278998c955b2d28a4aea59ddab694838aba0d4c594f0bef65df6242a1a504b10f03e4444d54afdc1a6b12d9a72cad0bea1499a4f17e627828749f09eefb5160aafed2803f0d93f916b826b889fd11f55bc6180a0166778a1b3f37fe2af9f1606479bc2ac61b7aea8e72492123793e7b45ab19a8e494fee4b2ba364756458c00d77d219fb4a03acb224fecebcac7d77b6676e97a2b3992e4e50755863a7730687c7def58506415fa2398ff497c050df4308f6207f18eebbd49e216075eb00d46094eabbcc36c5b3c87d15be6ef28d161298671de66e8c5816d620597a15260a8ec922932978cfc5ff8c0110294cc70886dfe79fe52e6ed71d8d666391b103a0fbfa9459224294b26ab57ad8ef4f19f80aa31b286e6a2cad2ae5a38f2939df0f281541e5a2f65977f231ea74ee1012b211d3f3ca225dbb2f74160b4494e16c49c1e0b5965befcead1f8579d6c94f9bdf4b73f13f369ebda445d142c0d8c17b0f543109b32b4ae641ced7365c53a2a7105d8deb7632a192e4a8e9cf187f5bb41957689a97169e98033837c2b51a8e21a7e2d838ebedb148bd6c71adc5a04a45dbbc4d36f7f97743cab331c564282afa987effab3882e6008a0bfecad89b6ced3b16eb8e709d6f8a28f5bf6f341cde4d3656461c283afbc336b5e47914d71e32c43ad0afb452b42a8dfbf00f3b3fe1fe6e2ba6c214a4474cb40f7fe4b57a28da90ad468f45a845fb10b739d087f317fceae96d2e2f72f081d9baf39d83b8292e4925c084750bedd782f3c3772f89c65b798e04d0e1fe99d2ab1f7ca273046b9537699acf2becf38a6d898bf91aae6070b52e2fd436ffaf92e315757170270227d705fa69dc56c2e7c5c15e401da949891fcdbc6619549804b191a93856ef58919b6b525e06af5bbce5d61fff0647e4bf37644b6728970d390a0b48cc002bbd41e01eca5e73fe58317b662cc4d7fdb5b2856ea8e532c58689ecfd287a438235056d0f838d1a265ee1784c529ecc2dcf52e213dd2465d84c60448a9802703454d3af28e2421fd0c834da50c5627a0464be295458d2663c2532e42ea0bacbb7ca117c706feab35570220dceb91ee33e1112a79203fa982584ac7f910a64565254953f6e4db1edc0be445fe0a481755002db66e6a83fdccf5702800c5e72fcd3511369a75e50b93190c98baabe46c446a3cad137dc7308bfec1a3909f41dbd8460ce848c4a5e57cdbbdf476021c73aba73b7dbcc3ed80c96ce32c5f1ceb733a021206adff7a7057e6a7c81bd19dc6c3550fd5d9887f1303094b72f33ed55d319bf5a5914f0694e3ca6f5746c5adb32b5882cbf09faa51f3e51d8e6c655b26550a2befddca26b8bb0a6745b359bdad52ea8acb9b43302e9662f4451242906f8be963ae6d71a86c96c625aaebec2d9a3e746865b37f417eaf1794523fcd056ca18776749eacb4fa8f0385833af32b17e10003ca4048040204297f1cc7125a082fd6b80e60ac6367461df42433ae64075a1f8cacebfec2a0db8d8398a1548c38bf56c73df1c1d3ba8fbd1b712ad23841dcc766f589f0c6a68fa8de68bf843d26bb67a0b8086db204c35b0c56bf3f54acf7f5547ae4bed1e7b59c32b661ad557bd825a3397b9859a19ed4ab63c67e74f39b090c6b0f331134a30d74711621f6a8137ee084084fc5ff847b507b3b5b1783f7013721879fb79a62edd3f534fbc1e7412072b3201e53b83eed571e9f513129e67dc363ca542a22230f6be33abe4b71a5e3ffe0ea0da903f4f4dafbe02dd672135c35a65ee46ddf898bbe102f779be8b3ea5f43a4fbde942681837a763a8cf37e2cca0101d8bd286acd50433ce408b3d71c8cc864d0a4b3185213460da6620e04107a2fa003aa87aa5cd763a143b4a8aba437c3e2220263396ddd5e481ca97c9419c90aa0eb4f60a809353b8fcd8d09c787ff2c309a14a35bd784c1aa758c0fa3dd0415eb1c257d3dbfc5e44294ca5d82d579774082947f7ff8d8737e313c478e7f0b405e3ee3f10825f84eebdb6eb796d16a2932786f0b62884a26043ec3b4226a995af51506857e8a9616fe83e0b1c20147e2860fde2c432893ce8e9edf355623c3a8617777a635fc14955bf1b41f1385219c7e536c7d6a6b2b8e7d8a073ae424fab1f70a66827302d8c0950700a24d5de4b8d273b14136a5e55555ef2a9f435bb3b9c3715b68100fa91ed822e67f7b4b370b802b037a6e40fe95b1e2dd82f3aee6346ac6bb9cd93c0dffa544622bc1805cc59af43e3d7fa4a15fd33870ffa7245c5fb958a9e8f520090e48113ad04073dad223bcb445367502760bb720efd9c836f37f886b0638ba9827eb99b94732f4306d4c42adb656658d4b27f1a58b8e392c77f3ee27c89b2b3276df45136e5639c4db9079e8f737e223c3b5775afc2b7c1b0da2dffb7ad1fdd26a592a189cbed8ed265a5cea247315e7754b4ee6a85fc0dbdcd33c0ca448b6f297a21dbca3cf8b75072c8f773b76965ac81e957db8e6a63ef614038b9a0f19c3f33e65160bf377497e545451ca55b5115eb7e854cfa05ccff5acc2d6783fc71af5cbcb6ed8e10b8e9a396cd54302ed795ed15f6a3e6db279c1faf6c902a37b97f66e710e17daa955b728dfe9f235a8df3ddf92edc7b1b3844cce2968a509752b611d271ca7596428f0b68c4fc709fe298c76d23b792af23869baee919227b0e1e997cb1e5cc9279a08d02a87e7efe30d5497b9aebe95203245661cc7626f2f138d25fe9fdf8fe91b649fd70d31665964d1bd378be4ec42c4256112c6bffd1793d509d0f6efa2351f007488608ffecd85e3c01cab808b7e19734ed03dc98fd60688d8ac8c44c4d9676082ac2b14c9c9560d95da54ce652f643e8e0c037d637b568f41bcb5ae1e05d052682ccd8c1ac775f8473d449a2c553bcf8894c357e96d0b4198a33de18a890b1865def4efcc8d982b77cd05f6c5329d4b4e2b1cf258969cffa0f6d5a733a22bdc38c4dcd1edd36edc5eb996df3dc2b5cf1408bea0a0a7bedc3bcb6897db89602b78b184fa70b6bbc9caed80c80244f48098e0bb3f47c766f4bfea7173e5ad3d2eb01fdb9c8b1f9eb31745e26ea06c8028993239f8ef0cebfa5f7d1bd5ddd0a1191c25518dcdbda054ea4224ed2bede61a96f45ebf92e465068a4eef0aa10c0d3b9fb3ad2e9b7dce4ed59d60d9b52a34cf98588ad69b930e83095e23ade0a0ccc84b0fc494f6395618c81ba14f55f4e673d61806d9a18ad48c4419284e5307241510c92dba6c9b30fbcff87a69679c03d7179f1bba3c5cbd6fc3f272ea58141ece99a8be77b22301faa3a9c631b0c026e1d8fa71064d8fd4b1933f8fa54f2f2e75731a25f408beace07c7ce9aeaf3db872fe870052b6074847f06755f116e3f46045b3e22c4d6b1db42b12eda7336df4b8ae33d129c4200a402926ebbf7aa471e6f151ab4a38e3a7eb979205a43b3044adeca8d36cd336d5fad0e17185d0ca256367c0961f01712ae59de349369ffef1f452bc9712d90bc2185703d5e9ca76531eae7cbfea559c0afd7faf74a54d58055c4ffe70170e4a374523cf8b926be6dc16c347edf4e3a374737d7a167ad87d6c17084b9e7071c9002839a359626f34144dffc9f7935664890ec398fe6abfeb920e8425fffb23401956f68bcd184ae18ddbca8b0346305b8d3e9271483087751046228c0d98011680f2035888d375c4ef5ecc2d70718d297257308ad35a8dbbd8df6547449d8d17750504f5a16b5c34deb931004b785e718e71cdaf199e6a23470e46aaaaa9db66d2ba67afd5b2aa9d7f6a5d073af583350421da5e0a598d5113d750720f4eb6e910caaaf9aea167b7e13e4a07c2b5804aade3bb52fe298cb2dcc2d26dc27911064f2ec00ac51bf41167639326e496b4d1532723c2e57cc6fcdccaf60517dcfdae75469df37192387e383a6b3ba8d2206b26e5e5de19a96c718819f0c317deebc23588df97b2acbd40c535c8c46d45d7dfcce11a7711d79fc1ba26880495cc707fc601b480aee7cb259e665b7c8660df6e2e9da0cf586d3ebf8ad107c81df1ac159f97d91334bf9053a935ced35b3bbd8b9e2579cfd3a88646245782047b71fabcb52cf1654bb7320b803b88242aa70d2fa70fb629179060463fb2b11ebd45999cd8a9db0506b40706938a0555d352d837c26bcc9f2a516ab3858bd294e9756e25f4aa05904c552c6b362fea0d0e1326c8855d0f01db5d5464030e964aa3b0f8bf69483b77536ae86b59e926f2abe9012cbe970296970ecb9f6bb9af0b60857e222a68469d3b469001ba5b0ecd3a7165ecb59d0997c7ad41834304232a1e03389bba1b0b2b7938cf536ffdc7b49fa2ff9d4</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">诚信考试,不要作弊</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>移动通信</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>移动通信-知识点总结</title>
    <link href="/2022/06/22/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <url>/2022/06/22/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="1475322a9b275c1d28d866d3e98b1b52e1260aa86e3229d1b237d29d54cad9a5">d23a4056e39b7e810998c80d99c7e17f86f9f2d02bab1f8b5f4197996369e4ef44493f53986022b248570954641e5a99169795bbbff464826beff794808f5587afb7488a2b41c505435d83871db13907dbbbe42c76b96e27ca28b3ef4b3861e89e537079f3f727ec1ebcdaaa7df883bd5684ddba8ccfe35304041e1df2731549e20e9351c29a31cd5d331fbe2606019130849264abef6e21498ade2afa6ac932316ce32a9757be143a61533dc5959f494ff41ef0b06a23da2a9c56d83e8ceab81a11c072283c217fb107aecdfd96ad9bd0352b8717dd8b95a403aacdf64d454acedea620e837d755666bdebf44937bb8993d33b17a5de5e51816bb953d14e778f155b779849a416dd729b32be034c3f3e6a88a41ac6428bf920e8b72c5630b38ba14a5cdd28c719ce1cd52ba9ce930b4cbe19966585059ae96efe39460fa6fe8fac8112740e5ec416faedad5c8560c8cabc0e2fa356d5694253e2a7deaf0c70f6c7d8b0435e73a1422e2b1cc206a8a5c87782f6cf9d634743ca2e09e77372fef87e3ce5e61db71c3ec0ee0e16a5b3562f2ecdfe8619141583b2b082d84ad3af2920bdbde69cb9cce22a53912b6ce8c99739d64f7416b7708747dc19ced1aa9e67b7a746beb03e04455cd6c67c4c5236e589528dd447cf76cf2b0074c098b6f66af70789eb017f6681aa769654a892569372df39c8b2c84a57f70d296c77e75be19acc2e025e04f1153e1459426c686e4a22197b28be83b85048341a4d86ddbcc45de6b73516d6172ac744f818542c2622ab52d7f00850d4e49ca5334979b4fbb17332999f760bd6e3707f3ba6c9fd0292b8b41bc5e4a27b168b72baffc8081e48d81de287cefaec2f71a18e2b42d0202777b3825727040886cf2e6c6bdd62007cc968c1e8552af55bf2d091b74288e8824c1d3f0d0e8dea8a39441646cfe350954acc4af62c08526ddcb815dbf688a9a119c7541a601e8802f7ec8731e959e4ed38966b2a0bb21bad6a733d555ee9db370fdd85619046b3c31edc4b5642bdcba828f71ce090197845a3a68b9787405718ca6f3caaa059084bcd0a089ab567fb4b76f850594e9f4f6e0b5f39885e1ea98fb9103cbafa5280bd84b3a653e71be1e07eb3340e9716a70e63b9b90fb0421a24d7e9fd7cd943afdbd0bfd1f380e67a339f8fffcd51e96ebd8f68c35f1cdfbdead2a1a9d500f1fe8909507b26d20be9adfdafb52f9196a9faf1c0b4c3dde7622ca7e6b06087c6f69358d77f7957186877b981f2647047b99e691b270e72f42c74a5fc01c6be2f0df771d7fba55293be69567bc8e3ae249652781b006b7aa8deb01faaced5f0a4938d9062878af4f1267afee4d5064a7a37e8ececa3961eb04e996bedc71683cac54c6a14bad5aba44111faeb0e9bf406169d6e15820ac72e9060146fb7daa46e3dbd963b0d8f29c01d31a4502a740c71b6fe82c0f814e303c642e77f23c22c21c42725a94c5a99516ddab178384ee956b3190bba94d02b62a435cccc298a1962950ad3c5a79372710fb2d40c92e48c69b92499e78aecb3ac9c09ad1c6965fca933238db77432193e5d81c64bcc6a9e7f5cb8515ccbe9dd2e44e396df55f00d241a01f34708d9f21d56379792654b8c69358474824cc7e957581d03b6a5a89b300eb39cde56ae915b9779ba1fcaf675ce95d7cc1d5df7ced675a945bc5259e1e8452d321f31e05b580669ec63953a3eec3124273dd247e3d774bb73ae51cf1dc7094a0a5bf0ff44e6096c0e873c5c42d29b9f9fac3069ee4768354608fdc30f2ea90cd6c7f4dc28d85d304d274686e8185df24f707685a512db0144f36230d439c9ded52c005c44c5316713bd90b3f4f895a8fd765cfc6b9633eca94d2a8e835f270cacad9f541b10c02f30ca5c506531ef22d76af8c4dc19666b7bbd7c5ac97056139c26eaf24fd665e0170a14c4fe72dd0efa58063d9adda3db5ceae43fa061720fdbdaaeead248f1ea5feb8bac0e46a9f973349187930fe84bfe669866376c34aad34474a9d6a513acdf963258abc690fd09f540e969e7beeb2861de8887d42708aa65ff082804d610c0a89a039b823a2d6af7953f2a56e3770fe07540dc732c813c032cc3855d3daededc180ae7055cc0cf1e66471620d4264e1f4ad14a5c30c3b7ea9debfce460ce3eccb50e7170f0a58507ea59a81b8d9073e88dfc07d8dac0368a7ffe9265b816242bdc537f3ccaa78ddb84a7c9c47c369547e56e6e969252c0de308b164b31b4f977cc7ddfca188431ef82ddfcb0c693d9181cd7c1d73897164d96b3e43ef6db299c95111dab1885ce031c1d93d96a8c33bd65987206f662f1e5deda03838c9be5b554797abf0b4e4d67dc03627fc61420975c226e5078c1b873397aa99070c20c730ad9ce53c0babb64a67b8748a729e77b49fdc23520701e3ecd2f3a639386aedacdb6f4518fdfa5b8010257a2128905624df19170372de913fd44c4c88fb50a51dd5c96d51a4530e1e807879fb16eb552dcdad38e514672394ca1bbc788161d37f559749721181471cd8fc2e7e89b0e1f197e8723c1d6494732828d515017a00435cd175f4ecd44a72b50b8129fa7076ed47fbc2d1e84ee17711910ede382c2d56a04111586f08926c673774d92c580ffadf1545c572c5b80ee969d4cdcb10200aec1ce964d80a6dbfc720971f731d70b4115cd221a8147f65468269ed8a40c912d8943552261d4198202dbeac1d18b8ef97accf196a02f0202cbc79d74a0bb90713bf0a25302c5df7f8fce0cdcd4316acfcd57c8d26b266fe4887327f079d727a433c2214aa11a17d73134c3e64c6a7e1e499b6b38eb90823e10c6172e0619d905bbda5d8b17c9c8c2dee7cff9ddaaf349ef4608feeeda79a2998834cf9d83edb05e70bf036a7360603aa745248b401fc85a15a71a8e79a911dc955d23941bc0f2b113129570d9800662eac8f9cd260921c05a60edb6bf80dc7e164fbfd989bd5557e6d11cd888b9c586199865f6667fb0a7a5fe08bcf434b62e0b106207a3b54ca44378f1b5cdd6ea6320623cdd5f405d68edd4c16c62ea2ddf89bd831a4c6975f3b63f1172c55d0b2bc7fcd03dfec0e2a8ac3c6d5a6ee96f384d27e9c36481b04e5d60343f35e79c8cd782e43dd2e13900cabe34bb03e3f5a75792bd7ff2fa63e42d095f56e789a4d9a698f7d93cd1d9ac73bee519dd72e28ed6c130f1c09fa12cacefcad2c68c1f6b6babd8df74a6f47516564b01b0f27e536eab1f40e6c75367ce1712d5863c432c5e2ec613237bfbb5898d10ed103c9fcbc7d548cd9f6966f7a536c039c5a56d0288459c40d12706f9dd4eafed3ce535b0d14e75e25ce1de31ac08f88a957c714ac00cfc870064ed6c35a045d9c223aab2c318066ccb7a258b2442802f7a70d3beca2ad1970a27050fc3970d12e9ff6c7d85a23778c1a75d6936cff12fe018e0fc0f3409b126c386ae375e310486b9f311920da9c52cfbb1333619b7ba17ea26809b4a10a4307300a8cf7ec4461750ead0176f00500ac259634eeda54acec33f93193ffc927e1874ed60685c6ddd71e0974a697d567b5923134c871205779429cd8e5d957360a18b11f7bafc38f868eb5788a6b97da2d2880690a29a27764b9ac412aa9883310a27b6ed3a56a9e1d3d8bdd53069f3f43c8d073ccc0472e1c2261a4cbc2dbb5cd09c659f1e479f7134fdb2737d1383ec7844a42d5fe91bed45011194759871950b43f437736534b3b88779fd011a0f3ab38590f87de2c0b2ace56284717a0a106184cec8b38d00d7b0cdf0c4d21112581874fef5fa142ec2a959a491ac821564982937e94012c0d6cc008573bfa8a5f1c7d9436a86a787b92375879fe30fe2491f7d00d5a9a73f7ddc46f89ef5df70746917c35aa3acca44fe16018100955b905df01aba8874158c44a44a0b33e70599e2bb9a9756c7f84e7a79741f34bb637cbf0bf2d5c167a40fa7bdd63e37b2982d98de698716470abc892d8a0cb464f4fa03acc40c09df0bba097b5ce056aa787b23e9002e6d04d581053e21c675d7e370c9917a03af1a056149e805f4f37e3ba2313b2b4e299fc8c13183c7280f7ec40cf2aaa6058b1e361e17b8ee03fcb8a0b577388cd49b49c002ed23794c7f106aa0e721b616bf91e07bd8a23453c44e77d5a12d95f67a2b9cf390e6a73b63d30f86bfb1362619a347d29785b59405ccea97c90b3814b1316e039d6c721e79564dd8c4c59d96c7bcdcca05182ccf918ce41215e467e7fd1aaad3dc5177756ef9ed32f125815191e8a1abaf6f0c82a30f7f92d8f8ef4fc0204610c9fcbd9c813444e85675fcb2c4cdc43be9a832f546734ea0b0d7c1c9c2515576c191cf4eef784ed37e9cf5d5d7de25155ab9a821cee0ba67935f56d3ea31c35365cfe81eb0e188866d1ec906f528428e6977f3f104ca4571d0023b8edf40db80a3d147785beab2e463dd92493a96df7d96b90d75e04d07bc63ceec240edbcf052361fbcf0af2b1920bfb3f2fa6f21d6c32f858f8a4ff59862e5121f8d5e378fc46683655c20669a4726d1e7ca064e679c1c500532d54844b3f5d543718e5c17271a26279657c0ddfa07c34b01d9925d258909e993dafec942fe16021e9cceb7f83aae99ffc83868038d2d05517d1dfe643823a118bc0249276efc2a340e9dabcf59ff887d565349b7f6fa41706661e0fd48eee8ce0b18ba9af2fe254e4dff2c7e29ab8b6de2b5f5f5fe41836b52bf45c019334f766095fe70d52c7d01bad2d42e7930ed08622f3f89226eb53028ca55c5d8891c34ba90eee903927a74064b92c98a9e34ee5cef9850d7b706c64da995b7e341e9519ea7063160f254406618b8cc0cdb37c7dfba263c03aee89f2f3702cf7cf14acdd2982c5b21ba772044acdcf4eb08235873638b57cd5ec9cb24913ef9845b14e4ae15c76c40ae34bfdd124959742fd95fbf69230bcae36478978bac0a357e4a54b87a22e5f832025f4ccc81219030d6d9a47d76934a4abac9c6a8de18db7dd888537321594f12a944e42e261e3b5437e3485662f353b1a81b3e9bfa6a5848485678f267ff521c4d5615b97e21ab985c23780bb55ebdf7185285d2c1529a604a3ed92e6debf9e509c7742c8ba3b537d1213d05097dad55d6fc789b1f5cdba4726743603ab0e83ef27a58c43b74bd77694a07743f6359247fba7e8534df4cc5a27b6915363dba6f831ac0cd8491007d3180d0497718b469583ae45f28910c77f8a1a51bf7186859ec111e6d2cad9ae8362b808dc8938715b74799f6956b18ac92be509aa5b77af518a7914cce25996d482d4843c479ca87f808a734677b86d002c1d3425c5382e374105edbeac59299cbf77c6658ead317514b5e41ef629b25b48e24cb69846c04b4f6133087b256997a69eb00601109068a7bc6058b950df83762682bf122c2a5bcad0b1e2c857a30d9b074aae61dc15f0f4da2302730d0061b92b212f9326a79607f47e9af145373a102bc4d95726f04a2222ac216b03949241a12b661d338b055e33e904d56ae2a8223925923bb16e52f46bd83d3e3bac060034b50361e125508af31adf4a985eef2a73efe9656096686906b70b9c7704849e7b413f78b6502c9b97b20d48c2b30ed91604c5b5ec40ee87065696cea162421b2a35a7682c1648019f8da87f5cb4f4135c32b6a6d3d4ffb08848f45b76cb5032faf252642efa714395bee3480b69b0cf511478127ce524b7d134cbd5b21154a7200712c4a82e85dcd89bc1310391fc200f356b081a7cccd6c6761d17f09ae04f87763a7941ffdd1d346bb9179a8bdf50ca4c8ae73cd87d96dea11b7fd7ddc5a4038f01a3d26c2bac274bd871f8745077c3b8916be620f9e95f916df7672495b65872feaf9d49c13d9008d58a0fdbb0abd530b088d7f176ccb0a6ed35ea33892f0b1eeb02c9f9bcdce4b3be775e51ee154da65bbfaf508c13dd340d37f88225fafbbc139f233fafa7a57da758e0680f12398671584b26fe356052aa3936ee4a64a5932cded2fbde5f4c1b2100340bc1cc1e668f29f9abb13da594284b3780f749e9f28264bfe23fa2b0fe26063ef05a935dde13cb6133650e2cc4338f062c8ca45e1dacc6bb2a5c13eca544de238d048fe9f246f9b375fbd15590ebd1340660c10659e47e39603156b5bf48cb845b287e25725b5b215f07b1dbe8fa033c652b1de69a544217b8e96070f983b4a66b966eab96f06c41b01c2122238aeab40be598fe7f0b37bb3f41d437242998a139059b76d0b9ebbb1ea855d13c0f7e4d28c980daef060056fbef05dc5bb0ca7adcbd27f742f4a0499ec7d15068af7e2d37d8b1e9ad39945f1841c0a6de82e0ea452afbb00d449f4a489a6342cea43d402ff8f7081c05db6c25e5b0fcd13349c24a047af7070f52c32c6d8233c5209eef54796240fe462cf121a2981cd411036386a5b528368d4c11953f4fccf15502a3d82d8f41957bd405b9b4057c038ade882696fcb5dea77c8b8c50ba0042b1e7c9bee2e43b824f84eae33dd638576693f1d5d61832892d209cdbd0f4a3474201a332452687d6f31a2008f79a0b85174d8cfea2f67ee8fc09563bc80756f9e2190a4b514d0dfab064ded60996f2db870cb991fe9cf7749f08ab76e72ec4298b1f22009088c8257b0b6e82e2ec8492b7dd4378c8773b61b7133f82147bffd79a77d2c6ed818fc985857c97510588bf0c13a774406827ff9b691836b1566852e2e6ddf585db6b204ddebdd3bac51a361a9186ad5f2dee123734622d992e8bf4ee76c4945319d1effc4bc216e9621dad2bb5b4db1a9edcc337006b04077600961e452d24416b1703a7887bf1ec286a8d0acc07bc8df058ac7aa4d3dbadeb06d8b80bdd92595c9745db158dd863e85a2447dd1780653cdf6714c739b7b506b92c2a932d0858ebdd885f866a42b0bd5c957ec83767d187ce32164d764c260152ae9be4395b2eeef74f51d591e37aaf2549a20ea37ac5d1b680ace02e04be0b7c334c37116da4cd4e6a2ac8d356125f1cebd049ed124ba087be5fb7d1e8131c325b23cb33e0f96a86ca6a585c6b6a1ae4f59caf0b5a0b8c4358e0b43f8aa584a1c91411e79f75fc157e9c8e663b0e319e06d45ace5642677b0c25ed15df3e8293572d67d916512d3c419af14c1ef9482e3d1713e20659759afe6c7e570527cbdee3fa18b7a9872716e223852a6ee36a7b493fa232d998e450725df92cca129ea15f0fa5211bc660f51967cf1efabded5c08737a2680a25c3ce2efd544e261112ccf73c9ac09eaceadaabadba971ffba3b791bd1d0cf72b6adece54b21b15da0d97fe2794ebd6868c7eb21fc4ffc6f862f9b315261af767f564632b89afe344928a357295d3232ba2eee13c90c68ee2a3a740400114b1ec84e2f8657160db032ca4aeaa49f25f66519a3eb4227d1f214c693d5e559e4594543280ac9ec81e6933ba8f8a4d210731eb63f9f93b13bb1f9d2cd4198692d53b9ce472757040a1bd29769d7a11e5ac578d73ea42e00ffd6582145e34772383d7521e3503b2496711705a7b6f38c4082b128a60441bd0fbe194da7639edf9616b34b915583f2a8c8384d1f17a83912209b6c629cd453ca48fb2a252f0e2ae562c1cba9a63d6f443361b5e0efcdd32231c281c71fe1cf1b08823391b2a1cf44fbd12780989e77725840f587eb7f2d933cc0957afdd94191633a9a8190cf935054908a605d40df0197c1dbdf0ae5ddc307c28b4b94c3313c3b81972a821946edc8690fd4d773c1afdb549690cacdb01661309c963d989b6851d9c30aa08670acf6607f2541b5ddd89ff8ac681807feb374f4131b1e55afcea119c73e9e9a9a787da01d7f27f83ae31c2d4a4fbc287e45cc56e1777df104fd64b95e610f3889789b4e6f407e88f776b199cb2088f5cff9224aea52355ee6d065276943540864eb63ec7e13d9f7d85f58ff362660b2fddf51e806b643d56dacaf53d40d063ef0e781ffb656061ba4ab70b3dc38150a80f05bd792255579ef52cc015f1a965fcbdb890ff55506f659b317d266992e82b44a97d558f6e4f80c77889c4a485d221b0507e2416026efcff6d82e46ec18bd3668c43505efb1712c2fc4fe1cdda5da051d2bd9525e776745679fbee5df4ad3ed0641c0c1dc931fe00ceb0a293eee82f3934688094423c17dc55f56d6ffe71e5606c90d76f30d7c9866c18751e315424067695fdccdfbc896e6f5d6a0aa37366396d6e54e0d6962410821202cf65713174d8e2c69d11fce1bd095633f69fcfbdd53115f6f84dea5df3b27b8075858abce6d80d80a52f5e7955df149a4423919d2d52c553ffccb35654b11706e06dde2d248a5f1799f10b0b2b02897f5a4015f8cd354fc9dcac431dc158ed13c042fe144190ddd62c09d1fd1a12a352a533da40ad586e26cdacdf58eb702e40aa14fcc248af6f581675b1c8e99863fe944dfe56839c48450740ab5b778bd6e6254d6d4fbb27d242a2b867c8af54515ab1c9c6a238b635d6b0f4e74efcbaebf7cc6a265adf6a830962f4242cb5ff70efd9bf54dca8e1d3a512cac77f3fcab2974633e92c23aa791a6a6151fab06d379ec5b4169fdaf4a73ce181df4f5ab2afba555682aa3eaf4f00ed8d3e3b3e17fac92818038c29fb0fc573d63547265a802be96c75c5dbfca3bab63749add2af7e439932164dab6391f66abf9f9dc18a172cf753d3f746696f37e9d0654fb1467523cb3ed587478973350e9e543eb8971539d356388a1e84fa33dad40140720dfd5c1815c0107cdafc4d0f388c670a3dd70ea91c90aa67c0f774cea48ce94fbb2f8b08e1183a4cb7eb0bc8c24447c323a35eb1577f4d8720fa823c4ceda92e5aec84f9140d3644797ac3a259d8c4dda5554079980bbf6ba7012ee16259f181ce09fb9314ddc8b17491bad509afebea8767de976b1c8dae4fa8e92c68e53e2abc241967dc61013bfc2d3e763d0a91cfd686752bccd112d6b9ab886cacaefdf4abd73d8f97a3aa970110b82d28569c079080677edb9d422be7fb87d186783117fab2fe20a56df7806ee372816bdedf92961fe963eb946cf1242d3ed9f5181082f1e36192cfc31e25ba913d7b43b03a8a33509298b50318eaf806c8860e87a29b9affc3b76ae748c24df7b92385b4a99a6ef2bde356c1b3dab15c410486c41ff869a22ac79e45e6f54505f65f6b75f21009def9da13c0e4051a71562b34ce0250a5100f2f06dde20cbe0bb2da54c221cb1dde97b6e1a2079a019d9456a0b9b1aa612299d53044198656cca9176dc38f8b36083541e6f30a907dc4e4568d1ca7546a5ca4e2c28d137fcd1cbb70a710eee604e7dbca60f961399015bfe1bdc53a92e0c93ef2f0362a5752ec2ba8cdbed4098fe81254f9e6b8e9e3606da24e5aed43fd2b86747f87f69e209c7b07356ae32357b3607d3feb455f5c847901131d046fc243d1b6fad764d035eb09374610f4431bd8926576f4b86f36c3cb9d8f787e7354bfe4f77f35c169f314df8eb2bc1dcce6c40f3606e105394fac28aa534de9b997ad30d54c8f6ac694f621558bb34efa67a9d7aa59a23cc8b4c0986bf545413891b2946118b134e6e3f802f4cdf4a7b5938fa1330a61dae460686788f7c2799cd1363663079e2236890984ee01880144d67cfc28b9104cf82f65e2be393a7601c9d217b77b007eb4f683248a17f5ffa90099600e26c1dcdca85e5d9085b44049a667dd55c3e9b818cbad8792453c5eb4ac3597e00fae50d22d4f5582d6d7047bf885d9770f26d1934804415db432781834f25413777f5672df0ba07b14a8197fb83448b49740ebc1c4fa587b98bfd7e8934d519cc460f6a1ad6c3cf88947d6755ac7bfe0f15423d121d45880b509635f703c9e4e0970eeb9d41b2cfbfd3f7871f6c58da8c328bb5369af85376fdd5782a429cbf87ae8af412efdc6f9b223575b5ac3881a26f690ea12cc9e8c21786920b6a5d46c58811e375c66d4c13911c86d84fd3b3c9f3a8745db0c988ab38edad0f201fce36fc1bd4705eb8b668c468f3c9e43101e1bffa5df97a6250d78c051526b8574e0716c4d40f902abf544e07e567d41cecb6da62f0ad41029cdece4e931fb21145e6cf64425cb5617e53d666df40bed566e8904f6eb8d087e78d5f1422374b781836920c95fc095778670d406f869e8730d3e0cde0b507ebd7b13d2e2151c34ea6dc9e4b34ff04d26d97c7cded81ba0e0982211629aafbb4cafb6c19c27a857c2689c7d961c888930cec5921eb7d92b8afbb082a3694c1f2682906218cc4d88cd6debf0d0fef6c6dddbb3f6046b255e5c293e70e89a369f7380b493ab022b5622f002d4f47eacf7b5f5d466b9ebf43b00dac557b8f1a17628ad2ea20c46f3c89b7b76a3a63d571489d149458b05e2f3f51397aaee9f289405ec460cff2b6fb66ddecb29724cb5acf18ffad3e8701a3b542580b270bc0a3f7ea2c7b6d4656006a3d2a548b787cf2d3a715217a9db61533a7fc962b2ae216e892d3286738263a96887fdaad4b78fac21def9e9cfab6cd9b12f7be7bf2a1f17d659f1abb750dfc888d7d9eca8e8a5ca0503d9310464c58ed4de7944cbe3ee53dba8d3b9b87ed40c40d99dac79b8083772cdb0e1d9097f942a8e93b57df151c1be0e9f2c0a40d26b79799bade289d2f91a0a9cc49eafee3a5ae586e75065b84314892b4b054f3eb905183fc05d13da8c66c4a600e636f7eecfa8ca53b6f560b18bc8a29ea482b5c780a6059e78519f4e661940f9f431e7aa03059434d7b6a051b3eb4d1f6ad2fa4b27e5732f8c277949427ad135b8ccccfdbdcb214f78b94bae72fc082e3a5cf70b7672300b2a7b27fb536c973935dc800c98edd4a4c83f29d55c7b9c2a4a11343bc2a6118a977cce5eece71426de9181471d782b1d33af7102a2725f552ad3045f09c8a42d1ed470707adee9425d18cb23d6761bd27bba30f673db3505883cd1896a19dc9bd5b994d447fc0bf9cd9c6a5be7db8739e6d3592f4213b4dd0416e89016c92844c753aee1be9ec262c26c5c190edfdd2bcfad95644f3c7f0137f2def67ca009102dc5d3148609dd62e21019b223ed3f3a4d41306114d08743f8278f4fd8cca004baf317a89774cdc336ad26d270bfb0bd63215106a3126535cd71ddb33f35eaa135bcf1bafab2a54df7e5a3667da3168fbaedd07305b33c571542aa1320cfcaebe65311de5f2d93f4a0fd4cd27c3db53b81c5a96bb4d7a05942ea70382761f05b41c3bc273a24f425d849f18fe52308e52f4af7784a0cc288ca533a8fac2cd4013942bc0b34692cf228b57789164f603eec6ca3d26a91e9c97c30c75e2b87ed717ce70c90bdaecf3cc20980a647562aef9959811ba2c19081877c7ec3984acb6447d249bdd464fae46d502130c4188bf2459fa983d8d4e8dda76634aaac7421913a2a95d10e90c1d8191f20ded6dca6311e6d9fb6e25dc4fc8695ac975011ab0f620fa9be0e15a82e0e2951b91c5290c5b08affdbdea27ec1f5493b6632723367f18a38ced41be0754b5c676c11f7d71831b7bfb681577951d459e5181788f93bec6c101d1847a2621e0bafe9dbacce259602725232627717c8b6052640e476a9c48477ef616e1b7f75f73eb9941f2a8fba6d18b33d13b6bdcf409b4eb5bee2c04eefe7c47e73b99b268255fea5908fa5113e455482380541aaf8e48710bdfe8ed44eb3f672e98e2744fdecb3b0c5e5a94240e84e8aadbd31ef43f53c64e68916511d1022e7b767b9cc49bf519e5f2083592ccb8cb8ac8299040137d61adeb64c38435e798db17e2db219f732d931fd11045ef062e9093e6effdae53b39cc7414022497806d8de8c98abd42940ac08b8dec3854ca3eb0b05d51408522e760d5b48033d188b46ec131d0418fc300db22459fb38831d257c34f35f9cb3bdf7c146adf12c034e673c1a614f35d0330c69e88899187ffaa53e9c58afb119558b32a39ba32e9585d53596c0c3fd477cb9c5ead2a4031d5c21dfd1f9ec054b3e122926c52e97b5121c3f9ced8d62dff66cfaaaef6a13bb4b01881e3223faab195409dc59a78f4ab82567b6375c18559cbe3d266e02052280deb004dc0f2a1d098b8829a692e31119e731b22b6416e3a63363e64af0a4cbff352a000dbb094c9dfe7234bc2e6b5b4ba555bb725dfd1ed105719ce6b22ea3b809207a0f683963e3996b36bf1e4eed0582483db527409de8c38dbd7e1a18400afbdeff79acd8bcbe7f0bc53c72919582da2abbc405514c03a59d8951f14e0c2d83f8b0903a663e1ba7cdd5ff7b3cfecfedc377778d542053416bc9e161fca0c8702ed35d401fc4a8701fd047a13221feb6c6cb67f41858986e6889df609727b216450d41e367ff89a4ec9cc47d4aedc1d6f682867bb865426fc6434d722893deb2310042e6f3c6cba181e37f334599723fb6181dde7543ad2c54c4bcccea58b8739f196c0432c01f4a22542b67036e64bb46a40f582cd78ce648a7ae859fe9a88f699adff6826dcfc4451b4c2d4f374b19e8813b3d590378ab63299757b114ab7fb847ce11924eb351c0d1d01d10d8554d0b9f0e58271959356c1d4ad3bd90e73f55b3d20936eafefe64246083db170d1411f28e6fe204d580ccaac26052380825fe406f289e96cec58ad4d063837673e68ef7fc2025abc9cdab30233bcd1705b24227097bfbf9555c6bb2e1f2f9b72ad6d8eabafcf4927a80ffb56c59ae698c469b6a0061c8613eb6312e0ca5460a0f038be979bbf0ee2ba36b7635eae2aa920706219ec5d810b5dc3814851ccbd0f2181317c0239a3a6a80ccfd2a9ce01f1859cc332c833b8c82d5729c87f736493be250a65390a709d00f136b3f5007f6cc25cca80119008a3b07bccecb5d987e5b71986384e9a99472c79c2f0c374fdd4f6c011f59b0438b12788b687d5e9141ac8b7c04f6f83d2f1c62a149a8f7306079c814d649b3c7b490008024ca0d9f11519340f6621cedf664f46004e5da10a3cca132ba6b5b1356277ad412e319fa1fdd485aa214b0d18f2462d60fe603d08ea41e30bb5f7ee0a0a8205453e56f016452cb03d1896c8bf661fc59ad5d33f67ba43d761915549d1bb4a95da21268e1c414bd8dbb27acbeeaeed01e5737e721836e8b96ac68adf1fbbd7106a5a6bb7c92dbb884541f8a5c6634818c5880aed6e906cedae7d828a0ab5c5ee313152a13ea22c4ea21c36c86419501f7e4c8e6b88afc67b0b5900fbc56b973c2c37c12ab315968d384b25eb2f3d4f23497465fece4c51dc9418f131bdfa4d7aa8db2dfdf0d39d660776d70e91bd802819d540d2277546a54a82fe19ef4ffa3278debb95cf238b2049b5dee61f09389fcf6db83ede32f0799f82fc5386e2e30567e01e64fe46bc60eaaf777fa5d89e9ed1d908e713f05a89095c1bc70ff4f2105a9f262be36c614417697f73596f6c6ef7dbeeba2db2fd47eb77f650d970c15aa8d2ccb6c6c00b68bed6400673e4b0b1100824d3c7988c75cce64a611a7198cf6ca912661cd603ecb37a127508e8ace6cec3d9ba03f40be0f2a42890c45b5fd5204571ee2306f74b0aa0352f83650d9be7c3a198ebb8807777cd7a67f45b6802aa494c822300ad8cc11a183e2f675fa740eaa9169d1dc1d238a981641ade4d4d886695af541352437ae5e798660cc15fa8af5591879d09cdf30cbcbaa5e0683cad30085398bd37d83cae2cf8455cf6a89bac98d4b3bda1899437151096e1d66a374a065a326ba393fc1620c595d447bb1e5b012a707fc851e510378ca4f73c565955525e0c6214bcbdc406df03daa258235461d8cb4df846923b3259d4760232e79f49f75ba80f0f23fffcb175a3f1ca3f123b0d67e301e9414faddce8af9962d563bc0c3b24682999a308b4b79afa880d7c00ccc0db4827fe754c96a74c42f6f7754c8edcfbd2ac895160794a8209433e1dc9bd6b42a8373f60e9eb254ea3746a1c553cfb23aa0a73d8cb2b4fed8f36f3d251d41d7cc82947b4527b257f816e5f5b96db8375c338ca4b4cbdaea14c689217f011921a314926f488a1382faadac611982a23768b471a09bdbe5e97ae5027d71e8150f5dfe5b941602a19d27a7b09e99dacca0eb3339992b9e16cadccd24153f7abc7342b37bb2c1bb9d167f5cc7921aea78ffd0f9ae65cea6aae3c59329fd3ba2246051f0f4fe1bd9a1cd6de8d45e13746e74d58a0f3700cafca5a743d67e60ae07ab02edb7238347f6357ca9303be5335087ac6bba721df5656420c9e2033f98dcf326fd1697448557f5600684f522122e6de80521beb1ac04dbf2b35b67b97c5fb8157b81ae7f46d9357247d5db08d1843f16fd051a2282276b59be2ee77e5c8c49817d51aad95204064e0999ac79740281d6c6c7cf63d396ca20a886ae6288263da30e04e52501c21a437f94b2734e1806500e250774e9ba85f734a07e0753ac8f0c1bfcbd9048a167ce9a6e2e35d7ec6896c234b814ed6ea18b45a4b0e45368f4a17e82f1bc17097f5efc7482d6b913270b6c0fcd7617d852d18933a706fcd7242034c326472775f486249ea23d648ec9c1a8c82958ff96fe9d7bc234e3bfdfdbc733c6bcc1694234aa19c3369fec7cfe8fe911f93662683077918226f8073ad49f14447293302c331bb0c3afd33065eed6db432cc619209d74ce8b89d06121468934013054878ce4b1972054f64a53074b66a7a128bd2fdd887d50c903d6587b08f6f5bc6fe827108ae4055ce332960ed39204567dc942a989b576fbecedf88cab853e2026fcb86b8425fb3c65dff314e06e3f3583ba4931769df481df7cc2f405b554ab2dde4a33cec92c03827dccfe26e5bdfa04db197d94e61f2c0b0bd00501da9cd96a6a878f94b09c183576acf746e14e4d5bec8cdf59adc03bb32e1deafacf12f6a993a8ddcd90a6fa7d27fd792676f0d5ce97cc7049a456321af687ebada16ef29535e27d009a3c4a275f21a99fc6fc2fe048b031975a265e37f716636e7e75137e3665b0c215f4ec6e963ca1660d12a4b0d4007c7e64531b5c1b36f85c12f0ba7afe614088318ef6951407949963c4d9ed2f28edaf4934a85075bd9227383e4e3a9b972e71e6c856aff9846d8e777cab6594c7b4a7b1be7279e65d9ca6ca6f8fd65fef0f0f2b2bb60420cc6a3d86a933f0383f271c7940cfaf4db75a5dda966420a382447f98a0edbcb74926aba1846f4144da4d9d9284c7f787495dd11efdaf7ccede603832a23657c23f2b917760aae2927d0493c0931d71ac5615658c736f6a4ec93a0a1e9b2e1285bfa28e460721e8be1ddde693df7c4d5614c691525c2558b8f20ab691207a0baae067ac0446b97e065cf7dccb39671a29c82c6988da6349c273dea263ae7036fe31d8cb4fc0c5f6f67976162d766546b37d482a3831b7d7145b53e80c33cc1c09c64244780ee351cb5ca9695e71aa5c733e42e84ee382ae6c220352a1e712ab16f42166df938dc049c6a4faa30c31d62df000b123bb57dfd5a7eb3204b3f73f842d4077ed41f78ef0c9e428445b2940b0942a58abc915a629be16046aae2874d97f6194404de1b750366ee0e37de2f2444b8f7ed5a57d89197eb3f5a725f1a1c390cbda580f21eff25cb597d332a16a0716f15ad9086eaa7889428781e7fd8581edecd4f7ae4eeb22cb12eedcb2dde841f50f2b0962a1e04b29b1d5229a53a3e70de0982f581561c552a29d6d67f936adccb8facc2f6f7af5b498a042f1fd7bbeabc235c47c738c01bb32f770110eb9d70c54051841d13e410d51f0aaf14b18503a8dabfe8c53ee5f33faa637917bd377c2ca7cc7ca9f1bbb4de1673b7ba83a9802d051b442e5c89ba6fec9e39bdd517f4329075ac9c64531ba62b4575ad500e28b0aa2da5cfffc699c8940131dc30c05748a75fbdb08d7ae2a802dacc235c992b0cbe42d5e74a3f7b6f85e6a157c88c3ece8b7fdd96854a91d4c00bde4b0ec7aab7e04c84a50269c9cd77ee04208d4f166a5ae569db10cc3979c9fae5d7e42775ea78cc963c3e90ef9627cb483fb7adfa852f9e6f76a325e448dd8ee8e05bcbd6715e5ebccf8f5b1f687484928ccf6dcc00cb70de2b929f346b1a4251a8b625232b86d62a2174be273d41d74748c8004bed760c51afedb324becc66216355c6a164cfb58e323218d173d987efd461c907d71b06236be554cf9032c009d571e7d8b5bb12296bb1e7188e51a3b8736b6cc06afd36b5095a5804645ae52a39866b2bf61ec4b93bddd383bbc4e05b8d8268bc11b997b1d1d59a20fb34b1eac2b5ce154cdffd212588d9cbec1ee310d594d65e1ea8daf191512501dc857801c7231df49d7bad18b0437cffefb6c597ec351db6044f5378936a74f628e6d647aa9398c1636427a29e010608dab12cd2c195ece20d05b9c922d798bfd598990f4dce1aa096ed2ba940bcb228bc91b132cdf961636984a1dbf13a5f03387acee755338d69aec9e6cd489bb337fd6840d6eede1cb79b635476f55898d8ecb6a0907e2673d1f006697bfb4049ed6339439d7b23fb9b79bc544bddc3b5696a96a242f54491f7602a90c11fd07c990cf273a3663b51acb0e0345514c5a724a2fb67d65e2fa9220533d04c2d5b3bdbd397254d0be534ea3c0edc242cd2c71c71df784dd9e6a6abaa9566c943a6741b93682dab43ec7c4617457da3077f10c0fc86ed5c296d04277b3c0601a1b19f9002831faa4dfafb931946a7eabefcba539d3ad6d795f1b31319426878d9d4100eafdd81c1e28df4c2fa7accc06a5a04964fee84f86a7a8502569821fcdce0054e8850e03ab07dda5a8165399b455035103ec9a1bc8fdf2d849c536c7b1d3488e9ba2ed2f498ac42673d64065dc4c3f95ee51490fb480d6a6306b97f38c2b98bc9cbb9ca2a96c72b4ae95c4837990e8d71406bf998cc3982a2077da81210e5378eb4405c36e1afffe62fbe1088970b2227553b8bf5e07a3cdeda6616b7f822deb586ac3d278bc48a7f4ce51e53a1e5d43d0b4ea6d3f9bfdb2c268516778859d4ab8c03c563ae21919b236750d89fef3b94d645f31c1adad4a6120ca8566eef823c3867d1a552f2546723fd294722a6af7837ce552a9f104f9958d35f0f4603009ed8d3035b4f4002b6131c2736eed0fa2e059787f83bfe5c1743da381e9d8b3b5330d456220206480c9b32582d1f50a821e91e65d06a4d42b628c25e1ddc2eb9d4e632967b1503907e3fd0fa3582f34d4124b2131197d9fdd57a6a387900ac09d1134480dc6a30783ded41517d5dcf55a81351789970db60f134365b865a9155c4606e51e1daa45f2f67746c659246b607357f6f2fca615904fbe9e3dc109416f19fb30deb0a1e091415e2079dfec671a36bc0031dc8f8f72edd513325b4f3dc176f33e4e2e2773e5c85c0c1ef0d85e5d6a6e73651664e7a54c0ac268d584e44344e3b986c3462e96493502968a5b0c831bef1df69c288f91de00201eae61bb352c0ac91130fb127d88ec6c2ae8622fedb6099fb6b00051dfd55708a9377f221babe6cdb49d344226da707d84ac8b1d7e0c51536096d66bf4afbe2bb9f0ace92a6cc5b966afa515f77a0a7d76851fdb652c2cbbc1e1d1b50bdaffcfce4e5b0d8cda01b99fea46ec73fbb77f386e309d415d5e15fcf4ae99d141319a0da4ce6d944cfa6370917e86cce170831a3736538ab6a15572f856290e3a4f1c552fd17dae92d526a1d13da4d47e3ab196eadbbc0a4823767aed5d951d48619a83c785b945761cd71f3e219c384b08ef4dcb6259790cd179a77cd82407915cc4dff6b6f26f02a56e144bae3eed958ce5621aa6c571530b530f5fd7159f6465188c813a2851fc3382b90d3fa588a11eba9d9d86d5fab3aa6855f3651888f14acad9f29cc2e5243314a5e9c405073c109a36a79463496eda15484b24d85d743de67eb815ecc6045c5ff3b0e262991bbb99c8d64036f6b032e5fe2d41785e155ee3e615cd0197cef4c966bfaff57ce3e8c7dc06c1a1fa7f4cc9a2a7d36842bb2bc373952393841a1ebc5a2ced7251fc9487b430e756c00bc67ec13b2b0c0cde92d0ce1d013e414f557a4fd496d4c3028578432ca23270d11b946b0ea46befc14ff906cf6826a014929499f8ef74081a21fcf0db8fe085665807bb83cf25514da08148cf745004d5a2847fb6deaff54ffa316a8d298c67bca60560275cf0d617eb72d1c3020143eac9dd0362767812f3b5b3fddc20caa62c623d666d96da0f0c3dbc6cf328dc848dd39f85032e4b1ae764ce978b67fd3ec49146d55d794475a1ea81cd32f01059851a85aa13f535e7bd3c41dd4ca844031f9cafba1204fdb44a42a672c75668d3ed2592750606ff5a3405efb3c63b86df5f1780395fa30bb1dc7a36f94f652ba8e97d6cd2351fcf8231f5e3b1eac978b03b98a32c9ed211bd0c67231753af25673802a74314d6f583810bd7a5584e829c3df934e6116c000b0b22bf1f6c16489b96e375d7d31010f269fd1c022acf551b08a60a9637c4e030a625d7b5eabe75d227228ca583470a8904f1a3621bc1b6d74f010c816ee055f9c29c754f5dbaceb04c4c4dab108903ced30692cdead74a71e4664fad280a210152a199c41cf5054b5b22a284a13613920d12f1225dd1007cadb42c49b2d55d69c047c57802c3e4ec532b83a42bb235014259048f7353900df887e2f2ac9ac53243ea91c208a6639c4e94c0457ad85cf118a622aff7176ace7cd75bbc863511d7a7d86c11acf98d50b1ca7d9c1e49f9fecbf1b49837205b25e041fc564b75ce6c947ec157d890432877463c073080aff87ae5587d0c94fc54870728610a2b8c47bccc0ee55e201676f1ac46ef9214f4eb0dd2871a465c717878594133319f1884211d80c78dd894d65db3be568689215b973454e621c0ea14976eef8deb18b5827bacbc27f3de5d75f736a5283892fe4e6d607133b4b23f917894476aa83d82fe3dd650efc412fef88a9b338596f3afa7a262074a0f7106cfc5eb5dbd27477c1aed6610f646a80e000998ca0dc5d8fad8c54e8603cc5437c9e08203acc8ebf3386dbd3563d3124b02865914b4f0e63c5431a7f4119f0d0325b60620e5e55c656491bbcb50ff06e982c0de6991e1ef579a1fae3e29088e287f17f97779481df43d0ac0720e88615d5e0c54ed98c00399f8d3fc03374215a89722738b61a88320e51c29f2415ee08225a50d31892bdb3174db2843b98255603b2844d9506eef809cfb4b17d696ab2fb22404aa3db9427a9d0b10aa8e1017d9784a5f04d01e7b94c213dc2acd756fa790e0b5a8e701b6dcc9bcdaa114cf5560a6e9e9ce2abad57fa606160e6b2e10ef9bde5a6c530bd731199f9cdf70c18dc302a02c75a0d3d24c9874bc54d3e03be450487f2b0311eb2ce13074e03acaa4d728fafd25f5cd7c9d5504969e05c8c5ed5f80458c406b033e5da3368189169c5e37ffac43aa0d2d08796b1dae3655b8c0e0d7636d4d091cf68f8e8dc6da06a6561bab93e3e464c0d30fcd2a01208e320a565a0e9bee2480d8fbb846a5b85a5a88ec51d095393e81f4046be35c6e8d0eef7544270e85fb5d6322f32c7696b8df02691263cc04bb7c59fdc3a395e572559c86ccd7725ae26666048ee91d33cb842bbeb1a2c86f499c5b9e7b52ff5be93df1fef6e0ae25a48f23ae4a670b9a08e78ef4592f99f3fe3b215676b5449e1001200f97736fbe2d31549c14233e2d5bce0ec09549211d6dfc253a89dfcb94a823dbc9578799cd981c5d73366f6b4791525caf891e5c5438d8df4a43854aa990926fe606442659bbd5b5d1bf15a0351f56af118969872d334bb2df4c6409de62dcc263a626f64cb8bf66f6faaef6c653406e37a8d578d5b06a102d45fbc875ce87a1d83409683b53b40c2a9539aafce202269de2a75e40dd388eaa790b88ae542fdd70109af2efcbc535aeb86f726bc5a3a132f07d75979d5fb20bbb44f624599be048a60a9975a59e9d0021cc1cdc6fcb70d5b7f71e290f1d1932babf3744396545b507839fcc1272823fdf344adb99456ab3a29622ac9eb6ccdab8569b1b09c735f9264b4fa40a51b5560c87893db9945897ff5c4c205fde8f5a2c949302fb399470a8564d110c214fad2b2ba53e5862e9f749be52bd50f50b0b7ad072e6a5ff847ca1fdf4b6271cd02fcb1085881d96dc8c50fe716443580ff6ffd1e9b65634f9b403cae46253a184362878317f21528aada64235771b806855d755bb7084595ab44347ea9eb2b07045bf461c6ac8f431fc99c6f98535495d8f62526e74059d7c919d805d89285b3b8b9a0da846588cd8a72072460a7707a5601136f67581eb5e0e93a5dcca913f0147b3c2cbfb4acf42e5a91441afee03470435ac43fd0ba8e015e7a6a6cd6620874fc2128dd73d7b3a14d476acdf60cf633cbd0a87d8c82017cc7c067f2fabdb72da6b98a36e939348e2451e509dbd29dc2ea938b5bb0316e75cf59cd4905d59cac459a01a9ff74a90da75a625756e7f2e125a88d3cb322a42ac76aa30c1911f80446b9a5ecf13e35b984d3b37fba86b7b0c6033a400e9ee07f20544a96569a19a18137a0d5ff29869662899249325b1937d398ccc01c125457ac09ca267651a4351226509adc2b2f10dab381c09edfc1f0833695114f814044455628bafa082a197743203edce19f70aac06dbfd08976441335f544fc34da0f1b0e12fb8a409730dfb303bbe9071caaf9315ff84ebd067fdb69e9451608b17bce86581e2b2396511431a6eb27a64e9a2348952e9d434f564d1f5ba36f6f8eae61bd4e821f7adafe59dc3411804cc6ad454cc3ab8c2e1c65e2988194509b11764235a625a636e75bc4374c6a401c01cdc988fed30f998459e64d0b6bbdbda0d10703b9d8b38c253f106820652271344be3e8c1616d138ab72b3dd3f85e1366565dad0d9cf9754d06918c252404ed15762bb943a028589cac8dd04fdeef7438bcc0716ecb644ae3697f21e71c3a0eac380889cc31aa846390da408184198175e8d13a56d710a48809f0a1bfbe2a098cf75aed235138a88b7c7d65450a5f941814c8580d80e0e8b8b144e0aad243d89d7bfdc45b82ecc299a5cf752b396b9d84f38573882259ec038e093c2fb3c7fdb5011539e82ea1a28128b79eb58731d80371cf483dac97a0ae47676297e3df9b0eedfcb17c5ff32d0046d14413245f7a27044a8b92f96fe6937d9acde544a4b898d51b86836e5b390b124ad9c588fc02e9add2be906e102a38315dcfec91e03adc0d3a5b92603162caf5d9a1d9968aae498791021a00949b5e39d1781b00ad8dc4eac5cb6a6abf192d535e011f2374bf1928b409137ce5a865f5b9b4d389ffdd3f2db6b0be3ffdb380c578e93b8c288c1116ed5f85352d08fd87031c98981a1c689e6f68d7af06b38b20037b1574898e69aa4ab3e699e6cd47b78c0913010889537134d0a84ea4a01bbda818d428192f495558bc03b4aba2ce5763102bb659aa1479e6a3c9f9c1032689fcdb25c84b3541e65d7d0a031aca057c5e73f6b40e70c52597ebedd6306c7af15869c5e8bc67db30c4ab34f6a09835eddf680d48e282215029a80dc1bcc193f8aa67eaed7f05a706b09d549d27d7e6aac1359f8d87355c288d422271ada20601c5bb1caca3e223da82116438c00652244bb338cbd6e9acacb777e54a496165b54a4ea13af4d76c6a38b15b9c0dabdc7d70384a950ec47e441235c8498dd00c433b09550ed627554e31aad365c819b263246df0ee51bd0498632151b3ad69dc1cf9579ad7791e26a76b781091bc69afb6dc4e3e86fd6cafa75a71e8c8060261e4343650e7224c01a3e86b68701d7bc5cf620eddce8db19641baafa0f8575186246edf3065d7170b568ca1ba2385be62d0a4c7c43c12152ebeadb100897341d9a8d46adccc36230f06f09472da3f803b7853622cfe27e2cf1cbdc5fa0f4cfdf5f9de6a3010d745dbf6dd335375d9e1ddc93d24fb1a5e4e60aa3adf8e71f396d64d5eac1f9a07f5c17be3e604c875c658a7443f73f3e3b1aed2c6ee2772103422b05a68fcfe5cd6f0a15128336fcf48859a2a7dc4f7e6879beb35ca364e9b70484b37bb73113eef793a131f36ab9c123ae2bdab0fc86a1dadb9575a62ccd580325f7bd3d3f20f0bd437f57b44e9464457c404276e082d4496c4f92698e4fbabdb4469b57c5eacfe5d84d8e0cacd725f448b58c6c223a994bf2af778e482fc4297f33d3f018e6b5ccbe6b14bf36539c3ece08c722a548b321cb78f38f8667571b738782a40828bb2b158509bc36dd476046b044653a7e4d835606058a974a510f673ef2dc711d00e92b019fbcb1752e13bd00cda22a47be7228011fa959fbc072d8a7f341dd66999d776e4043fdddd25833a9536a1b78e3a04ccad7c2b19908043271c4bc72b0e4239e84ecb67334aab47a37c9c42fcc62d1c28861c3fc86602c86716a88accf036dd2bb977db464bab1168a0bd135dab36679928d940e9de46ca3327181dc5daac1e7f0a4d8c66315df46e21c326b5f1070cb57e6139cbb5867d3da7ebf02aed351934465bcf37ba6c91d6aa97a9a035836321e48096e33ffaaec483ef43e698698adeec138cd74e410727bdcd294a18a46f7078124d32ba049fd41eaf03c9f48b6f4eee633f3c9a541ebe774070fd197e06d43233974d684ae686d50b125b7165cf53aa1b0f497ae36be91614148ca050e0e3fe965c7d56ef95d99c8867a5626e6215f7633d0d00b38ee2b1e0ebb458d835194bb8485ce5fd6f17f19e3d275f6f4c107b558a9c6b024710f8494a8854097db8516b752b4d79186c9f15798126db7614df68229f0e3983e112cb7cf61483cadc9172cad0d76636963f86554c4210addbf109aa17b1eb2dd02dfa04c47bbe844d26c83d687fc3286f211224c6ee63e47594e0562e77a8b55c49ce4f9b96f36a8bf40955f79ea93f5f8ddfc2336061d8ec2061a8f144d182042f57d7655619dc591c3adc42d5361c31621f88df9569d72be4380491f4560dc41a2c45f4c6e0d2d8604cd5492337250a7b9db9cd40f31f5a85f74c593806909f786e5f2c8bde8e5a47e45242260beff850fdf475a87c692ee6e5c670ecd2fdb97c20ce9b897f5c799a3d3ae0cc603706465b66ecb06874986cdbd9f45cfd71f11845fd9b815b1cdf98b5122d126b35f8e227c65bfef6ecdc6cc8f0fefcf2075f6fbde65f50d6cd65f90e765fac10313122939c1d4373a25f0d106b4471bb0277ed320e795081065bdfd5872b1724ffacbccefa7133345f6719a6f8c72da1726f98b2aa9d15aece70363e53e47c0f3889e786f582bd94c3ba0f7f0b84b8a09a04ef1bd42cd3fae58b161926d574219147d88d7585b968ad2211d549517ede7ad18aef8363f149fa0fe5c93e0faaa5c2cae52fef94a982e9719c5b7863f34245d3aaa0c10cce1b43a83077deb804a7980d70db5903057728b82a7fe7aaad4819456c49bb65e0eb6608d0c3acaf4009ad873bb33bf23f380a4df4b79ab1f88d28d621465216882bd18eadbb75977c1333593cee408e63320b3b03c32f4148e2cf6bea23c9010d8dc69c8e0e8567ba101816022378baf213d3c8a1b83dc530b756b1101428b39062d41a1575d4e9fe426c07814f87780f1960e3d8101581c6342a8af7cc160cb0a17e0d15907f3770275e48096ad9c8d0e19b8b00379e4b7be5e715a48621caba08c959e1fb85d87acd55dd1364d5a879f71cff597ead2d65fdcc1da36cfbcc11f31af7bdc04cb2c75c76e2c6273574a5fb899c91b92e4858f00a476b5dd5cb91415587f088a31d45e2624b8af007aabc63877f7f558c66789cd26ed7b3174f5988493a91abc43a23a5f352a4dacb19b1c113551c490febbe98b803a6675d59cfbbdd830fa26c53fbd5be9722a1c3c28d1684441d333228a7c025889d5ab0c4f5feb703c5d8b456703816a11e488e985b11f224094e004585c71d4fe6a5143cf35ed88c535971e221d1332e04d4fc65d643fa87d055f0e13e753b2e15340e3edd1bf6307f239bcedc12d8f76ecf6cf80892ee5743735d4bab0a076b69135c7b5ec01ff4abff92adac93caa516ac038af4d967574c505102f59c8e9a3eb1d3bd87c23e03ed50e61098f9ebcdf7517a5089feb5582c045f926814d1296a6483d56e657c53c19b8a9ddce6e009006a7df9bf7f3cd56abe8f05ba1fa5149db8dc14280e36311db73c5b16077b9d0ae4c7ec85fe1ea2ed8b3e2111235b26ff338831342910ca782ad71cab18b9f660b1add67a4916cc179696bed3d3afdad8f71aeab2c41d725da8f821129032833f910bdb8228f76ea3689573f18b8317b213b2109df4881e7b2165c24dfec63bbcab2bb03cf886bf974e75a0105244d85d3e0c1141122a1f6dc634a3e7f86ae06f53e04cec654fe7b160c50639f8d1d154bda60c6e98807b5a66d6baa623ae486602a632ff99ff6ad45f0710cf63652fcddb0928aafca9219b0dd6c5bc2589debec81a51a8900effde4b645277b02cdc41f6a6e3c1c2ca84d1e9f189a749b38f655acc44c9648abb0a021a0b5a8edc20efed17edccc63196470363531fbbee6539177a97ff5835afa692ba5983aed580e67be320240d0298091897a9e41d7820707a7d252d729955b473cefc8d061ffb63038a573ac30470ed900060a5779157172ceaf24ee2461e34ca850ca346aef822c9ed97b9aa5942741dde7f5d48abb42b2061a4c7647ac12e2aeca12180c45547512969ad5fefbb40d29a4d20d9747f1f09f3aaac44e0c4f0284ebc763a5af5b1548bc96430cdfaacef7de1a4ed188d7ad7f765710ba0a37fd8774393442469769ce59e750780f2eb9eae34a6be8820894a32baf17ddcf70d735ac1eb9f3ccd2c0d5fb692eb50be43e46f68305ece5eec06fa7b749529aa2ce7a5e5574f03fe87ee322252eda2d6abc96c2060ab60ab8b837c6af2d19bbfbccdf5e584cdf8e41eb8e0feaceb13a05eb069bbc194b8f1c85dcb1bfcf3611e808a3c4d8b0260adfbd03dd6fd103f64187cf2fad89cc6748e765fdbda2ebce3195776c40d4410c8171e4817652db193a99572f9d471e254fb16e0b3b929fcedaa336c62c0382c6dc222fbca6446b35b1aae2fb6d6c01d3645d248695a2d8213d6069ba50d5ce59d47eb3f9f8eaa200cd6e3dc5bec6a3d767e4d0e81bbb4fbd09ef6d9137566a9d1e116707ebee01f72726c79637cac9db9bedfeeb7f9f0c72359c1dda1d885f49d7434174c09c0dc29722a12c2b06a31b98d4d911dedb65f194b5a3e38c5279eabdc08b0591bcfa5b29e7ce0037cb85eb94914c073cdb85259b63667f3bc125d6f5d215df49a7ddf169690457d9fa529475d0ab2265869cd036a532539fbb952f9401d62abf08ab9ff965e3571d587c4581ce89b2c209da37d4a04d28a35d0801c803b2e4d3b0c94f386a3c17347cbce88c1b65d6e709ab8f37ed0b3a5d0ddbccef42b2a16c72550e363eb46479449a7280dc7743eb9677cc1d67526364928709ed7cffac6714c8c2b7e61ccf30fe5071caf0d0ae1b4c8b2ffdac46ed262a040e518d3e31eb639df5b57bfdda1f1fec61187879cfc9c4a42a50be0ad56d8966a0edf6a1f92cefd8fa198205d8c23658a24b1c9ff5f5e6b6fb694c72c5f2ed781a2b5033fb72b032ca729df7a1d74ec89177d17a9deefad427c53d83665373a73a2f64c15fadb4b28b6dd916b835942dcd4bf8bf8163845d7bab7fc856d0c3a25846a3048b6e6b1af1f04105cfe30b6bea98b6978ba978359cf0e18609576d64a5ecbcb135f70a23c5371ba17d59debed44c5418aff3a4be49c279c26256fb63ed1142f9e80a5dadc7542434addca82b5871edefdec21de235ed311c2d381bd324da6ad722fc924590ab5cd5116dd37f14e5831b2c1045eda0230e88fedf15903621feb15e708c0ddd73cefa8c7088a9a815fcdcf008c5ca6b4f75e0c07415f7f9335e0b98aad279561a790fbb3e82dfc77c96d6674f7147f9054f356f5115a37858ae878823dcc11e3c880c8101eac1e3957d22af8aa01192f0b619e818ba0d0de9ad65f09e856f5003d15a959d5b29781ae8063df60a19c16664cb8dbb7991f573a13186e85a5a49efffce9afb8b22aabf8e1fcf157f06f2bf7198f4413a18ce461f98ecb5dc995452acedd758b40914c2acb8d5d48d8179d719e62539d5b59b64aa3c1ab1de993be8fa9d587c0694f5b9cd37d18ce312ef614e8d4c8d0bd3b6bf3a3e361c24f215cdffbca3fedb375359e10efc58590c071bb504ce97364e167b5ead4870675e5a6519187f6bd7806ebc71942347c3ebcc6428f57f0e6753e7d0b3d3d7b3c19ba83ea76199cfb8259470c75a65b394f2d508fdda8fc3bfbb69edafba015a1d24d37b1b9734a41e30d0c378846598a2977a306760f950818dc5914c48690e825c282864b98ebf1d38a25c2db04d2a07139f1497b21b2b7234b95a53a838f2dec01b63d4564fa0b2ad7e12cc447106e280bed30e5108b2a6eb532e3e93bfc976dc12f0af21134df469c0fb36c982299078604c2260b68856959e9baab12c63d18c0917d20d756fe07a668ec9c806e5d0842df67ebf2b3223846bedda280123e577ccfd23b26324574c34948331c35bc9d97fa51ce8a7b9fa315bff0256672d13a853a5b788c59808c917c2ab05031953d7522de855f39a564b0e9de6dc3b106d6229c1a639d35d1b585f2aa8d38e5c61569f002e7895f465f91ef66fa360db15b72376c89a0a674b104d137d2988e12cc1e9e2e69befed6539d8cae76c10324eed13826c2c3d699e9dd1fb6cae66a0a037cea9bc4a99055ecde6920a27e41733ca151b2b892f267a8f754e1d9fb13158fcbd63c235fcecab8a4813c47d387b40a2adfe5a419c00ce572bef1350c8aa8dc2972173c13f8c44fdbc04912d558c33fb00b54e9779e12b6707fe8f8b629ba65e4bcad6e0de99611b4354e491934a8e69a949cb3cffa8a384cd258a3778376a6f882d63782ab03e65c571242a17dc04f2cd5147dde1c8331ad51748fe9c2c84ba1c187c67424ffec2dcd7aaa3cbbf809e117f4b5c6a86a44711d079c282d6277e955b0b218cd39ca3c9a1f20c93a700488e8c38dad6422a77dff348246c5c93f356b3d87f60ef045bee29b10546c7632511eb669f064b07cb02c52703cea0705389a0c20aaa741262603c48bca4217e139dd5ecba73babc31a09c4fb610cc66fc800181e4b46c878ac04220ddefba27a171ba593bb59395aad3c2941bc5adc6414bb0c04b2b5ab6232ae4dc505213a984575a408b8ce577d12a6ea50fe247aee3f8746d6f4e4b2eb50f6f34f5839a325ac4743cd33ee1b244c8e00f5909de51287443be0133cc289737dbabaee5017fa6b5eaf78734238182ffabdd71d9df41349f6140612d37507e667f74fb743ec1c0ceab000e4f8d0648ca845b6d7f3c71dd43088ebb30bb3abe51e9dee0f43b69376b50ca8aebf69cde96704a26fc4aa1d281fd3fa07e21d2ed46cf8739c4a6302235bda0569ffb4b89dca7d36111378e4add1f528edd1990816d062b1962ef72807baf1524793f0cdffffdf0f0634cf0e479620a406441d4f242d1b7376f2f614f567d8f2e8849b2379e9fb613531bccc3989f7885564361e2f7432148963d2ea22ce556220abccbfb44dffee5f18e4942c0a42ebf94785464e097f439e02bd330ef29c3e250177fb327d588e836ef5feb9908a4c8536666b00266de763be1fa17fbdfd67ea4d3421f57f9842694a99d1db4a594d0714371b08efaf00f898ed7ad8e59246afbc9511be164473c99bf29868b83c2d08536df0c0f6584fb2c1fa14f097b157ebf95f45c6e2f571b53b656b7018836d0551753a48954f20ee7a8431fc1e1e69a986b352628705b2209f391f1ddbe62585b014a9821c2b03703f1f0c525501418cce21b7019aefa7d2b381be3e3d3454eb62be2da568979111daf343491a72b641ad9c7aa3771dd194d0ddfc06aa847fc2838fd079e304dc290c29e7213870eddfd405d6108f9d546198c8e18d64ebf3d7063902c165fd9576b098454d75f0f2e7b64e308b0a798f5aa0e2aeb8ae4514047f1fd7ced38fcb29bfea59098870c6e39d331fdf9fc4a9fccc1b372998949230760c7863f569f57a1865f8e7a84a74ffbcf01ccd1765bbe7493cbdcb10c542b5fe547176f1ae9f7bfac831875b492e91cb8bfd515026acbc580502de0112fbcf9dde95c3af883a0a0da9db837c832eb74adb04eafd57af7f8d6c9eeb0a89d23e33e394676965e061ed11bce1216e106eeca083fc620264170f876dc4ec2e9578b2100ac211ae516ce355d913fc531d6a0a5b21d76485e7a7f1fec0098070e81ad1aa5a5941135b621eade18a416028c6bec07ab133341d41f9167bacee1b36be53431e099e7b0aabba41d91e1217e251bf2902bac8dfcceda793d387641aea7b20c1387aedfc49a60e7d99e0cf627cf8e4f403a932799862a99c0fb530099ada5c2c2d266275dfb46470dfb287609030261c3f1924c21429708556db57624b171901d6344d1f08f3ace57e4d6d0b0c8ece79bd246f6fa3c577589f01caf4e94fe80fbdb87695d60c8edb8a939cda9d0f8088c311a145afa893861489c5267f7286778e3e5bef09b8f4c94535385b0e7e5936ba43a85abf69ce2cd88ce1ec8a8127ad2e1b09036bf39238a8b094cbdad813067388c318520abe75e7a774fe245a902a38d76c1dfed04d43c9b36942bac791c357ecdf62891ca5197068cc40daa67ce12dfe9c97fbe4fd2ad62080df4e69f64f508d9ad1142ae07112b3f1870091d97bdf294281469f0c740be9fff9b5941a5e79d8854541ab82acbc855491fc0b9b65705fe5f067f46847362ebdb3a62eb100e069e293c91d39d4c06c21ef909df133e0ba588d87f758a8e8116f1d1cf638d5e0ef686df6b2864dcccbd8f109256516d82b88add843303f80fdfb853828705dc3bccd5f18580f3aea8a398ce116fd7e83016c86d03e89ab2eef26eb688144662c01dd2f8a65f8126675d0e71d27162d8ac1780bb97963d64eec20a09bc5072a337ae25c922eac2a19421a203de688c8c86f7f8848f90e74a1cc6573939b42f83095462e7f203499f33d1c02f3e92b0fe842852c88ff54e238cde949f7208e5b5dcca4b6c1e281879444cdffd766704622901b4befdcb44b914d78b605921035ac9e14f91ee9936dbbe56d65a3baf72091490e86b0f9c465c163bbe0a1f88bb69ea3fce51cc3fd7a7b89bffad42432f561354015a7e02a5de458b948754a6a2fd510e0aa65873b4a577743547be459ae43e88ba4a6d0460d20f3d3c34da89af600736196abb796e8aa109c964c4bc0b93076a768b51291e80b31da96f17cf250bb00848dd65f20afc5dd616738415f650c05e39a29ecdfea7e4318010725518b66bd621945f1b53cf71af3a0353b247e75c3af52cf11acc19e2f74f7d103734951b1e5055291046089428506fbbb17e3a64236c9316f2c6492a3aee482dde285b2ff75195cbebcf0a57d6622abe4bd808a934e5562b2666a81188d9197793c6e38897dd61d12bd536f6f116cd4e904514ad88938a3f3e930a4edc5e9d1fbb7d884283dc5c30904090162817bdbe4c0590e104dd840d6383436188d8f22ac0992736574558d2c828d14b5a50fb9668e33e25f543555aaa3517226713e0ee3fb429160e5ae85b7f307eb6e68929c810d86c8eac7d07bb2c7eae270299ca6569cb2d268d151b620f639be7134e65d21b46eb03d3362f794499b5fb3bfa1b869bff3636d87d1394e03b65f86185d49290904e81314b68d211cb5747adb7c357d77efac15d5c4c5a55bb4f3d264a088a3764914ae217ae230929086df2ee0502f084cafd9f99196d30145f7637a7151c80ec825be43a4540c1cbde60edbd561dba67599d3efe51139295eae3db24623a46a4e643044d90c5e30160834d66cc7c1577f3126b27b5165fd5750869ca7dd691e282671032a528f1846e207fbb51e643942912098c4c9077f52a6f786848dae5de5824986363d36ffcad77992caa414596325a42f6b710740443a101de99e274a00baf90ede21869ca4bc51f886a1cb8a432cee4ec916d4ba1b811309a27287890dc5a027c8272f72d773094fd1f786c79ca1d0027bfe3a404b538231c185bd9b72a2e049033de1abf3d3332c3211c4a14121a25b648c04a9b02a24cd8648d9529045c66090695f2e39d02d92c643debb6936ccc4574b822262ebe07d5666ddfd8ce2e912d10b44b519439c358892caf0ac4ce092d3c778f81d45b65180c2179d7532a0174c95f44fba240068933833c4751492fb5f8b898089019ae3cc296ff45cd9d1115032917eb155720da0437796955fbb0edee1289a14a96548569dd4949e7a57681bbfe9c50470d211a9b393fd2ef748a7de28de8291a93ce88e1bf9adfce63b0c0257b0b2f96f9510bfdf682c4c5f4bafd57be14a8e114baaae17f5b4210e261171579f8cfb76f5ffd451342432da2f22dd50182ca089ccf241668366974a4b82115ba020d3bea64ddee3e2dcde72c33b3209f6e9694208d3fe28f1b4182a329e8e138fb9624a5e0f355fc3421f6445af8bf48794366c161f2be232c3c139c3c1237d591b22e07849a33ff131bf108fbda4fb9c600a14ff6c049b08e211248c5dbc566164e568417ad14a079d46e1548079619b3b8c056183cdf17ae6df01c3eced80e4fd43419a1997498a71ce1ff229434faf9f307264806e9164b9cc0ed425a8a30372b51ac378fe8f93aeae9925ab4f51780ade827f0880b4c030753d06f63054afdb1f3aacc8fc55403cfe377a7daab95c8eeed9054713b1004d8a10aaaeb8baa059edba3c907a86d58d72eeecaef0998b14a780420e4c01d3bee72480a0fab88974b666d0d83f7b0c4daf793b5bd51127f2d4f4ba6506a687d6e2a6deebcb2e1abba9286e4531b62dd0020b9414560ae803945c9dd6a1d981f6c0b5cd4f5d3cba9a1f66fe604dd74c9fe1879f96c2de78abf41007f8cb428fe08f7bf0d2a5a9dbfd7cda2418fb82d05603fd01938acb509b843ba52dc3d3be264181d145fec8e702ae4b60394743243ec58a36539598e18e1cc4321fcce162d8f46264615a61831c7abfd9a8fe1093a141f810618a6c88dc2adc0d656618015708cf9e6abd1b414b0c5cf458b41ec51dbd71467f98aa179042953a278e6281a64289e02aa32f85abd3be00b2a9d6d460bcca516bbb24f8421c4aea48a3d4650b0cd6bbd18b8cfb9385b93b751dba1b535fa334929e6834c91f4ac15047e57efe1f787a49eb6431c3c57b9647d441c05d21eb55d8f346f1ccb951aa90326a9bab3c950ed4582e4a264e242f47aa1da6bb523ee98df8d8fd15bfe853a272362703d29565c9336e57600b1ab2246efc4dfe7ec1d62b5d27d79599924b9e44a3a517c6bf779a637a5473653e4ca0ace8521082d727732cf6cb11f6fbe72fd984ae0cfbb73505dc1d79f5d098516ea41df29d562e6166fc6b6500c6e93c406aff7dabf2f4e7df8945fc85b5b272bcc20bd4c5bfc667e183d120645bfd0efee3a3b4f2512ba0e6483c5f0f09c4daddab60df6d9e7e6e63d4d5c4f22dcf6973858b698d50d261fd7d1add90b834a698089f5ad14a8155c2844857b986efbf4ad513b9f11f80e3fb152fad496303e11a0bfdb53f58b440ca6a7c99aea1a478431ded646eb908ed46c774809006b3fe154cde5c4a4713d6b866a8892f4c3f5e9b0d8a7abb6b261c27afc92f818a5e8d7635a39c05732cb8fdd19aa2a5e310d7b50ef3b485aaf7c2b56e95f39c46cf28cb4b777e0c531bf6b2b6b5c1d29e186753255678780e0ff7d0f119c7790033407299ef58294a5c040408feaa8d02179b18cd7cc26a5f2a013c84803883cb543c4b898b66b585fc77224ec20f5693d43d760c188012121c258620a88bb0a1c5f665b0cbffa2b82bee1a6361c619be8f618d72103aa224ec0eda35bb57bb30c323206d588e3fb34d724d533927ad60e706ab50c37bce2d7a37962ff9a2012c1c5f08882c569ee03e96a2a4ccf870a0b5edd44372257ed68eb62e2f7a3df9ee4ead7278b181969150994b902bddfc92d2da9e77800efd5c68b81da57b40e5adba7722a068596a68c98940b4a8ccca349458008f0bf2ad53e1e89504b10e0fb4792e2a0f57e5f09f1d63f6ef91f17496b8ddda4b1f27a2fdeb4ba42b571ede9ef1a54c0a2d9abc62b8f61cb84ccdb4a254b5a4dcc168747bb36e3c4261a2a46425948c6cba5e9a4d2ac26e48db3511eb319bf6fa1d9c9d660d7f716bcb6f5d1400366efd3db022281cf0488154bbc8ec4614bd76803c898b4ea4e0979a1dbd36dfae32bf79977e265f2c9593bfc69beef84baa5c54b5740dbe15a953b6b40df737623742dc07548573db3362a3ac2a232d64ffdb89398d8d15d61f2eb1bfbf759af27f89af208c8e3f1777f3f4c53126fb3a1d3a118771c0f241505322c51ed159bf1846fc24b36301c60e5af04dd954458684910331dd928e99cae523b87c718e96664fbf58bb22506169671b957e4d17c2a5cad564bf549ab6a8ea1916d2df9963734e9cc810a5bad99e672575b091b348f8746a557f5fbdc547609addd99bc4978c35003ce03bee858656cc0e637ce897d7e6b96efbc52d03be3212d7aff0c15da34321d0243ea68d5faaa017da3c34036cbe92225371a91f1009b9d6e58eaab7afea61672ef0da2d878406a9e1b42413b2f05169cc9752b5d633260b5273758083a6ec8c8ce5581de6104f9345adcb576192515583d34d15b862c885d84b771b3c68cfe5848200da19f85433a67b8578c2a49640ecccb15c03b4f3544dcdf1f4d2c3f6a7517eb0c4211c42af4cf4f55669d137d68931e6b8de5b4880c7af8bb2029429c7517367880b5ceb8a769f04c1f9e7b20a25e336d3c908ca36b562fd65cfeb7e157529f564ae0826ac0d508bb45a4a0315824d23332bc20e32cbcae958bcd057823e78ef130450053a50cf225378cffdbfb5fbda9adf3b1e14f106be5d4514dc1c1972711617cb226d7f3f91907ed1b321a9c71505d31ce93cb5e9e1936de2d2b7f5874bf2369bb7ba4726a591537caa7030f44f235f79bae5dd6bd5555d2e10e9be734be4b5e8e05e8646b2bdd0540a69c4d3fb9119bf8e65f2dfdd841132e955817a9a358581371e2343592ce34f4dbb2986737fba171190a42ed7966d70b827034eb14d7b3f75d43ce8c3cbb1092a08b897c83af2ae4d1c188644d18fc0b4513800bd6b81ff961392b34d5a75643626dd9d1cb2c77b8c457c84702668491ae9da2399bd2b827764e33252b49dfe72b8579894c19e53e476b1cc6f137ef4f31827124efd3fc812326c526fc10ba683eb6efba3c41395c9db0a4090e7659ccb154d595fd41d57cf04f96b542f14c793309d6c9884e5e605291911028fd2240213d1e54d4398a12f5ef45bee280114242220a9962f54cc233c041eeb28a1d4c05662a9daa3ae7e013a35b9796462f4b4bed6062029975ded824bf6051502ccaaa395c5bd21e334ad172529f3c6888badd6a3ec8ffae282d7f6bce7d08a1a9e53c577158207505a8288b2ce2aa37e9f6da2ec3d64fdb75daa3ac2deed9d9589bf302ad816c4992c5fa461d31ce62e8fdfc102e26ae3dde10cd98eb9cb959dd25700e32f3e967ba5c802ef864797eb861b94ea1b0475099711e5e8e3af51339b8d92b5d112c35a129e871e83ed53a8886ca5a593f9bb09d88b0c298b6119b846c1bef06530256f39e52e7bde0179e1e5bdd2d0eb37dd679ccfef42b11b2be24ff35d103203cab4122a7c699320de014b13f25bee328dfbeb7b145c86f822008dea9d5614a38b6744db519baf04aa629609d242af82502e257ac9a9a7ad481ccd37d7f766c31f4973e96a5ae8c4c995e226adef75d90520d3c30b68b6c1d0a39584d360ef7ce0793a672fab021ba49d45b2568ee0d8d349c28d27a4ff5beacd6b4b5baabd730b8aa098eb5fb885f62aa36e0e1a613ddbe5f3ad90e0746baa6211e8d5fca76c740b4d2f72960c127d606754dec00d1521d70ad2f2ef4a9dce22504262dc508efc023017ec331b261d60deea5e0354786d8919e3e3457537923125cf475181eb1309e3d737add089795ea66375c50b4919feba436adc67f4282adff393c008a653762f663582a968e13d7448c74ac91e06788d5c0969d86a730cb46cf9d9101af87c5b77b116f54c22b8136333a96c057e80ee6a364417cb3fe745ad5f0c5b55982386dce135ecd37b9095faff676d0c0d35b9d29927371fab1c1a012d19382f71eb499f19e31e67cd260ddf2a3480d6d8a731c4b4e63c9be74c8bc48a21339c4bcc7d6b305e6aad993886af17f1cf63cb0de81eec38ea6542092f2c5cde57982f761e0a1c5ab3448895c250b46198284627c3ab17c447434cb9c7ae04499131533e75d2d0e84fe45823ea406eb459927278dd5afcc17822dfc99beaab32c3bf672791d3910846225e9197488c59328473eae9f537f8225fe7f0ec36ca089879b41cfd291ee4bae81a3a04ad4151620bb992627ac7c62282fee4f7d3f8042f59e3381005b05cc551dc0895c5f523c51bd73ce2e8d460d7c1d160cf863981cfc3aba1c4438a20a885e32b94238ad0d783686a547ae9e0fcbd52f37b9b666631efca7295a02dd2bffa74949c2bc3cb12720ee4a06c49f554b9aee917c978b6c60838f0c9a44fcc6290a852ac68ec1b52c9ae2e7a951f2ca12169fbee04b84f7c5e84b28e555d3aeceb49a306e15ef193410cc786c8097dfa39639560f91b75cbc88901db0b069d86eef7bf6c241bf3ee9df96b8ac9e0ebf702417ef2491b5a4a5a76b674fa3145d077992d61e34f0cfe6d22de2f4f42163d11f956c0ee154144c7952279e0153d598b476bee03359767353e013d225fc00c9325c33cccdf252d3be20d2f7f4814caaffb127be91e61e3d1dac4c2b1e57ed2e45ec8b6f9429e3c212e26defdf8c87a36e4bb368725aa46588910852919041e4e062dfeff02854ec53426d15eae64e4ad59be029e1e22fc02e0439fd4c636173502884d63ff0055706dd16b5d5c19cd2a80e1d8e77d9a6e865cea53d6a54c2be0555d2fd0c65aa1d851655b28c75321990168c84084d96b6ae1727e29fb378caa9c8bdc9b5180133616316134dfcddf436843046ee9b6a5f6d44be823598cde77e3f659a6f985bdb123ea8f9cbd02cffff36f0a67db564dd5751b31cccfb51a6a85aa44f9524810558177006d121eb43d76991721b999161a19fe48e0551f2abec376db815266942383c7853f39a853a86a89b431ad03fbc6c783818d8a607c1bdd0cb8ab3f4a440d1a0f700dd0d564ebdb39f4dca5d9e370490ab6c8fbdb6af9c5cd438e859d7ed51e3af0a46abcc5590de16b4a78b4759a5f6556df19840c566160c5abc493d7f74cf6b9444adb17b802f00df383f101cfcafeb2418605da313841a6a0b21d87fa784d35d1d2164a8ff8343eb07f3c8ec56ffac657dbccd2902b978c414cda99ced9c72cbd932f5869133059121bde7ffe1a1de05a83c3b3d3fba93149f7435fb02b8fd1d9340df9d1f67443d20bca6c771f56b577c20784150d2addb9e3e15ed14583114108b2083a0d8a217088f9f322d12ef998426cb3f0aadeeec5b29d844a3684065547783aba6da813a3617dc5d3adc8bc14a6765af69d6d77d834eff6bf8e6f331cbbaeb19e18a202d8a1358267048ee46cd7f4743e95af44fac96b6a3e27b4ea2cb34d43a4aa7d10e345e992aa20fa84d4a60e47711888b0739f8387ed03fe3c12da57eaa329e100c31b2255084728424f3a892f35f3464393c6ab8de6ca590ebf918612fb946a3404b749306ba76783f52cc5a43dc6630f64a38c4b5c548128498816655277877ef92b225a0a5517567de4ac63e5e433cbbc38419e14c5284d1be5eab0d2be5a5516e3a13399c5e1247b7fd1ecc2b21fa350c6e46d1f109b6bddc5485f0e3d6010bf0bcf56d24b87f17e6211471bf2ae6ecdd3de8808343c83a5663ad4114060e6a1213adcef8e3c1a5e095df5abb3dd0e578a7a178cbaf4e199926f29d8d781c4273ba2969cb2a8a684fa2c124a523c0cec8e1d9633b7fcb3bbf4ff32272d0028b422c3771e4b68a55f796ff85e974ec09b4dbba87e562315d2a2c8e155e1b7d415076b719c19811758f94faa75b9f09cc889578e24cd76a1e9b0b19073683c87dfde400e2a5f362668bfcfd1f5bea48eca3c32ef286c915631556a202014294bda564204d3a5456956962bab4dbcf60696117a7770458b97c00fc570d44bab59c11a9c2a48cdbc899c9cc8af4b4bcfcff9430a624276429c4f31cf15ddf93d97c2bc51fa987f3d6bef14165b3e48c327824a7a1f6c94e89bd95a3c7447759dd1a1346c2346fecdf802135b2ad0dcb4d9d635afc7d7988553c60dbdb56cdd315989c4435f802f50945f1a99133f82df016fa65e34b5502f03373a7d175d0de1dd1dbbd2506bb9aaa9767601797e49d7b0d89b55002df00faeffdf0819d55f799e159ad79a6d4ffe44f256ac93f1ef2f7b858b3c4fafc0369f16756409dcc2643a42e7d126eed60354930ff3c19c7442f4ad0b3fd95dba5c7556f8e02671a2d6d6ccee57713019f3111f2155816bf9676e93ad6376fa3ecb405eece35abd0ad250b7eda6a95f0ba629318094bdce6d3ed79ec177428da8c884a0acaa25233faa962c82ab59600ad32d886f1d02d58c051d2e72df5c87cef26ff17992338de061aacbd640f8b5f1684118c611c7ad13ec7405e6b847f06880585f7754bd4f628f0a63f0a593d501ead56c5858caf0b29fa523b007344f6e6492591f6acd33460d55ae2b613b005786faa21ca0c5d760ef3d6ab923668a72767d401bfeca73ea07cba9ea7251a9464ce629b16c85751277adf90f39d71e38f7eb48d4fd9745baeb221adadeff423c3a286037c01b7fd365e12d85986835a05559502d4fd23c97fc62f04591b9937589c37566aa6e00db5b829bdee12a0fcdf65ef126de3b42b67592f564c367eabba4393385dfb83af024cd7e6020957a5705dbd6b2b9af4ee2712df455a854fdc779ad77b8d817a2411de6930edc5975b962ff62252b67c8c4869d062ee76ae70b3c8da6da358c91b34f0e4d549807e5628ae0864fa18fd2e375a07a19660f0121f19681537a657863bb0c056a96251aa9b8911acca99f53bb6420d539bfe1f81dd8eeda79554484f5fb4270351e7c4b341749c00791f875f8e35c86b566c463e857f28bf2637ea3ff7979370e1829a5d2bb1f5f03340a04e2f1be7ae36d0d89f275f882a827a3fa0bab10d7a9cdda59280dcef10bcea5923f67fe4eab5d469fbf0ce279c2613ee30e9a1a68c59bf7cdd9493ff4c8254c6364f214e4e1e6277780db9ab8164f8ae2a0a62cf8c42f0f9348b0b2de0bfc854888f9c973ce7667e6043f5de6e618bfb8cd21223343e881ca36ed05b39eb0cb6e2c5e9bf73022d2590b75035b5d429737b77ccd9c34359a71eb69f7b09d4fb836919e85aaef884ec1758fc788e3bbff47c6db3ba541d56924fac88d067a52e879dd144653d9ced6c40cb91e1957b5b349b3a0803ba5954d90513fa155c7b97b943cc5b8679ccb947f0f02dc0cfe01458fa05202227c114ca294296e1f98a1cfb8ff378e6f9c2f11fa08d6a31e07dca9ffa136194d48e6448deb6d7cbea946f396e79089879bd413a6419f125be11846eda4503985297c3118bf88c4f5cb976f3deb746f399f768dafe5d765fc1078c679f16d00704227dcda569dfd77e69663213dff75aef4d5642acca9b75e68e3e76d7b517315c9c570a89b7bbcdb2963a8f4ef8b17e5a6e0751d0438094c951597f516047d378198c94ec5c4c5cc5d410ab8e177e4159230e9172529d5e756376197417bea9ace92fa202fa69d5ebab26e8e175aff457ac4e4de615ddc981b322fd97af27846946c99e3a44cca386f7b1b8f54c8b623a1ea51dfe5c695eaf6c8bba9eb62b404ce71c90c9e76be7ad8ff3403afd0ac7743724ad8b24f28cd0685791de381cb0eca9ee1bb638c6a2741df2192fd1fd939852f677205e30749100a759dd35e1bbfe19f1c814255f04802c352d4822caaa967c0b78694780e87a9f68f2cae59b6bd240846a1bdbee876a9a9084ce618dcbffc81d789f5bc9d22b0bbff438713e1e76a71295aa85ddffc8438ef38e143098c4fe5dabf0c6795d4b7dc0eb72d18d28e0272f7a77699273f6b811b0050a62ab0a479ee2789bbc2a841fb36a6733a06005c88eb2b972e05a5edb7758880462c97cf9dbfcb1a793496af30b4969f11eca66229e668583692b2211d30d7eb62c0d590505b106e19aaa2ce7c40ebf2fc055a90ba1cac32b54908903759cc1a979260d9e97bcf840f570ca41738b46a304906b747e895022c55473b47e5aa3e416656936aaf0c573d63c49fe202213929ba617888b4b173ee23d664e9e19ab02be85209578804470a337691406d31006164761492cb8eb203102664ed4d5ccbfe5dd054e6df33770b36ebe535b599c1f92894a8dfe3868a76e9e48d7f71a34becc1c1d9ceb607c309e25832941f1b5464f3c723d0225f8233af57c9bdfd776049f40dd8a09c960d1330a892e469b0521c72cb88f13eb9f0417a6c33f81a2ece2fc008dbb268d340a5014caf7ca0a68ddba1b56f85baa7a40075da9a901dd18429a10f62156cffdf0b118c16d000a03f660d353412d1434df795879dc6118cfdb9045867a0491725b5f7414aaafc576536dabcfaebcafb0b26b9b38349f894cb6e4156f43e81c6ed263acec8cec09cea544153f3d669d896009ca12acb69af4fa7c239e1bb2925036e967412dcaeb63676ebe89176990a8347c0c6dbd8fb70e414d35b7910ef2c2038de98776df881f91cea035fc064a8e9d0db0435847b17daf0a4720c3400ae16aa8bf274c0e83ec3463b14b4e3f182e21ce60f86c78b33ec068af617d7814d8b5388aa6e9e1442c54c5a31b7586e89505aad28a3f7a4f8929a4e0b8f376f1185ae9a6bbdf5e616776c1ef94405f446519188386003819be415c5732a18b0eee56462cc8f02de9c3bbd743ed9f50c4ab1b715788b70e90f104cd9d6e2798f474d784ece842963711dc79b4608f87d284b65cd811a44958bcfc1d730319416e0112e430edc80583a5c9cc50227e6a0f8d204d84b5bf68b4d375c8cc43439291aabaa9f6c29759a6839838c0ece64bd805fddeec42245e527d69afb22b767369e349cc0e6c0e8ea98f0736e084dd03f06f8b61a36fff3ac17d5b12068767968c3cef41ada87a1f6b76beffbde69b6b1650bd1679af2f2d154dc5e714933a121824208569d06d4f1f42c4ea4824da3590618a121faa38f0663754e3bb4aa2a86b26be53b4b708ac441ae92a28f4c3a6477f69f0135f38761201b588b5d756443fe6eaf00f946d8714c9d3065408bb478be6c4bb2c3423c47dfb5048cb1d3864af02460e966e043eba077c7e542517c21f8a99ad7913380f11cd9ac7c308e1834ff736e838c18600296e7b80e692afecb846631ab7051ec464814f1fefc6b5cbdeab2f292906e06fdf0100cc860842db51efa44ec57f1809010c40566cf703b8ae1d194fc49c2c7b39b6db67b8de08c4e6e464e4d4b55d964523a0c18d87bb3be2af94e720514db0323905cae722433468ec839e1b1740458bcd329794043110e4ea89d6867b0643802aa84c2cc4ef84508d1393fff3546bc060c8c6b8998f4301d85e63c6669260f026b1cd63967d353aabbb270edddb067b6ab6932a0840499ef629347051aa467d466cb15a98f19c05ee6fc4906248347473e313b526ebe2bec9b626bbb522b25d918e2a3d0d99f12797cd1390622e3e2985f4a833657a4f84c71e4d599c3bd08d51e210090cab81b94a395c91ffdc197309f93c62b95bae0a8549d534608d8291b5a85a3126eb457a067796dfdd897fef0f54a6ee02a8e7a4629eb271786e5e043d36bc878c69b6adbde275cd30b5a06e32173f4756bbfabec43ead874d39ab1f396561c455774a9f3eaba6783fdc276401cb579984283286c8ea3e69be6f8e3a86707bda47b61d26194023caa5199466d98d9ec88a99f2e5d4e78d42f69bff43b2c558ccf31e7d731a7749b81626713c982900ba9218d43e629a7452ab9a1af8365c806ac41a3753ff8542f1f05d4235565d307ce1829d95c838e1973693f67b55aa35c9293a36609ed63686b4d9a5ee174d2233fabc319ca0e90ac1a4fbcff9df088571e079dcaef01ea6e95e87e863c48703e99022a1851b4b47a36c9d78c5f6ebf2763ae029d67a51eda489edd36fde85cd982c1529fe017f68c6b1361a6df03019c3a16b53bbb5f2866732b8aa501c397120cb5036b4faf775ada60e95a16bce79d3a7b3ed62f955426b0ad967d280f14f7de3bb7cb1ef9d7f06751b2f7a8897d5ce2b99da04023ac6f5c19f4f0d826030809f7e11ac5171d4c59ac38297428db2b4575d2dc007471978c160ed68a81cd762f216a81bf17821b2425c913f4daada92be9932568944f8e377b79496e93ab2ba08d2fee56f29c6b1c0b855d8117a0e1ca661dcf5b257097f2071289683d4897a6e0218646947f7542a61c4539c977a45e803ef69412674a22b6b2bb09c6d7d56a68746c76b02b3ef33bd902c47711bf9aae8e8c7876aac663ac85927ac4cb483220a9511a39e09fa558fd8fb015ee5639512140192a930a0059d5c29addc2544e815722faaa54eba9c36e5c33150ebb8243ef3fe79dd9eb3a8a5d101a3eb6c1e8610de8b41b98e2d8655b21e8c2c96f7ebb8aba1435e96bb8e2910b70ffb8a17440728f0c6b684e12aec3d0295ad64ec540245de87c2f5b39d89308cb8bfa9c010a001a01083db94dd0a1aebc88f571cfdd35c22157fa1a59f711019b54090400a2b02d87fc2df7089ed8b0c3e1c971cc57e30d659224e5ea3cd6ccf34ab4467962c23d834bbdea582731ae547e223053aadf10da659747edfdd1dd9aad16431202e4f9970bf99a5b2ae08722505fd3357f6caa2a7b3da15d22ca77a65ae87e6fd78986e255ceedcb0275abb98041bd4061a05f6c2b5ac8cbf27e14a5371d98331acdfb6ee08a909e605096bdd65c9c1e32c9cd018022dcaa013e8c8fadb5a2106e54c2a4fdf2923d03d5bf01c3d6a81710d41cb05e22e9cfc8f14585d0b52536e3c87eaa40b5e06e4edb6dd361f3a73ba7915ceef6121f03f5fd9437c78297b983f1b0e742f4078fba370d5f6d0f858c74cd354356b5db51885e95b7e5b292987b10b9a3f66040b1b0565d07612e09d4743cb052eb16b434b29e3c403e7c2a9dd56e45d5340d677f35f99a7890d1e716bc50f02f0b74f0119c64676409ecf73904005ca0894437996caae6daaf731985404b70f63604fa40abdde5aebe8bcfb414757e054d1ccc0a2aa7d9f767750363514bd12539662c7aeecb7f6034ae502c740739a9dd722ea83da3ddcf77575a0c94fb348ce6904a8a487e8752d9664a9c38e3065e232edf8c88f08936461ee23448b4688d0cb53dc695934f775f5a2a0132f351f84ac4c2394f93d8af0e95d7eb1ed846d8c18ed3508f9f786d3abec171138426fcc37762f5be09558ec78df7e8c26446452db0a0cf12f29bd24d3ec26e80f5325d3c19000e038040af27d2de9d0460d3b20e3426120a7d8411192d87f180d15744bbdf9041c8bb8153bb6eba93dcc0fa55f6090752739e90aa3bb8bc81963ab2bd533f394273d0f6644a072d1b5aba22e5c9216e4caf10c8a085c4d6a6ac24abd83830ba4b8fd918743032b55eced87c37b2ed984ea03baae29de79266d78879e69b086e9480ec00cd6a4b5512508ef744e2c5d8ef7a83daef03122f9953f8266a614a6fc345e11a2bbdddbb030875ea9b7fff5433f83316445b8a9d322e9dbdc9e541c281c4495ff833ae4c677fd172093af9cbc94e564b45602560ba17e7af7717a65835e7188809ba6d54a1bfe5089e5acf820bdf80d2e13de79532741ec7506ef2b0f547db4f8b852cbc6baf6d65d265c7f45317475763356f945390dced476a8f020a1d3666af9650cf517cce2ada9e043306f593b5abb53ecbe0fe854d72ba31840fc7fb85a0291298c9a6cb58422f0c367c35c17bb70359a0072e54290ffb2dea991286d7791688b23b5228172a40275349a6719c6867f905a2d0a27c2f0249344e5ce8a670b78ebc3e0f68a9daa17cbeec52e5125af945f7272f7d8a16d68cb15e9bae4879123e786015f96b263a31cd59a62c7e5f1013ca170110b1929566e8a8b22c9a264621665dd51647446be26c535ba70bbdeee299afc9590cbc491210ccd49799b6f176773f582bf9dc8a56cedb96d5b1a159d80523f9beb91b7e9ce21e1de6390f461a41dd09f0403823cd52f43840bfb735d5d876b01e48f58aaaf0781c83dca837f4b09c121cfe4db27071a8830c2ef7a8a409890fad06478e49a9540205b4425b6c0ce395a102db9a986defb23446d7ce25dbe023568e9776c37764f2e35d62a68b1df1009e32d89b83b6eeb86d6b9f976538e59facd9a1365811f0bbaa9c1cc8297ceac14d33de74b6b89260ee77b510848bfefc77a861c2c210e21de66b6329f6d96e3852519bf199ae76d9a2f1ce9eb224a8acfaba9171d7aaee4bf523a9b1ef050ae858211f36df2352abe0536a4a053ecdffe9a4ead8ec4eb2f7c394b7bf7bee7d0087fe455609431edb87eb90385c9aca1880dcfe371ca181396ee9ee24a8da61670aaca4d47ce161da628044d9a1bf7f13225e5aaae473e8287234f00be396d2d52f4529898a3f40e05cdb5939fe7d75364a6c1c1099f4202ebba2cf761f106a4c58bd6433b81fadb589e7d192b419a43c63993e9af9fa2aee331df36d184a5c7b09ab911667bd5556409abee6659b29cc5b2dfe7618943c8b61b178b99d83b71b01c624fccac9bc7be3b9b23abbf0240236aeb31a6f1d48fad20e967e2c13a84f4b068d295fed38c33e008be58836d6dd16ce3fdb3bcad0004f5a9e7461660f389b753d28a599023c0987ce2eecaa5029031768514732a2f5dbf1c70c57577e26dc09b7c4e5eb0b2fe1296baddc656d630b82bb07520fff0820710f27760005e0110a2aa868df422ee5c1c0872932dbcd03c0f241c600393687878ce32aef69058397c8ad3c9f35a063c948e4673346190bd0d2be69ee868c7a360d896ea7ca5638adc0084f4222c9fe1693537c550f252613100ec09b8d8539f7c3bc049e83edf77361c8927222012fb2eccad1f3468622fc8a30215b89772a2da601523a05e544dd99ba3cad15e6fac46911826ff8aaa57ec34e2c15a38feaa2e2997f8b1e8d9f13e02b4019f8521a90727a361d8d647c3141735486b0ecdc4e35e0f1c90e6e2654242c139c4d207c4494a6745f1a2bd4ee1983ade5fe268e20a264d90f2444bae0ffbc104b3bbd91e2c2e942029543dfd5d93fb47ea2c70ff8e50632da3a24f80d14cbffdfa728d28027bcb61d3cdcfc33db1ce2c7726ba7f6ebe6b47e4c05185e6d6eead7fe45849e8d190b03ec58673b1aef9e2cde9e168ef689376c271319af3b95756df605ee9fa4023f67f7706b3000dfc8311fdd3d08b8badb746a7c071711334be057e984610fb61cba154bd69fd6ae674075e91ef4cca1d318e97e4e9081732476fae7601dd40c23aa892829bf504edefa274c08d3bde78fc9eb5a61750e28058b34783312cc6514f20733931b0ddbae54ba9d9df13c550ad435dde11d503fd0e8be9c8a9984478b3f64e3b7e77352453d50819bc11fdaeb7b6ba94d02f3bf99cd8414fc973c0c4f5db7f390f4e9635b2a1dd53ce69275727d5a9fe12d95c3610f2891108b515435c0babe98a6beebb38dcba331aba5db96acb6810766ef5f5fe5f77825b92e1e520966d0acff4a821bac634cf711aab01daeaf5b6e8ab68ac67e5c280c72852e9eba0e9db897d0be4861885276894ce5e1b71518173cba130e4f4f25f03c4deb4f9ea6dd42c0dfa57ddd5518ecf04709ae3d924a14f51679d992eb2e7371f94bcc4cc65234ea5d79a3863c319faebe0e623ce95aabf8fba65a6a7ab577f624148b7b51ba7f05e72c9b4af332ed1d08ac55b1cd8023f7abc43e307a1b141e7a5c6bea1ce3615d23ed95cfb1f29bc6c9c0707f9f5ca785881449f2ed5ecf679ef8f8cf18a518478a65e49c0752550b531586738204b70baac726f58284c50c953531f8ad09db847589ec66f62ca53833e698901b18dbe0549be2b2979c7a3301ef05bef93e22da82626a2ffa801c5d7b8950507a447afd3ecee810d95c5b3ae36909b81bb64ac084473c3b2c3d0589fd90421db2cbc09c633166bf5ded210f48a4c3d5e13279030092f9b3484aed3b9582edb5af78db60f0a9e3f7a706ca40127146b93a832e08078ca5f4b61ca6a4bb1ec1625077a5f80a87b312efb7a2ac99d56f652d770ad7566d715ffea92ecd6d48bf23c60f909e9e7bdc815d74b9ce03571c481cfa1303e5c2f431c3275648effa6f31a1094a6c119741fd5f9a0aee5508c612633ffb0bd6c792812e12d14f233aa54f143a3d5818fc182e0b899405b649f8c272ab745f4c85ad57ed80b9e1f78e2df1ed97811834ef8afbceeb9caf07e7c66660f6b37ff4eff0e357bb45c11107f50817933a4fee118097c14228ea39791388dc067eaf66211878511f0b0bea16d309a6e53102baa9667a5ce68c7919e89294d152a5a5525d78ce9b20a60712897f9eaec8fa52a7bed8820f8f174bc49f3a9bab4b824ab3570d9e77a729e37747f5de5323531f438cf73d94f30ff1b374e3825f5be5446cb96fd7f26f46f7a6b89c39b40df95e1b809c61ecbf1582a73978e99265bd652a4da434f6353c4e53c19c869da80598a0ea8ebed0aeda9d6f73a173a59b6cd1dfd461a68a6b033dab8d7fafad80a1f7e39cd1c6036b296cb7b6cdb9e687120d68c07fb7333ac5f2c03d47e21100d852133f3e2551eb1668ba9d9c3c86dacf9565ddc128aca85193557261ee58a95c214d263a0e7b0b490cd5b13859ec99e262128c0bf64691b60ab1190929ec2ded9f017e744a1f06e1c32f55ebdca4d2212fc34d31f8a913637caeb225d49d5bc0fe1c097b134fb4eaf7e87fe0a3626031967e31c45d7bf7fb04587153732f844435848639e7cd26f53f4ea9483f29db44ea77725e8140c2bcb1883cffeddae97ff0d9a97a599752041fbdc338f420973155cd042af3f575eb50a8e6f3014d269b81303e5371d6ec37493c0e170dfeecf987e99e18d63ce8d9b05d571c32b105881263f6111b9cda78ebf817b5d970f17412152b31efee3c339349cc098857e9e72468ec4592d951ce273af0be3c695134b2d4f3ff458e8a3108f5572ff050ff2c041ac262621293e2804e43c61a3a8f057acce0e05f37acd9f848ae101dd825b5e27875de580bcf3c91a52065f4aed28bd33c06ec17996168ab035d643a2f88a1e7ef7e8f5c72a272c23c3155ba449300182fc23f3efa3430192064af2cf2c04a2ed7ec4691a1603641c10f994b7f160492bac8287a6c906696dd72622c4d7dff661d6940d1f3d80c77a7b32adb51f3164284bee40d3649a7f7ff67940916218463fbd99f7d2f264a841917f999514e15a0050db38ba3008b414aa347c7e90029252948b7348b1b7e42fc3db3cd39d7d7ac8d66d413a90ff44de8c06eafa07bd46249778f7942bf628f7be763c2432523b00ecf3ac2edbc2ada07e7eab50a03a69613044950f7dafab01ab7e9af46b1b36df7db89427c3da30e262bb6fb33152a316431b8682e0d1bb1455915372f9d31ce1fb016490043c99c507c8c8f46b430ddb22ad6ef87008d899765c6fda693d30301f808e9ecddcd09efc37a16aaf7008fa53604531dd8f31b860c495d2609afbdb036c17f0a55e58ebb60c6ea8f88c5f8d4f85b8a1a4a26de58f3af2f17b64cec01a8d986d122700629f4e3206c30cb86cd3612595104d5f651a48ed62d6434ad747dfca28f3e5ab2ab75621ba0e315681e44a921aab17c444c037160657b89f73b2fee504ac9497003b0c7e625802f4242ea80a7e188cc503eb3cf7c23f85ea771747aa83c29415b1dcc8eed1d17aec2b44321ac47c746c4d1b99b5b474a4ea5f5e92323044bec7dd8d061da2fd2344573c919d57adbb3c86e217c041fa5a613d7cbc009722eb04aaab9cd9d0ee8db98b7c459b4aabcd8d8429304f853a151cde301a05213c3603f41e3b0ea4026f520796b4f82543a04aa56630645f9c53b20a177145bbc2e395d8c60da943181c493344aa03d73c8fda8c2a682305104427a71a7ac7d2ab86be23963787e0a70f86f2615800c56e9649a316f6d3f3333566288d427f1a937c9aa9e191b47b74df5c3c8906dc8a4bea6e7510558efaa3851cd03ca41c0dad2d594c36f7474b81182af19647cad9e229973af905d41b0515d06218e2f906b80ed1025d7d9503b310c3af4feecc8030e84a7a362a152e15b4e43a48894ebee0116d1849b70bda31ff824956011bf64dea9539d73c909dd3bd088769afce50004c1189d81d3dc110d69deb9a1801863e183a46dd1093a20a734276a223764ad0293fd83c1723ac3709315dab7bcfeca1feb4d58fc81309b96ed9a905497174c1ec1a99ff750455d679a152c3f9e45562b7fd9f6611d13a09d0f0cf12018e32300f6e9578eb398e38583673a898bda6c6fb2a6af5680084d8234348efc6db6cf623f494835d12abe11d91a5112034b77a4c537973a4ed3bc5b913a2c3fcb7c8494d571d0fafef72ab3a009364529fff7077f013ae2bc177e1d901d4514337b2b2909a576a15c5712f44d7a3c39daf4a9ab8659e76f3441720d0fc45bdc940bb11adc21ef81ea0e09f2df5fe1c833641073ee8c1afd440a4e7b38e9ea7e8b9cf5777ccd42fcd3eb373c36a91028d97a6ea3b8f664dd7a6eea156bd637a969f7672cd97da7fc9571d99b23e1ab3bf946472526fc420468482558b2ea31a146543c9a05653cbca144b118295b698dece900faa4da3e8b9a025a505e45f39bf47cd3b05daba34a63e4895e5cd3ce9603329ba0aab749220c5e6222da56a54fd80c3602a6b5093f537a4d0c4aa5ba0a4b450504a6ba1683defcb3700d5b803383ffa0e1a139abc694ab37e50af76993bf2068e54ee071db172979d8dacf5216c4fa66d9f13a0f00cd31fcdc2398a2ddeab50580cdbc6b0ef121f55d7140935c4b391c82cfdaa7b7e5e62de6c9d07212dd2aafae7aa15fbc153431d30419880de4a8f6f60056155151fefbf85bb593753d5c22eeedd9d37135dacd16b2a0866d447a5340f7a4fad586b3e82ba1612279e2309fa14bba1c6a30df9f9d23afc4cdfdf4a29fe1ae0d98795bc7073839a3cb02c184098df71146153d1a41079118fce909a093b6118882f2e70f4b06a0f567f9aca32d64cc5213e28fb2b8ec4ac96500661097e1cc76221cfc7c073cabf0baca612b7b7a34ad0413a72603cc39d64cf6d7a0f006b0cfcde929d7d2814bb3f0c29cdd6dc7b3fd4f548e22df106a8e03cdcc4fadc5d25d61487cc8ad9767d26e89912d2f5915fe7627384a842384e4a08b1a7cb59553dca8252f06d6e8772efb4e52df09cbe2e7b3468cdd3a787d6103be3ade2cb64d9c601b377a269f34324d82a4896877b18a2dda0fb8b9f9f9c428c547302b8d75e0c50f6925775e892b98ead40895f53a31e99c5e09655a0548c991bcb606911c87b1b41e063caa1c3844100ee9cf4a968d8570ece9aee0ad5e924822cac2530f6b997cc753c5b1edaf058cb05b3fda5dff50032891d2ca11e0085ae785f2e9016b787e57e7528df0828e4161a35d3ac99fd6e588aa416eca143a366162cfa7c73f11e6b365baff4f6eed9b52c6a9deb3ca0552e3101c2b702c3df64037cf58ec9b944b2bfcb151afd185c7e7ecfc966a035a16cff0805b83c46f4e2fe937a2eed71abd7ff15c5a0f75a90f67595fccb54234a0f16056bc68ce7b1f27435eb5ebbd86e30edd5f9aab8c526381766b790c57bd11350f9cc93be192d856946e82209533b0e77a94041dd5b9d07c8eddcd785f3d18776d165b9280cead4934467f6ad1ff09b94caf381bca5ecb8c59ae90e5914228371db9187199a4c72fd1b16fc5202340a43ae65784fb54a79a3ff46c5ba9f4aa2fb1aaf28a762212c8cd2019c25caa192c2155537cbd03710b9aa5256384009b17719d21d4af7583873da522965f7670178e0bbd535d1478e725fa803427fa9c5b571c962f28921b00f6ea6e77597e2504613fde6a12a61083dd1297a6feecca176f1bea1716a3fce321db65935161637ef359f72ae4878ef0814ce070e1b9c17a0e6933432eb127cd09869077e6936fa7312ef1a51857d59f489afe4ecf2d4411abb6b1b21f4fbc7aafbce91cc619c6ccbd148077b415d32e4b0f5e8a2afb182de260539452faa3d25bf6b35032f29dba08afb33154962b44de52dd9cd2e3aba5ac19dd09a654d7fa00ad3d3ef9461d56bffc2b331fea8ba2ab078beefb8e9642a35060b54f7e997c9ef59ce9d73d7c7024a134058d3859c3fd00688aa61b754e333dcd2a927dd320e7489a43fdabdd1052460e7efb6e8f03315d426255ebba176ad37deb434af9395a9a0b349f003dc9693e427cf44b126f6f05cbf57e3059b3ea5ebca537bcfcfa7cac1cf757d15f2dbc5a479b8e07a379c9256c120e813645be2671fde0be5e7ce1f67f4afee9e5b8f2714b2cd3ab23d4550adc7c42d864de59c29cd78050029b14b9c4370d5865b5a93bb9ef91dd6b4ffcead9eab051975ac098c24751b0efc129baff14f28ad98ff584a6d9b425f84a49db360d9d45f751f503b711391aa186490681270875284b595cdc49b031d854590de1e5670c35c0b681054d0e7448dca1965068358e6127f3db2fbced5f2f0feb11aa7e9e46ad040bfaa74a5e4553bc04d1268dbe14e1d3508785986fdc3c462f4fa5c052b955bbc8b0e7ab6ac808c06b6badf9c1cdd89956afef1b94ae3d05ecde069e244a175768c145397357bf975e27b005be547b489156e36c09229265f78ade91faa9525cccaa8ce5fb447263444315a30c9ffc596aade734dc749189a1ea21320d1a3dfcaec1efd592fb0d91b7828f08a06a90577e3fa7fa61e21534e12e06d0837486ab6dbeecd0584333c7988afbc2aa15279e139e40e1b00989e8c6ddc3e72ea20642ad06b9c24c39d80af18d70a3719f8a5dc7ccba73fc9445d6b26a129fe1b2f4a6593be8c559fc1d94655bb3dbed7ae9c033c54f1c934675481371469cb44b242c7a40672276007f9a84636891381be18cdc8ff1f7ae09a72ea0317ce8161a977ab8579cd39e878971521d6816b9b0af74a57919d5efbdac93e1d4adb887ce88cd09e762e6926463317a83a39daff8373cd29dda23fa2147a05d2b6a2dedd56475d462753fab3ae662cd0d2e4dda008f9dad0ffad9b363acc03b22ddfb10d30751af34a92cf4f35f8b44c40ac37674d217635e421655b05449cf26b8ef4b82bc26a687bcd2ffd34bcbfef1164a4979c84cac58f91bc0778d068cbc984754426ea510d5ddde1f69f310fada24e8d1dc26cf70ae2e23c78ecda27514fdd7564ef2f4e5deec6a352403189da08051e30d3385874e0624e55628aa13c62cc26eec7035eaa9d33a9b7cfbb048b06a2b7dc1eb00b736c88cd3ca9c2f229a63829e7e64150c5db4eb34390854806740f60c648f4b7dbe0ed3b9b232ac896b174bc298db7c132c2c1e93094e8428d745d69b77a09845e9abefc1568662a5b6d208a6784ae5f876049ace299d531612f619c2397ae0048d8fd86ff7e6489c2a2e28db9a9f3e30273922d5eaeac4cd2f11e3fd39baf5dd7b212be209de025ea10950db68a553024d834e13a7551c17e459b5b94863afe7f69c8473f0e80ae292e102c4755c85390eab92a721e8315a6eea328c3a67a43b125d7824178b25fab7b04991296e689dc57792d1f1e5db552a75481bc4ac01adc0b2b3897b12bcac6636837a5e602a6d4e8e28a1f337a77c141d95e1eb3d29db0c1fde71f5786a2ff2b511fb85e2cc51ba21b00802a39525165d1b18e1071b5a4873dda3341269a6b5a7512034bcd9090cba5cb56ca68662458be5433196d93a7071f3dfb9145030ca87abddbf0db6db77456ece408ad23b64533c357201a6379ed7c5da6e213727977e00ca498956c0ef411d86914edfa3c3178c03ed95cbdc89d50817eebc80a4967440a6361454c64b567fc1dfd81a7090b60fea91878c5dc02c2c624617659bc862bfc8154093eac84879a7b28997f0ab8fb29adef6180d53e60dfedc851ab625d2552320ff04f906fa717bf0e9b257756e83062c9c3d0e770d38c87824d21752a34db47ca30caab225d51f12939bdc55bdc3ad5702578a856af1de6a46d10609c5ced362a84a43fec598b30f191ce20034657babae2c29ce6f10c34d396a14866502e21451ddc97b75d1ed3dcabf3e7ad89a073604a48944f892a2c77ab77111df466d866d9f559992d3c4c910b2543c83e8096b5426c7ffeb0ce2037f05ce7ec17e4d2e70a22fe84627962abf61742429165ecaca1e3ee36c0f694eaa3f87e02b49aa111de1fbb54e5bbb3008fe1b4efd6b21e30fa214ff91d46123db2d93943e473e38a45655914b3d26c24be0171e8ccff52078c5ed8d39f2278b3bd3780628fe130976103af5ecaf20637b737d3d845202b742ffaafccbbc23817a75ed2843c16efcb31c9ed4dea74b8ec6db8c3cd5507e6db989d63d815c298171ac79641f3bcc67c248e3f84849672f89c28c7eadd486bd12d23ffc28da61eea883ebc2f3d7054ca75f5c2f16f8059623898975e7647119e7cc2a602f68d75a5a0047a1d8d4f2505c1f4fb0c33fedfa6788e8abc105bd9921667f8f28b94ada0d9d3f744b350e3e7c0a53af75f6dd4e9139f857f5115b79d0be0ebb047f747682a3cb3b1ffd1c036f7da61c2085a3394c3a075e9ae80c2468cb359d138d2fcc69c8b80b652274ac45c50296ca1280449b5309b76afe62da4ace6b7b8a37de2a495765c3f2626bbb3f171afe04fc2f3af56f878c6a000aaac8f3415519dafbf38dd02076c1c9df514832e89fd82050e118f7fef759e4186b63d92cf1704bb09bca23eb4a387405b49f8469cbc96238cae09c4168692989148e69d9fbfc2e75707ac95e2562bfcafec4dcb175d25b0c45759e1c31d5ab5c2b4a62b6fd203f165ffb6e846145bc0c960c62a2211ad0181fab356b2d0bffccb5e34fa20e0d5597027104c73730296c5bf9731ba56706c2bfb580332f4a567d0038f6d49b288ee697cda4b2f6a754252b3ea3780d781ea9b75a8003f1bbcac74f5ca1bc7508e6215c590eb18637ee3404e0a563a0ef3a7b0c7d452d5c87fb752e811a0f0380399cfd21c127f02d82be8ed64a687f392e5a9faf94e82c6527e445c22b5935c815b1cd0c11930ac96bc4285d3d552c01d608a451c0cbd29a5ee99ce402cb734759004ccad7e0b3dfdd925da85f83213dda962bd8635705bad4b8e1e426b60cb9c9637d2de63747e643e36ff9bf72da16795deb38fd7d65d002d346dca949aa1660b84ef98cafcf34a1a3ba1b468a244b6a800ebf837cee0548a73a805f74624a83f5bc58b7267b5b85b5c97750ba3318a50568fdf64503be4a7d7c22089018df5831f167cac3405b63b269e0ad616e194d2495a427c442114011a003bb9ba14f7e8cf9e90fba41997e69e7d70a85eda8ee53c1ced95e587cb9a0122f07cc8551e51564100ed5df694d10f56e60ed37726585c614e0c55403c2ec4c882b08343073f0810790320a1de69bb6f5587eba5ec0715dbb72d79004ff355a5e175d42f98b002756cc4a42699ff2a694ddf01969bb0b26ee81239b9f6e95ed81dd70bc6777dfe21775dea2aa3449ae706782c9751b2a83bbd7cca32c7c224f11fc909d250850158fda935ec2ce2e9ef95352d4dd671de15e01e53ffa43643440cab5bae9ca89d6293371cd3e79e6a72d20b2efdf969d9b9edb5c44feba7e0ecbe9e0e166cbead5b6025262b2bbd0070a109adeb77c9c2a44c3e5b550be55414cd4a8adb824ec1a4be01d7501dcce465ba5e0dc1505de12784fe653b10f76239636d3469cf5150001918de8c09140e6c1620ef7e94e6c99ec510354e109d725aa2efd77173b89affff6f00c78fc9f0920a191734f0e2f4ddb481c533f52cb972750cacfc449f99eab67c7bcb1ba181c812435ce94dc014068b35e6964426fced8853e10c6f6132c567032b01253b8412e616358828fff3fbcae50a9b2bbdd717b93cf8995f5a82ad8b3d8dd6db9194adea356cea0b761ff4fd5a4a931063e380ea0fe066696daddb22cea84d6da65b1484cf092c62e7215b86c04b033b90bbf2a9cd10dd89d0fbbded8ab1dc3a361b7738b41f10a928a0b33267dc524fb224d3297d5c90e4b2cc5308753c4795163944fd1be26a1580c2a6a4de31f42a6a981ff2f5d3845ed22c4a41b8ecefada84c486770c8014607e05de9937b1e05a8465003ea8cd49ac6ff5df9db0e2c923204a88d511ca83bd096b01129e7d17b9099cd499210e961ada9206c3497331a1b0740db343616576a1bc7a3e38ca17c23efe96e0a0329812b79e55ce14467b958b4b77b03dbaea91cbeb8997a008b1723bc98ae6dd25666d045dca688927bffe308d5d7e1506ea3ceda5da54ba71af6dea39ac7ff104a2b2c6adbd4011408c3c51d8b8b0207d1b1c7feed48b70773e4f364e5b6eaa60c41a9bfb6bc9639c0735e0088cea8a10461d6a3f759b661721bfbe6fa98351fbd4d1f3b098719cf63ae65cf2a5465d3abe98348bde17ceec15601d8e284a8905787c424341a6b857c5fb1ec35b6c74c1ab3dfcf821aba8884cf0fb9ba6585c2f3067a6f64a06eef226974265d8dd65f702aa3449225fd781bd83a92e966808a0dca3fe16d771fb43d4d4ca88fb63346c6fba86611fedaa6b34b629811295468284e4470306aa412ab24bc939d5d2ba73f3ace6f9c1065a63a2702b7962ed62e9153af7e7b02fde5936279d34ae193153ac4f0c0f0003d85803fafc98a5c07a04672a15708e8e232273a60b7f19b3daf25e727db7bdaa2f317b0692856ba2c56f4794a0a4e24ad67a1adfb32a91f68a84cba3a548f3ce67550a4283caf0c616e32c4a34ae2d0e8901155fa4e59ef40de4c3247422b329bd2a37885d03df9153e26f85f9cbb6aec84305f36f143e530beaa5e7769ee870f876de47e48f96d1facb9daafd40ea374f6501feda049c21ff93bf6a8712f36e672c3315675e2d68a20374cc35a217e5fa6245494e1bf955fe69d7965000f30ea795bb71a71dc57d2fea1d8306023ab063917f0294a83b980f209b78ca2c96c37b45fef107d04cf71aa105eddd0e1a807a12e98b85674f5a4327355db32320ad5737b9258ed12d5218575208fcbb9bb0fecbeb2d11dd8a7b69714b2f9895cc1913911094bc7a1e77539ea06d730fb593a4ab5398ba033d5179ecf4803e636c182b93fd27fdc09b82990e003948e3bdbf576f01361ee6975f18f7acefb6033aa86809e9e7cd425ef6831257d15c03d0c267bed9dab90632c9dea540a3ed074e1fd95eb19ee603ab6b61565d9c5e355d9e21ba565b19140b49830e7907eae1a941139f9fd1f65131fc681b7e86185e2ffd0003f7c11d96186fdcc0486956a7c6a1f6323dd8677df12b531d10b802d4b3ef6f4a145e0308ca089cda3dc286dc0367e47bc72dc2a3ac261eab0135c403b3ff2888687597197d355fd797a78f06fda92046821a137ab125b3b00ebafd5bd51eb2b4d883c004a0d1c880bbebd4a9177287b9594714d71ba10217aa0e3c98538287314bc3e0dc6421fc79731d7df32fb895d8db1ae99a3ce6417c4eb2e4b792ff072b86645864423773293de9ae2903b43a59c6c3d13d5a54f4e517dfca2b005caeb910d6fa8a3c3b561923e94c16b2acf0fe9363c37275942c3bbe98f9ab636ac71100139a61ae98bbe2998922f0ed741bfbdeb804694f77385a65071a84b1651e157f0cc900e379724c650ee9a2dffe97596d903a64fb53c26c103b95cdef28f8a0463e868ff742d28c8f83ee04d06ebe46edc65eb41d43b30a4c6a6eb1616877b0195b8a3bcd32908ae7f08347a3987a26454094344e642beac2de73c1891497d1a4634d08f5ebc75af935974e6dcfaa4daeeea54de6cf6c16a2246c05b776d2d8de66581caaaa612bf4f8b0c6d97f09f81eb3425cd990960ac45589f845a0d0072393a308c61723f7b73905c8b3e840797487c7b3104fd96ae779d5fabcedb7beacb3c1941931fb1b8a41cbdafeef92dbcd5cbd83a203c796d008daabb06a690aa7fe703b42cc97158bd5c3d8ea6a15a1f7946597949c871ce13760b9f4cff36a88d4be60d1a6143b3f9d733d882248f6caa416a4d8e431bdb8e82365695fbe94afe06a49bf1d06ea137962f3dd1a143892e55fe5627995820c38dda87e3d1daaa6e26ca2ea0342dd2759e6a0c89c599c9727802ce2bdd2f1db11b3c870913c7b8fb657f57ecd5566ec2ce0aa9e80298b7bed717985d8978d248cea02f1b13711306056a4b482c6439f8530b4f4b18f45fdd9e07eff9d9b6351dfed4e303af219b47656a4a9955e1575a5550338b9f91a9a06b7db18a32974a80c0d9e437c93908e47bee73d61915b00233219568b284eaf232803d42aeadbbc4f792a6d5f01686cedaf3ea488e6da7406ed2f2a545c68815cd05ffc8d9d0d886e0c80de3aa0662b17425f0b02155cea30230ef64bf2550a632cfc8b24f5c87425463ae89bb9cc1119ccf9762746a57699cbeb52b41ab31d6ac77d630b7600be9e0469476ef4415ac55fe48fc3c352d9f78146affee7240e4d8974cd80c184011e407f80c3b4be94fad920b70093c7305f90daf7cb3b25b6dee6f0145d372696e58af1d9ccce3df2260fde6df7eab86390b9d28df7b6d64610aba66f756e90587df08a66aa5d766b62c8cf591b6a8095cf3b8b5bb93fc30f0862b68bd111b77aee6e83186a1b6abd5389a404be43055d27a987181e1767f102c3ba47ff07afc2655c928b89108985d291966a859bd15f860bd83931619d37052fa5908389d4a2e73ff41841cffe8912ce18aa8aa5b483e7655035254cf55f5dcfb6a382336b3dc444b532011212721f9d28d97f41adc22e10cc45ffb7cfde280bc8fee89f396ad444d83bd7e17526db8c86d666575c437718e0877249ed8eeda05533f1e38d30ff17e610f6254b23e0f98ed92ae427bca03ed13409b3731ec66429b474006dd36ceafbff15f4d965d872b12ab33f5fd92e664e25581ef84f4813b2f531c86b9f5ec065092cf3180de335711ed91a6b31f4a6e3ddd478c947d3a114b3fb5a98b4d14c099619a76aec06f638295413224283e619aabac467263ace4fe35d2efab2266f40bcbb9e63ebd17fcfbe64b5d9d2513d885784c76a68863f9543d0f4fe0eff9c1807a198a625c36d7b32caa346fe718798e4c76d56d928cc6016fddc86770904f6311dd136f447b25ea70876563bd5ca015eaae2d083fc15c3990134a3c91a1697eb86b9b18f8a6814208fa1296f3bf4097d2e9c569fd0e0864c9b0a35b2e48e0b1c0eed79d315820f8898a24dbcaaa89e7a07cbb954e4a61d835f7951de5cdc8247ce6346bdb5e13b1a261348809b43724434893a760021846833e4d0bc43b1fe8d97acd98c048c14442e65cfdb0eb7d36ed416a037b6054cc5a30115a053116fc8507d88aaf04aa8e86d83df14b4f3883110b04b0fa410d84851e85a75d949434273e737b95733d7da7da4e8df3708b447a78e743961f6bcc5cab554221cd048ff50a5b2abd492a9236e0cff958bab4d2769d5145676e874b9985e26e42dfb61df00e83fd005ec179c6270584f185b96a4f6835ce0c72e5eb8ebd6868274b87a8c7495c36bfd8ce692b6dd6193f4365bd4e82beb1174f35003b6f6030840741ed908f651bdf18f2259da6d66f5ff10e5946526a63c0eb227b912cd8131581b55b0cf0418290aabe084fb41ebd8a3f199c6e0549fbdb247c5de55bfbd7e3af65a54c7330692593e9b8299439d9db099ce08d7940d93632ce721b3d9b5a71e68b4011d3f3a41b944bf20c2053b10208dca8447e603b5d49e4f806d6ec3d89feb26ed175496e08bfb04fd7ca50ee00e9542cde6eabf305f9ff42cfafa706fc43fc5e09fdc946c4f7adb7a70e36951a1d86e11db351fbfe9fd136e330e08259fcab29425352d1311241715ede8ec76901ae5a0584a201c4d156a46bfeb3b22f516dc61dca2f4a41e66bfe18dd364f8eacf536ed16b45f9623aff35e7e77725d65b8ef7e55c0c4c89a0aebff12d6eba59ecb405c39dabb1e891d98593e0777e06d5e7bfbd699a55820958434697f032c61bcab648c23fad0cecbc841934b27056a77b694e84ed6e503ac9b489cd62bba42bf3af762d4bb7e073c9586f1c2122dc31614568f214a69618e7fbd596f5e8af0f5acd40d2c1b06d11be1daf5aae8a8a4b2ccfeb5f56f737a22eceee3f57fef57447cdda5d1d28c3267bbdefbb29345035867897682157f2c640fe4df30da8902264192329a1fd8c5b08bde61e9fdead030188748be74c5012ca0ac70076af78f30bf06ad0232c8a7e20b03bb150e366969e8d7e114eaed2406bdc1796bdf67256d4176aaebfe0b542e34b03ac1023c267550fc7490fc866dd16f3b66ca66a53a13ae067d1732b773433f620f82fce1baf70ca9232212fe4611e9ecd77b1d97711493486cf8bae63d3e6e38e1600b614b95d70ffe45f2cacf38e6fe815e5fd3c5c623f72bf499cddf6cc969b09eed2764ffd5dba2eebd91b371e8686f83b0f809316560aff4cb6cfb74b3352140af20849577f6ce9197e2b8baec3297cb73f277fa6f72ad4154337c7755647f46848f76b488de422961c4a74150d62df6ed69fb377155db428e635280d1005dd88d5f461a5203fdff950a863bd891bc042586a04022ff729e10f78bc35828efc338193fe5c67a6f7be4e548a66383fc9f487c3d650e5d463dcc4f9d4148fbc2b6bf6ca3f82d56d5d834e90352f125bdd7bf2572e185b81f315048681b20132380592e29908df447763be4d3b6459f19e313ba15700c864af3ebed3e6c29ccc93724b3e650fe1b1038a7cce960d30c924d7646265b716bd9034e0f8553ac362185e381058552c819bf723618361fa651ae7828d6d9df8ad46d003ace173fd70bcb679da3a9721419a8fdf9a1911ebe5f410cf7ed4d58ab3fa030c5d3ee9e6257b393396b709b3b4e7fdd1d98676e74449226cdc91782ed042cf68e72eaa82efa9685aa280eaa78359f7508d9525da9648b95d0d04cdff28b6fc510c5cadf14ccf4f280d98539e83f271c78033d0caafcb6f42c24c7b3596a089745d26633a8424da174fa219ded93b06f73371f139ebee8667be6aa870a641835713691a9193d21bd45b28469620152b1725249d802260b8784cee86c43ea4b153a7b9493deef146babe27574331e84d379b86d7d00f5ac786712c4e2ff7087cadafb9c3bef80b3e1fcc9183a887669765601fb220c5b877e61d8831f560179b72f08ca8603e09560cbcff4f8a41e6d37f232dddcfafd8a03b9f506e26c479bfc4997fd4fc48ea1537e7cb7971fc04abd3dc1be6ea6ce2474214b51b9f63781560201d6ad1b4062e65c8eb041f555b6e88ccef56763d1a8dcf7cabfddefcd07f0cc9de047169c0c77faef86567ada277c2a244b732964ef05458eada168201f63d1e2c3ec78afb7567046eab88e420910780695a581056d00639043936f28237a9c0973622b07f54fcc716a2a115e228a0cb2f4334bc455926f9458d14174b28502ea12f2b9ce6f7152ddcb2e22d8e8fc87f5e3ca989f86963d90287a584b22d6800c09fff720dac1e324b799712b26ce23aa6da8a38da8e8993d968a910c253e55968250ffa062aa0bab595b89b50a1624d2e018641ae5080a07860d2e2cf37c4edb111b4c2ffd95694a3982ec39d64a341d1c4d40bbe2d498f2452c77029182586788306790380ff2e3de0c9bba954a6d596a4f73ff9978dbc5a28f7786eac76c23226fc0e2f2289c2c440cf71bed9a930eeaf9e0f874d17642e2ba3c55245851ac3657f87fb8beabc6fbb81d1eecbd8553f0a3e4fd28a7dee5a0a9316491f76dc5fbca7913defa23de8d4387537fd11c945c28bbdef162359addd11f71a07061c48781a3fbaa9f1461616cdfb155b1e44ee99bcb2db3a4aab3f545dcd959a36a48f2559ce8b3e29f21fc88d3ef54de5bb8b3dab674a3b1062556b199eb25cc35a851d79a208a7f30f19e054025f55b036e99a2db35db7747aa61f7f3d7e9fb110ed45acdf174aa499e29d99f5bb411c90bbcba3f0c9d5fc733efb290bfe2e308bab40def1f4c85e0df5242883a08871a77fe75868cde961e8e249a590ebc433a224c28260a69d7c00aabcd1aa23f441fb4409aedab9baf4bc1c9a87833c7c508a4e6e47974d809e56244ea826f5372316e9ce5419890620f698e669c2bc22ecfaea0fb483180cd4486041310a8aed027894b19c726bc632b738527a68999f7a85aa931f55fd7d1f5504a4e364c0697b7cb86bdcf6f6c4008e00f9a7a1028fb17d7c9505c5fe3063e774b4d3068da0451c4ec63b056723e6eb8a92194222d02c8b8f21000b95fc25f252f0ff4cf73a477a3b0fb85f93dcf9f00c14253cdb6a6402adc16788705cf0f92a84488963c8f8157411e772d851e2aa45a1125bbb8ad4162b0c8b9e0e375783566141ec64fc461ea9a87914c566b067b7449a37685225961cf4b533e880f8992c1d2c58763c0118844124f80910d19417796261520c31b372dbfaf5545f97dd6ffb9643326c71ecd08c1a42b42451f5678d6f18bdd49373e89f78b2f209ad307ab93b9f11f0ab557d8c9f0a1fb87a1fcc2b4275db239b20ec2c2d87085cb1bc9870814e13f073e0be0c5d0517d4cf9d3d2d928bb889608d79cc1a65c08deb66b960b13ea6a5695acb03a46417b7cbb53688a84f0f79cb4dcecf1e1d07cb017520712cab98bda09ac3dc2da2fc5242e170e521775cf52ee2719678392ce1d57bddbfe92befaef7b6a4c68147d327ce65292b86f2f3f232a585baebbda33c05fa2cc0f72d1a46e72490cd58a09f3f85b167a25a50d2145f217f81afcd2bfa34fa2ce17bd491937d8ddaceb23b7312b3d074be26b82b4e41320f0d3deddd16560f138e9f51d0420abd16eefd68522b9ca937057e9e8b08468c9c0171b4fee7000d0071532187b113a195a000d05b53f987cec11874db18a709ad6ab7aa5add5946651396d2c72473e6b8b7faca7eb11a03af7eb1878213aa9ca9c8da7aefcd57f8c02e32a2b6728a2fca7a37e3eec0b709a8ec25f14b31e3589d599f5d08f45e64a03860aee4c5077c4514439c4fe8c6a4cbae1e0d244feaa0023a41761eba557cb653ee38f24ba5f5ebacb62c1ef16eed3acbebe86ce9d698445c856ec3b582db08fbfac13af79d25f6faa37610700c8d6f3855efca7abb2bed4055e7494686b76b9fce9ce5dbf6228988b70d3bf80fbae368201b309a8cd35184ddbd9f4180be2ff80c6fe0cf3746dc7230677f5451ea97039814eeda1b26a563931d8a596cd0ee0384fc55b8483d652ab29a33a7e4e1a769e2d86648198abcd9c5b6619e1bc9350369a15bd13ca556c5bce8276cab8121452c95651a969f93a82d69785e88db4b71f0be9c6f96bf4d445fec7bab53473116374f30215d8875ce2352ee4ca97d8e15c227d1cfefea38ce25f65b850850e899047c07ab3f132b6b06e1113402a74054d9cb138d510f7385300420d88d7b8ae1d6771fc1e20c09311736dd677fa12e42a5fb7d8f6ba478511883ec7d27556f15a754e3a4f10fff3ba632b29a22737ce18db9d7b5ff0bffe52b757554f96fb1e36e1b89db953f24a694932f4136d9adf1de1a1c9006771c578633880f36a95f8c17be225384ca3743fef6eb258d40fcd513f7616663d3c9e091043befd21713799fded05ff016dcbf88c7bcd36048351cf1dfeb5e561b0fbd0eecd00851b133b76f2e93faee050d7e9f08ffa40a6af13cec1668d82fe9b34ff6b0fcb2b64e1fefbc171b17118289288c4d6886b9970b6ac802960e638b1258f29c47234f6a544a026354a27c4d119ca79deb962332115ee1214cef5a2b2d0dbbc895ede737a02d9378787643ded8b1673054f6b38a797f551a711b96e98e9bb1b4b7871f3484cd1a4821e704af89417629a15f78e8cca098fc7ee1e9ad8ecfe226b694f339d4bfe28cbfc028fbc28faea5c43e65933a70f05835defec4c9c37b1281df701fde2bfc655158c6433c583c5f99b2170db22cb91168f3191ddcddc98da5c1a82957378d1f3a185cbebbb409a67589dcf8150ba71d107fd1a90928ee0013666459976635e127a9217a648119f8953cebf0c9abb4f34ffb3d3f14e66610d3e84503b031fcfecff6b1fd683d9845439a6adb5b66db4748b4ff5266b04f84c7c80cccfa242e3c7738cfa2da94427f2d30322553dc6ca8e4f8161864fe72fc50796613a639778394148ff4a1e258fde2221b49d6b0aacd4b2c07620384b8d156a2198f29e67c178b60a1218f621b4c7eade6f91a3797cd267dbf7591fe25a857c1e4cc708853053669d1b22712b45f8fde0721d75f6fcec5f44a97bb2d247c52d8d2b6caf413a23aeda7d045cae9bdbbc287b640aef5aaf4a49e13a3a7914fb788da1619e9065a63188bdd468c5bd37b47c5e3c934376e7f1d0ff16a43f1be1577c3f0bdafd8eac0fc5b79d8dfe92173a8d07871653c0b15511810b58a828608c5b25f4c9ed882a01cec562b9ab1a1e8055490c1421fa0485242080c391bcc8880bab19501d4c01c07bd0bbaabce55f8dc34f8bab463eb3835357591c763cb2f6838b0f0382dae29da81b38f3d38d2b0ee10f75f33676aac95c7c3fbbbaaf19a2a2e1eca1703a73cdd48387ec2628ae3750197d165709309441d3f7d6805353e85e9c87a37683849336fc4241165ed565a54483617569a905c57ccf493f99dd9c915a1f4ef2a77fd204802d217a4d89a393429b4e6bb1489966ce8127633144e5aea97834a3cc3197eff214f022568ace5a086fe40077c5820789dd29b6b011c22d0b34493e1ad9c9c8ccc341bfcbc71a180a4a39ea10161f9886ece0ff90e1bd93ad6936eebfd4786eaacc57f6ab29db66b760e150a7af65d9f5da86b78f5a13c25a17153fb5e686f3065cce3ffccc690c20edde6b6018937567ab0e12f41d0b3d4ab18ddec3efb8a775720437491ca2a6af433221db7a65fb32190b00d2d63aa4edd2cb7f83ffcde48a2dea7402fd46229284ce1811cb1f5e4b776c15ad384faf505acdff437815746addeb525c72251cb619853847e06baf064357fd77cf6f480707539c8cc368ee40d2166e6d418eda16a9c9ccdfe54a874afa6d95ac32ee2a72e9a08b529de187d101efb31963a00240512730e6c3a792bad79fad3913f10aa052b97a51acdca9423e8eedd97d8213fb0f363f33d560946903778e6fdd5eceffd5d756d393002718358c920a84eddc184d54cc97447646f30b8ac19993a87f43709d1a65c0a20cb54cb454bda6ea5c5000f2adadd908cd82ebf35d7a0e9fc802655c902f4a74be703b7b71682dfd7ebfe99a12cb141ec36d2b5f5b946bb52bd26936f8aa6f528f3caed20ec5741f4ff7d5b3f7622c650051a111aca920401a3c635c50622b15dc034d4c725d0719cbb36943e1bf6288e651b2e7547be37cce682f134127b36eb510653a1329802eac66fb44a8fe35ddb27a72059ea5cd199f09c23779ad2f855bafb3add444f74548da5587524e6678a41952427e73bb14aae071898eff08a1e304715f6e73d4ecfed17ede1d6baf8442f614b7bdd6c280d5329e296859d240132bea3de512f60df1f032dc1eee0f290a55214735a7b599254f1df44c7031127544a82bf2a21e43ed57e3ae46c4040de5b48d1d2b2285b5f1236778b58a323e21921a051b84d7b7f3216d106a2122e69f53999e78837beedd40b22311795c4009413aa341b621cceb520cee46289b6cf5ee68732c607e8041853fa746ab44cf363d83aa4ff37bc016aa11a936b2cd521a39929ee11d599386adf301d4ea2f96f0109881b6fc581d34b2fce5ed883109ae5fb263117a1fca0b74ee7430e8ed62630b6cda369c7f90fad22851484bfec0e08068adcee083eeddd51654c72b6919ef8332595a9c79e02e6d3705e7da344dc1120c4f0d0d0d7473e6dc53c0048a76e61becedcb8d46a1dde66b339d3549fec134350c3800438763ea7d4aed211d38b7a7ac7cd3fa96336546bb809daa2ffb742bc5d808ddae61b98188f47bcc27d42d9cadf352f6b0e5ad7abf85498fbea204193f6cb955b655bc05cb01034888de11042c725d5df299ebd8cb70744d40ea727d7a6083dd2f07ee91727f467e3b3417a9a348f586fa2553cbc8faeaa781055bdbc87660e842f154352ff769e78f000aab2267efd7b828959c423ba73fe5ed6ffb6bc77b42d4d3dbef4db384da6e219f447076e4ff7cda522c4b478c300561c3521cfce5eac5d4dee812479d0e08fbc3d9e1803c704ea0e0974c32da527ff94ac8cb91a41d649d616f5d04c215451f7b47a6dbc2509a2b5f9ba067b11f4bb509939337d91879ce262e3213880ee6e833b4fd2826ba3bf383347ec4e349f844771b1c1d5ffbb2935742c6e42d88a10f6681a420bb9fef2a8477875636f3d21c017ae93638e2334b382d111731a0ad44d77cfe35090fa8fd2b41192ce6b0c9c2ab15835242f1d2f639eac4409e0e9b7882052b8e382cfc17ce9d30865114f1e8c4bd2990f8061e65d00204f8a7335ebecfdb0cfe4071d5a9f1253684e81e585380770248e19aff0d977b86e4f019ba1124101216976f40630a39267927091e60d24b36d172841c3190f989e12f6b6242e03bad5b20f5503b3fbdd32fb0fc9c3f8b13ee99a30a33176f937b0fdb77414947e833c1d6ab7ae9b5610b11f01f9447ca41ae9b2ca240006cdf188b80db4d4fbefe13ea8d656eb8648239f44f73702bbeabb2c24624e767c2d7835020b8bbb65fd218cfd780562ca1a218e41f880be2b0e4f896089d2d7fd4b2bd0b3140c2b95d4011f54c0c7c6f2c47ae410f8e3858eab77f7aea591f7d2a4c0a1f76a91857942ddf554722719b1a3bfabd2ccefce181753091f6dc6ecf283aeefcb4ed7501a7b1a5899b7f63f32b4ce8acc6a41db319d6df981211a52319906096f59ed8233bcae7eed4e83e68555cee1fcbe57333007184b129b11bf9df5c418c992d4681727b173edb038af366caf1fbae7a01303784c4d276ff85e72e4a2567b99a5eef5191f59979b0c835492f8419e35a42351dc18c195cd48d169d7be6a656e14df6a604fb73589a481a6e97182a56d79cb0d24cc46cb4fdfe09072c02af6e1788b05f9a149487f4442e379808eeb57a72b4d162faff7f1c2cf7c79d6457a3576e18df092fdafa6bd2e074c33834b8eb14e3624c3ff7ea00f2f3c1bb1fc36a31ce8525910a560cd7f22d08e9f6fd8700522f2ab9891a83c7c625edc12ef26003d20100ea47e4d6e43d862fd99a7150bc9f1792ca101ecbb2cb8bb05e01e64a98c17eb437d67810b4c445b67db49d4c7623a71cdab94b726edef3bbdef0faab67cc0b47bbbc67b9214e7e505a0bfc3539b221c1a44f24881cd3b6e54defe9f29c1c82726598feb15517b274d044b0e540a4c9b0d05c0819755ab1a14af4d070c02c784656b24b9a8d9b32a587bf42ef22a7fec80fb787d2d95aa562f57680ce54d79abdbc033a98072ffdc156c82d3377f35bb1481e264343cd95b500399684091a80e4ec0fa410b1c48177b904cf8add2d4f66795d83f2011882fe57a17e390cc4e040887d4504cbcd77faa01105f26d584ca0cf5f5ca2921859f2d26a8837c89e05de509538f9585ed5b75b41142221aebfcd4a2a293ddc19e934791878f8058e614780b365db3c9c48a49015466ed401e8c609431308b5d0522e8e8ed8e1228fcd17bffdbcf23d0fc029f417b80f4d066680c521c34f63820aa2d05495710ea4965a8d61eb335421132e6d67fb09726fba4cfb7f50084993bc0d61b2363b0e5f2aa85b36384d2c21c2bca7c4afe4ccd5ad97718a80617ed9522cfa714f490472c628482a6758f92d6f3acc8dea8c0b18c6ab5f28abf4c7a6f13219679b5b20443fe9d896e7c6030f602749138a027f6629bb3e8d9126bcd90eae5ce9307725e23d07f5c29fccfeb3237aeb973f1703cca88d5af4938f9becac41eaf764ce32ff25c9b272db2cee419f7900fd4123418652d45e16571f39aef278091ca8edefd51abaa6c396eedfb90cbba4d3736be1110d2f538d4a61d7d9f555d1621e3873b71364bc19adaa5750c6fb772f97e1a19421d38564a9b0205824094ef9a380656df4b401c9ca31231236b192a2aeeef7d6861757b57c1764c0659ebcaeb59319a6ae5064ae7016b398ac23c95acdda4bd3f3a14b5022b26e77d3e93741980708f5e75fe822ef9306e8bd195750673d3b57154c6f330db3d4ac3106f5b683b6d604ded369930a9420cadd80784379148c0127df1442e526414daa6258c8076515a238bc6fea89d12e103da7bddc2c1002fe00f2029e0ffb35844b863e9a699c656a52426c44e2318bc381c19bd736ebc208e8be57884010af106d2539df43097cbdab41b9494b081288dd9fbb4ccb8ce3f23afd26e6849854002cf86d6fa21d28cc53cf9b912e5620075dc3f9d0bda46d293bf0ff99b6f07f8aa7dc3eb46d9229c3e90a8ef3147bd8c8d8a309fe65f93e1efd1e1b55fd3fc63c1a662069b8efc175aec207548068240c99e5b5eb1b9a7b222a482c35e5728ef48b70336c6a1a2ac680678f3b702efa4cc900cecc84391c0b2d622c19c31db1a8a52b6a75598bec20f459c93a9a40993aaf55d91cb7f4318b6190a44f7aadadde9b0fddf80c4cc1456fde4c7da3918338a910d350b30567f2c15f47dd53f7893b70b33ea0d8db7927cf7df892612e65e9beb31890e2d4cf04c23848016c1255ec216f0a90250b936fe76a2a4a86cbf828285e383f16e478212a0c997b69687cd0e8b18d5235f0abad606d4a0716105a33ee0048bc861a4aad03c40c82641bd1a1631c786a9992cb920f8bbda5f9930cb07a5dcb21867a4d2e169f2ca6d68d31f916d2acb215662e1e5f004965e4d92a55169de92f0bce388b2fc3d9497878dab7d866106e4225b3344319a168805d76180de8f3f4b53a1580379827802ebe5b1a6f22f46c1b5838e1f4c8f4e8bee13a34dcd8cd69a0ab329168d8a2a79b5781aba943978e54fa0e07ad2708ec2628d8c116578835a39b5dbc51fc86c85a69c68b235869f954217e87b5b899c19dd6c6ea2287c2de3f2f973414650af022a1b815f68ab0842bf67bc47752b7acbe88a85baf5eca945abb8afdfe60e9ac62528a91dfad33ede025941889e723ff1d5457b1f8d1b63d632270730cabbf5b4c17b94c3155472f4e2125b0546c7b05c13d6b67dd633d11989963633956d6560a80d42b0e2b17f7de8ab257057e72d71069a66424f6fd255420ac012a5b6fe9a19a114bb98b4d6f0909906424332c6d72ea3f2f7128c1e9bbe4456469e3dbf728bb5245df8c9036e1dcb33d6bed3c1582e176cea9ea9f664f21df0076cb6fdb5d93747e284bf64658d5465a134a0ba6f3824c567eb8c416e2ed9741532da5f199b106afc9c103d5b2ab87070deb0f1ab36004a3bebe808e096e1ffdf9fd41a574126db2de1618e6221837674701eec21f356527e99c5e0472b4d70577b356c761cc1ab702eaea6aa11917675c857ecaf28da3cf222c80e12a901b82e172252e6bb7941368286a3060108d8ab41f1084901e6a483f3db63045adea4c32afc8d54cdf1c562fbcca0cca480051b13f59f846f25535ba5ad7f90e2c5f884a17aa2ca01c625e7fd323dbabd755fe05d73b48cb9901ba9d13136b918dc8b71c29f9bbf4504927fd7a921504066311dea9f74c46c0f6aecbce37a153c5b2c0b879a3b354fe3f95f1e444e7053ef493e1e753e77eb9c7b8de1cd85e4f8e07de845fc8e9f68f5aee52edb5fdecd458e22041a7a0d74ba288ae82ac054ddd3d46165a51c569a40205f275f3d94f7845a99c1a7c8a834772564cc502f3edb01e75ea153d0a139c050dff120e4f8bf43722a6076f30b763e283202e82fd86ac5098548a06f6e449cd8186ca3ec85582704324e39b7e621da0f107fc6094204caa2712a3d55d44c83cf4d259ea7f8ae68de6427d0b84521ca95b2bf075b228028c055e98647b1c1a11f7ec09ba52bcc46aa7b29dd461a6bda4df35593740e79b4f56179a5a3ae572c48f9dfe3c943996655a07084ade4d69e48cef9aa60d95a81e70e49aab23cdb7d8b4ccca756567792af89b1a6de2018c9165d63de3414e9b018fe25cbb097ae7adeff9b6fb20577e4a5d982b6cb3ab8df452cde86b731f3672d0e080e58776dc3903004ee4e01f8f15445db46c4a7fd632cd9918e9519000fcf96d0d19c162ae961d6f3d2c09a8912abf5ae6f0db41e6d995965f0072adf48da858ad38dc6c83a2dc9744a9d388658e0843a6500c5519f4ea4cfbd5993f92824b1422dab6c6de377fe85f434bcd5cff15187e5e0a61634091e35a2ff0b3196e403b29b37bff2263add4abf293cac5bdc9b774ef167f2ff0a86c83cd8948cb783c743273ce83b3bd9a5786ea8ac9530af1d23280a9e4796c51c29af1370a8eadbc56c8680d73dc1359e7ec90f43b91647b31a76d4f697ccf64e369a05fb810e0eb63cdcb9464c3e02e2e3fecc5bbc6d972b7c231151b10a4b43ace5f0e9adbbc9cdcab2a7e1ab6af5d97f771e826febdcc1b7e60efddf3fc87e531cc1a994d5262d46e059597f76f4c64fc1c001241d71c1f8afb287553c29aaa90476d06603e23d91fb3af20f7bec39ff89192eb68ec7ffc9a21e1598769a13aee7153e3a1f21a5b439d81df99a91064b61eb8c86e64d7a0012035cb21cc9bc36ece773dfa755f876462324fce7c9d893ab326cf1748bfb32702033817dff2570ba2740aaf333e55060878c95737c27c25a79f70b9e9acdbaf7235deb47d7bd7af3c5d138f1362a05adf45d7d5de187bac2c3d0cd8ac67094410fa310856da669b993c14a89d0a292c4db2844fed9aa0b63a731c65ba0a5946c7638377927ba16b88b6ecdb49100d75d64bfed9eb4b390c56458a5e1e93f10de8836e006b4c36f93543606ec784b8a5ac95d3addfe59574921eea93dfe1bf24aac42877a5723b9b58d0481298678297fa34c39469c5fb44d0c7c243233ec894807c39ff3c46bcf9aed4136812b08e6c196728310a221af34bc52eec6b8ea38a51dd874c164aa8bfb2810d7fb03b6359d91473e438cefeb45c10cda593fd34bc2a73aa05d61acd2de61aa205401db9a1b26558b799ac50e0fa09e6b31caffc7a87b869d68ca9419ba4a9090b31cd829520c86d91ef80d94a80cadd47e417aa469ff3f007a093a69537f3168b5faf09ae28c8e178373fbb49b8cdef6bbaa333af713e50d5a2863e012c23eac188a5fc230ac477bd5bce92358d9f7cf44cffb7838a23ddf149e03153ca9ff5668f5f0bf319ec557469b034e7570120ee67f697f3decdc0068749e69fbacbe9a8a80c829dda2a685578062f2d33f603c2b777aa3e432c9840ff2441a911bed199482caf63b34ad5d63102c64bdab0a9bd4fbdf1516629bcbf86d7f21e2fecb03e83f1f7d0b8179b41e0a6280cf72a81855c4bc0a19a9e4cbf16f20f7fb9e6946f37d3bc1c2456be7464dbc4b231e7a6afe904de69d30347ad4bbadc9e6e6f0a6ff80e488eada8c5c64cf110920d4962c6033b9dd9bedf5442d87d526419b06ee6395719af7fc8324d1a5c0467736ee9e97907a01d79f15ec9de730765394121e7a4384969d8b6ab47831c0e5dccef4b48f42a38eedd312e70706af5437c72b2f7542f6858ef87f6938d2a35d54a2404f90cef1764913eef4881de61f63f58ad211eb09617e8c4aed457404c03d9cbea941c2c633a5b61ac46df1c5927f7dfdb7acb92ab3ed78f8c9eb57439c4157feb4a2f75a742783f6e96b2354e7a9f89018c7b3e139c16f28f942dfb75eb1480c0f255282e9b18e9e5f463b1a81177bba1912d7ef5089abde2c6fb73215bb2ce1a296886a46517c4b4c663832951ebb82ea3c42992d7cffdce8233a4c25fb0fbbbb65324441fa71298922fc9d6066681516240be0c071d8fee61e52e285c4e5f267aff04d3ecf0cee2a63d141e48a4519e07611d1e2f123b3384640b1d10833e4c8904fa67b18173fdc1a00390b7367ab8ced07ef3e8442b12873dcb1f2e8bc95f33632a52e02c2221bcc882f8b93ee1020a8b876969a5c2f3cf9f380a30060ee7cbf7f141c4695a1a580ac000076a06dd407774ea1a9bc1cdd9646300ba258400261e7154390695ab3ba9ece7a7698799abe4d0e61daede0b97733e4e7f6a011bedcda37905476bbfbf2e9cd790682853317b520dffaf8d3d8ef7372381ad408960a180d765a59cacb0ab3da64f21ca93ecde254fec46574bb23c73bb7771aa5ccdfc35d4f73e790d9e384c4ef9fad1b34c109999a94b2167b5c7387bb150f77b8cce8741cd0b4c3294121129d581cc49c1b71c61e0aaab2163287c6c004d2ffdefa27a0861ca841f82df594028faac886364353ecb44ae580cb6be119feb2c937131be58afef2898b852e96ee1753824e99492504b8effbbffed4de64a54a81f1efacbbf3d9ecefc61383b7e2eae8a17d593b9f419378ebd5aa8b6f719d32cc5e7f4aac321a5752a1954df0112501aa6f7cd9d0b4b3d44c02a98f58efca7281672d033e142ab6b85ff7b815086f2503f046ae6d06023214c6a09de868f57c466fba38b54bc426ab59a826adfa139c1f9c4458d6908c04e333974a2cf1c3c617d640c7a6479d692a9fdb091af9e825eb6884ebde818b334ab9e173a162068e1bb8744c340375d79e492253297ba5b3dc1ff5df81fd496ca206468c3cae9eac247d45733b5335f2c48f614a4555ddd683ab075f418d63d15f931360e10d80a1d8322f143e8bcee0a667bee19b3bfa2245717420b304a0087597f13325b8f2c40eed2291291df5ed35ec6c45a8254d28de99ade6e7e0bc86ae24beff4ef6ac25c59bcfbfbe6efe6554c790bfbfc69d9853178133d69210f69ccd870fcd807a602095504e67308618f0ffafa64fa5ce9f1b18da91bf52c9459fdadc6129b517bd49b8063e8370ae25e83dc06a3ee4f63db36756bf4d7ec09e19153056aa4caeff9378ef61b95b8a995a8f7399ddf38d1749fd762e476023374898c89078349b827e0a1da5116a9b779504100642683e4574ae38ec53218a67dd2b364be10dbb0833d963a71014b649b3063f917188052c06243a7875739ff31efd97e363c1c4b50699f46a47eec35167c79e7a217681a8bf8939a3c17bf8c86e7a0e7d7919fd298b11ec8a02404f4a421e10df0a498146b03434016a4e81fab13bd59e2accdbcac4f983d2e907f28544e55b68ce9f2065737260a2aa59c0bcebb014b0b4225759e2d1d9a83b5b1e5ccda78eaf21e1ee679c3c116c6fb3e7a9910a7be4f2c3ce8cdd1933e695eada098dc4082a19e6faafea1a867e65c4aace7fe4a829a889248f73009371472d83304229c6890275ddd0a1777a10ca59bbc633651d35c2f2e943f235e03d5c962bd9d24ae3165e836d9bde64b990734d0a83f2270f046b8282c5642cdb2ba7426e27d4052f4bc04d9a8fd4450248d31038c77aa5f1c3845b4ee6fa1b6f10ab2b3f17110ed0c99af69a9c777f5737d3ea87f4409b1b774fc658e7df4dc54605e94839771456c216fcaa890b65a2b2300389e0fa6ad04423adf5af44da4a030aaac1c9f80e6346f1f6365ac58579eebb9287225374785a2b7fd8d88aa997b639244db0349483fb3f79aa54d4ab053a9495dc5ce79dc627eb0372ddf7a92cc3dc104b33c5874bb44a7258de49fbfb088b603da4d6aef88d3fb0f6b484d2b0579772ccc76a46778ea95694cc3b24ba821b9857400810856de8c411cecd925b4468440638ba481cb9cfbe5353b6d87e032e31254372278696678178b3a6073f38f6a8b526ffdb1a2946e3e5199b88a84df3347448923e8be6470c918bf68cff7145c444df56554f63d70e272e1344c8d9827d893e032e4a502cd752b074336c44e47c98dc3fb3f88e738bdb2452c3b49f047aafd64a359564240bc8e1adfd19ab3593301d9718a9895adc5aa8733924e2fda7b90b62cff949c4158f70d235aed98d805aa7fb7d37d0b60d705142eae230e2dc497adcf4469e13e9757a0a2da6c3b518d66d906f49372fc17b262886596921699d9884dc84ddad9e5c8dc9f681776436fc92c91f2c515100461cc35bd37817a41c9a8f26052f9119259c2201b7f83154bb2edd296e022e4eac636dc784bb844c65bdb7745d506f525253bbd760be12100fd79ede035213f96080b1ce6d03cb0017d7efecf95ee0ed48acd07133c85cef79c3ce46fab8ca2f39f4e55815151bc4347739ec571876e5358743ed719fdba9f433ba7cbde1309ce778d05e147b1963ba8edaad95a11313dbced62f08495a39a7893ea432d91dd345352d8a0f39ee662439f0691e2f4d2489a61539a84165d2be7149cac241970293e129efbafbae50bf1c390f9123570b35da1175bf44020afa1a9e6449b06fe8ca53b9393ba6d09d1e5bc349b08ed82de1d56fa508c9db5a55f303f4d7ba9015551b3cb40957c6dacef349a970c725bab1a06c0be4f81856e5a3485300317405b0ef2109c3d5638990a058ab4ae2b076bc5ab4eb5c996266719cec</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">诚信考试,不要作弊</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>移动通信</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>通信与计算机网络-知识点总结</title>
    <link href="/2022/06/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E7%BD%91/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <url>/2022/06/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E7%BD%91/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="通信与计算机网络-知识点总结"><a href="#通信与计算机网络-知识点总结" class="headerlink" title="通信与计算机网络-知识点总结"></a>通信与计算机网络-知识点总结</h1><p>本课程内容分为两大部分：通信网和计算机网络，最早的电信网技术关键是交换技术和网络结构。随着计算机网络的发展和通信网中设备虚拟化技术的趋势，通信网逐渐和计算机网络融合。  </p><h1 id="通信网"><a href="#通信网" class="headerlink" title="通信网"></a>通信网</h1><h2 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h2><p>简单来说，通信网中所使用的交换技术主要由两大类：电路交换和分组交换。<br>这两种交换可以采用不同的业务类型，业务类型分为面向连接的和无连接的。  </p><ul><li><p>面向连接的（connecting-oriented）<br>在双方通信之前需要通过通讯会话建立连接，直到通信结束后才能释放这个链接。<br>面向连接的通信包括三个阶段：  </p><ul><li>双方建立连接</li><li>通过连接双方进行通信</li><li>释放连接  </li></ul><p>相比于无连接的交换，面向连接的交换会消耗更多的资源和时间，但是通常可靠性会比无连接的交换更好。  </p></li><li><p>无连接的（connectionless）<br>通信的双方不需要在通信前建立连接。通信的发送方不关心接收方是否可以收到，也不保证连接的可靠性。<br>如果传输系统本身就具有高可靠性的特点，那么通信环境也可以保证无连接的可靠性。  </p></li></ul><p>协议架构中每一层采用的交换方式是独立的、可以是不同的。但是，如果下层资源没有被固定分配，上层无法使用固定资源分配的协议，因此不存在下层使用分组交换，上层使用电路交换的情况。<br><strong>面向连接的交换适用于长期的、稳定的、传输数据量大的通信。而无连接的交换适用于临时的、传输数据量小的通信，这种通信不需要为可靠性负责。</strong>  </p><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p>电路交换（circuit switching）是面向连接的交换，通信的双方在通信前建立双方独占、专用的物理通道。在建立连接后，物理资源会被分配到这条连接上为其专用。<br>如果双方的通信需要经过中间结点，在电路交换中，中间结点不关心数据内容，直接转发，这样的传输可以保证传输数据率始终恒定，这样的传输称为<strong>透明传输/透传</strong>（Transparent Transmission）。<br>同时双方与中间结点的连接使用的信道/电路是不同的，且一定专用。<br>电路交换的特点是：面向连接和透明传输。<br>电路交换的优点是：由于其透明性，电路交换往往可以稳定地实现恒定高数据率的传输。且当连接被建立后，基本上不需要额外的比特开销。<br>其缺点是：  </p><ul><li>其对通信资源的分配是固定的，且双方在通信过程中资源无法被动态分配。</li><li>由于通信资源的专有性，连接被建立后，线路在空闲时的通信资源无法被网络上的其他结点使用，通信资源利用率低。  </li><li>由于电路交换的数据率恒定，因此在不同类型的设备上传输时，两个设备必须以相同的数据率传输和接收，网络的利用率受到限制。  </li></ul><p>电路交换的应用例子是传统的语音通信网络和光传输网络。  </p><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>在分组交换(packet switching)中，传输数据分为多个数据包（称为分组）进行发送。每个数据包的格式是标准化的。分组交换所使用的资源和连接都是逻辑的，被整个网络的所有节点共用。双方如果不通信，资源则由网络中的其他用户共享。分组交换可以是面向连接的，也可以是无连接的。<br>分组交换的优点是：  </p><ul><li>链路在一段时间可以被许多分组动态地共享，通信资源的利用率较高。  </li><li>分组交换网络可以完成不同传输设备之间的数据率转换。  </li><li>网络发生拥塞时，分组仍然可以被中间结点接收并存储在缓存中，并不会像电路交换那样双方因为无法分配到资源而无法通信。  </li><li>可以对不同的分组定义不同的优先级。  </li></ul><p>分组交换的缺点是：</p><ul><li>无法保证每一次通信都可以获得足够的资源，且不能保证重要的资源被合理分配。</li><li>在传输过程中数据包的顺序可能发生移位或者丢失。  </li></ul><p>分组交换又分为两种：虚电路和数据报两种分组交换形式。  </p><h4 id="虚电路"><a href="#虚电路" class="headerlink" title="虚电路"></a>虚电路</h4><p>虚电路(virtual circuit)是一种面向连接的分组交换，在通信前双方需要从共享的通信资源中建立一条预订的路由（但是这条路由仍然和其他虚电路共享），并且相应的路由信息会被添加到分组中。因此，在转发每个分组时，节点不需要为每个分组选择路由。对于使用同一条虚电路的所有分组节点只需要做一次路由选择。<br>和电路交换不同的是，虚电路在建立连接过程中建立的是逻辑信道，连接被建立后不会被分配资源。<br>虚电路的应用例子是：帧中继和ATM。  </p><h4 id="数据报"><a href="#数据报" class="headerlink" title="数据报"></a>数据报</h4><p>在数据报(datagram)中，每个分组被独立的设置路由。因此一些分组虽然有相同的目的地址，但是并不是沿着相同的路由到达目的地，并且可能会失序地到达目的地。<br>数据报可以是面向连接的，也可以是无连接的。<br>无连接的数据报省略了建立连接过程，它不关心交付的可靠性，但是可以更加灵活地处理数据。<br>无连接的数据报的应用例子是：IP数据报和UDP数据报。<br>面向连接的数据报关心可靠性，有流量控制和差错控制功能，但是为了可靠性而付出了更多的代价。<br>面向连接的数据报的应用例子是：TCP数据报。  </p><h3 id="交换的粒度和分组的开销占比"><a href="#交换的粒度和分组的开销占比" class="headerlink" title="交换的粒度和分组的开销占比"></a>交换的粒度和分组的开销占比</h3><h4 id="交换的粒度"><a href="#交换的粒度" class="headerlink" title="交换的粒度"></a>交换的粒度</h4><p>简单来说，交换地址是有层级之分的，同一个主机拥有的其不同层级的地址是不一样的。在某些协议交换的过程中，为了避免记录有高地址不同，低层地址相同的数据分组在交换过程中发生错误，在交换之后需要改变其高层或者低层的地址。交换的粒度(granularity)所指的就是：高粒度的交换即会改变高层地址，也会改变低层地址；而低粒度的交换发生在高层级，即物理层等低层地址不发生改变，只有在逻辑层上的高层地址发生改变。  </p><p>具体的例子是ATM中的虚通路连接。ATM中，端用户之间的物理传输通道被划分成多个虚通道，同时虚通道(VC, virtual channel)可以从逻辑上被划分为多个虚通路(VP,virtual path)。每一个虚通路都有唯一的识别标志虚通路标识符（VPI)，每一个虚通道也有唯一的识别标志虚通道标识符（VCI）。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220421135621.png width=50%>  </p><p>为了避免从不同虚通道上来的具有相同VPI的信元流在结点转发过程中出现错误，中间结点会将来自某个虚通路或者虚通道上接收的信元根据特定的映射，交换到另一个虚通路或者虚通道上。这样的交换可以是低粒度的（只是将信元转发到另一个虚通路）也可以是高粒度的（将信元转发到另一个虚通道的另一个虚通路上）。  </p><h4 id="分组的开销占比"><a href="#分组的开销占比" class="headerlink" title="分组的开销占比"></a>分组的开销占比</h4><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220417165838.png width=50%>  </p><p>分组交换中，固定长度的一段报文被分成多少个分组取决于不同的应用场景。粒度高的分组方式(如上图中a)其额外开销比特（payload，即头部的控制信息）与用户数据占比更小，传输效率更高。粒度低(如上图中d)的分组方式，其额外开销比特与用户占比更大，但是更多的分组在交换时可以更加灵活处理，交换效率更高。    </p><h3 id="交换技术的发展和软交换技术"><a href="#交换技术的发展和软交换技术" class="headerlink" title="交换技术的发展和软交换技术"></a>交换技术的发展和软交换技术</h3><p>交换式通信网中的基本硬件设施是交换机。世界范围内交换机经历了”人工交换(manual exchange)-机电交换机(electromechanic exchange)-程控交换机(stored program control exchange)-软交换(soft switch)”四次大的技术革新。<br>程控交换机中的功能可以大致分为如下几个部分：用于连接站点的用户电路(user circuit)、用于连接其他交换机的中继电路(truck circuit)、用于控制通话的信令收发模块(signaling circuit)、控制和处理数据的中央处理器(CPU)、以及交换机内部负责各个模块的之间通信的交换结构。<br>传统程控交换机的缺点是：由于各功能模块被集成，因此如果要升级或改进其中某一模块，整个通信网中所有的交换机都需要更换。此外，对不同用户设备和信号，可能会使用到不同的程控交换机以适配接口。<br>软交换(soft switch)的基本思路是从物理上将硬件交换功能与其他功能分离。物理交换功能由媒体网关(media gateway)执行，并且可以兼容各种用户设备和信号；其他功能模块位于媒体网关控制器中，媒体网关控制器可以被虚拟化成为网络中的一些结点并且可以被整个网络中的节点共享。  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220417163755.png width=60%>  </p><h2 id="网络拓扑结构"><a href="#网络拓扑结构" class="headerlink" title="网络拓扑结构"></a>网络拓扑结构</h2><h3 id="拓扑结构的类型"><a href="#拓扑结构的类型" class="headerlink" title="拓扑结构的类型"></a>拓扑结构的类型</h3><div class="table-container"><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">结构</th><th style="text-align:left">优点</th><th style="text-align:left">缺点</th></tr></thead><tbody><tr><td style="text-align:left">星形<br>(最基本)</td><td style="text-align:left">每一个站点通过两条点对点链路与同一个中央节点连接：<br>一条链路负责发送，一条链路负责接收。中央节点的作用可以是实现广播功能，也可以实现帧交换功能。</td><td style="text-align:left">1. 新设备可以很方便地加入或者离开网络，可以提供更多，更方便的连接  <br>2.设备之间不会有干扰</td><td style="text-align:left">1. 可靠性低 <br>2.需要中央结点</td></tr><tr><td style="text-align:left">网形<br>(最基本)</td><td style="text-align:left">每个结点与可能不止一个其他结点相连。</td><td style="text-align:left">可靠性高，交换和路由设置更灵活。</td><td style="text-align:left">需要设置的链路数量更多，成本更高</td></tr><tr><td style="text-align:left">总线形*</td><td style="text-align:left">所有的站点通过标准的硬件接口直接连接到一个线性传输媒体上。</td><td style="text-align:left">新设备可以很方便地加入或者离开网络</td><td style="text-align:left">1. 可靠性低，如果主线断所有都断  <br> 2.需要采取某些机制避免碰撞  <br>3. 两端需要端子吸收信号</td></tr><tr><td style="text-align:left">环形*</td><td style="text-align:left">由若干段单向链路组成，每段链路的首尾通过转发器与其他链路的首/尾相连。</td><td style="text-align:left">被传输的信号在每一节点上再生，传输信息误码率可减到最少</td><td style="text-align:left">1. 结点故障会引起全网故障 <br>2.需要采取某些机制避免碰撞</td></tr><tr><td style="text-align:left">树形*</td><td style="text-align:left">从一个称为头端的点开始，延伸出多条缆线，每条缆线可以有多个分支。每条缆线可以视为一个总线形结构，缆线上有若干分接头。</td><td style="text-align:left">1.分支之间相对独立的同时分支之间的资源可以共享 <br> 2.新设备可以很方便地加入或者离开网络</td><td style="text-align:left">1.主线断，处处断 <br> 2.需要采取某些机制避免碰撞</td></tr></tbody></table></div><h3 id="通信网拓扑结构的演变"><a href="#通信网拓扑结构的演变" class="headerlink" title="通信网拓扑结构的演变"></a>通信网拓扑结构的演变</h3><ul><li>最初，结点之间的交换能力并不强，因此电信网采用的拓扑结构是网状结构，以保证端到端的连通性。并且当时的用户数量少，设置多条链路的开销并不大。  </li><li>随着用户数量的增大，网状拓扑结构多余链路的设置会带来更高的成本，因此电信网采用的拓扑结构是星形，当时此时已经有一些技术可以保证通信的可靠性，以弥补星形结构弱可靠性的缺点。  </li><li>电话费价格降低带来了业务量的增长，中央结点的负荷量增大，为了能够分担中央结点的负荷，此时中央结点之间由设置链路以分配各中央结点的负荷量，弥补交换能力的不足。用户接入数量的增多以及为了保证用户可以尽可能简单地接入网络，在用户连接端使用的拓扑结构仍然是星形。此时整个通信网被划分为核心网和接入网两大部分，并采用混合的拓扑结构。  </li><li>随着业务种类的增长，在这个阶段，中央结点的功能不再是单纯的交换，而有计算、存储等功能。进一步地，由于有足够高的数据率，这些功能节点可以被虚拟化至云服务器，并采用云计算技术提供支持。目前，为了进一步降低传播时延，部分云端的功能被拉入接入网，实现边缘计算。  </li></ul><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="链路控制技术"><a href="#链路控制技术" class="headerlink" title="链路控制技术"></a>链路控制技术</h2><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><h4 id="停等协议"><a href="#停等协议" class="headerlink" title="停等协议"></a>停等协议</h4><p>发送方在发送一帧之后，必须要等收到接收方的确认信息（称为ACK/acknowledgement）后，才能发送下一帧。接收方可以通过是否发送确认信息来控制数据传输的停止。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220331151203.png width=40%><br>停等协议保证了传输的可靠性，但是等待时延降低了传输效率。<strong>停等协议适用于通信时延低、总帧数少、单帧长度长的传输情况。在总帧数大、单帧长度短时，停等协议显得十分低效。</strong>  </p><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>滑动窗口的改进是一个批次一批次地发送多个帧，只需要在一个批次的帧传输完成后，接收方才需要发送确认信息。每一个批次的长度称为滑动窗口的长度。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220331154807.png width=50%>  </p><p>具体而言，$k$比特长的数据被划分成帧之后被循环编码，编码的范围为$0∼2^k-1$。<br>起始时，发送机一次性发送编号为$0∼i$的帧，接收机处理这些帧，并返回一个包含接收机处理的下一个帧的帧序号$n$的ACK。发送机收到ACK后，通过将ACK中的序号与发送的最后一个序号进行比对，从而得知上一批已经被接收机处理的帧的个数$i-n+1$。发送机再发送后续的$i-n+1$个帧，并等待接收机的下一个ACK，如此直到所有帧被发送完毕。<br>相比于停等协议，通过对窗口大小的合理设置，可以使链路被数据占满，实现对链路的高利用率。<br>简单来说，如果窗口的大小为：  </p><script type="math/tex; mode=display">[\frac{t_{ACK}}{t_{transmission}}]</script><p>向上取整。其中$t_{ACK}$为ACK的传输时间，$t_{transmission}$为帧的传输时间。<br>那么可以使得整个链路被占满。  </p><p>滑动窗口适用于<strong>通信时延低、总帧数多、单帧长度短的情况</strong>。  </p><h3 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h3><p>差错控制主要包括两个步骤：检错和纠错，检错即检查数据中是否出现差错。纠错机制主要分为两类：自纠错和重传。自纠错机制比如循环冗余校验(CRC)和奇偶校验(parity code)等等，它们都属于前向纠错(FEC)。本课程中主要介绍了自动请求重发(ARQ,Automatic Repeat Request，它是一种重传机制。<br>AQR有三类：停等ARQ，返回nARQ和选择拒绝AQR。  </p><div class="table-container"><table><thead><tr><th style="text-align:left">ARQ类型</th><th style="text-align:left">简述</th><th style="text-align:left">优点</th><th style="text-align:left">缺点</th><th style="text-align:left">适用场景</th></tr></thead><tbody><tr><td style="text-align:left">停等ARQ</td><td style="text-align:left">基于停等协议的ARQ。<br>正常的发送模式为停等协议。<br>无论是ACK丢失还是数据包出错或丢失，都会使发送端的计时器出现超时，此时发送端重传这个包。</td><td style="text-align:left">简单易行</td><td style="text-align:left">速度慢，资源利用率不高。</td><td style="text-align:left">通信时延低、总帧数小、单帧长度长</td></tr><tr><td style="text-align:left">返回nARQ</td><td style="text-align:left">基于滑动窗口协议的ARQ。<br>如果终端在某个帧中检测到差错，那么终端会为这个帧发送一个否认确认(REJ)，发送方将发送这个帧和接收到的这个帧之后的所有帧。如果超时，那么发送方会询问接收方需要重传的帧。</td><td style="text-align:left">传输速度相比于停等ARQ更高</td><td style="text-align:left">重传导致传输的有效信息不多，效率低下。</td><td style="text-align:left">通信时延低、总帧数多、单帧长度短</td></tr><tr><td style="text-align:left">选择拒绝ARQ</td><td style="text-align:left">被重传的只有那些接收到否认或者超时的帧。</td><td style="text-align:left">资源利用率更大</td><td style="text-align:left">对收发双方的缓存和逻辑结构复杂度要求更高</td><td style="text-align:left">通信时延高<br>（比如卫星通信）</td></tr></tbody></table></div><h2 id="路由策略"><a href="#路由策略" class="headerlink" title="路由策略"></a>路由策略</h2><div class="table-container"><table><thead><tr><th style="text-align:left">路由策略</th><th style="text-align:left">描述</th><th style="text-align:left">优点</th><th style="text-align:left">缺点</th></tr></thead><tbody><tr><td style="text-align:left">静态路由</td><td style="text-align:left">为网络中每一个源的终端选择一条永久固定的路由，并存储在路由表中。只有在网络的拓扑结构发生改变时，静态路由表才会发生改变</td><td style="text-align:left">简洁性，在具有稳定负荷的、可靠的网络中表现良好</td><td style="text-align:left">缺乏灵活性，无法对在网络拥塞和结点故障时进行调度</td></tr><tr><td style="text-align:left">洪泛</td><td style="text-align:left">网络中的每个结点在接收到某个分组后会复制该分组，并且转发给每一个相邻接点。最终终端会收到多份相同的分组。由于每个源点发送的分组都有唯一的编号，因此终端可以根据编号将编号相同的分组丢弃。</td><td style="text-align:left">1.鲁棒性强<br>2.可以访问到尽可能多的结点 <br> 3.不需要全网状态</td><td style="text-align:left">通信负荷量非常高，极容易产生拥塞</td></tr><tr><td style="text-align:left">随机路由</td><td style="text-align:left">网络中的每一个结点根据链路的数据率、有概率地为选择一条路由。</td><td style="text-align:left">保留了洪泛的简单性质，降低了通信量。</td><td style="text-align:left">路由选择可能不是最佳的</td></tr><tr><td style="text-align:left">自适应路由</td><td style="text-align:left">路由的选择根据网络的状态的改变而改变。</td><td style="text-align:left">可以对拥塞灵活处理</td><td style="text-align:left">需要知道整个网络的状态</td></tr></tbody></table></div><h3 id="路由决策的要素"><a href="#路由决策的要素" class="headerlink" title="路由决策的要素"></a>路由决策的要素</h3><p>影响路由的两个关键要素是判决地点和信息更新时间。  </p><ul><li><p>判决地点<br>判决地点指的是做出路由的地点，有分布式和集中式两种。<br>对于集中式，其能更好的掌握全网的状态，从而做出全局最优的路由判决。但是如果做出路由的中心结点故障，则全网路由无法工作。<br>对于分布式，其只能掌握周围结点的网络状态，因而做出的路由判决只能是局部最优的。</p></li><li><p>信息更新时间和响应速度<br>如果路由判决对网络状态的响应过快，容易引起网络波动。并且，信息更新过快会使得全网负载增加。<br>如果路由判决对网络状态的响应过慢，收集到的网络状态信息时效性差，路由判决的有效性差。  </p></li></ul><h2 id="TCP-IP协议栈"><a href="#TCP-IP协议栈" class="headerlink" title="TCP/IP协议栈"></a>TCP/IP协议栈</h2><p>TCP/IP协议栈一共有五层：  </p><ul><li>物理层(physcial layer):提供主机和传输媒体的物理接口。  </li><li>网络接入层(network access layer)：提供主机和相邻网络的数据交换和接入，并进行局域网内部的路由选择。  </li><li>网际层(internet layer)：提供跨越多个网络的数据传输服务，并提供多个网络间的路由。  </li><li>运输层(transport layer)：保证数据分组可靠地交付到对应的应用。  </li><li>应用层(application layer):支持多种应用逻辑。  </li></ul><h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><p>起初，计算机网络的目的是能够使得用户可以自由灵活地加入和离开网络共享资源。最初的局域网就是依照这个目的而建立的。局域网的数据率受制于两个主要原因：碰撞和带宽。  </p><h3 id="基于竞争的接入控制协议"><a href="#基于竞争的接入控制协议" class="headerlink" title="基于竞争的接入控制协议"></a>基于竞争的接入控制协议</h3><p>局域网中采用的接入控制方式是基于竞争的，因此会出现碰撞，如何避免碰撞成为了限制局域网速度的一个主要原因，因此，需要一些协议来避免碰撞，这些基于竞争的控制接入协议如下：  </p><h4 id="ALOHA和分隙ALOHA"><a href="#ALOHA和分隙ALOHA" class="headerlink" title="ALOHA和分隙ALOHA"></a>ALOHA和分隙ALOHA</h4><p>ALOHA是一种非常简单的协议：任何一个站都可以在帧生成后立即发送。如果发信中遇到了冲突，则发信失败，该帧被丢弃，经随机延时后再次发送。分隙ALOHA将信道时间分成了若干时隙，时隙的长度对应了一帧的传输时间。凡帧的发送必须在时隙的起点。因此，冲突只发生在时隙的起点，冲突发生时只浪费一个时隙，一旦某个站占用时隙并发送成功，则在该时隙内不会出现冲突。<br>ALOHA和分隙ALOHA由于过于简单，信道利用率低下，利用率分别为18%和36%。  </p><h4 id="载波监听接入控制-CSMA"><a href="#载波监听接入控制-CSMA" class="headerlink" title="载波监听接入控制/CSMA"></a>载波监听接入控制/CSMA</h4><p>载波监听接入控制根据信道忙时站点的等待机制，可以将CSMA分为：非持续CSMA、1持续CSMA和$p$持续CSMA。  </p><div class="table-container"><table><thead><tr><th style="text-align:left">CSMA策略</th><th style="text-align:left">描述</th><th style="text-align:left">优点</th><th style="text-align:left">缺点</th></tr></thead><tbody><tr><td style="text-align:left">非持续CSMA</td><td style="text-align:left">- 如果信道空闲，则立即发信。 <br>- 如果信道忙，则等待一段时间，该时间长度服从重传时延的概率分布。</td><td style="text-align:left">简单</td><td style="text-align:left">传输结束后，信道容易保持空闲，即使有一个或者多个站点等待传输。</td></tr><tr><td style="text-align:left">1持续CSMA</td><td style="text-align:left">- 如果信道空闲，则立即发信。 <br> - 如果信道忙，则等待直到信道空闲。</td><td style="text-align:left">避免了信道空闲，利用率高</td><td style="text-align:left">等待结束后碰撞概率随着站点数目的增大而增大</td></tr><tr><td style="text-align:left">𝒫持续CSMA</td><td style="text-align:left">- 如果信道空闲，那么站点有概率$p$发信。 <br>- 如果信道忙，那么站点等待直到信道空闲。  <br>- 如果站点已经等待了一个单位时间，那么站点有概率$p$发信。</td><td style="text-align:left">避免了信道空闲，而且降低了等待结束后发生的碰撞概率</td><td style="text-align:left">$p$的选取至关重要，随着站点数$n$的增大，$p$应当动态地减小。但是这样的动态设置需要让新加入的主机也知道，违背了局域网设置的初衷。</td></tr></tbody></table></div><h4 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA/CD"></a>CSMA/CD</h4><p>载波监听多点接入/碰撞检测协议(Carrier Sense Multiple Access with Collsion Detect,CSMA/CD)综合了上述几种载波监听多点接入协议的优点，其具体策略是：  </p><ul><li>如果信道空闲，站点立即发信。  </li><li>如果信道忙，则等待直到信道空闲。  </li><li>如果站点检测到碰撞，在传输过程中，站点会主动发出一个干扰信号（称为积极干扰信号，jamming signal；在基带总线中，这个信号是一个高电平信号）来让整个网络中的所有站点知道碰撞的发生，之后停止传输。  </li><li>发送完干扰信号后，随机地等待一段时间（退避），以避免二次碰撞，之后再尝试发信。  <div class="note note-info">            <p>任意一个站点在检测到干扰信号后都会发出干扰信号，使得整个网络可以快速地知晓碰撞。  </p>          </div>  </li></ul><h4 id="传播时延和最小帧长度"><a href="#传播时延和最小帧长度" class="headerlink" title="传播时延和最小帧长度"></a>传播时延和最小帧长度</h4><p>由于信号在传输线上的传输时延$τ$($τ$的参考值：<strong>电磁波在1km电缆上的传播时延大约为5μs</strong>)，传输线上的站点可能依然认为信道是空闲的。<br>由于局域网上任意两个站点之间的传播时延有长有短，局域网按照最坏情况设计，即取总线两端的两个站点之间的传播时延为端到端的传播时延。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220517164059.png width=80%>  </p><p>从上图可以看出，<strong>在站点发送帧后至多$2τ$（即$δ→0$）时间就可以知道所发送的数据帧是否遭受到碰撞。</strong><br>这段时间称为争用期，可以发现，<strong>在站点发送完数据后，在争用期时间还没有检测到碰撞，那么这次发送一定不会产生碰撞。</strong><br>具体而言，<strong>以太网协议规定的具体的征用时间为$2τ=51.2μs$。</strong><br>对于10Mbit/s的以太网，争用期内可以发送512bit。争用期的单位也可以用bit·s，称为比特时间表示，因此上述争用期时间也可以说为512比特时间，即争用期是发送512bit所需要的时间。<br><strong>在这种情况下，只有当帧长度大于$2L=r_b×2τ$</strong>（在上文的例子中应当为512bit）<strong>时，源站点和终端之间的任何一个站点才不可能在源站点和终端之间通信时认为信道空闲。</strong></p><h3 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h3><p>随着交换技术的发展以及交换机的价格逐渐便宜，避免碰撞的方式开始转向将碰撞域整体的划分。<br>网桥(bridge)可以在保证两个局域网相对独立的情况下，支持两个局域网之间的相互通信。换言之，可以使用网桥将一个碰撞域划分为两个子碰撞域。  </p><h4 id="网桥的功能"><a href="#网桥的功能" class="headerlink" title="网桥的功能"></a>网桥的功能</h4><ul><li><p>地址学习(address learning)<br>由于局域网中站点设备“来去自由”的特性，其交换表需要动态改变，因此网桥需要有自适应地址学习的功能。<br>简单来说，可以分为如下几种情况：  </p><ul><li>当某个帧的头部中的源地址不位于交换表中，目的地址位于交换表中且位于异侧，表明发送侧局域网中有新的站点加入。此时网桥会将数据帧转发到对应的目的地址，并记录下源地址。  </li><li>当某个帧的源地址位于交换表中，目的地址部存在于交换表中，目的地址是否在与发送侧不同的一侧的情况未知。此时网桥会向另一侧的局域网广播该数据帧，如果有站点接收，表明目的地址位于异侧，网桥将这次交换记录到交换表；如果没有站点接收，表明目的地址位于发送侧，网桥不会记录下这次交换。<br>为了让网桥有适应拓扑变化的能力，会为每一个学习到的地址设置老化时间，一般为5分钟。超过老化时间的地址会被移除交换表。  </li></ul></li><li><p>生成树(spanning tree protocal)<br>当网络中存在多个网桥的情况下，可能会引起网桥环路，环路会导致一个广播数据在两个网桥构成的环路中无限循环地来回传输，这种现象称为广播风暴，从而影响整个网络的性能。<br>生成树算法是一种解决环路问题的拓扑结构生成算法，按照生成树算法，整个网络的拓扑结构最终会以一个无任何冗余连接的树形结构，从而避免环网的生成。  </p></li></ul><h3 id="局域网定义的变化"><a href="#局域网定义的变化" class="headerlink" title="局域网定义的变化"></a>局域网定义的变化</h3><p>通过交换机，可以将整个碰撞域划分为更小更多的子碰撞域以进一步减小碰撞概率。极端情况下，可以使用交换机将每一个站点分割为单独的子碰撞域，即每个子碰撞域下只存在一个站点，从而真正避免了碰撞的发生。事实上，如今的网络中每一个站点都有类似的功能，其物理承载设备是网卡。在此基础上研究只有一个站点的局域网并没有太大意义，因此局域网的定义不再是单纯的一个碰撞域，而是<strong>将由一个交换机和其连接全部站点组成的网络</strong>称为局域网。  </p><h2 id="IP协议群"><a href="#IP协议群" class="headerlink" title="IP协议群"></a>IP协议群</h2><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><h4 id="分类的IP地址"><a href="#分类的IP地址" class="headerlink" title="分类的IP地址"></a>分类的IP地址</h4><p>IP地址由两部分构成：<strong>网络号和主机号</strong>。网络号表示主机或者路由器端口连接到的网络，网络号在整个互联网范围内是唯一的；主机号表示该主机或者该路由器端口，在网络号对应的网络中是唯一的。<br>根据不同用途，将IP地址分为了5类，依据网络号中有1到4位的类别位对其类别进行识别。<br>这样分配IP地址的好处有二，其一是IP地址管理机构在分配IP地址时只需要分配网络号，主机号可以由得到网络号的组织自行分配。其二是路由器仅根据网络号转发分组，大大减少了路由器中路由表所占用的内存和查表时间。  </p><p>其中ABC类地址用于一对一通信，称为单播地址。<br>A类结构中网络号有8位，其头部类别位为“0”，主机号有24位。<br>B类结构中网络号有16位，其头部类别位为“10”，主机号有16位。<br>C类结构中网络号有24位，其头部类别位为“110”，主机号有8位。  </p><p>需要注意，路由器的每个端口将拥有一个网络号；由于传统的网桥或者（二层）交换机不需要和其他网络进行通信，它们一般没有IP地址。   </p><p>分类形式的IP地址的缺点：  </p><ul><li>IP地址的利用率非常低，分配到某类地址的组织往往主机数量并没有达到上限，这就造成了IP地址的浪费。</li><li>随着网络数量的增加，每个物理网络分配一个网络号最终会导致路由表太大，导致查表时间和路由器成本增加。</li><li>两级的IP地址不够灵活，申请到新的IP地址之前，新增加的网络是不可能连接到互联网上工作的。  </li></ul><h4 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h4><p>在这样的背景下，原来的两级地址变成由<strong>网络号、子网号和主机号</strong>组成的三级地址。<br>某些单位可以将物理网络划分为若干个子网，但是单位对外仍然表现为一个网络。发送到这个单位的IP数据报在被这个单位的路由器接收到后，按照子网号找到对应主机所在的子网。<br>子网划分的信息需要单独用子网掩码表示，子网掩码的结构是网络号和子网部分全为1，主机号为0，与IP地址相与之后就可以得到子网的网络号。  </p><h4 id="CIDR"><a href="#CIDR" class="headerlink" title="CIDR"></a>CIDR</h4><p>随着网络地址即将耗尽，之后又提出了CIDR。CIDR把32位的IP地址划分为前后两个部分：网络前缀和主机号，其中网络前缀用于指明网络。此外，CIDR的IP地址后还需要用斜线“/”其后跟随网络前缀所占用的位数。    </p><h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p>ARP协议提供了从MAC地址到IP地址的映射。<br>ARP协议使用MAC帧进行传送。<br>每一台主机/路由器都有ARP高速缓存器，里面有本局域网上各主机/路由器的MAC地址以及它们对应的IP地址。当主机要向本局域网上的另一个主机发送IP数据报时，需要从该主机内部的ARP缓存器中找到目的主机IP地址对应的MAC地址，并填入MAC帧中，然后局域网把该MAC帧发往此MAC地址绑定的主机。<br>同交换机/网桥一样，ARP缓存器也有对地址的自我学习功能：  </p><ul><li>当目的主机IP地址对应的MAC地址对源主机未知时，源主机通过ARP进程向本局域网中<strong>广播</strong>一个ARP请求，其内容包括了<strong>源主机的MAC地址和IP地址</strong>，以及<strong>需要查找的MAC地址所对应的IP地址</strong>，这些信息被封装为<strong>MAC帧格式</strong>。  </li><li>局域网中的每一个主机都会收到这个包含ARP请求的MAC帧，然后解包查看需要查找的IP地址是否为自己的IP地址：<ul><li>如果收到ARP请求的主机的IP地址与请求查找的IP地址不同，则该主机忽略这个ARP包。  </li><li>如果收到ARP请求的主机的IP地址与请求查找的IP地址相同，则该主机收下这个ARP请求，并且发送一个包含自己MAC地址和IP地址的ARP响应。这个响应的发送是单播。<br>同时，该主机也将源主机的MAC地址和IP地址写入自己的ARP缓存中，以便今后通信。  </li></ul></li><li>源主机收到ARP响应后，将响应中的MAC地址和IP地址写入自己的ARP缓存中。  </li></ul><p>如果所找的主机和源主机不在同一个局域网上，则需要路由器按照MAC帧的操作将其广播到各个网络中的路由器，由这些路由器进一步广播寻找自己连接的网络下是否存在这个主机。同样地，目的主机发送的ARP响应也需要通过路由器转发到源主机所在的网络中，其处理过程和MAC帧相同。  </p><p>由于IP地址会不断变动，ARP缓存中为其中的每个项目也有生存时间（通常为10到20分钟），超出生存时间的项目会被自动删除。  </p><h2 id="IP层的路由"><a href="#IP层的路由" class="headerlink" title="IP层的路由"></a>IP层的路由</h2><h3 id="内部网关：RIP协议"><a href="#内部网关：RIP协议" class="headerlink" title="内部网关：RIP协议"></a>内部网关：RIP协议</h3><p>RIP协议是一种基于距离向量的路由选择协议，最大优点是简单。此处的距离是指的路由中经过路由器的个数，称为跳数(hop count)。<br>RIP协议的特点是：  </p><ul><li>每个路由器只与其相邻的路由器交换信息。  </li><li>路由器交换的信息是本路由器当前的路由表，路由表的每行表示到自治域内某个网络的<strong>最短跳数</strong>以及对应路由所经过的<strong>下一跳路由器</strong>。  </li><li>路由器之间周期性地交换路由信息，通常是每隔30秒交换一次路由表。   </li></ul><p>RIP协议的功能是让一个自治域中的所有路由器都定期地与其相邻地所有路由器交换路由信息，并不断更新路由表，使得每一个路由器到每一个目的网络的路由都是最短的。   </p><h4 id="RIP协议的操作"><a href="#RIP协议的操作" class="headerlink" title="RIP协议的操作"></a>RIP协议的操作</h4><p>对于使用RIP协议的自治域中的某一个路由器，在其收到相邻路由器发送的RIP报文后，进行如下操作：  </p><ul><li>对于从相邻路由器X中收到的路由表，先将这个路由表中所有的下一跳路由器全部改为X，并且每一行的跳数加一。  </li></ul><p>对于收到并对其更改后的路由表B，本路由器会将这个路由表B与原来自己的路由表A进行对比：  </p><ul><li>如果原来路由表中没有某个网络N，就把这个网络添加到自己的路由表A中。  </li><li>如果原来路由表中有网络N：  <ul><li>如果B中的下一跳路由器与原来自己路由表A中的下一跳路由器相同：  <ul><li>如果路由跳数发生了改变，则对跳数进行更新。  </li><li>如果路由跳数与之前相同，则什么也不做。  </li></ul></li><li>如果B中的下一跳路由器与原来自己路由表A中的下一跳路由器不同：  <ul><li>如果B中的路由跳数比A中的短，则更新这个条目中对应的下一跳路由器和最短跳数。  </li><li>如果B中的路由跳数比A中的长，则什么也不做。  </li></ul></li></ul></li><li>如果3分钟过后还没有收到路由器X发来的路由表，则这个路由器相关的路由都设置为<strong>16，表示距离不可达</strong>。  </li></ul><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220608163708.png width=70%>  </p><h4 id="协议格式"><a href="#协议格式" class="headerlink" title="协议格式"></a>协议格式</h4><p>由于RIP协议通信是一种短而少量的通信，RIP协议使用<strong>用户数据报UDP协议</strong>进行传送。  </p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>RIP存在的最大问题是局限于相邻结点的路由信息，<strong>当网络出现故障时，需要经过比较长的时间才能将这个信息传送到所有的路由器</strong>，可以简单记为“坏消息传的慢”。<br>这样的机制使得整个自治域中达到稳定路由的时间变长。<br>此外，RIP还限制了网络的规模，它能使用的最大距离被限制在15。由于交换信息是完整的路由表，因而随着网络规模的扩大，其开销也就增加。   </p><h3 id="内部网关：OSPF协议"><a href="#内部网关：OSPF协议" class="headerlink" title="内部网关：OSPF协议"></a>内部网关：OSPF协议</h3><p>OSPF是另一种内部网关协议，它是一种分布式<strong>基于链路状态</strong>的路由协议。<br>OSPF的特点是：   </p><ul><li>使用洪泛向本自治域中的所有路由器发送信息。每一个相邻路由器将收到的信息发往其所有的相邻路由器。  </li><li>发送的信息是与本路由器相邻的所有路由器的链路状态。链路状态包含两个信息：<br>一个是相邻路由器，另一个是路由的代价，称为度量(metric)。  </li><li>当链路状态发生变化时(比如代价的变化，或者路由离线等等)，路由器才向所有路由器用洪泛发送此信息。  </li></ul><p>最终，所有的路由器都能建立一个链路状态数据库，这个数据库在全网范围内是一致的。  </p><h4 id="协议格式-1"><a href="#协议格式-1" class="headerlink" title="协议格式"></a>协议格式</h4><p>OSPF协议使用IP数据报传送，且长度很短。  </p><p>相比于RIP，OSPF协议还有如下特点：  </p><ul><li>允许对不同类型的业务计算出不同的路由。  </li><li>可以将通信量分配给多条代价相同的路径，进行负载平衡。  </li><li>支持子网划分和超网。  </li><li>由于使用了洪泛方法，OSPF需要让每个链路状态都带上一个32位的序号，序号越大状态就越新。  </li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">路由协议</th><th style="text-align:left">基于类型</th><th style="text-align:left">路由器交换的信息</th><th style="text-align:left">收敛后每个路由器内部数据差异</th><th style="text-align:left">协议格式</th></tr></thead><tbody><tr><td style="text-align:left">RIP协议</td><td style="text-align:left">距离向量</td><td style="text-align:left">整个路由表</td><td style="text-align:left">不同的路由表</td><td style="text-align:left">UDP数据报</td></tr><tr><td style="text-align:left">OSPF协议</td><td style="text-align:left">链路状态</td><td style="text-align:left">链路状态：包含相邻路由和代价</td><td style="text-align:left">全网范围内一致的链路状态数据库</td><td style="text-align:left">IP数据报</td></tr></tbody></table></div><h2 id="运输层协议"><a href="#运输层协议" class="headerlink" title="运输层协议"></a>运输层协议</h2><h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>端口的本质是应用层的各种协议进程与运输实体之间进行层间交付的地址。需要注意，端口号是一种只具有本地意义的地址。<br>TCP/IP协议群的运输层使用的端口号长度为16位。  </p><h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>TCP连接的端点称为套接字(socket)，套接字由IP地址和端口号拼接而来，格式为(IP地址:端口号)。<br>每一条TCP连接唯一地被通信两端的两个套接字确定，因此，每一条TCP连接可以表示为：{(IP1:Port1),(IP2:Port2)}。  </p><h3 id="网络地址转换-NAT"><a href="#网络地址转换-NAT" class="headerlink" title="网络地址转换/NAT"></a>网络地址转换/NAT</h3><p>对一个专用网络采用专用地址进行内部映射，而这个专用网络对外拥有至少一个有效的全球IP地址。这个IP地址和专用网络中设备的专用地址之间的映射关系由网络地址转换/NAT(Natwork Address Translation)进行。<br>所有使用本地地址的主机在和外界通信时，都要在装有NAT软件的路由器上将本地地址转换为全球IP地址，然后才能和互联网连接。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220615165924.png width=50%>  </p><p>当运输层引入端口号和套接字的概念时，外部网络的网络的IP地址和端口号被映射为内部网络的IP地址和端口号，理论上如果外网IP地址的端口号足够覆盖内网所有的主机和进程数，即便是只有一个IP地址，通过不同的端口号也可以识别不同内网主机和不同内网主机的不同进程，不需要设备轮流使用IP。  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/计算机网络.png width=100%></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>通信和计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信工程</tag>
      
      <tag>通信网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>附录：关键协议头部结构</title>
    <link href="/2022/06/17/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E7%BD%91/%E9%99%84%E5%BD%95%EF%BC%9A%E5%85%B3%E9%94%AE%E5%8D%8F%E8%AE%AE%E5%A4%B4%E9%83%A8%E7%BB%93%E6%9E%84/"/>
    <url>/2022/06/17/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E7%BD%91/%E9%99%84%E5%BD%95%EF%BC%9A%E5%85%B3%E9%94%AE%E5%8D%8F%E8%AE%AE%E5%A4%B4%E9%83%A8%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<table>  <tr><th colspan="2">协议名称</th><th>头部长度可变/不可变<br>头部长度</th><th>总长度</th><th>关键字段及解释</th><th>注解</th></tr>  <tr><th rowspan="2">ATM</th><td>UNI</td><td rowspan="2">5字节</td><td rowspan="2">53字节</td><td><b>一般流量控制</b>：ATM中只控制站点收发信元的速率而不控制传输速率。<br><b>有效荷载类型</b>：表示该信息是用户信息还是控制信息，服务数据单元的类型，以及是否经历过拥塞。<br><b>信元丢失优先级</b>:CLP=0表示该信元的优先级较高，只有在没有其他选择的情况下才能丢弃这个信元。CLP=1表示该信元在需要时就可以被网络丢弃。</td><td  rowspan="2"></td></tr>  <tr><td>NNI</td><td>同上，但是没有一般流量控制字段</td></tr>  <tr><th colspan="2">EthernetV2</th><td>14字节</td><td>长度可变<br>最短：64字节=10Mbps×25.6us×2<br>最长：1518字节</td><td><b>目的地址和源地址</b>：目的和源的MAC地址。<br><b>类型</b>：接收数据的高层协议类型。<br></td><td>MAC帧头部前还有8字节的前同步码+定界符，它们不属于MAC帧。<br>尾部有<b>头部校验和</b></td></tr>  <tr><th colspan="2">IPv4</th><td>长度可变<br>最短：20字节</td><td>长度可变<br>一般小于1500字节</td><td><b>源地址和目的地址</b>：源和目的的IP地址。<br><b>总长度</b>:指整个IP数据报（首部+数据部分）的长度<br><b>标识</b>：IP数据报中用于计数产生数据报个数的字段；长数据会被拆分为具有相同计数的多个数据报片，在接收处需要将计数部分相同的数据报片进行还原。<br><b>片偏移</b>：IP数据报中表示某个数据报分片在分片前的整个数据部分中的相对位置。<br><b>生存时间</b>：该数据报在网络中的最大存活时间，以跳数计，每经过一个路由器TTL-1.<br><b>首部校验和</b></td><td>4字节对齐</td></tr>  <tr><th colspan="2">TCP</td><td>长度可变<br>最短：20字节</td><td>长度可变</td><td><b>源端口和目的端口</b>：源和目的端口号。<br><b>报文段序号</b>：TCP连接中传送的每一个字节的顺序编号。<br><b>确认号</b>：由于TCP采用了ARQ机制，所以需要有确认号来表示期望收到对方下一个报文段的第一个数据字节的序号。<br><b>校验和</b>：首部和数据的校验和，计算时需要添加伪首部。<br><b>选项</b>：最早只有一种选项，<b>报文段最大长度(MSS)</b>：整个报文段长度减去TCP首部后的长度。在建立连接的过程中，通信双方把自己可以支持的MSS写入这一字段，之后就按照这个数值传输数据。双方可以有不同的MSS值。其后陆续增加了比如窗口扩大、时间戳等选项。<br><b>紧急指针、窗口、偏移量、头部长度</b></td><td>伪首部不会向上递交也不会向下传递，只用于计算校验和。</td></tr>  <tr><th colspan="2">UDP</td><td>8字节</td><td>长度可变</td><td><b>源端口和目的端口</b>：源和目的端口号。<br><b>长度</b>：UDP数据报的长度。<br><b>校验和</b>：首部和数据的校验和，计算时需要添加伪首部。</td><td>伪首部不会向上递交也不会向下传递，只用于计算校验和。</td></tr></table><p>ATM:<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220421161600.png width=50%>    </p><p>Ethernet V2:<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220523145310.png width=50%>  </p><p>IPv4:<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220629125846.png width=50%>  </p><p>TCP:<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220629125717.png width=50%>  </p><p>UDP:<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220629125742.png width=50%>  </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>通信和计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信工程</tag>
      
      <tag>通信网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.计算机网络：运输层</title>
    <link href="/2022/06/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E7%BD%91/6.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%9A%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    <url>/2022/06/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E7%BD%91/6.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%9A%E8%BF%90%E8%BE%93%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络：运输层"><a href="#计算机网络：运输层" class="headerlink" title="计算机网络：运输层"></a>计算机网络：运输层</h1><h2 id="运输层端口号"><a href="#运输层端口号" class="headerlink" title="运输层端口号"></a>运输层端口号</h2><p>从运输层的角度看，通信的真正端点并不是主机而是主机中的进程。也就是说，端到端的通信是应用进程之间的通信。<br>但是，把一个特定机器上运行的特定进程，指明为互联网上通信的最后终点还是不可行的。这是因为进程的创建和撤销都是动态的，通信的一方几乎无法识别对方机器上的进程。另外，我们往往需要利用目的主机提供的功能来识别终点，而不需要知道具体实现这个功能的进程是哪一个。解决这个问题的方法是在运输层使用协议端口号，或者简称端口(port)。<strong>端口的本质是应用层的各种协议进程与运输实体之间进行层间交付的地址</strong>。需要注意，端口号是一种只具有本地意义的地址。<br>TCP/IP协议群的运输层使用的端口号长度为16位。  </p><h2 id="用户数据报协议-UDP"><a href="#用户数据报协议-UDP" class="headerlink" title="用户数据报协议/UDP"></a>用户数据报协议/UDP</h2><h3 id="UDP协议的特点"><a href="#UDP协议的特点" class="headerlink" title="UDP协议的特点"></a>UDP协议的特点</h3><ul><li>无连接的<br>UDP在发送数据之前不需要建立连接，减少了开销和数据发送之前的时延，同时也不保证可靠的交付。  </li><li>面向报文的<br>UDP对应用层交下的报文，既不合并也不拆分，而是直接保留这些报文的边界。UDP一次交付一个完整的报文，因此虽然UDP没有长度限制，应用程序也必须要选择报文的合适长度，使其能在IP层不加分片、高效地传输。  </li><li>没有拥塞控制<br>UDP没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低，对于对时延要求非常高的实时应用是非常有用的。  </li></ul><h3 id="UDP首部格式"><a href="#UDP首部格式" class="headerlink" title="UDP首部格式"></a>UDP首部格式</h3><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220615181439.png width=50%>  </p><p>UDP的首部长度只有8个字节，一共四个字段，每个字段的长度都是两个字节。<br>需要注意的是，UDP首部在计算校验和时，要在UDP数据报之前增加一个12个字节的伪首部，这个首部只在计算校验和时，临时添加在UDP用户数据报前面。<strong>伪首部既不向下传送也不向上递交，仅仅是为了计算校验和</strong>。  </p><h2 id="传输控制协议-TCP"><a href="#传输控制协议-TCP" class="headerlink" title="传输控制协议/TCP"></a>传输控制协议/TCP</h2><h3 id="TCP协议的特点"><a href="#TCP协议的特点" class="headerlink" title="TCP协议的特点"></a>TCP协议的特点</h3><ul><li>面向连接的<br>应用程序在使用TCP协议之前，需要建立TCP连接，传输数据结束后必须释放已经建立的TCP连接，TCP提供可靠交付的服务。  </li><li>面向字节流<br>在TCP中，字节流指流入或流出进程的字节序列。也就是说，TCP把应用程序交付的数据仅仅看做一连串无结构的字节流，TCP并不知道所传送的字节流的含义。  </li><li>基于滑动窗口<br>TCP基于滑动窗口进行流量控制，其会根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应当包含多少个字节。  </li></ul><h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>TCP连接的端点称为套接字(socket)，套接字由IP地址和端口号拼接而来，格式为(IP地址:端口号)。<br>每一条TCP连接唯一地被通信两端的两个套接字确定，因此，每一条TCP连接可以表示为：{(IP1:Port1),(IP2:Port2)}。  </p><h3 id="TCP首部格式"><a href="#TCP首部格式" class="headerlink" title="TCP首部格式"></a>TCP首部格式</h3><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220615205317.png width=50%>  </p><p>TCP的首部是长度可变的，最小长度为20个字节。<br>头部中重点的字段是：  </p><ul><li>源端口和目的端口<br>各2字节。分别写入源端口号和目的端口号。  </li><li>序号/报文段序号<br>占4字节。一个TCP连接中传送的每一个字节都按照顺序编号，整个要传送的字节流起始号必须在建立连接时确定。   </li><li>确认号<br>占4字节。由于TCP采用了ARQ机制，所以需要有确认号来表示期望收到对方下一个报文段的第一个数据字节的序号。  </li><li>校验和<br>同UDP，在计算校验和时，也需要在TCP首部添加12字节的伪首部用于生成校验和。  </li><li>选项<br>长度可变，最长可以达到40个字节。TCP最初只规定了一种选项，称为“最大报文段长度(MSS,Maximum Segment Size)”，表示每个报文段中数据字段的最大长度，注意MSS表示的是整个报文段长度减去TCP首部后的长度。<br>MSS存在的原因是MSS长度的设置与IP数据报的行为有关：如果MSS过长，IP数据报需要进行分段，如果MSS过短，那么IP数据报的字节效率不高。<br>在建立连接的过程中，通信双方把自己可以支持的MSS写入这一字段，之后就按照这个数值传输数据。双方可以有不同的MSS值。<br>随着互联网的发展，又陆续增加了比如窗口扩大、时间戳等等选项，在此不一一介绍。  </li></ul><h3 id="流量和差错控制"><a href="#流量和差错控制" class="headerlink" title="流量和差错控制"></a>流量和差错控制</h3><p>需要注意的是，由于MAC层、IP层都没有流量控制和差错检测，TCP/IP协议栈中的流量控制和差错检测由TCP层负责，TCP进行流量控制和差错检测的机制在第二章数据链路层已介绍过，在此不过多赘述。  </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>通信和计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信工程</tag>
      
      <tag>通信网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.蜂窝移动电话网演进·卫星定位系统</title>
    <link href="/2022/06/12/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/4.%20%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF%E6%BC%94%E8%BF%9B/"/>
    <url>/2022/06/12/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/4.%20%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF%E6%BC%94%E8%BF%9B/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="1d66b9be57346d13b6303b542da41c97c12d6f7472b90d126947ac6e3dbad410">d23a4056e39b7e810998c80d99c7e17f86f9f2d02bab1f8b5f4197996369e4efd6d7eaf43fbbb6c360d8f60494a63d57d151f367758cebf086d193fb319bce3cd071abeaf5b7edcecb3daae2ee2854896255a52027cd7c367bd8bd91bc738d39bfbdee5b38a9ce4654697f6758df1b169947cda211fca947e93a0fa64adf468c4f9495dccad7cab58c636a09c90625a4ecf0f932e5876f6afbeec24f6a763418af9666fb90cdb338aac8d1019bee18bae25702e0b6f50b8b2f89fbfded34c856bedaf727707159672ac12676e65f25181adb88ac8136c0fde46995f6f425f52e5ff85fbb0c69384eeabfa5b8d447d9c9f52d17547d9b378d2f13a7a3f5ad85689818b48dab57f2990a93b61d694cf60952b6c9148491b2149cf9a4b8970ee7cb90383c62e38a3c3c46848eae40628487be8afe579f42c9589ac09e782d34ba7ea69437dffe04c97442096c8728b543f0331cc1add3da3d6fe126caf21d59ea6593793298927fcb2556187f7127d8ccb95574b0dcbca228a6271c4ed2639ea069ae35bddb8b684bfd1088c08cf48e7b2537b7775d2dde5032315b5d06a1b6b22c4766b521142276e03f08393affbe55aa7e0503bd5f3982349d3d9335945d3474e52d88d398bc557efcce2fd299af9aa7c1b7dc5fff36cb34a7a691a1e2adf4fbb0eeddb7266254e3ceb0891b5f658c56a6d70347caac016e25fc5229a3ad884fa8bba88d55c3831d226fa78d47a0102b183a3ef0f9d45e8dd11ab6184b78a2940f149d1ebeda4d8e2957043d01c0dbd6088245e471df7aa40dbc3fa579a08a8ef3778d53b0bf47700d01346fa7261a0891381810790976c7bcee71f6e881ef00e58605c1932935029964eab4e06d250ba75db2a2f2a7912ccb27ec9cbba968b6226d03b453594b4dd099ff8c271df6d8a3d05c471d446c21f00ef433368c90f62ec195a9f5102cbfc1506ee6c82bd4db5534ac07b062dbb0257b75d61a5a6561ced7eb23a08010a44f0e3f6e1d04121878ad30ae6ce3bf7e2be56aeb107f0129b2bfd428993f13cd1a6bc9bbefdb6797b5a85c099ccb59013034f13015c3e043b75c251b92f91eed9354736d0449cf867b6959dc4b0a7184289875706c13c857f1c57eff6b836ffe9e9c2f19f040a23092c475a9c280784759e377fbc69f5e43afa14f6645a99d4ce786aae799432a2fb1baea1560d34a87e7c4f3501db72de5780b3408c9e2e4b6149407070355fcab2eb901a1f5964dde103955eff80609dcd9d5305541b32c37e579b51aa0e7f73de98035858215e1f7cc86b4e8a31256e80c86a939def8cffe820a5310b76e8a5b2f8a61a20427d9d5e43e1d74d73de59e6c09f99f7ae20e96eed95de670e182eb62487f4a3c40536cb458e8a336fba6f97ff4aa5dd02c14e37ab92ad2240724e8b976e76135b4bb1df35e8c7a815d6420a320f5b771bdd402c32924a0bc9ca9382014fe245e9a3c451f886f01dc8a05cf1f71b0fd5dc62b5dd81f0655ec55b27bbe9fbe377b72a43a12606c713b2ff7b10814d71e9a304dc597759ef66f8e3a839104f8f4f911b3d2d6bba46faa35ae724a705f9398b98c69185564593aa01f559cbcbc027ea319d156fcd1e9a97f8c4f40d4a5b09380c4a99b7ec55c54e52c1669ae1c4efbe94a89c8f743a20d50113940fb32eb4208157151812628108c3ef9852dead4370543d80362f78abc97be7f51b9e0b4840272ca4530a6869afb5f21d2667e65152090ec1e467ae58fc333b7b4b7cf379cf67924a4eb8fb53ba4f935c6f7a9088073eb86a8409c40913b3b82e7f50eac23261a90a20437982f53580f82f4291068b5d4b6dead91962a15b0e0975a40ac3e300bd5f4fc82c11c49610a1cddca4525d99d7e6f83128268c0ad0fe295980ffb114bd526d827a49880981fa90100bc6b45e5fc1350dce28209bcaff4dae11cbce54a4968447be3623109446c058d62869b3f42ce38900fdff0053fbcbbcac5b7d46cc586da95c0276796777f3dab83e7ec5ac6eaa455b920c40c8e2129e66901daa7276385c148a2a30164860710d672a715a7d38af12558968e09ba57a846faf991a713644d548eb1c593bf793cc5a5e0d4f87bdaae5e7f56d60086edf0e4938911c9d14bfce5df4fe7562f81c827eec32414095b653183605e792b625400ee5860636bdb6f298a738c604d7d5876221f864f480fb092fb0f5e8cac2fb11f98074ff23b83a9dd94fc064fddd3cc633b380f74d3fa60af9a54953e26b4088f19cb207c9d80ddecad72c521bebeb0d56fa32445060f62aa57c6fbf2baaae69414bfa9c68b2b1752a551473c31816553921a54bd44fc36f7443786be83877d96b372d4fd3094e130dac9b800ea74070f99da58231f58ac94f79fc6fe0850d9e5ed052035e616a7d53e1afe4b7d7cefb187b972a89612e6605e27e6676b39a1d08b50fb627a1b71a786317a7dfa9f2f48003ccee12a850c15630961d165d29193eb0723fc6434fb0421ff82eb8889bcdd536c61d2c997db646ab26550b5bd18badee38032338a3a60818c385a88c93de83e2c722fe9301fe93f98a3bf4054645d2a34803de141f383d7aaedf04583b8e0581d1a0ffbfe0d8205f04e355b5dcee489a2696c00277526302e2f31f6578844760bdd0451278849529f92fe375f890439331f28b448c7326a8f53e475fd7e1768e98e26df83744758a27c79ac4032e2450b476a6c9c076180dcf8fd49a9fb29f04e9a8c4737bbde0a438f4adbc46fc87ca2dc94ad83511ae02822a23067707addc564063ad13ba24c06bd24df0d0716ec9b30253bd6296ba2f7f87f31c5989d2011d48bc9ea3c517fc56b2583681a1cdf7adb6ae0dcc4ef0646b6f2fa32700f33f9b64a547c0f31b37421e333c84a8683affcb1e7028eeb80876bd34f4fb37ed7c5769ef100aaf138cbffc1710b4c15c3fdad4dc3b84da4acd248cfd797350c6b064ddb1795d4ad7adc551926506438b7bf910ca4a61a2d306c6a943b6466c05e2d772c16ae4f6b0cd0a270e067276140c3c709f6f791b2892c7b332376298d4aea9ed7f85b0d13487a024fa4f14a1229f15e0debe89ba89d5a6b5eac5389258dd2a72d95c59ef9c575e3f5bbfcdfbf7fc0740a9c02deeb97ecc2ed717a25bd6a575239dd266880d9409078aeba5e04ddab882411913ad71eff670a2530d0011b73cf2933e86621c9af91c64f9b4cf3bc523fa0c405582e5082c6520547b63a098d3c1b2ed46b8169839188a8305c67bfdec2298cd5c036c25f5081272dc48adcd28e42a2c26859554fd2dba01cd4ba03dd48ff0ad1f25b1ba77b0d03407236e3b06edfe058b55c2b77ff7b058bccaf14150c1c2a2eb985984c0480c57bb07c8dc714c18949dc234c03df463459569c9a94a1329def5ba2c8f00eba90dc6a25d475d59b00f82cdeeddbb80d5b181066c2b9638c58d878b6f8b2bf58b2b952bea1852cee145c98fa31fe772eaf87f47276cae485cc9e431800968d5fac1ef1b5365fa57ab5f569b6c83ade67dc7bb5a92393cd6f4939b0a7dbeeaf43f99274c42dbaa48f0b1ab54dfa7546609a220530e2cf41ab0cd9812c3c71830c3c14df6b8a28ab11cf82eb7da6dd713ae726757a00675284c58b54f1def77c0ca663d7246ca8464679f81bd9a4c4a20ea5808965463292fe33187448912140a4f0a2a863deedf00c50e6c2baf04650d43c1ab09dde26daffa72dca4590fea7da9fbb73acd66dc083bde2dcd7d72e975aeff461870f72d5d54a984d71038955590cd4b0dc303e2844a5fb2b75973a7b630625ebe3fb5b9fcd9e1990ffc7d610db818f32a2241d3dd961c83b869404e621eee9ddcb71def2981c1e68f64766e90719fd3d9de90a2b15e2dcc68b5b25899d30b94bd62ed47d901060a7852ed3c79d25d9b2031623cea2f0b8dca1cfe7fc688f331c21cbd3e403048bd936a78b79784d24a910d79efba4077dcd816872fe1b166c68d6016f1dce0dbcb80bd6c9b530a9d0e46dd4d876334c6417d83b8c3dc9da08ea26694f91c62c71bf88383698cada7f5c74f01543e92d975bd7ee3b6ef56835c4e4b0f16f0646cdff8abaa6c71be82c5747a0b1e906643a50237112f15ceafd26ff3cad6b67441a52ed4ad6194eaa87503c6d6dc17df8e0e9994f4decc85d125656b4ada3cc167acd3a128c2729e419fcfd64d71ebcef3f791fc6010113734a965b57c8ada6fae40d1c4bdd3f5dcee56b1352c734179bc18fe23adf556bcc3378918cab953ae81348d2a41038c768d2254c3bc570ad658634211a90bf42658e9d325713b82e51751f5b1b01394e1cdb720b89cf0ae55740a79c2c18c55e329d3646a053e0cf293cf2a2063c751551821da75d7434cc833776c5c868c8760eebfa46d67b6dfc75d3f5b5c54088eb35539e33d6f7a060eac70a7f9cd7d4807cfbf3ccf6be07c5e1f0607e23a3b1c2fd56602cf97b6ad758eeee3450ca785ad9e33279f2c90ef2f74421d73635b4ec7115dfd20c8718d8d2182db9a31e1977603b956a74f1dfc47dda83704d53bcd92e7dd6c385be412460731bce761ae0b3c9d1a61824b878cf8383c53383b705f539c2abe5af03a1f1e10997a324a58d79209f34af9a7c9a924a6deb74010c5fca4c4b0fa793b0960e42b82219c36e40a17f9372b99ccbdf48984338b187b8f1476bbd5f8659ed769fd3df891824a6a87625bcb1b41744779b9a8d787adbac0adbe3bcb5857123cccefd1deb7c5959b475200bafb8e83c7c5148660228a472991c7910345919b0b9490a133174d42ce43dd74c4e4cdb4ef1cf452349189c46ce33730a93ae5cee13377922fba53b4cc3650c1bce153e24cb32cc45c1951aa37f6203cb78680b705f1d66183b46c8cf0bd31ff2b5c53e5525501c55d3ec32db9fe363f7f76d0ae4babd0c47d3983e74f72f411bf466220b0768e86243c3f066853d211b0af94256b5d844b4631a75eb6836a869164c9f46e0337e7ea678cd2d1f512f4092f65bbc07ea53cd9546cedfb155d2ca9ee8bcb5f91027157e2705bcecb1e39ef732153dbc2e8f7f9bd902d26124e27631c7cf85ce34bb42039e3c708c0d9109966a45476fa5ad340ffc12dc14491514f1599b2cea07333dc09579b1245e7031dab3520d1497eb7930bbdf99eb6e04a91a069688b21b28e51a4bc934fb45827106144d35b165d8e637385f80c7849b68e5871ba3df66a0288faaede318fe4dc13493cc8a371184279c31d995fde478dce40c8f739eb11c095bb83ca64f3a966f599f1a6e11cd5911f04650bd90910214395c0da55173b7fe0cf594e77057054b72b55aafcc11a9575d64a7c7bcb8df538ecc704a5024bbb0703ac1ec5225318f3e84e12d6fe57fd766aa2381e7667954f8b93a5f63551253eff0277700eacf0326f565c4cf87a63bdc16bd95577271145023d21e68c04fc2124a6a0971922a460f1e773cbf6775b75d1afa99741da1f1ce38d7e646e4b4b1e8f776199db6cb703d1972e3de8d25125f8c0d87109f82185b7bd39c4cfa5b6ab73a3b46fc82328ba48eed16237ef3a63a05e8f4c5d5d942fe9cc7c03456e29c60f0c869c9057af7711a67f9c2ab94179a7713c1c19023cfcab500ecdb769ce3d2828d112d9b7b562fd9a121cb0415215839a0e58634b42a62a5723a01a74701644720b7b96aa56e8e57d4ba907f0555ca34be78e315424418747adfa0a4796e88ba108399f53f6cbc83e99b01ec50a14b5f07e7d38aadf9677b059dd9be1d12496654b0ba687ce0451553bec270840e69b9dbcd81b85050f665bc3f0f9a082415d8bd7a759c733c74bc7b90b9b4d293c1fe6c445574a7a19bb1b646bcb93c37603cf667b05e4bf29bec381e52094f24830d27d798374703097faea88401bb109f53dfeef910a96e4892c370bac40c1c7885daf0cd3195e595e33bdb4023940baa81b7000ea95fd6111cc1066db4210983c99024a188e5bb98fa5ab1c9ac9a974a3456f9f1e0587deccb6497713841faed14f0155c8a7af4ba148116770dfa5bc7a0a87d335e25b20b38c941b897221f2fcaff2f8a948298b02003fbee5d7bdf3efde02cb408e7308bcefafb119b1188a520794c0ce257b55b035ebc03cb40ced11f7ac7951f5ff643b1d8361161c40aeefe877dfda4acfec7864151f3f18990baeaff4c97fb4e3968a8d81829ef207207936fead5a30ef4100af299d9b1f8bae378d95a54a207e15279e35586de555df8c6fdf4466983a375c638650fcfa682c62ce84fe3e58248b6f7d320bf5728ece478828f6beaffbb0d955a485e7a673e121bf0f75b834b5c0095407b6d586ce3b811650bf635bfad1e6cd6cdcef019852cd428a0dadf67f5e70291a590f427b8faaf37f3ba0934e52c4e75d9b65cc9a988a50b85f1ff245d5e0f7d6827e20b28b3da4be44335b98ff0e452a61ea79def7d6f2b14543657f5d1d33fc51e68c1ba49278de3b9710eb0e68987c3661bf057847596d919384a74979602e8789a8f46815ed14089b5a61a6d16dc4e79a0c447f32426509d1d7f490840faa84d86a9a667473db2ff2df89f56ac4abff7161d7677c1887c872c68fb503266298b98d8a9463058e4542c6a6a99d068ed3c17668f36a3b95c44320597dfde99df094f1f41507a3e0d2fe2a9fd4e39018f3992149eca4fe23472bfd5ff8c7a9610cc792eaeec245170e34b985b8e5d12e3f995f444af9f08dcb499d4ae0d07c158bdecc9500b69c2878ae6956f4d50ee80fa943cd631e8add63b7b79e539c847e68bdb20d47bd2180241a6be4030b91520b9df9ac99724f32f3baad95558e1b325de6510021ae1c89ca5ba327047fcee87bade79167f0fcd67147590ae4d352f00c76c697d1203eda5b411ce2456c0835ec337c725aade816206e9695a34c9bd6871305a61e06a01071b657c2a360ec3b8f88751223d806d99dc2cd121ca3979431ac9e7a9f4891ed011808500d88c2d2b3715a8322f85a7aec4d207896bf9eac049b6c4e70d1a6f3bf298ae0549e3db6e79af5c98d30012a6b6da01f363373756568727da7d6f6b67bab3f16373b5d4a96a010ea1d94e307d6e6c3eb0cb8cc0f5ce0776e878d0f5db43af432635ef2eedd53310b6ca2b2f2c2ce7b3c27003230c5b73ec83de94816ff210fb31c77eba9e49be4ce12981111e66ea48997f9b4c07e7b698b4202516d7ca5d89161cad9bf060a1dafd675adce97f915de43b9e309b8f22f975a623debbf69da34e792b78f8fcffeceb81ce587c68828b2d6bae3e2e062d8a6fa465d01beba88c5b73ac41d900829cceb18819bb71f2c83c7ae3e148c4878eb916ca01b26417e945e62b6c23065dee47d95adfaaad22ef852eea6ca797b386c080ab0cdbce6870528aebcb90bbb1ae0f832b8bb9916c7f3897caa10a4c3e59b399ad1890efccdc2644a07efddbca67b6ad2055faa5146aa50a873aee215e2dd6e9ff50cd43e16c04bf193ed414ee31c05635b85ca9083d4aba79917833577e3d228783d296d59188a24a53dfb32790622cda847754d88c30b954dd51eec9bb524fe759c689af6495ec3b40e0b08f537ad72ccc795c0863af5fb6ba9789466da618ae592c35239867c6b2c446e6a41f9d2ed8104c3cc895264885bad083f65137dd706029c7032286d5a49b5b7f12de1f8b84cc622dc9816aed5958ccd76cbc4f87d013edb1572398e74a24623fbec178816c2fd2a79c5a6df03e5c0027ba8284bfe232ddc9395a5031d3ea41dbec7a2fe697e52ff2749146005f9a65f9181260244eb658badd6bf77f8ee534ed3f084c573bef7d031e00aceb2f88530a6c51a9431b966abe334085a882e41a750b5d178b44f0703f31871205088c223192e2f365226d6d8cd79a8e087695f39874e74f56644eba6c077f056a2cbefc51002b8e7563dad17c64f2f1f70a783350caf840d7d41885d07fce65abe44e8ae20721853b74c2032c2961cf338b0fdfb8895ac24c938dcef0daf01a3da2e14c9d0a5275dab94e91e91b25107edae662acb1807927fb63ac4d24c00065e1b311ac61711704c4949056bd182c7d5675be4c3d0b37736e5f6b7bc1a94d4d3680b22ea832b4662b3121c13c72d86761ba196376ed2a3ebc59b8dd074870774d2c00856a6f02f8f5a81af645d5b3b34f7b96382e33fa69c8a76a5ff8f8f7122b3571f049012da02f26563378cfe0a1130061d6e7fd841cf213f53e27a84204b5a0fca640403808f1ca71a3433b00818e8e19432b8e7faafe04ba769eb48f16f13d0578c1ebd23e6e009fd0604fe807507b68d7ede7efb5f0edb08626c5299f60afeec08242da3d8e63050db35af30d3c2411933565c4f1cb8c323171e12ee5518acea38c5c3648474564dd25c3ab91497b41c176811d498ae1ed03ceb90179c9e7b8874e48450229ce5f558f89a2986a006fe9c088484667a19746e0a3b149a7114ef81b9edfe1df1015517e4c30efd2ed0ac5ce235ebec554abb16e23e0ae1ad17342cb2bebe6de897efbecdd354f90fb84b276e72d5407eeb5b075f9e73528663aeff665e568619e4bb7a136a6e56cf39e714280cd904b34f41e624469878a726659dfc115cebed24efc2610e1fc0ebb0dfe7995d2aa370ab58cfc1547c6e8adada762f368098e936715a8f70dd831b684514f2ae206f0cf6ce60250a05fd7e4e62820ab015e948ed5da94c58365a83c896ffed881ebc02058f5ca47acd0716bbcd3bc8272610994f069ec915fc449faa41ef4f04e50e4a27f149e1c8c5d8fdb5b166c25758b832c778844b5e6bbe0d6ff787f3de6792198fea0ec97eda52bfb6820c43e15ecc9a8731916c4ca8c688bab81f99701f3131a987aad101677256de74c851990136118632aba9e163bb24024ae28731ada2dfc8f466060b0441f50e7062465f96b51ed5a749bf39936ced4a62580591462e5cadac6cd04ad7e65894a37851eb2d45eb42ad91d070045664cd59a577fe52fd3ea2c28a762e5a18d58da0ae60ff2447b0d199bdd5de8b45e24719d8443cc70aed59fa86c117233ae8c69b9cbfa71aeab6771bfafd3b0ebc23e3adc524b4cfcb814cb3575688fa43afd56eb09d1e4e9b9c0a25fca1cd8c03482aa25b60a1788f849c879ec4412d5d986d5116e886a9c3dacd136643d28f64e9b208157726d7e541d47026db09a2b39b4c09b5053111209bc52895a78b72eec8872865879905997806a73e652b4e78e1e124c2212e1355261fa190d7b13b54cfa23e29687a681252f3348a3b9d96c67cf410889eae5fb7648f69b75630b633ea9f7b9141d17c98bd007cff15c35e03554f1439d670bc1a448cad6323aee8f59de05b3dd82a86d2e881091e3254d18b76ff7f2cd7b257e7ea8620709e03f7989fccf69f04ff39768cf5b102168e589546d9e28bc0204f107dd6b5ec5be856280ecdb39a2d9d1577639af6405933c855370853089bfe8830489612e361078a1d081818d9a9e702ef831fdd173e0f3ed885770d3f8136cf8ac0abd259766c8e1b519d84eec88490cf7c3af40a23f4d5180afef34f634fea9aff5336d68e2d71797ee62ca404cee80a12cd655128b015db3314008b6583ba138bddb2c8b82bb65d6beabc5ece53f8944eaccafa8e443efbfd18fdfa17066a1be6551dc6b6d8ccd77cbb4aa6e71e619b4c9a7ef815d2c6a10f526f2c3bf0fc7717933f2c0061bf68581152e437d8d75d94eede5f97e13a5bf1cd098ef807ba862b3721f667148f5294762fcfefa065d3b81e44a0c28aa8fbce60485b0ad6f3cac18c4d76edc016502951ef43648062608637cb6806e74e1e89b0af62c8af42379ec7b170406c1b0b5b6535e89dbc156d4df2a6a4af6cf67baba609f72881bbb2b80d9b035d9fce742a5179e088488462432bea1d78a680b560c5e48fcff33898637af1463dec165a4113f1d1cd6cf6fdc7b4947323b4abe6215418a60ba59397c523ebe9e2d0d9e51efad77053f75a2aee39f9fdbe0bb4cb2663b63b12dfcf74eba488698b701c0d4585d682acb6f3cf4fa94a8424bf347ee85d5883ed51d6a5d8b3729d03a579acbcbe402abb5476eb6bc424d363cfb21af5488457f0a07ff10627e2ce297da8775dcc64ee140c7b0d1b53e7b806821509bbd97e70ff60c9e15e8c0509df5d39e74e727cac60d367418de3e218a44607abde7f40400621ecd45fb254a493d1768f43a81b318e00d67f3301590045c3d6ebd2a3ff2dd599a655af8c93ce3564638779acb597f6e7ebb51fc0112b71e511d7d0cc4a46d66dcfdb335a71deaf863ed8c3feef8cf6df2d7e568e73679974378e15973b3931967d4f28cf3eed4aa44a7be1922b3e0247c61b18338bf9d7365a6e78812d1e315ade51b5d6c5a5c26d46ab2cb16cf4b9571d23d7d313a191ce19998d22750f459ec75630ddc52f15efccf2f179310c71c8d5db19ae638f03bbe5422e45ba417b75192f65e94eac6425feb1ae301b6a1ff31f02197f3b665e4be5d9c71841fa5853c729f7f9b4858ee5c68f4475e1d8361b7eee81400d02edbf5dcd2d8c7d0de5e9d0d12ade1072f378f97f2aa358dc0e2cf8d6797c9ace397bddcb002343813184377d2da081e8a258bc2037d015d1117ac4bea70b82f2af8c5d0ad8c230b1f5a2025ff41ba2c1492e1f582ca845ec5d0cd14e18707241d8141339dc66402fd432d801d9627099d96e0b69e8f0c65aefc1059d5f10a9f56a26d1c9353c957af512fd8bafe30063fd0f23b952ff22f9ecfc77157ba7ab0e99827565d6c1aef776298e8e56c5491016507c7cb713ed9e35631f0d4bd3bd8bb6604fc297e7a990d7c6347021b21bba932197e08cc179dc51f6ad372b0d3631e5e3b78d68e0764cc9614855c55a32291a3b1188c6d604a222880477e08a6a457c085d32b4ee6ade0c60345b89f674a6112de57205a4c2b93f3cd0173e9d4dc14c029049c7456ab72215a1b42af757ad317f4535586989ff4fd0a7cef5daee8c66f249735479ff7286dd7456723d1927b000c8f01fd9560ac87dfc107368fb7987b43225be48d9ad8e4b40525309a47e307f500cbfd7e2a3017e3d345438c5b252ad00f937085a0eb61dcebd7f69df67b18125315629f25511d1289a3435a65befe959072704d30ed4b8bc5dfa2e0c459bb2b7e6c411ac9d295eae3b5e589e546f3bbf2f919de5bf3fb9e5814ed29ce24141cdb58a5abc8909b61f5ea53ee41d203f7085e947324f6bd986195d8ba2c3a4daf3124566993982b66f0f86a06dc288a20ba20fc2997d08513fda6dfdc481775b71a6c4206e5aa1cf20a5acfbea3cae5e260e779c12038a207e2cbc1a665f3645245173b97a4cee4f4b42294bc814df9b05d6ffc7195552cb073433024eacaaff8e520a3a5d4e4efa4a33108f4a8fec4bca492ab13528653bcfad6a54723cbb8214f39ca47854459bd9832c0491dac38cfdaf97237d3189a5f3c13a6001c53caa7d21c26e79b97c464d6d735a2cdc791bba12664b4cf1b43656b792162b64d8416521dd632cd74b3bd4e336d5260673e07fe8c199c0a3b7355c9dd137c4ccf3468fb964bea47e03c1c0d240e6c2b7bcc435887ae231bfdbe07ce402ea7308fd5a11341de2d16463a3375804183e3bdb1a404ebfe354d3cf965be7028cb332488e81aa16d600177244c5c9c84721ba13c43ed5c2c1eecba79835525650ea0aac2b26559892e3884a68fe7a8cd3fc7f71cb7bf5b3be9cbf7c32c0a05435f50ba69053082088fe46ee691ed9f616ad1c83bad580f20759472562ad3bdca669c638ef97564cb504a34637e34902f6aa410780f42bf2423e13223b07516954bfa5e8d2f61106fd4677b2369b87006965145f5a2af8e75ad1614aa908c2349e9292cae244bf0f9805b50afd8a9256c7c55648e69b350d1cbe132b1391c8acb733548a306669c81e4f8ac3b7f4b29edcf56e007f2f9c92f356051bbafa38f4f9c6462fd74b040db5a9ea3dd408231c410d9ad9ec476cb75147ed3c7e7d6a527c166b00e5c66e81a9277b996472df35f7b3afd2a7d6b5038e84b9c75fd82022b35d211b0d8c646824a0745b58d6f597926ce0af21a59e95202b0a993d0c8797a510a33d425836cd2bbb75b46516c1cca543b44ae0c23a11ccf5a4e8dd8ecf289299af19e62f0b58692429a48d690649e741cdfc8bcdaf5af9efef1a157acebd79cfc3f13b1060a79d439013852035fbd57828aa87472d016b577e4598ad40893cbc3706a21e5ce14b6cf56b9dff60137108afa0400f94452400df5dd76fb86577fb99d50d897528d2c8e1377e4398b9fc6a91a9b7cc8be36ce60f78f952fa17cb7f6bab77f871db1ef41bacdcf9710cde8e0a3a7e89469a7597bea5c3d273408cdcc7b0d2bf65b2d687c57ca118f2ebdc8a3834afaa03518558fd9a0bd1f8e4f32293568de0ca616184ef739e5b7014677d32c271eece72f816be3b33352ebeb35d608fd514e8db7cc1bde932a3344aa87d10ea1d65bf6495f9c395b8fc7539ff11e86cafa91cf87e7e5621f87001434cd3518bf869b8112f49cee2146b910e7c6350b05fd55ee1f8f67ea000d71f711e92e8aa96e7d0f30b12b142f951277da21255feca047ce202f047657b98263e4b43c3b9c416bba405ed78a2ea4295b5a24020bc9d68b0aac228f117b8add9ee322757f80ecf6d5ab47b921698258c59399ec891d5d1993274b884b32b34615996f7d4f6e7b45948319b80cbef038f94b5845328ebbc24ea9e9ca2bd931c743250d74db0b1ba5c1dc3376010c8f08b21e207d782cd97762718c82dba4d28bd8c9f2f6cb222ed0802a9621353eb06345ac1a6f1356063448939edb6c52244ceeb54d23eb74ff574e3518b4356057a30fbb6014267b2e21c1f442409f7a38792e670d714f77dadc2e66c6100a27a13e4fd132d3e042affa07df5a7e422094e668c946552facc51740262c98638e4aa5f07b8b0d3372c0cddf7a9e2544b2d4c08168967541ea08b45e92313282a7837618ef6701468dd26241634c0313526c01c78f0c5aa89643140631f3a82be8caa1e9bddfced153fbaa5eaf5ede1d7c8c01d67721e5e54c8942b1ad64f6613deea2e7f81bb1e0e9064f79120b81500dedeba9c4f0f268738d02c6f437d9b3888e4d24aaeb0db87aa1012f140f47182155f280cb437c37fc1cadd146582def18f027b297066ec85539f3297aba14b05361ae04809063c5da38f429db812360327cd7723e0b21ae98cfb74397483586dae7a5cd961bf6a9e7139c8de0c5d0b8e0986f092b14eff34d304f162e041aff6b989f12cd0ac756120f8a046c859f73bf4be59040b694d79e0f6b0305305c0849ca8bfbce4851add3352d6b19afa7e7843d7f5043fe9ec5ac10da4313f6ec835672b105ff8ab47c4e6e11d342b3e6c5eb5966366d9462f9c8566cb5dee15648a60857e0d2bc83e2e009c3fd20695bad71f1dc873205c8d5fdf6d3dab84f68c04256688cd0cedf75deacbe2e05cb96334ee688a1158ecd44003fd5e8f67668bc0dfa200ce30f49e5581209cae973df3ffdfd05201fed36cc7b106fff25cc119fba341e51d9191445b4491b35949b43f345b242b80db3241f23ec8f7e49654e7666dd3b58db57124ac0588ef99c33ed1454fed79af1d0abc97d331088ccd61c041b3edb4f890c05444f5da0fbe55c5d7fac7c51d957b644fdfbe45ed48970bd6d5e2fc14bf79c41b273ad3692f8dc07b8e9a18cf60e82bcb4d8fb522d0f68d5f696ddbc1ad8811eab01cadf0ceac7fa64a6f52fbb9820809351d95f99ab525511bca6eb406b8adef33019c1a03c6bdf4ce25184fd1575468ef863ec5d6e163edb9f6929424f2728e84743a2c8570b96c6baa3b554c9abdfb1d54d6202341c7086c47c3a5d7aaeaef635492f5e1aac47dbcf5842e8a15b54f2bd2eabbba6ce02850902f3a94efe02fbeb5bf48e2ade87264240abaf706213d5b9a3e1db542947acafcd918a5fab8e16e5dc680a51e7fac364b4bebfc07f1a15579b47f3fc2027c40ace17f4e61911d9847dfdf34561135c6f02efc5d0c454cc00111587131f71c6c5704a0e43dfec2c73f3341925f3fc0d9024bf2ccc191aee2a54b9fe9877d8d106344ae36513026c1ea69745081cbf30efd348c6149e566cd1e934f8f00a7fa69bedda2a676a619c9fc45b9fb1cfc137b2fbebb942d9f52e2e7ee9afd5d9c0b390b8b886fef7b5b661a5e00a07a5d4c781a9be236397b81765d886cc3beda51bd7baebfb78ee8c27256ae3f59a16d69c2a720e880711a33d15bb6c6fdd8e77d62610aed1ca5488c0a3159bbdee69a14aebfc98e3e7085d1773eb7dbc251a4d3385f47f46ec4e2ec15e6a6b2471c1976e717efcb31fccde2830a5b957c4737974e22f1da1659c95d4d1244e47e4a0a2ec5bddec8dcb2893516681cf83654332ef792184458c249aa119cecc6582b6fd95facd9a12132ae4bcdba017f31d01703aa9e1feaa20c8aef29035f84fa964df1a824190758f9484281f2c76ba27e6be5ef44c0f848f761328d44672047d0cd70f32aca8e5b17fe2cd1380ba2a646bb5144db1326b49929a5c8e7f10bfaaccc7757de47ec704e05c6e990c2e23e391749f502d8c9ddb5c767e3b742907be14eacb812ae5b228c58a680b709f9445beed0753cc7070d2ea41c38241fcaa46c1713c38d7c89c73c147c9d9e53c058ca306dd72d3e028790b783c964588a46f0a9c9ddae6c1923eaa7f954632bad60a011b3dbf999dcec9b380cb24cae09f4fcafe791f39d55349dc7ec3a740a7f055e3ce9b6a1784aebb3065ef9eb2502368f5b6d4d7c4367c69f833d69b109ce286b3f6847edb26edfafd22fa2ad8f53f77276211e0852ac21ce2fa9412b3bfd4a5eb928d0660c4c44359d890e0f2bd4381fe8e3ad879ebce400b85b247a830715b6e57170308808493abe5d056b336df02a99254aac511ac5336aac7ffeafbfcbe5650d109354d016556bbda1e51cbeff58f5d9272c41693dac303650763fb03e810fc8890717b35e3b9d17724da081da6ec2d9b3fffce48e639f47bec2e7508d06f17781d69871470c369977b8aa689b7cd59013585827a8b52c8a8f7b2b08e26f66767054f65d197f60e5150a67f985431ff021fb27e99984d39102d2be6c3dc154c6cef13c82441af5f2e524b25735280ba0535305b3bd8c4286f64ad6a91ee4fa57c4a78d56e7488dc344810677d880754b95dc4cb7f6bb12479ee0a9bcd9a054a339aee2bd72fc859680fa661342d9880f8dfb21a8c455592a7dc2e1bb8dc4a4bb767f5c5a536aa0916a8fe4254f0b0ac40b060298797a0f9391fd5edbd9e0316bafe703135dc312aa9f2c68d00c85920551c46ee553606ea44a3defa2a2e10c05f8bd2f69651083d48b9bb50083463c7dc7be9dcf9909f67a4b0cbb3cf0141488f834b856bd1566e92a13a3f2a861bfe35a448b89efb419de42ca1d15ac74c9a756f052fa947a4fb2acc99b59f05e52cf0362d4c1d56825d749e2c4444db78716833aa8c3e4546a5b8b23c8d32ec5bd600d040233c25a5aec4c537feaaf5c87760a031cfbe97c9f11258bc4b9c578567552844b6288ad6db0fcda976ebc4f452f3dcfce095d16a60f66d7ffc65987dded2fb8d8d22d7f5372169158be61ea9c108c7d2c5db0716436ed7f6d081619db527bb83a422ee511ac06dda7fbc522afbc073b852528528853379b47db4e7cb9b077304240a8bb083810ff6471985164783a24ef1b822e2102ab597443b704e1fe1a83d1c9bf778e108701b26651948582d928412a8c3bc11f93aafd8b90f22c0343cc4146288b37a26559683191305d485281a522c9b4d24fba42703738edb35a9915d069cc5d6a50a342c0b1124bb59c1cd43468e7408ef75c09be651264cd5374631e26d2d83c8387efe5a19eccd96ab9e17264b7965b9ebd4672661a156f6cb2e1910dd432085d701cdbd2e41966ab3ef05d63d652c60dda15fdb2e424e7078d23100b9bcbb7cbf886e01bc5823d6b87b645a6e79080c2c12729d74b97375bbea233e3ebe28944944c2aff3d915f20c039b12e91ef0b999c6f01b9ec674dd014d717b92ab4d87a687a8747142c240ea81c2e58858905635eb276364265d269717a831aeb289415536bff3bc80b15bda9990b1faa6f0a03c8420958a295618b8404eb3c7bf6d041052aa239b9bc731345769d970259487cf4356bfd3dad48b1cef1fd1f7c304a92a3f81d852bd67a38c1de127986784706d69e3b5d67d145da2ca0b53579552e82e1bba18fb0d12207328dce7d2031a7d9917109e60af09f1c92038ae99b62c60f83ddd3e11816dd64d03fa378bb58ca80189e03842878333b0d1934af503db65a4b45283816cb876c39629ffa9f93ce76bcdd24865b21143b05622c4c007fa144d1c34a50a239fd9bc3f128508cfe3ecd4e3abffbf48143b31a557b264616121fbb4dc90bfe118cf9aa43bf4a5203c52754c96e7044642018d6fb2d113000b799b258dd9b2c1f01be727189cd4b28a5861deb522d11a8eb35e7e8ea79e78e63b3f8f28a33ec66a15645c5e5f753a32ca2e5fb9b9f6db719939d2aae89a89451c772a3287361b0dc654ce03c4bb80cf9eb111cc20e5a9ff8c51c96b7384c7633725a190723f3f545f9ebfa4a22ca896eb2a501cf9f382f7f321efe34aae73a2c20f540c2fec3267e436ef727be45f54ac269b6ce1097675681ddcb6b9ee4208e759066cb9fc532825e8c9bfb07c06c395c669f3b9cfba19f8a7cd013a87cb345658c16e25fbecea4e08ff2d94fd87552312f86ebeab31adc6a84e179fadfc2012dcfd6b409f6d5a68611a0424ef01f129f091a5636bbb1cd4c8021412efa904b2ad7f425cad44f39b94fa3fd1203c601aec4de9f12c84bc7525233438bd802c4faec50c49a0998687a47a6e96084e46cad94e4ab308d9be9f977a7a7f3412e74347cbb6546ffc76b3827e6ef59ec2c35e2ac084348812caa64c352ff8863270a120fcbf642d174ddd1b7eddc0a0b4d91cd62e3c9359b74b7c13a9a727c85a8b2ae3afc7c9bf2082ebdad07faaa0ce66c0f2cc1e8fd3c645119771ad8b747d13370f995f3516f71e29cc45e2c03faa40b257681444a5853d8b1e54bc55884ec0cbfd45a5f1a145928945643fe208190c22a4feb417e382a50b8b3bdd9747370123324f214b2b518efe5b924629b801e90c285358b5ac180916585c9cede056148c8f94353665ee41eb3c5d409ce66a42b3ab071606b412e78778ab63783d9b12bbaba26f4b8ede3ee8b4d21ce1d701a199f7be4058b38da7efbcd6ebd6858774b9348c0f405b97b511e69d13f1f9480959cf2b931acf9c3aacc5774a34780cd0e7fc362a029e7eb5b6298fdb50a96ef6dc966ff71e456680163e3095c55939485560bdb2ca3913ecc32b39c74ce41e1c526491877d0a05910c8961697ae5601973e7e707671d75d32abcab70a4d94425c22afce3ac681f5351970089bc0acd28f38e9881528bb552761e5124cfa352d26eaad9744502704c43df9309ed9a01228c5427a654d03ce9ef25af60a0476f100e95fbc7b96cc8d7f5ab9c080e9fc3d6fda7a30e50b2d44ed2e906cadcc62430bf7ce51619059d643461d5971433b3a4b33abc6d9fc65135e7a2c5fd9c37cc032792d57f619c488ebae8e23d2e2e2dcc2c83a15d808b25e693641e60f6bd9d4ac8e78adc58f025dcbf12ccdcc2ebd7cfb3ce04b0e39a8acb58cbb73f778e26d0a2bed1b182ebbc12ec25c808f6175a5319606d10586e8d4964bc6fae43873a29b600042cc3bffb4a5ed2479b7314422ed355974dd02b98bc4a6d7ce8a45f5296652e96f64db51cd84e55b8d8ecbe2be327ece4c2547f17021f2d6570892c1d306f6b26079b4dded42a973a01d5d6be226f400dde6097a3015dc39c5ba928ec77da14396de9d9994e189511a55583923c960be533853d234ea5815483c348af0a338060880a133293af26847105743cd01562e857b9389d6e13d76170000b674c4534647160d88078cdd3f85d9394a23a33a60d69f328827efdba798e2af610975dd8728ecd067e790838ae64e446f8ac77bba793ce76e1d1b475f42cb522712a6d96edec6f43c29080218e8e2dd5630ba777ac4da1a15924609569e4ddb945a60a740556d589538d89851448b14beb293b214db455c64bd9a981974923e0e19271358bac5460edff604e1f1c040c01db3de61ddf58661731d93b92e27d1b6f9f195fe04dc7e27ed53fa8375da141a4ece1a48895231395eca8e5a40e5c57e454795d117fbabe08a4dda148a5549e70fc9754d47bc5e3f86547f73a70e2082616f93aec267526048737e48a981be091ebadffb320649562f0fd9ad446dd9576424b3680ea13f55cd3ccc976065f259204a04da38ac083d48e44cd1eab2fce23dae2da92a0d6a7bd2b4035cd8d7d1de7e04cfc679b7794cf7f89ab733eb2427ac70466d123bafb3a02d53f242638ca0d7df1cf16d68616191a0cdee8f9f2545a4024ddefe2d011e840571b995584e5258a8a19012cfb266086d8037885b24b2b49e0518bd1c7b48a6fa91a56b48f7fe21756beb8792ec4527087b05cbd518d1c848886793c1692f301fdec8cf284d7e1283a0a97bb0c81b9d088d81d65bf44a8b949e983ed4f2ecf1b48271428898754d547bd33a1254d4cf9d0a934290b07fd90b4a2f62a9425ac76ffc21df8113ad913c68d85ac827af2ec4c205265eba9a6d0034f5801075aeb54a097d836bd32c8e09af6f473bea70dcbe394782c4fab9bb6506a60fc562d541216f0dad0be06a00a4bacf3e10161d7a96a6366e3fd11fb92de6a1e8ffc6677a14725f1b1c0130ba0980046aac42702aa8e5e7d4a5d39b948f05e5c41c1e3363dfd83e00bcbcd8a87413bad5da393fb2a702488aa54f69926d1896558652b8f1d5b6d6b38fed53ef738f70abd2930508aa82516083e302649b67c4ed28a2b1718ff9b7eb5769ee90d2480a007d6187f82ffa4d50ca96ed68b2b898605ab31cc7242851987faa10024c5147d143cf6f407e47a81f6b8b7a622a3c4802d83ad076882e667e447afcac9ef31f909701a07dac66884ac3b247d2596b671a4d98f7b4fa552e6d31e550a4bb91d803c9646827203311314868490c08750f16dae696652385ced9b3981b017a4f5f7401c854c6c8033634a4ebdf7ff8d396105737765078ce35b3b94bafa50a5de797430717a9d6ed89abed72ee202f184795c61d93cc16999ea411ccfd487017626ace3f09c477591c5814b597bac843d339992e2b7d38adeebfe31b043badd922ce376a37930fade2acd5ad3beaeb0cf5686e8b5f8ea6371155f77a328e04dd565afca272a184c938fa3e834a0700676f9d7c511c990201400d701ed467588d8d66f35823999ee167f202c0e0f096947164fd96631c2fe32e753f8c84af38c05df7643f854d9455fdebf13bd245aae9e87f7309230f275f9e44914b78f971d148bd8dae305da06ba7a13b4ba892113c6484afa14e35e4f43832ef9203684c1a2f9b0a8491cb108af1abc0c6a57ad47b2f24f19833146e3dfa44b52e4ede9fbae5808e525ce04f6b7151bb320254589f9ebb19a27e16566c4bc6633e87683d79171129fb1990fe3cf6082fff819a38b1ce88c985d11f6ba868904fa1e7c2e05297e9891e5c60a41befbccf12cc3d567f04fdf4895af6b622a74c80a07fc006a4f74ff1ac50a611524be76c7b320c5ff12a619f5f5ff633ffcedf004f432cde9d78f4e0cd5bc4d2ecaeb787e02734d04b4d0cbdc32898c9fe419aed916d51a2a4fcab28518e4a90a7bd7be1b277fe237741bef4468c827054d69adfec6c0a2570ef257ecccff9a62c39261f4fd2a7e1da1ec5ded41e0377346dca50d4a21f605195349fd67cd83a264b6ad8539ad36d0a99d2a9104817eb41ee2125b8d60a69d7f87dc0f01cf00ab53fea05d663d844fea237d1058d74d11f35ec67a2e19fb5d6040daf0938c3c4e3fb9ebb81924a9275b774446d45e739ea9eed3950fbd78fa96cb0c98c4f3e1b58a64aaeba492d0f435c21f19076d995049a42c845fd95e4ad333062b3740f222a9eb40efb0ebe97f6a9b4638dd30585967e35462df6dfdb49512768276892a2601410d8cf6b441a96e9b05ddfc6c1a3e50a3ab00d9966e76a9be5922bc042eb8faebf8a09abe2d3d2c6dcdda0d78a3ce2f6a2e408cb892700f35ba252d7d788ba6a93026278b58d710656bb51f35a5a36b6d8271532499fd4e11418c2e6db3a6d71c09c0600e56472a50a265a00dad0672b219cad647d64eb9197f0d9c57f15f923bd97f5358c21d7268c2e0cae4d42ca6ba5fae76ed43833c81f81d035c3a45f3a9984a852cd6fa3e9322d87132aa4c00175572031965ad88bb5ab6220552f2671661dbbcc87de043c6f5a6346c331882d43f3d63a13289add6586638b0b6476f67396869f1dc95463e280c32e22830a6570d922788d6bc564189efb49ff3947d43a401b13a77eac3eb7c4f0c4ea7db19206be40e417445473dab08eb84d991165a0b66c23f04ca2b02e2233ac5b95b1fbe9fada410cae727295bb5e8ff06a668465c12f78227ac31d222cff2cf2463864c072873adf7929201556b54992311203ded1818968409875b97b4bc68bc29ac65f877a8908e7081a52872d51cf7ffd5c42aa615639b0ab6624a43c8b940d356aff9d5926afae77d653524120b8ae4b4115b9f7b434bbb9a9a368344e64bc2c580dde9924287d1c72c4dffe815de11251a0b5097d5e97dd637960bf30969820e0d26c74e7294e1d0fe5d8c372f77dfc145e16de5a78aa0acfd340b3493263bbaf366e847f756a928699bb43e485e1f7315b43cd33623b5bfbd37e53e4c8b1e3da1baed7950753a3c99db6c21ae0a43cf499418f37b27e6741c398e792b754fdd4ffaf07e62719df371a528d511d04a2e53a5a5a542832fd6d22ec761809108e15b39607731db77dd7e1d99b1d8efe2265bb318f29eac13950aff96ad60e07ab34a8ae6fb7cae2f7aed34c491d03a6028e5b292d1f3be35ff969896e956321a38b75a0a2f61a49307401fa0a745e1d7d1ba4978c7cce668ac5d7da9dfe4477772421969869dbf22d7319be223a731024a4a056aa917fd6c4f0777b36658bee06fa39c91ba3c6bcea0192f73f89a2d6e03178aa04ced241905acf9fb49226b030c11d6f01433a047579156c3a50b89864c00b3fbebeb06ebddc222939d77ba0f36c92b3baae9d7561472bf0a3a43128f012b567383ff1515b3d33eac0bb3d4ab4f1be01f2abc16c06a03c940ffdb65a98775df0f45e0740fef7fe97601e9ec50dd67e94b023d4b9027e614a3fece077bed4bc7766364261c4fb8e0fb7ebd26dae0f087d5678912d6f94e9a349bfe24c19d230f9475d985c14a57bf0197fba020c1195d54a00d9614d30f03aa5add3a0c6165f3ab95b3374f3fa0286fb6c9fb3b16f4eeadcd130ecd2c9c6e127977baee812fc9b3b1e0d71ead40729f2b5a820c1a7e394f59e97fd1e42a2577b76d21f7dd00cf7d7e3dc0ac4de99d6f194a7672017a35456a7a07502a9df0f3166dd8bdfdf20a26873cfec53d2088753f8f9df86c478dea2284461d7878b96d2e85f3de119366de1c977aae3a7bdb335dbb2d5576ed70b4eedee4b16f982dedbaef60be2f17d7f926d2b74ddbf1043e90af0dcbf37c22f0014936648b9d4f34d64eecedfeba92e527bc6ffd1265fa01d8a8e71608841c11f8b7c493099229d09f815e0ef36911455e4dfaf2dd02d7f9e71c0772eacd6d379be9e4a3222f4f8dafbf05881ed68d65e2db95ecab5bed36e0c91d53ac20c4f086dc977c85b62d3904855da56fea08861bbb1e5162d0262c418410aa7b7b868b915848223bbe741e8122f71c92d33feb309e5359dbd8bf88c894d73eeeb7ac44256c3290d1b1d0772ca3262abd9319718013112b2db066e50626549028c7da6806666250e461d6bc3e1e00c1a0a7b9a8e004dd382f2e11b693dbfca8a88d6fb5de33e45a318722ee20d54f5a5dab8984d17678255051dbfbfb39899fd818d41ff0a0df94f6ddfa80a4e80cb04a070aa75680031771d01495024a9136d6d0c1f08b34e3f75dc452156d957603ad90897bf58073c5981e736d30f5d16c03233600956fbcd8a9e60b71c748f50be602b8efab71230daea993d14aae6adc1f7b5a0d2c48ea5de25a6e38555a51f8a43b11c8f00998682d2d06716db454be4b4d561b241821a3375ebab57aa46f8df1f9c84a11b182e3578e017d13e5c15c3ec10d333c12408ddf99abe2fcc9d5c07d0212e6e41e027bbd87a5c29ed4f94054dda4af921e31b06bb261bf33ba451a06a58864550bb93042abead39c6032fd8390871d66ede53c985a691d3ac76cf07eaedc9d552ac3279bd9809c5a7905588c0035456baa3e2b6081eeebdcb3af27309d85fffb25e485f69ecde7fcce7a726e1e689d9e5131cef547ff7b52ecb2729c34aa787794e5d7a97570f7e672e62845377a5767f9f1e53ebe36084668cdc9e0b0a154e67d7da8fbd90838137672b892dbecbeba4aaac692898f85b7dc194694ac1a8b77600026fd755530796a1229ef43956fa956233ff1294ccb6e83f9b7afe053e0e75dbc4cb452a3ed5a3613183a7d4f5eda85ff09a06bccb28bb2d3064b332266fcb67c2becdf6c46e36bd6c61a1ffc889f17595b75818c14daa4fcec867a6e04a2f4ebf9d035c41013a099c4ff7439415b607599c01426840f5209343b800ed68f52d958c55c6cce42e7c653cd7ead01faf0c26835d714cf0ba0f7e4f292f314cad3d1a5ddd0e9fc222259e9d48786f515f20306a9917dcc7e8d798eebaf20272b51b91da3c30ca449277ffe3cbe8b6461d6a0981c03f02f984f0cc7dc5a6384ed087399e25f384ffa04b7243603b1329b0a560fce30c5163d12c51a42c276f8cbd21139a5f24e49750616cb51272d5ec12c6e4e652abb408483b86e3e82e06f716a9f7312f94ccb995ee1aca5c83bc4d7edc9c895436144ab4be03fadeae042684f75c86699cdfbefeb5a157b975bb0c8c4e1817744f20dba89903765ce5804fdabef5fa08e92dd3105444a230220275e56f1d2de2906bac7151fa928a3d1476ab1c7c4e15f579fef58cdd8728f1fae130f38828435747bdfa8392ac775244ad2909934efaff0c40f0d3867aed8f1a07297b6cd2bff2809f8f9d5e4113d6d13cb88428078ec0cb8ef355b4975ac910d46f4aaebf577209005ceaff1f8a9807d3553bd5636585bb69cbd2602e08c7ea1b434a62f3de89d1988392af20a0d3156b108687e07aa27f88063bcbf1040e836333bb37d72d85550ddfb2c19b0cc0697f63b78684c8a2feb8ae7504b439b5cebd16040d434abdb9ca0ed87a3b5cfbac45eef8e00c767e0bef132ff198f0b2e9ed86fb21d685f599f0396defdd99dd829dff988c3cf0aa7a7172c5fe778af30104b18653f5936ce8fa0562e478da530ae087837117e6782088244b7f1a0799caee4e977762ba753e96f55200fe90d68406988344938c322828ef67d2bc53fc497195267a71d7f84f4f68b5c26fb7baa5572c9f07df9ce5126ccbed34cbacacc501c6eddb0e779fe9458b54b4630fbb87d84dfa40500e60e676e3b7fd7ebf7591ec692e545591ca923a1e1b73e1e6a182725061e01b6c751da4356b807be42a2de9a38c94356156903a80129348a4f8a6f4a0ff8fc2cad445f7791d1bb9117c57529a82ccdcdb6e73a9ba94c3b98ca6eb86b2ce876436b0715f7c28f26de2f2023f5417c6741b2985641ddc72f0011e8776915633b9e5938fc19b5825b7402fd779570ba2e094214e5e6dc80e15405c2151cdb79ddc37d5053637d72af0263c2c9def0808891c9a3cc1aaa78fa29fa89d7687c956182b47b9c8e5eaa8b5a14aeafb0682bbf688967a15a58338b7c6e46e0e63bb5ecc79363ae8370d534c94c71b1eb68508a3d4b332d294975df3d6b68acee841a775b50ee29b9c3ac744a25a0ff3a86b64b1653e0d495341368db49fcebc784faf040d87687cff65ee3122e2357dcf9085d039ff318f5e977634f18d814e79ed9915c54250add6d61892691382ee6ba8d04beaf2f45a5fd4849e7d24786371bab9313a2dbc7d5aa38ce941a3930c6dcf43d5f223e74617e65e8663475229a39386fa95aaffc9af5d21f198d5b637402d0e6e6366e53b576a958d8f6161cc785d951468676be55c737cf89cae6f17910de3d6e2af309298cfa2688d07d58faef4b2887c922c594a62546c9f07ede279555b943626c64998f3795a459f958ae9f9ed18141e32c2dc283de04f871cc30853307d98599e572f76f322a127afa1e2aab9d5d4cb9ab4ee835d60cc490c1aee5862f588c3fd9c2a00308e6d68bfdb0f5c23cb8c2766e5454777e8386f4aed6377a56df5304ca4b4b9bb0d14150e2f56446a06c1eb7325b0fde89a4ea3545cac497d75b83ac21131c34987a5559c5619fe16ef97daeade49ebdfed2ca678751a48e866bbf90767db07367bc5535902725cd3f4b557e632724caf20a1e4836f1f48163796e59dfadd7b7a58905e88334920b683de67a1ef37b54c207012a04805be7e7ce12e580a1e577d907a4dd5252bd90664f95f2293f18e0baf92ee0b6119d5564e88c6c2678f88b9cc77a8129771e346180f0b659925c9ad21a82413cc94b26add3c183d6e4a4c87a3f641a07b6d6d3726d40b873d1c6ff4abc82b6be3641948bbae9f6331807072a568b0a3ed8c8685436732e84ef073191881c9fc3fb65a02f9e0eca5e8197c41aa59da1dae47fb14810dd8aca5552005a0541b2155cf685fdd3452fd9b533f9e99f6bc5f4d63620892ccb564cede438bb8bf50b62dceae3cafa8f03cb1b8bcc898eef63195a08a3341b1ea3fe74a74ce71b3af032f3192da36eae0621925839f4c7a6e05f998af16487ca441bfbe210ec75bb9028630c6be5d618c0b35c4d8b0996941b8e44da3e3934840ac00b0a459d8f7fdac114f8fa7401d388c28b72601dc9c61306e48b84c62b1b009eb12727f2dc48dde5062bb2da4bc764c4e54730eb0bf9478ebed7b680462fff1731a624a055fbff3e1cc849e28f76dea0c2b46bf4d6734f1c7b31b855261c7cea40c5acfb220d909edf9a449d23b4d79d3b3c3fba567caa5ef1f5c62f5b5b707d5ab7121773025d566a7b3448350603b615e0a8d3c80a62adc3c63288433acad7bba00820bcfb9cd07882b4b16eeb3a0b6ef39e0b820acf592c8cbcea8bb6ad3d3e354e0bb9da4bfb84bda13ce2e11c2dfb25d5ba8e85855bbd26ba2fa9dcf5c120f98728deac2d61840f1f67e249a90a989e88d146dee1bc945ebbf8019c9086570e0ec376e60ba07df57466686102d713b2c2da599e319241afff646ddeb688a3593753baf8ea3697e740a06a2131deba5e4191e06dfc7128afcf354ef71f0f0b13ba360b8c84de6606a9f1d35b684c15bd3cba0ca46143d0c75c1e420ec88785ab948b482e8180cf83a70b20ab95da4d277023dccf70dd7a78250b2e19606553d76a0cba7bf70f9ea4733be64c16bf100f136ad6c80b67dcb92dd510edeb4c8f015a836c601f039face75f6fa1b8f3139458153cd45e4ec2ce4df0e704390e7176ebe5ea2f388ad4676b232bcf676007fcd67350f752233fd9d7f2a4e96ac959459279e2eb2814a65b9cb82d2f970c5b85329225045a2b6c4a018fe7836b5e1d946326eaa9d55b980b929e889768d5559ae4b2328d9df375c6d54bad31aea039377518d57db05bf8df3d767f6f8aa0e55f8ee30f991af961475b046aae14633dd8fa750dd60193bc6e1a770ef6182d8554b4ae1015c2862886aaeb8a357e92c4207fe6222275ac8a738e608dc7292387f94bb642ae0c6277145fd69b24cfc7e946714a70de6be4d51d95632518519c5a019b04a7d6309806340615b3d6056f9ef8e3a83a8620d4a9102727263041ac879080b1b0c5c6d303de40d6c108567f75cdf3ccbd15519dd2f661b6e76556f1235e07ae3c911ec411a87740bb48ffeae04bacc21a1897b0d928b43d185037a838b5150057d7c11d6e34c82c19ceac3efe90d54a15b685ea5a914f8b48c407af006afcf538808fa8a48c0d22f2f5c35a53e997b1a9f6686094219280fbf0ca80989753ecb9125b171af6596db54780c5cea87c6b651e4561ed1fe854a2bdc135b876a043241b887b63b5729106c06bb0c4483e7f9d2e274b5337071ba8da6e7e7c1ead94501d0ab11ce5b98b945d3c160b7d6d256364acc819b7c4f5d1bcfb3812354a608e5687e59e127ca4c508da1a51b92da0047bf80289f673f684d051d25dff4f097b9bc39623e05f421d427233cba34b24bc73ac3635c073e2708b6decaa8366beecaf576328a7158b8cbf03906c305ce99a01899cce192916520b0376a4ba0105034d7e304d24b5cad0d17ea32e705b275b12c15f949408539c30cbe9d63e9cdff25d0c8bf7f8876a8e0a08abd187651b86edf96e7b69ce3ff2ba42b0abf30dd2b2a5b32981c70137a6eba67a6cbbb3916c4edcf2d6477c032d2526c891224b54fa1b614b49602a15f65f6f3820e4dd7e7a4d2a223fdb7d948cca6e0e5b424d386d79927db8aeec0645e99eeb7130f930c0863779b7ead44536ad1007e10878726d67c049b7238f85866bfa2aa00383144eaf615cd945b5b5ccce59928126e4f8084f1845768da00e8dd102cef20cb831063be8389be733b251ff0da03c6a2e4341134322a2db9c1effb205ae2fe55f22534ef41351f1514c7e3250eb3195bdffd10002adc180bc62d9f6571ffbb6b0588deeba9db8268ad681ce4e40743bcbd870290b215bab69794f6223735f19dba65c891c937b80b2f5b01bd51d942efbb5aa9a9359b611c68adac32c970a63031fa50725a3b85b1c8763d740b91886a82b7d1b88dd8463979a0d0f12f2e609dbcb49ac0c1635efd735cfefe2bbb78c58bcfe32c4cef282991d2315e828412588f8c5396ff91087c97b2239ed4dbfcbd296e380688d1cf4cb7b90fdbf8c4e4257f5b6ae8c2920a0d52eb7e1a159b885ab6cf6162bcd22b5264ff6cc2d24344fe00a96f472089be76436108f979d0b7d85e787be5a558a0601433e34b9bad8b0e6bd8409144fcb855e107030b457005e3fa845b0624cb4b1d2657b0acfe1b178ab26ca0b2a3e35479056c0def0c43daeeb9a81fdc26aa3f8522c4f4ed59eb9487cf000f637cfed59e4e59ae404cc303a61568c0d9e51600b8c8207046c1c22fea8cbfa2e68cd460abf687ab920722a596f9cb2adf7a3c5f8ba1f7393e2b6deb899f7cdcbddf19f3d4ff6c10ec61e2317b153bc9f320d8e70ee3b95bd8ef618709f99225a5c000dbfcf3c42fb71e4b430f8fa264f9ff38706c9632b113e5501053e8326814452957380d247b6ece4e9d6e8af7f320c16bcd0a4f395fc38718b0ee633bb54dda0e2d0b8a1908cdbc4a7092d64703c365d1c435a45229c32c8e4787691a31e2addb417abc686f8d530f74067e19b586657f44d22261b23997d5b5f7e951729564d8e9aa9a4a2d06e19ad3491652053506eb71ae94d62032d7951f626ad9bfa3f28fa4507209d4cb058b5ce6f5b575549b82b72a3ed5645a623ae4e42e6a5b98918f4273e68db3dac7a9ada1e38194fd47562ac5beef185d3187d4e72160d97dfd12f5ebcfec93bef96e664690f27366b897e929067004aaf8c198b94a5d348d382230418d39fabffe5fa21a754196b801d029b6d2a92a315884b15c5972a14bb4dd56deea544b5b9d44963425de03400ec83b6165c779859d419f9457923f854e6d76b033ae885623c91654a632e7eecb698629ebfbca04c0d095696b0ba33dac6789d6dfb42ba6bb3a32b0b50a6875685fd26273822be427ed9129d14805b3bbe8d04b4febc1ebfd22a2a049210df9595143c43cca1f75d96f43271fdaad14eb45a927dea568dfbabb0aebca9c0e5bb17aee998c9ffeb4c961b550c78048179cd5d49e431308d9d4f5ed9e07b814acff8a13f5ef4532b42ffaefdb0209f1a48454129b0dc2bd6e9acea763f67c6297388259aadc5ddf2671777ad2a751b8116cecb30faeff7b11fee6b5ac745a396e09176d9c0ec355094d97a80eed8c9db63aa275e35933f1cb84f0871129effe955d647cfd8d57441b77a676fc0847f6d94c77b93e1d015fb18312366efc4caaae5140e26f265a3f75540a6d5b8c1070101b9c1ae379797c07349d8619eeab2601dd55af11a6c27825f6dec2cdc61e4855b6daf47be1d293b573484a98ac0fc7a8bfbcb1194b7f84e068fcfbedb6dcbd88a98828a5261c0a9f2a4f9f0539fa90cce45e46c67198684a6fca73c97b8fcecb960dbc1c78474da0e3913dc22b9e185778a6ba768dc9952ecce9a6223df411c3e89ebac4b03235540c273141e2e379b150a729d6976f91dbb06bb225533601b4eff570c11a61628b664406c08d5941ae73130bf45620f214c71f8c3f151aa53c6070137d0554716de13cf7c202cf716fa5043c02824eea893f008d4b648dd10a613f6f7759671788c98fb0248120ca622129d4e8227d421d99487aa74ecb882cf722d6e3e17b83377c2792c28ef9957597d2087d39f1b3d54fd591419bff366a98eacc7a6191d45a403370592ca4bb6538dceb063f01bfaa85bc647f854158a4d2e52139e2bd327145cfa53596aebc10cd9e528e5ba4b509bf7968d94c6bb520cfef1a99a0c6782d5e7f9fdcce780b7e5519fe8a1ee678ba7310f6401eb65167edceaf4fd6c1470fa4a397cdcc95aebc39017dd01aa3bbdb1f2b863d6efe0042363bd09058de72c695573e23dc3ab40fd114e5ca514b7b8f7349c21e34f597ef22d3a68677cdfc52db0a3ea7ca118aef6c494a1c122fd080a9fe170fad0831684bcb79a25020843ea73422df282eca49a0cc0ba9b9fcb6103f3bb899b2edcce451ff3ac12cc0417c728051824091c3ecce400778cca8f8d4f8fc34c22b43cf1ba53244acecf791bc228fcf23a4c62dd5c08e3f01e5566a5f05e5a2bbc9d92548c386fbd12ca6b61f9796a380d1e8fc2ddeba4ad1c33f6d87a91531acb4195ebdba4e8fae7a352b48c64c1046d8c21377ae392bdfdbac142f90278c1471311b0c73a5b620b853683f720119ae0ede9f4e436fcb5c7befd211c19bfb6629ca57d846d31eb19a81026ac0ec479f0b92e5b3187489809acd0bbf1296de3ed868eb57ce2955c57d516aa9de95ffe4c7fe86e9a9cdc6da9b27487c53154ec086418b671c3f68c739297944aceb0bf5d3066dee96ede5bcb9290190d04f4086767c141013405ec01da586b1df6ab31b4d5155e94034adc5f808d60d335f4d2000b4b5c54120828104ea90cf48203d17d409168d29b5fb1e2c79e6d8a304aa30674b1178fa0e304e6bb763318d41f229a319739ba1bba4ba561ba513ed56ac396fe4b67397735efba79c1bcc496bd5449e9e55dbb4749c1c349b135ed65ee1314e45a516d98c4a87c9d64d8ff21963375c9cbdb65b31d05c8352bd2c2ab079c396a5a51d2d25ebaa1d84e536c9ca831e3d3df61087ff5e0d2134a04b990caf006783560524a9d779963f7f394e2b625effd1a9072bee26080a2b27fedb10605c357b6b122db152d386dd38a9929b86b3d6d344d9e7d3f1f5d5cdaf15816b731da0169e087eb88268c7aec95b9a654e2a5336442b268e190dedeb8fd7a922ba2bf4561cfe4832c6557ece49ca3c11adeb0526514e0078808489d4a732f3c11b25fe66b993e7882f007c9762f116d870d25d54dcf17391c38ef1f16ce57c74716d76aed2130c97c6dafe64f5e5e0c51f7b52c07d02bdf21f7aed5d3da7e8b1117a94863dc94078a85b58e6dcb030c2524e0d410823ef0c24f3d3dda79e6d09140da5150228d814a7fec33d42b1d7c299a5a4f9d061b18af2410e3a9ccfe85b09f6242bf4d0b463a420b0cb33a29646f337d56a3fc6ee665a35618dd92e391b0606d06ad60fbc4f85e2bc50be4728653909807345d65c6668bc947684145973f1319ec909ca42212b5827359fe898e95f58ae03ad9803bfe0bd736ce54cad3050494134bf2cf714dc17cb7de02d07c72c5251bc740237d6bb0e0ada2d76d59ec097ec501462f3c66ef9eb6eb031afa970921840bf6debec3484a4101a1d20db0a2f01017700043ae4ef59b94c1a009ab6dde49df3f53abf7d2fbc7eedb928ff7e3de5cedd86e6578c133bcd93d03ca69d8f52d8d26db1c27d129f7894233fa73a36b31e9e27fe746e76f5a5d6d375b1260108de87e8fccbb90c1c1591f0943a8dc022173d05084a8b3bd33c50db163c589cce80be26da63ab0418e32db61ecbee945840d373ad60761b2550e4f5a27b46694a57c313fbe72d3ed96e4e600fa4e41f03bb483e6119bb1913bde3d2dde68c966483cd41ea5f41911f24a1e87dfc5d34e559db62aa69aabf717aadf8e3f1d204760ccf6da2d132ba85eeef7f56410c667c7e84ca8d812f04451bd64a52346fd80ff76fe4550c27de3c3f00a8b1527940a16b33f91c648bc3d339f0c1f3dcb8b3151ce7b708f8a68ce2709542bb00e8b5edd148d50d9018c6dd4a049f80146cde0ef22c4aa302b21002503c14a79a8a2ed50b0536a913e3e737ddfa145bfdc7fd6688dce420fc3480640e6c23707b3854c337a4d207f1f2a9ca8464a6aba4f975289b2331003a246bc570ae138477619afab592ffad41c6b2b6091112c238c70c8c418b066594cbb90160a93be678c0870069b178549211b30632d10b296630e72c4d50c21fcd472646c8cfe20ec8061394a56fda609c72db8ab1227aaa65ba15a84214ecd6c13cf7431600716f8eeaed31e90788c029975354c8d60fd20aea3873d71642e627283aa209cb5b3dd2cc8661400cad889a5c20378387076bc66b51c98020372abd2e8e87741685fedfe6685dcb6cbdd5716fa7b77b70ff57641dbca471cd9b1e171592b0594b7f89338d4c9a8aea2460d20937383d48e6931cc3fde257d35afc84865bb73029cf01131ae304fec8c9b89d5fb6d28ba40e456bbde012e39d77164d0a8ccc78f71619b57e573cafb8edeb568ea6be0b2294ea6c854d7eadbc2700c66a5a929e367a05689e920ad203e07ca8a273f8f3ccbfdd19c06ef3fb8560ef7a20ef84934c4f744694da369b21bacd1f9806834481a3a5f8089b4c37ec20c9100e7cd2c0f36c953f10c7eab3973ad7aecdf6e4c1aee315b148c434539995a5cc2bd85191801eab003f1816ab03996efb36845e92792199d00ac31aeb47decf3da2724cd984926d1720f358b7182e130309ce6b152f2850eb81a384d953e8854cc30600d4967ce2b7576bf9d253e356743277ddd4494db22ddad151e5864a124acf7a68d82855d30ad940dcb43d32b8186040f597405b0c8411ffa6558f66a6fbcd683024f5d1a57b36b9e84fc5ddd56b7190106f077c68c126cfcd6713686f230995c4a33a3c663e142c14bc2534eae08d77b082d12509325968b0690d10d4808750a196d024e7bede43b406ce41a631262f128d9fd13738d0784e11e4701716406dd51298ad9dcb3806d95c25584efc847c12d8c1732b1dbc881ed36a15855b36bf280eaa26e3154c863e52eac4345c504976ebc4b3351c58a9276d4054d5aa495ef564e071aee8abbf256ecf233173c4f5a00ae432d8ddf3eae64ad25edf35b3b4a78d7cd0eba5fad70881a6c57ff557732c350136d0cdd5e9eeb218eb06b738fe618f4803a2297954f35d767c3205eca559edda8b270cf38a0b27a50c67bc1ac6cfb4e884e9915b52078aeb7ec4e766dca44a27d12e793d71d02bc53826f31ceb69720eb01ed81e8455df9626c185aae540b3409f8cb443725bde1d25a12071fd403360b16aa35b20bb445f45adb668f3346f9c3cd4d741636aa38b75f6826e2bcd056851c18470a6c8e5f847eb3cd9e34ebf0f081a4bd586a8215765f7f462dc2cb0b948bcd69a05891070b97371b66b8a09ea401b9b1ddf84510566d22f662e1f06900b4afbed91c53b0fba49e72d4807a6ba98b7c1a8def2a2ab411ab92b14647a276902848961f6e5c4be7edbd707f50471e2838ebaa5387ebe9fc480a33d072dbfe3ffde15363d6a37160f05e032f199b14ae15c752a4184a98f7d6de589b69cc862c7337ca1a242d91af49965d6c349d6465490f8f06eb88132f2543d17ec364e1c5680c0941b881d1e683d00e13c05bec47e34d51acfb4e8a19a3d062e9208b42ce9a1d3b492aa6432f61b0de783f05d0d1b5ebcfef2dfb0301dbbdc0bd249808909393b9a9cba7da9f3feaf8c16eff5f05c6fd84cd591754a78df86926d4d4be3178280fe9179f6ef9bdb4d60f6bc8abe00d0a226a716545802b189e1d752e22964dc51307cd4f231fb7e296c850ac71e0aca059698fae7b660e673671c882d492dee47f1e5d9d063aabd076537af024957f67a4f6e0b2bbc12fe985d187971d0b339b69bed2c5f73e5624c242b3dd8d650c4cbe142319474986f68aff7c29f264cd6a7dba3824db90f75fa8cf8ed0d46c613ab493926e04066843820a0c76a04515f8f1f2310460e7ae83bb371d0bcb668a5b32220fab3514f967640edf58c3a1204c741623cf5f62b551a362d24c77e1c180f4a83ccc2b22d664e0aa777ddc03244d4410c9f500265d14b681b12fbacc652a457cd63805e9c843fa3d35955891eb098df6fd729cb93f66c06bd13a48f42eafa5c92bee6f055005263e45b7c8dd7ff439236320ed2082a87d3ba712fef00a8c364c6e8fdca82ee11cd2c7381963d3ca84cfcb28bd7092799fd545291725fd7491b5ed6e3e88cb04987454bca49ff5d4ba68cea4c033af1fe3b131e3553ae24801a43afc57ec26690127257990d4e58f755bd5ac4f898655afdb82d6b327468869fa76fa8cbd2610e0a5cf135f9c9b233f6e3aa68fd8f3ddd487886cf1ab70eaa393c3e0773b138857dfd91bdefaab73d4510d35921b39935a63937de5551b4085d66c82c4052b727bff9995fcf5680a4baef46ec0c47a7faac08c74b07c7dee34c6607df1d47e7d891840ca36b616ccd70368f73ee829e5d0b6d128fd9db2f4d65e1ed2d363ae2c41b925f15231c76accee2f8cbb604e3c14f62f5e8fabefc8bb93b9dc083a18ea46c98c7e356a3ddaf6a3178eaa3f13599afcefe703e631092468d6768e85fea3a0cfe17735178cd3a7aa646bc0430e4c250cae0704e302bbbdc56e7e86b9b1bdfeaf4fec7dd6a472d304ad674a2ba31fbb84d49bd65f094c6e58e2f6693dd66f9241ef69e754f7f144b09e054bef8dc7b0e83164628d8b689db8779fd3d801c6b5e1d300f6f07fe2a440515e01e27a913fbdd1063086c787efbb4452b47c71b44b7fc2f3a973a63006feb7c393f590a80ee185f18d16c6f1023cc0c4a82ac4bba6a9d870cd2a42fb68f8712019a6300f65ea06eaaff3f51194d03444da1f707174b85b1a320af1577ee37e800d71b4ada459bed9c99d1afd5d7b538c576dceb603c990dbf73a140779de0a4a7705e3800c92281b4e37a0c317ef7157774029d03bba4366f1ead08a027a61e310a64adfd180c3e40481806cd093b6b11291718124cdb7794faa5b38378c06cae0831ae5dac6bc505aff85a28f6034621150c9adb23a7ce023d0289a98e5d19a6527a99c4ffc5cb96c588ad2c3006c99d60babac8bc05f4af62da6d4af9acb360e03b310ff35b608f90487b65f7ac13c21ae9339d34c4b9f058ba070b3693d0bf275e71f9e0ed830fcdbf55cb6c496963462085cd5e68c26c1dc133030359fdd6961f4258fd84979a35e20ac48535f996be22be102dd89f9056852f8f7b42c7442886029ea14e9f353b369b3c2503d294b11e14a622a1c8e8dd39ff2a28b32fa0f8b20ae23d98fcd59cc12928cf526c0ea1399d78872c9338f0c4492407eac23baa9771930974a213913ba0f1c419bfa8ce870d52790c71b735c8cee136ff8cf7ab1a30472db7a5c247f0de6e0ae5b54e7faeee6108c6e0ff5b5a7bfc1c27fce6c8f5f0eaa8b0035292ff0e722227594e4ee0f471ea3fff14d73067dfe829719658d0c4a6820f3691e08e156243358c20e7331715ba78b185314a0ce7daa3dde0ffba66ccfed5c01a43dad49093b5938a3097096fa70606d4b6fa56aa982b8b3597504d871287961ce5c9fee9f88eb9bd9d0c178b51c4ccd9cf13cc8725d2b825628ad644ac380af09d019235afc9f8551a8c66deecb4d68ff08d15e0fe94544a0be3d31089c5fdd3f046caaa4d72cd9e8694528fc24221714af01c8912ed5299e21b6439d413c1ac8d31953fc2f7ce58e0bdb0cbc29fbd17cd6ebc8bee1f77c360d4d743767c2bf88e26157a8170b753fc00555bc56e0db2be714c2250e9c831e18c134c2b4e8b3a9048934e0b0d0f00667e6118718cc4f0d3498e460a431fc36fc352378529c42b422a827cab170185624833a23bb04bcbe72caae02353dad6b31f9baf50c16c160eb377fdaf756ebc94131b2fd267c266f24c1d4f823418c9791b3fb5bebac40c5643bae73686857872711606e1a2fb86d57a92575c6d8cab7f43dc9fd0d6c7e0c8f1c0bbeb266bb327700dbc308a1a936d57869f2090b4311b6a153e1644291ad36670ec2e2a7bdda2c5479a0daaae46949502689ca7c067b5c2b43a448da420726834cc8f7ebfa2fc3d7aaa9017e3e4793c92598b497621119a9dadba5a18858521a8f1e5b6549fff1e8a35966cb64d79178a83d92322d89a2c7044945ed2cb16ed6567499bf0d512e05545c63b7d7ccba02da853845128db67ecc71d5f290d2ab24fe0064e5a6773a53a5dd3c2c1c2836e8bc8112ce4a346fc1b05334df1cf3fa63a833ae96a871562846b97b0097d88d99df9f1787a1909481985e9d81456b5ce0b0872ba4e23cce586abf2aa02fa250e34cbce2fa5d95449bf8abee629226eec3af1db63b8b0742755a760073c2a0520c403572b2348ce9cc447cf9610a4ab26be3d93eb2357fb727ab257bade858d5e2b9b892d64517508194f8c59b31da31745a48083fa64c2bd504a1d1b4ff1922f42539b0b249fca244d05b5a25bdf2d5508ad18b364091db1e14c3eaaa346cc8da4ac0c02d507e449cfda5a63e8e25767f3b4dc526c082498ec93596b169aa227d4f78ae2ceaf309c7829b99102c6e19ec06641896fefec3d0776a8be0a089aa319e6ffd8e7d4dab157594379e59d6a24ffcd3916bf082866da69c2694011f8e43fbb3ab111912209bba4bca44fd6d6ad40c9be4df78ce498f2f66eca0eff5a55f8b6d5bef9eb89735920753c7a8b65c9584de940da6c2d827d2fbb3c4113330041bff9d2086e52912abba9070eb735c1d3a096415dfd9f8a36268f9a867f48f6c4cc2925f515ed6e3f0577adba096f1ccb618e062aa9413fe7802ca0e0e4e6f420dfa47e6061c02567e9f181c20efa7792a77bb2758acef6c4ed76e7bb79275e4f668b67d9ef0a88e03c7243ee3ec6eeac8268b4724d6299c30a6cb2c03695b82b390f6928b1730c0b9a4e1c3e12a8cbb7187960efed78835bc3e9bce111d6934d728179acd9d2cde95bec0986ecbe56ef6f748aa3496321eba8af091db2831b0fa8ed1abb3afd77062a17320dc32e4459909dc9f3816bde6ea384b39c9bfb1f80adbc1d8951efbc038d8ee6c4de7c5587334f55542de3e13a66daa5097214970edc1132f20aec887de27ffd4e9d9c3a4653befa396799ea0b29c53fff135f9c83752e2a8600e0f7c2b1441726fce80dcdb7af6165324d63a9f6b3f2fa5f1358e42ac63e7347d7cc546f9925521dafbf8918988198632dc172961815c2b60f5c338f171e512960ac4eaadc517a7bac9e5bda54a2273592f80b59caea00ffc09960c53a760e7c7d2746546660e4aabdc5fce297e95edad4db7bd425c86fd85eba37ce38aed41703932cd303bb80d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">诚信考试,不要作弊</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>移动通信</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>控制系统-知识点总结</title>
    <link href="/2022/06/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <url>/2022/06/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="控制系统-知识点总结"><a href="#控制系统-知识点总结" class="headerlink" title="控制系统-知识点总结"></a>控制系统-知识点总结</h1><div class="note note-warning">            <p>注意：考试当中所有的作图必须作在指定的坐标纸中，否则零分！  </p>          </div>  <h1 id="模拟控制系统"><a href="#模拟控制系统" class="headerlink" title="模拟控制系统"></a>模拟控制系统</h1><h2 id="系统的频率响应"><a href="#系统的频率响应" class="headerlink" title="系统的频率响应"></a>系统的频率响应</h2><p>对系统的传递函数$H(s)$，根据s域定义$s=jω,j^2=-1$，得到：   </p><script type="math/tex; mode=display">H(jω)=H(s)|_{s=jω}</script><p>$H(jω)$称为系统的频率响应。<br>定义系统方程$H(jω)$的幅度值-频率响应为其转换方程的绝对值表达：  </p><script type="math/tex; mode=display">|H(jω)|</script><p>以分贝形式表达为：  </p><script type="math/tex; mode=display">|H(jω)|_{dB}=20lg|H(jω)|</script><p>系统方程$H(jω)$的相位-频率响应为其转换方程的实部和虚部组成的夹角：  </p><script type="math/tex; mode=display">∠H(jω)=arctan\frac{Im[H(jω)]}{Re[H(jω)]}</script><p>系统的频率响应可以由幅频响应和相频响应两部分表示：  </p><script type="math/tex; mode=display">H(jω)=|H(jω)|e^{j∠H(jω)}</script><p>系统的频率响应、幅频响应和相频响应在复平面上可以表示为：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220303200958.png width=50%>  </p><h3 id="传递函数的级联"><a href="#传递函数的级联" class="headerlink" title="传递函数的级联"></a>传递函数的级联</h3><p>对于系统传递函数：  </p><script type="math/tex; mode=display">H(s)=\frac{K∏(s+z_i)}{∏(s+p_i)}</script><p>如果将每一个括号的常数项进行归一化，就得到系统传递函数的级联形式：  </p><script type="math/tex; mode=display">H(s)=\frac{K∏z_i(\frac{1}{z_i}s+1)}{∏p_i(\frac{1}{p_i}s+1)}</script><p>对级联系统，其每一个子系统的传递函数为$F_i(jω)$，有整个系统的传递函数：  </p><script type="math/tex; mode=display">F(jω)=∏F_i(jω)</script><p>系统的幅值和相位为：  </p><script type="math/tex; mode=display">|F(jω)|=∏\frac{|F_{zero/i}(jω)|}{|F_{pole/i}(jω)|}</script><script type="math/tex; mode=display">∠F(jω)=∑∠F_i(jω)</script><p>可以发现，整个系统的波特图可以通过各子部分的波特图叠加得到。<strong>因此，对任何一个传递函数，其整个波特图都可以被分解为若干个元素的波特图的叠加</strong>。  </p><h2 id="系统的频率响应分析"><a href="#系统的频率响应分析" class="headerlink" title="系统的频率响应分析"></a>系统的频率响应分析</h2><h3 id="极坐标图"><a href="#极坐标图" class="headerlink" title="极坐标图"></a>极坐标图</h3><p>极坐标图最大的优点是能够在一张图上同时反应幅度值和相位随着频率的变化情况。极坐标图可以绘制在直角坐标上，也可以绘制在极坐标上。   </p><h4 id="极坐标图-直角坐标-的画法"><a href="#极坐标图-直角坐标-的画法" class="headerlink" title="极坐标图(直角坐标)的画法"></a>极坐标图(直角坐标)的画法</h4><ol><li>对$H(jω)$分子分母同时乘以分母的共轭部分，并$H(jω)$的分离出实部和虚部</li><li>找到$ω=0$在极坐标上点</li><li>找到$ω=∞$在极坐标上的点</li><li>列方程，找到实部$Re[H(jω)]=0$时对应的$ω$，并在极坐标上找到对应的点</li><li>列方程，找到虚部$Im[H(jω)]=0$时对应的$ω$，并在极坐标上找到对应的点</li><li>找到可能的$ω$为其他值时在极坐标上对应的点</li><li>从$ω=0$的点开始，划出连接所有点的轨迹，直到最终到达$ω=∞$的点，并标出箭头  </li></ol><div class="note note-info">            <p>方程$Re[H(jω)]=0$和$Im[H(jω)]=0$根的个数决定了频率响应曲线会穿过坐标轴多少次。  </p>          </div><h3 id="奈奎斯特图"><a href="#奈奎斯特图" class="headerlink" title="奈奎斯特图"></a>奈奎斯特图</h3><p>极坐标图的优点是能用一条曲线同时反映系统的幅频响应和相频响应，但是相比于波特图，极坐标图无法直接通过观察曲线走向得到系统的稳定性分析，因此需要引入奈奎斯特稳定性判据理论，以此对极坐标图进行改进，改进后的极坐标图称为奈奎斯特图，其优点是用一条曲线同时反映系统的幅频响应和相频响应，也能够通过曲线直接判断系统的稳定性，但是对系统频率响应特征的反映没有波特图直观。  </p><h4 id="奈奎斯特曲线的画法"><a href="#奈奎斯特曲线的画法" class="headerlink" title="奈奎斯特曲线的画法"></a>奈奎斯特曲线的画法</h4><p>奈奎斯特路径为一段在s域上的闭合矢量路径，其涵盖了s域的右半轴，如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220304101920.png width=50%>  </p><p>奈奎斯特曲线的画法如下：  </p><ol><li>绘制出$G(s)H(s)$的极坐标图，代表$G(s)H(s)$的频率响应曲线，对应路径i</li><li>绘制出$G(s)H(s)$的频率响应曲线以实轴为对称轴的镜像，对应路径iii</li><li><ul><li>路径ii(奈奎斯特图上从$0^-$到$0^+$的路径)在$F(s)$中对应原点(0,0)。  </li><li>此外，如果系统的开环极点在奈奎斯特路径的i和iii上，此时这段绕过的路径对应将路径i和iii的映射以$R→∞$的半圆首尾($0^-→0^+$)连接的路径。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220304112314.png width=50%>    </li></ul></li></ol><p>第三步补充路径的方法如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220304115220.png width=50%>   </p><h4 id="奈奎斯特图分析"><a href="#奈奎斯特图分析" class="headerlink" title="奈奎斯特图分析"></a>奈奎斯特图分析</h4><ul><li>奈奎斯特判据<br><strong>当频率$ω$从$-∞$向$+∞$变化时，$GH$平面上奈奎斯特曲线包围点$(-1,0)N$次</strong>，当<script type="math/tex; mode=display">Z=P-N=0</script>其中$P$为系统开环传递函数$G(s)H(s)$的在s域右半轴的极点个数<br>$N$拥有极性，逆时针包围点$(-1,0)$时$N&gt;0$,顺时针包围点$(-1,0)$时$N&lt;0$<br><strong>系统在s域右半轴不存在任何极点，表明系统是稳定的。</strong></li><li><p>根据稳定性判断系统传递函数参数<br>对系统开环传递函数$G(s)=\frac{K}{∏(s+p_i)}$，如果系统稳定，那么$N=P$。需要找到奈奎斯特曲线与实轴的所有交点：$(c_i,0)$，并判断其与$-\frac{1}{K}$的大小，根据$N=P$的临界条件来确定$K$的取值范围。<br>当奈奎斯特曲线正好穿过点(-1,0)时，系统处于临界稳定状态，系统的稳定和不稳定处于随机中。  </p></li><li><p>增益裕量和相位裕量<br>定义增益裕量(Gain margin)$G_m$为使得系统处于临界稳定状态的增益。增益裕度可以通过奈奎斯特图上表示为相位角为$-180°$时对应的幅值$-\frac{1}{a}$求得：  </p><script type="math/tex; mode=display">G_m|_{dB}=20lg(a)</script><p>定义相位裕量(Phase margin)$P_m$为使得系统处于系统处于临界稳定状态的相位。相位裕量可以通过奈奎斯特图上单位圆与奈奎斯特图交点连线与实轴的负半轴夹角测量得到，如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220306085527.png width=40%></p></li><li><p>灵敏度函数<br>如果开环传递函数为$G(s)H(s)$，定义系统的灵敏度函数(sensitivity function)为：  </p><script type="math/tex; mode=display">S(s)=\frac{1}{1+G(s)H(s)}</script><p>灵敏度函数的最大值$M_{s}$可以反应系统的鲁棒性。而灵敏度穿越频率（sensitivity crossover frequency）指灵敏度函数幅值为1时对应的角频率，以$ω_{sc}$表示。<br>在奈奎斯特图上，$1+GH$可以表示为-1到奈奎斯特曲线的向量，$\frac{1}{M_{s}}$是-1到奈奎斯特曲线的最短距离。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220304121001.png width=40%>  </p></li></ul><h3 id="波特图"><a href="#波特图" class="headerlink" title="波特图"></a>波特图</h3><h4 id="绘制渐进波特图的方法"><a href="#绘制渐进波特图的方法" class="headerlink" title="绘制渐进波特图的方法"></a>绘制渐进波特图的方法</h4><ol><li>将传递函数改写为级联形式  </li><li>列出系统传递函数中所有的零点和极点，从小到大排列，从而将整个系统的波特图分为几个区间  </li><li>找到初始值：  <ul><li>对幅频响应：  <ul><li>如果存在$s^n$项，波特图的起始幅值应当为：  <script type="math/tex; mode=display">±20nlg(ω_0)+20lg(K)</script> $ω_0$为波特图横轴的起始频率，$+20nlg(ω_0)$:$s^n$位于分子；$-20nlg(ω_0)$:$s^n$位于分母。  </li><li>如果不存在$s$项，波特图的起始幅值应当为：  <script type="math/tex; mode=display">20lg(K)</script></li><li>对相频响应：  <ul><li>如果存在$s^n$项，波特图的起始相位应当为$90°n$  </li><li>如果不存在$s^n$项，波特图的起始相位应当为$0°$   </li></ul></li></ul></li></ul></li><li>看系统方程的每个元素在对每段区间波特图的斜率贡献：  <ul><li>对幅频响应：  <ul><li>对每一个$n$阶数项，其极点会给幅频响应带来一个$-20×n dB/decade$频程斜率的变化；其零点会给幅频响应带来一个$+20×n dB/decade$频程斜率的变化。  </li></ul></li><li>对相频响应：  <ul><li>对每一个$n$阶数项，其极点会在$ω∈(\frac{0.1}{T},\frac{10}{T})$提供$-45°×n /decade$的斜率变化；其零点会在$ω∈(\frac{0.1}{T},\frac{10}{T})$提供$+45°×n /decade$的斜率变化。  </li><li>对每一个$n$阶数项，其极点会给相频响应带来一个$-90°×n$的相位变化；其零点会给相频响应带来一个$+90°×n$的相位变化。  </li></ul></li></ul></li><li>将每个元素的斜率贡献全部叠加，得到系统在每段区间上的斜率。  </li><li>求得每个区间的终值：<br>在区间$(x_1,x_2)$上，纵轴的变化量$Δ=y_1-y_2$可以求得为：  <script type="math/tex; mode=display">Δ=klg\frac{x_2}{x_1}</script> 因此每一段区间的起始值为：  <script type="math/tex; mode=display">O=O_{-1}+Δ</script> $O_{-1}$是上一段区间的起始值。<br>找到每一段区间的起点。  </li><li>连接所有点，画图。  </li></ol><h4 id="波特图分析"><a href="#波特图分析" class="headerlink" title="波特图分析"></a>波特图分析</h4><p>定义相位穿越频率（Phase crossover frequency）为相位波特图在-180°时对应的最小频率$ω_{pc}$。<br>增益穿越频率（Gain crossover frequency）为幅值波特图在0dB时对应的最小频率$ω_{gc}$。  </p><ul><li><p>增益裕量和相位裕量<br>在波特图上，<br>增益裕量是0dB与相位穿越频率对应的幅值之差：  </p><script type="math/tex; mode=display">GM|_{dB}=0-|H(jω_{pc})|=20lg(K_g)</script><p>其中$K_g$为开环增益。<br>相位裕量是增益穿越频率对应的相位与-180°之差：  </p><script type="math/tex; mode=display">PM=∠H(jω_{gc})-(-180°)</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220307111837.png width=50%></p></li><li><p>增益裕量和相位裕量与稳定性<br><strong>如果相位裕量和增益裕量都大于0，</strong>则系统稳定<strong>。<br>如果相位裕量和增益裕量都为0，则系统处于临界稳定。<br>如果相位裕量和增益裕量中有一个小于零，则系统不稳定。</strong><br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220307112342.png width=60%>  </p></li></ul><h4 id="从波特图反推开环传递函数"><a href="#从波特图反推开环传递函数" class="headerlink" title="从波特图反推开环传递函数"></a>从波特图反推开环传递函数</h4><ul><li><p>阻尼和固有频率<br>当相位裕量小于60°时，相位裕量、阻尼、带宽之间有如下关系：  </p><script type="math/tex; mode=display">PM=100°ζ</script><script type="math/tex; mode=display">\frac{B}{ω_n}=1-0.5ζ</script><p>其中$B$是系统带宽，是幅值为-3dB对应的频率。<br>可以通过波特图找出相位裕量和带宽，以此求得二阶系统的阻尼和固有频率。  </p></li><li><p>系统增益<br>系统增益满足：  </p><script type="math/tex; mode=display">α=20lgK±20N_0lgω_0</script><p>其中$ω_0$为初始频率，$α$为初始频率对应的幅值，$N_0$为$s^{N_0}$的阶。<br>如果存在$s^{N_0}$项，那么波特图第一段的斜率为$±20N_0$.  </p></li><li><p>终段斜率与系统阶数<br>系统波特图的最后一段斜率与系统阶数关系为：  </p><script type="math/tex; mode=display">k=-20O</script><p>$O$是系统的阶，即极点数-零点数。  </p></li><li><p>积分和微分环节<br>可以根据初始斜率判断积分/微分环节$s$的存在：<br>初始斜率为$±20N_0$，如果初始斜率为正，则代表系统存在$N_0$个积分环节，如果初始斜率为负，则代表系统存在$N_0$个微分环节。  </p></li><li><p>一阶和二阶项结构<br>根据之前的讨论可以知道：  </p><ul><li>系统波特图上的转折点对应频率为系统的零点或者极点</li><li>波特图上发生斜率变化一定由加入的零点/极点极点造成：一阶项对初始斜率的贡献为$20dB$,二阶项对斜率的贡献为$40dB$。如果元素位于分母（极点），则斜率贡献为负，如果元素位于分子（零点），则斜率贡献为正。<br>根据这两条理论则可以判断每一个区间上影响其斜率变化的极点/零点结构类型。<br>如果存在修正，可以根据在固有频率处修正前后的幅值差求得$ζ$:  <script type="math/tex; mode=display">M_c=20lg(2ζ)</script></li></ul></li></ul><h2 id="系统的阶跃响应"><a href="#系统的阶跃响应" class="headerlink" title="系统的阶跃响应"></a>系统的阶跃响应</h2><h3 id="稳态误差"><a href="#稳态误差" class="headerlink" title="稳态误差"></a>稳态误差</h3><script type="math/tex; mode=display">e_{ss}=1-\lim_{s→0}sY(s)</script><h4 id="误差系数"><a href="#误差系数" class="headerlink" title="误差系数"></a>误差系数</h4><p>误差系数为：  </p><script type="math/tex; mode=display">K=\lim_{s→0}s^nG(s)</script><p>$n=0$：静态误差系数；$n=1$：速度误差系数；$n=2$：加速度误差系数 </p><h3 id="阶跃响应与传递函数"><a href="#阶跃响应与传递函数" class="headerlink" title="阶跃响应与传递函数*"></a>阶跃响应与传递函数*</h3><h4 id="非最小相位"><a href="#非最小相位" class="headerlink" title="非最小相位"></a>非最小相位</h4><p>当系统的传递函数稳定，且在s域右半平面存在零点时，称系统是非最小相位系统。<br>最小相位系统在波特图上高频稳定区域的相位角应当为$-90°r$，其中$r$是传递函数分子分母最高次数的差值。非最小相位系统在高频的相位角不存在如上的关系。    </p><h4 id="过零次数"><a href="#过零次数" class="headerlink" title="过零次数"></a>过零次数</h4><p>如果真分传递函数$G(s)$中存在奇数个正零点，其正零点的个数对应拐点的个数，也是其阶跃响应过零(crossing zero)的次数。<br><div class="note note-warning">            <p>过零次数不包括点(0,0)。  </p>          </div>  </p><p>如果系统是非最小相位的，则不能保证其过零次数一定为正零点个数。  </p><h4 id="初始下冲"><a href="#初始下冲" class="headerlink" title="初始下冲"></a>初始下冲</h4><p>初始下冲（initial undershoot）指在初始点偏离阶跃响应最终的渐近方向。<br>如果真分传递函数$G(s)$中存在奇数个正零点，或者严格真分传递函数$G(s)$的$G(s)-G(∞)$存在奇数个正零点那么对应的系统会出现初始下冲。如果系统是非最小相位的，则不能保证出现初始下冲。  </p><center class="half"><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220309103736.png width=30%><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220309103819.png width=30%></center>  <h2 id="补偿器设计"><a href="#补偿器设计" class="headerlink" title="补偿器设计"></a>补偿器设计</h2><h2 id="超前补偿和滞后补偿"><a href="#超前补偿和滞后补偿" class="headerlink" title="超前补偿和滞后补偿"></a>超前补偿和滞后补偿</h2><h3 id="滞后补偿"><a href="#滞后补偿" class="headerlink" title="滞后补偿"></a>滞后补偿</h3><p>对于PI控制器：$G_c(s)=\frac{K(s+\frac{1}{T_i})}{s}$，由于积分项$\frac{1}{s}$的出现导致PI控制器在加入系统后会改变系统原本的类型，进而改变已经调整好的系统动态响应（系统达到稳态前的响应）。因此，需要一种补偿使其能在$s=0$时提供非常大的开环增益，进而减小稳态误差，但是在高频区保持增益为1，进而不会对系统的动态响应产生影响，这样的补偿称为滞后补偿(lag compansation)。  </p><script type="math/tex; mode=display">G_{lag}(s)=\frac{τs+1}{ατs+1},α>1</script><h4 id="滞后补偿器设计"><a href="#滞后补偿器设计" class="headerlink" title="滞后补偿器设计"></a>滞后补偿器设计</h4><p>滞后补偿器设计的思路是利用补偿将现在系统的幅度响应在补偿器设计要求的相位裕量处调整到0dB。  </p><ul><li>利用稳态误差的定义，找到系统增益$K$</li><li>绘制出$KG(s)H(s)$的波特图，从波特图上寻找系统的相位裕量$PM$</li><li>在波特图上找到符合补偿器设计要求的相位裕量$PM’+Φ$（其中$Φ$是修正系数），找到对应的增益穿越频率$ω’_{gc}$。  </li><li>找到$ω’_{gc}$对应的幅值$K’$，并计算：<script type="math/tex; mode=display">α=10^{\frac{K'}{20}}</script></li><li>令:<script type="math/tex; mode=display">τ=\frac{10}{ω'_{gc}}</script></li><li>带入$α$和$τ$，得到滞后补偿器的前向传输方程$G_{lag}(s)$。  </li></ul><div class="note note-info">            <p>如果设计要求是阻尼比$ζ$，通常阻尼比可以通过如下公式近似为系统设计对相位裕量的要求：  </p><script type="math/tex; mode=display">PM(°)⩰100ζ</script>          </div><h3 id="超前补偿"><a href="#超前补偿" class="headerlink" title="超前补偿"></a>超前补偿</h3><p>对PD控制器：$G_c(s)=T_ds+1$，其幅值随着频率的升高而线性升高，但是这种特性会放大高频噪声，使系统抗噪性下降。因此，需要一种补偿通过增加一个极点进而在高频处降低系统幅值，这样的补偿称为超前补偿(lead compansation)。  </p><script type="math/tex; mode=display">G_{lead}(s)=\frac{τs+1}{βτs+1},β<1</script><h4 id="超前补偿器设计"><a href="#超前补偿器设计" class="headerlink" title="超前补偿器设计"></a>超前补偿器设计</h4><p>超前补偿器的设计思路是将相位波特图在高频处的部分进行抬升，具体的设计步骤是：  </p><ul><li>利用稳态误差的定义，找到系统增益$K$</li><li>绘制出$KG(s)H(s)$的波特图，从波特图上寻找系统的相位裕量$PM$</li><li>通过公式：  <script type="math/tex; mode=display">φ_m=(PM'+φ_c)-PM</script>其中$PM’$是设计要求的相位裕量，$Φ$是修正系数。<br>计算出需要抬升的相位。  </li><li>利用公式：  <script type="math/tex; mode=display">β=\frac{1-sinφ_m}{1+sinφ_m}</script>计算得到β。  </li><li>在波特图上找到幅值为$10lg(β)$对应的频率$ω’_m$，令:<script type="math/tex; mode=display">τ=\frac{1}{ω'_{m}\sqrt{β}}</script></li><li>带入$β$和$τ$，得到超前补偿器的前向传输方程$G_{lead}(s)$。  </li></ul><h2 id="状态空间"><a href="#状态空间" class="headerlink" title="状态空间"></a>状态空间</h2><h3 id="状态空间与传递函数"><a href="#状态空间与传递函数" class="headerlink" title="状态空间与传递函数"></a>状态空间与传递函数</h3><p>根据系统传递函数的定义可知：  </p><script type="math/tex; mode=display">T(s)=\frac{Y(s)}{U(s)}=C[sI-A]^{-1}B+D</script><p>$[sI-A]$的行列式$|sI-A|$结果为系统的特征多项式。  </p><h3 id="状态空间表示与信号流图的转换"><a href="#状态空间表示与信号流图的转换" class="headerlink" title="状态空间表示与信号流图的转换"></a>状态空间表示与信号流图的转换</h3><ul><li><p>相位变化型<br>  对传递函数$\frac{Y(s)}{U(s)}$，可将其分解为：  </p><script type="math/tex; mode=display">\frac{Y(s)}{U(s)}=\frac{V(s)}{U(s)}\frac{Y(s)}{V(s)}=\frac{∑b_is^{(m-i)}}{∑a_is^{(n-i)}}</script><p>  令$x_1=v$作为状态变量，对$\frac{V(s)}{U(s)}$可以得到一系列系统的状态方程。对$\frac{Y(s)}{V(s)}$可以得到系统的输出方程。<br>  再根据状态方程和输出方程即可绘制信号流图。<br>  <img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220313141835.png width=50%></p><p> 如果$x_1,x_2,x_3$的次序相反，那么得到的是能控标准型。  </p></li><li><p>能观标准型<br>对系统的传递函数$\frac{Y(s)}{U(s)}$，如果其写作如下的形式：  </p><script type="math/tex; mode=display">\frac{Y(s)}{U(s)}=\frac{b_0+b_1s^{-1}+...+b_ns^{-n}}{1+a_1s^{-1}+...+a_ns^{-n}}</script><p>则可以根据这个结构直接写出系统的状态方程和输出方程：  </p><script type="math/tex; mode=display">\dot{x_k}=-a_kx_1+x_{k+1}+b+ku,1≤k≤n-1</script><script type="math/tex; mode=display">\dot{x_n}=-a_nx_1+b_nu</script><script type="math/tex; mode=display">y=x_1+b+0u</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220313142033.png width=50%></p></li><li><p>级联型<br>如果系统的传递函数$\frac{Y(s)}{U(s)}$写作：  </p><script type="math/tex; mode=display">\frac{Y(s)}{U(s)}=\frac{(s+z)}{∏^n(s+p_i)}</script><p>那么可以视为：  </p><script type="math/tex; mode=display">\frac{x_n}{u}=\frac{1}{s+p_n}⇒\dot{x_n}=-p_ix_n+u</script><script type="math/tex; mode=display">\frac{x_k}{x_{k+1}}=\frac{1}{s+k_n}⇒\dot{x_k}=-p_ix_k+x_{k+1}</script><script type="math/tex; mode=display">\frac{y}{x_1}=s+z⇒y=\dot{x_1}+zx_1</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220313141619.png width=50%></p></li><li><p>并联型<br>如果系统的传递函数$\frac{Y(s)}{U(s)}$写作：  </p><script type="math/tex; mode=display">\frac{Y(s)}{U(s)}=∑\frac{α_i}{(s+p_i)}</script><p>那么系统的状态方程可以写作：  </p><script type="math/tex; mode=display">\dot{x_i}=-p_ix_i+α_i</script><p>系统的输出方程可以写作：  </p><script type="math/tex; mode=display">y=∑α_ix_i</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220313142926.png width=50%>  </p></li></ul><h3 id="能观性和能控性"><a href="#能观性和能控性" class="headerlink" title="能观性和能控性"></a>能观性和能控性</h3><h4 id="能观性判定"><a href="#能观性判定" class="headerlink" title="能观性判定"></a>能观性判定</h4><p>能观矩阵：  </p><script type="math/tex; mode=display">\begin{bmatrix}    C\\ - \\ CA \\ - \\ ... \\ - \\ CA^{n-1}\end{bmatrix}</script><p>当系统的能观矩阵满秩（或者说能观矩阵行列式结果不为零）时，表明系统是完全能观的（completely observable）。  </p><h4 id="能控性判定"><a href="#能控性判定" class="headerlink" title="能控性判定"></a>能控性判定</h4><p>能控矩阵（controllability matrix）：  </p><script type="math/tex; mode=display">[B|AB|A^2B|…|A^{n-1}B]</script><p>对于有$n$个状态的系统，它是一个$n×n$的方阵。当且仅当能控矩阵满秩，即其秩为$n$时，系统是完全状态能控(state controllable)的。  </p><h3 id="观测器设计"><a href="#观测器设计" class="headerlink" title="观测器设计"></a>观测器设计</h3><h4 id="能观标准型设计"><a href="#能观标准型设计" class="headerlink" title="能观标准型设计"></a>能观标准型设计</h4><ul><li>将系统原型改写为能观标准型，并检查系统原型的能观性。  </li><li>根据系统原型的能观标准型，得到其状态转移矩阵$Φ=A-LC$</li><li>根据系统的状态转换矩阵得到含有观测系数$l$的系统特征方程：$|sI-(A-LC)|=0$  </li><li>根据对系统设计的要求计算出要求的阻尼比$ζ$和固有频率$ω_n$，构造目标系统的特征方程。  </li><li>将目标系统的特征方程与$|sI-(A-LC)|=0$匹配，使用待定系数法得到观测向量$L$中的每一个元素$l$。  </li></ul><h4 id="非能观标准型设计"><a href="#非能观标准型设计" class="headerlink" title="非能观标准型设计"></a>非能观标准型设计</h4><ul><li>找到现在系统的能观矩阵$O_z$  </li><li>根据$|sI-A|=0$找到现在系统的特征方程。  </li><li>根据特征方程，写出系统状态空间表示的能观标准型，找到系统的能观矩阵$O_x$并检验能观性。  </li><li>根据$P=O_z^{-1}O_x$得到$P$</li><li>根据相位变化型中的$A_x$，$B_x$，找到$A_x-L_xB_x$，并得到目标系统的特征方程$|sI-(A_x-L_xB_x)|=0$</li><li>根据设计目标求出$ω_n$和$ζ$，并构造系统的特征方程。  </li><li>将系统的特征方程与$|sI-(A_x-L_xB_x)|=0$进行系数匹配，得到$L_x$</li><li>利用$L_z=PL_x$得到$L_z$</li></ul><h3 id="控制器设计"><a href="#控制器设计" class="headerlink" title="控制器设计"></a>控制器设计</h3><h4 id="相位变化型设计"><a href="#相位变化型设计" class="headerlink" title="相位变化型设计"></a>相位变化型设计</h4><p>如果系统以相位变化型给出：  </p><ul><li>检查系统原型的稳定性</li><li>根据系统设计要求中的过冲率和设置时间计算出系统要求的阻尼比$ζ$和固有频率$ω_n$，构建系统的二阶极点项：$(s^2+2ζω_ns+ω_n^2)$   </li><li>如果系统原型存在零点$(s+z)$，则添加新的极点项$(s+p),p=z$。<br>（此时可以得到设计要求的极点多项式为：$(s+p)(s^2+2ζω_ns+ω_n^2)$）</li><li>$n$个反馈控制系数$-k$，并计算得到矩阵$A-BK$。  </li><li>找到改进后系统的特征方程$|sI-(A-BK)|=0$。  </li><li>将$|sI-(A-BK)|=0$与$(s+p)(s^2+2ζω_ns+ω_n)=0$的系数进行匹配，使用待定系数法即可得到所有的$k$</li></ul><h4 id="非相位变化型设计"><a href="#非相位变化型设计" class="headerlink" title="非相位变化型设计"></a>非相位变化型设计</h4><ul><li>求得现在系统的控制矩阵$C_z=[B_z|A_zB_z|…|A_z^{n-1}B_z]$</li><li>根据$|sI-A_z|=0$找到现在系统的特征方程。  </li><li>根据特征方程，写出系统状态空间表示的相位变化型，找到系统相位变化型的能控矩阵$C_x=[B_x|A_xB_x|…|A^{n-1}_xB_x]$</li><li>检验能控性。  </li><li>根据$P=C_zC^{-1}_x$得到$P$</li><li>根据相位变化型中的$A_x$，$B_x$，找到$A_x-B_xK_x$，并得到目标系统的特征方程$|sI-(A_x-B_xK_x)|=0$</li><li>根据设计目标求出$ω_n$和$ζ$，并构造系统的特征方程。  </li><li>将系统的特征方程与$|sI-(A_x-B_xK_x)|=0$进行系数匹配，得到$K_x$</li><li>利用$K_z=K_xP^{-1}$得到$K_z$</li></ul><h1 id="数字控制系统"><a href="#数字控制系统" class="headerlink" title="数字控制系统"></a>数字控制系统</h1><h2 id="数字控制系统结构"><a href="#数字控制系统结构" class="headerlink" title="数字控制系统结构"></a>数字控制系统结构</h2><p>数字控制系统是指控制器为数字控制器的控制系统，本课程中研究的数字控制系统的结构如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220609144002.png width=50%>  </p><h3 id="数字系统的数学模型"><a href="#数字系统的数学模型" class="headerlink" title="数字系统的数学模型"></a>数字系统的数学模型</h3><p>数字控制系统中可以使用差分方程描述系统的特性：  </p><script type="math/tex; mode=display">∑b_ky(n+k)=∑a_kr(n+k)</script><div class="note note-warning">            <p>需要注意系统的初始条件，如果规定了系统的初始条件：$y(0)≠0$、$y(1)≠0$，则应当利用z变换的时移性质：  </p><script type="math/tex; mode=display">Z[f(k+1)]=zF(z)-zf(0)</script><script type="math/tex; mode=display">Z[f(k+n)]=zF(z)-z^nf(0)-∑_{k=1}z^{n-k}f(k)</script>          </div><p>对差分方程两边做z变换，整理可以得到系统的闭环传递函数：  </p><script type="math/tex; mode=display">TF_{cl}(z)=\frac{Y(z)}{X(z)}</script><h3 id="稳态误差-1"><a href="#稳态误差-1" class="headerlink" title="稳态误差"></a>稳态误差</h3><p>和模拟控制系统一样，定义数字系统的稳态误差为：  </p><script type="math/tex; mode=display">e_{ss}=1-\lim_{z→1}(z-1)Y(z)=1-\lim_{z→1}(z-1)TF_{cl}(z)U(z)</script><p>$TF_{cl}(z)$是系统的闭环传递函数。  </p><h2 id="稳定性分析"><a href="#稳定性分析" class="headerlink" title="稳定性分析"></a>稳定性分析</h2><h3 id="根轨迹图"><a href="#根轨迹图" class="headerlink" title="根轨迹图"></a>根轨迹图</h3><h5 id="通过开环传递函数绘制根轨迹图"><a href="#通过开环传递函数绘制根轨迹图" class="headerlink" title="通过开环传递函数绘制根轨迹图"></a>通过开环传递函数绘制根轨迹图</h5><p>通过开环传递函数$G(s)H(s)$直接绘制根轨迹遵循如下规则：  </p><ul><li>根轨迹的分支数<br>根轨迹的分支数量是开环极点数$n$和开环零点数$m$中的最大值$max(m,n)$。  </li><li>根轨迹的起点和终点<br><strong>根轨迹的起点只能是极点，而终点要么是零点要么是无穷远处</strong>。<br>如果开环零点数等于开环极点数，根轨迹始于开环极点，终于其左边相邻的开环零点。<br>如果开环零点数小于开环极点数，那么有$n-m$调根轨迹终止于无穷远处。  </li><li>实轴上的根轨迹<br>实轴上的某一区域，若其右边开环实数零极点个数之和为奇数，则该轨迹是根轨迹。或者描述为：将零极点从大到小编号为(1,2,3…)，<strong>实轴上第奇数个零极点左边的部分是根轨迹</strong>。<br>进入实轴的点(称为进入点(break-in point))是函数$-\frac{A(z)}{B(z)},G(z)H(z)=\frac{KB(z)}{A(z)}$的正极大值点，离开实轴的点（称为离开点(breakaway point)）是函数$-\frac{A(z)}{B(z)},G(z)H(z)=\frac{KB(z)}{A(z)}$的正极小值点。<br>两个根轨迹在实轴上相遇后立即分离的点称为和分离点，在和分离点后，两根根轨迹会向对向偏转90°。其中，<strong>起点值较大的根轨迹向上偏转，起点值较小的根轨迹向下偏转</strong>。  </li><li>复根<br>如果有复根出现，则一定是共轭成对出现的。  </li><li>不重叠<br>在任何时候，同一支根轨迹分支不会与自身重叠。  </li></ul><h3 id="根轨迹图与数字系统特性"><a href="#根轨迹图与数字系统特性" class="headerlink" title="根轨迹图与数字系统特性"></a>根轨迹图与数字系统特性</h3><p>对于数字系统$\frac{G(z)}{1+G(z)H(z)}$，再加入比例控制器后，其闭环传递函数写作$\frac{KG(z)}{1+KG(z)H(z)}$，此时的特征方程为：  </p><script type="math/tex; mode=display">1+KG(z)H(z)=0</script><h4 id="稳定最大增益"><a href="#稳定最大增益" class="headerlink" title="稳定最大增益"></a>稳定最大增益</h4><p>根轨迹上的稳定最大增益出现在有重根的位置。对于二阶数字系统，对应特征方程的$Δ=0$时对应的增益$K$最大。  </p><h4 id="临界稳定"><a href="#临界稳定" class="headerlink" title="临界稳定"></a>临界稳定</h4><p>对数字系统，根轨迹上与单位圆的交点对应系统处于临界稳定状态。  </p><ul><li>当根轨迹从实轴离开单位圆时，此时对应的极点应当为$z=-1$。  </li><li>当根轨迹从z域上其他地方离开单位圆时，有如下求此时系统极点的方法：<br>对于二阶数字系统，其特征方程可以写作：  <script type="math/tex; mode=display">az^2+bz+c=0</script>根据求根公式，有$z=\frac{-b±\sqrt{b^2-4ac}}{2a}=\frac{-b±\sqrt{(-1)^2×(b^2-4ac)}}{2a}$，有：  <script type="math/tex; mode=display">z=-\frac{b}{2a}±i\frac{\sqrt{4ac-b^2}}{2a}</script><script type="math/tex; mode=display">|z|=\frac{c}{a}</script>当系统处于临界稳定条件下时，$z$的模长应当为单位圆半径1，有:  <script type="math/tex; mode=display">|z|=\frac{c}{a}=1</script></li></ul><p>将临界稳定时系统的极点$z$带入含有比例增益$K$的特征方程中，即可求得临界稳定时的比例增益$K_{crs}$。  </p><h4 id="临界阻尼"><a href="#临界阻尼" class="headerlink" title="临界阻尼"></a>临界阻尼</h4><p>根轨迹和系统的受阻尼状态有如下关系：  </p><ul><li>当根轨迹位于实轴时，特征方程的$Δ&gt;0$，对应$ζ&gt;1$，系统过阻尼。  </li><li>当根轨迹离开实轴时，特征方程的$Δ&gt;=0$，对应$ζ=1$，系统处于临界阻尼状态。  </li><li>当根轨迹不在虚轴时，特征方程的$Δ&lt;0$，对应$0&lt;ζ&lt;1$，系统欠阻尼。  </li></ul><p>当数字系统的根轨迹离开实轴或者进入实轴时，系统处于临界阻尼状态。要系统的临界阻尼状态对应的极点即是离开点和进入点，其求法是化简特征方程，得到比例增益关于z的函数$K(z)$，对其求导且令其为0：</p><script type="math/tex; mode=display">\frac{dK}{dz}=0</script><p>其中微分方程的解中较大的值是根轨迹的离开点，较小的值是根轨迹的进入点。<br>将临界阻尼时系统的极点$z$带入含有比例增益$K$的特征方程中，即可求得临界稳定时的比例增益$K_{crd}$。  </p><h3 id="朱利判据"><a href="#朱利判据" class="headerlink" title="朱利判据"></a>朱利判据</h3><p>朱利判据是一种对数字系统的稳定性判据，相比于需要先连续化特征方程的劳斯判据，朱利判据可以直接判定数字系统是否稳定。<br>具体而言，对于一个$n$阶数字系统的特征多项式：  </p><script type="math/tex; mode=display">F(z)=∑_{k=0}^na_{n-k}z^{n-k}</script><h4 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h4><p>其稳定的必要条件是：  </p><script type="math/tex; mode=display">F(1)>0</script><script type="math/tex; mode=display">(-1)^nF(-1)>0</script><h4 id="充分条件"><a href="#充分条件" class="headerlink" title="充分条件"></a>充分条件</h4><p>系统稳定的充分条件为：<br>将特征多项式系数按照如下的朱利表进行排列：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220416152153.png width=30%><br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220609150157.png width=30%>  </p><p>排列后的系数满足：  </p><script type="math/tex; mode=display">\begin{cases}  |a_0|<a_n\\  |b_0|>|b_{n-1}|\\  |c_0|>|c_{n-2}|\\  ⋮\end{cases}</script><p>一共$n-1$个条件。  </p><p>对于数字系统，其特征多项式需要同时满足朱利判据中的充分条件和必要条件，该数字系统是稳定的。  </p><h2 id="PID控制器和补偿器设计"><a href="#PID控制器和补偿器设计" class="headerlink" title="PID控制器和补偿器设计"></a>PID控制器和补偿器设计</h2><h3 id="数字PID控制器的表示"><a href="#数字PID控制器的表示" class="headerlink" title="数字PID控制器的表示"></a>数字PID控制器的表示</h3><div class="table-container"><table><thead><tr><th style="text-align:center">控制器类型</th><th style="text-align:left">传递函数</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:center">P控制器</td><td style="text-align:left">$G_D(z)=K_p$</td><td style="text-align:left">降低上升时间</td></tr><tr><td style="text-align:center">I控制器</td><td style="text-align:left">$G_D(z)=K_i\frac{z}{z-1}$</td><td style="text-align:left">消去稳态误差，但是降低稳定性</td></tr><tr><td style="text-align:center">D控制器</td><td style="text-align:left">$G_D(z)=K_d\frac{z-1}{z}$</td><td style="text-align:left">增加稳定性，但是放大高频噪声</td></tr><tr><td style="text-align:center">PI控制器</td><td style="text-align:left">$G_D(z)=K_p+K_i\frac{z}{z-1}$</td><td style="text-align:left">减少相位裕量，限制噪声</td></tr><tr><td style="text-align:center">PD控制器</td><td style="text-align:left">$G_D(z)=K_p+K_d\frac{z-1}{z}$</td><td style="text-align:left">增加相位裕量，但放大系统噪声</td></tr><tr><td style="text-align:center">PID控制器</td><td style="text-align:left">$G_D(z)=K_p+K_i\frac{z}{z-1}+K_d\frac{z-1}{z}$</td><td style="text-align:left">减小振荡，无稳态误差</td></tr></tbody></table></div><h3 id="离散化方法"><a href="#离散化方法" class="headerlink" title="离散化方法"></a>离散化方法</h3><h4 id="零阶保持器的离散化公式"><a href="#零阶保持器的离散化公式" class="headerlink" title="零阶保持器的离散化公式"></a>零阶保持器的离散化公式</h4><p>如果零阶保持器和被控对象看做一个整体，对其进行z变换（即将整个系统放在z域中查看），得到：  </p><script type="math/tex; mode=display">G_{ZA}(z)=\frac{z-1}{z}𝒵[\frac{G(s)}{s}]</script><p>$𝒵[⋅]$表示z变换。<br>上述公式称为零阶保持器的离散化公式。  </p><h4 id="双线性变换"><a href="#双线性变换" class="headerlink" title="双线性变换"></a>双线性变换</h4><p>双线性变换由$z=e^{Ts}$使用泰勒公式对其展开：  </p><script type="math/tex; mode=display">z=\frac{e^{\frac{sT}{2}}}{e^{-\frac{sT}{2}}}≈\frac{1+\frac{sT}{2}}{1-\frac{sT}{2}}</script><p>得到映射律：  </p><script type="math/tex; mode=display">s→\frac{2}{T}\frac{z-1}{z+1}</script><p>其中$T$表示采样周期。   </p><h3 id="离散化连续补偿器"><a href="#离散化连续补偿器" class="headerlink" title="离散化连续补偿器"></a>离散化连续补偿器</h3><p>PID补偿器设计的其中一种方法是对已经设计好的连续补偿器使用上述离散化方法对其进行数字化处理。<br>具体的设计方法为：  </p><ul><li>根据题目提供的条件，从根轨迹图或者劳斯判据给出的稳定条件中找到系统临界稳定条件所对应的临界增益$K_{cr}$，并找到对应的角频率$ω_{cr}$。  </li><li>根据$P_{cr}=\frac{2π}{ω_{cr}}$求得系统的临界振荡周期。  </li><li>根据齐格勒－尼科尔斯方法提供的频率响应表格完成对应的参数设计。  </li></ul><p>齐格勒－尼科尔斯频率响应表格如下所示：  </p><div class="table-container"><table><thead><tr><th style="text-align:center">控制器类型</th><th style="text-align:center">$K_p$</th><th style="text-align:center">$K_i$</th><th style="text-align:center">$K_d$</th></tr></thead><tbody><tr><td style="text-align:center">P控制器</td><td style="text-align:center">$0.5K_{cr}$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td></tr><tr><td style="text-align:center">PI控制器</td><td style="text-align:center">$0.45K_{cr}$</td><td style="text-align:center">$K_p\frac{ω_c}{1.6π}=K_p\frac{1.25}{P_{cr}}$</td><td style="text-align:center">$0$</td></tr><tr><td style="text-align:center">PID控制器</td><td style="text-align:center">$0.6K_{cr}$</td><td style="text-align:center">$K_p\frac{ω_c}{π}=0.5K_pP_{cr}$</td><td style="text-align:center">$K_p\frac{π}{4ω_c}=0.125P_{cr}$</td></tr></tbody></table></div><h3 id="根轨迹方法"><a href="#根轨迹方法" class="headerlink" title="根轨迹方法"></a>根轨迹方法</h3><p>根轨迹方法是一种在Z域中进行直接设计的方法。  </p><h4 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h4><ul><li>理论一<br>根据z变换中的定义：$s=σ+jω$，$z=e^{sT}=e^{T(σ+jω)}$，有z域上任意一极点$z$:  <script type="math/tex; mode=display">|z|=e^{-Tσ}=e^{-Tζω_n}</script><script type="math/tex; mode=display">∠z=Tω_d=\frac{2πω_d}{ω_s}</script>其中，采样次数为：  <script type="math/tex; mode=display">n_s=\frac{ω_s}{ω_d}</script>工程设计中通常需要满足$8&lt;n_s&lt;10$。  </li><li>理论二<br>对于数字系统的特征方程$L(z)+1=0$，有$L(z)=-1$，此时可以将$L(z)$分解为幅度和角度，那么有：  <script type="math/tex; mode=display">∠L(z)=∑∠zero-∑∠pole=±180°(2k+1),k=0,1,2,...</script><script type="math/tex; mode=display">|L(z)|=1</script>因此，<strong>数字系统中某一极点与其他所有零极点的连线与实轴正半轴夹角的角度和应当为±180°。</strong>  </li></ul><h4 id="设计流程"><a href="#设计流程" class="headerlink" title="设计流程"></a>设计流程</h4><p>对于超前/滞后补偿器$D(z)=K\frac{z+α}{z+β}$：  </p><ul><li>根据系统要求找到阻尼比$ζ$、固有频率$ω_n$、阻尼固有频率$ω_d$，并找到设计的极点$z$的模长$|z|$和角度$∠z$。  </li><li>利用$a=|z|cos∠z,b=|z|sin∠z$将极点表示为$z=a+bj$的形式，并在z域上标出位置点$P$。  </li><li>将系统原型数字化，并找到系统原型的零点和极点。  </li><li>选择$α$为系统原型的一个极点，实现零极点对消以简化计算。  </li><li>将系统原型剩余的零极点与P连线的夹角利用$arctan(\frac{y_1-y_2}{x_1-x_2})$算出每一条连线与实轴正半轴的夹角。  </li><li>利用$∠β=∑∠zero-∑∠pole+180°$找到需要增加的零点$β$的角度。  </li><li>利用$∠β=arctan(\frac{b}{a-β})$求得需要增加的零点的具体位置$β$。  </li><li>利用$|D(z)G_{ZA}(z)|_{z=a+bj}=1$解方程求得$K$。  </li></ul><p>对于PID控制器也可以使用同样的设计方法对其进行设计，只是其控制器结构发生变化，由于I和D控制器均存在确定的分子分母，在利用根轨迹方法设计时还需要考虑这些确定的分子分母对系统角度的贡献：  </p><ul><li>对于PI控制器，其在(1,0)处贡献了一个极点。  </li><li>对于PID控制器，其在(0,0)和(1,0)处分别贡献了一个极点。  </li></ul><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220610152116.png width=80%>  </p><p>如果零阶保持器和系统原型的离散化写作$G_{ZA}(z)$，设计好的数字控制系统的闭环传递函数为：  </p><script type="math/tex; mode=display">TF_{cl}(z)=\frac{D(z)G_{ZA}(z)}{1+D(z)G_{ZA}(z)}</script><p>找到其特征多项式$1+D(z)G_{ZA}(z)$后可以使用朱利判据测试其稳定性。<br>如果系统稳定，可以通过$e_{ss}=1-\lim_{z→1}(z-1)Y(z)$或者静态误差系数找到其稳态误差。   </p><h2 id="系统的状态空间表示"><a href="#系统的状态空间表示" class="headerlink" title="系统的状态空间表示"></a>系统的状态空间表示</h2><h3 id="系统框图"><a href="#系统框图" class="headerlink" title="系统框图"></a>系统框图</h3><h4 id="系统框图与能控标准型"><a href="#系统框图与能控标准型" class="headerlink" title="系统框图与能控标准型"></a>系统框图与能控标准型</h4><p>系统框图的级联形式对应系统的能控标准型，简单来说：<br>对于$\frac{Y(z)}{U(z)}=\frac{b_0+b_1z^{-1}+…+b_nz^{-n}}{1+a_1z^{-1}+…+a_nz^{-n}}$，有：  </p><script type="math/tex; mode=display">\frac{Y(z)}{U(z)}=\frac{Y(z)}{H(z)}\frac{H(z)}{U(z)}</script><p>那么：$\frac{H(z)}{U(z)}=\frac{1}{1+a_1z^{-1}+…+a_nz^{-n}}$，$\frac{Y(z)}{H(z)}=b_0+b_1z^{-1}+…+b_nz^{-n}$。对$\frac{H(z)}{U(z)}$，有：  </p><script type="math/tex; mode=display">H(z)(1+a_1z^{-1}+...+a_nz^{-n})=U(z)</script><script type="math/tex; mode=display">H(z)=U(z)-(a_1z^{-1}+...+a_nz^{-n})H(z)</script><p>根据上述式子，$\frac{H(z)}{U(z)}$的信号框图可以作出，例如$H(z)=U(z)-(a_1z^{-1}+a_2z^{-2})H(z)$<br>的框图如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220618121826.png width=40%>  </p><p>对$\frac{Y(z)}{H(z)}$，有：  </p><script type="math/tex; mode=display">Y(z)=(b_0+b_1z^{-1}+...+b_nz^{-n})H(z)</script><p>根据上述式子，$\frac{Y(z)}{H(z)}$的信号框图可以作出，例如$Y(z)=(b_0+b_1z^{-1}+b_2z^{-2})H(z)$的系统框图为：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220618122929.png width=40%><br>将两部分合并，可以得到：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220618123059.png width=50%>  </p><p>对每一个延迟器前后设置一个状态变量$x_i(k+1)$：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220618123935.png width=50%>  </p><div class="note note-info">            <p>$x_1(k+1)$和$x_2(k+1)$的位置是可以调换的，因此能控标准型有两种写法。  </p>          </div><p>对$x_1(k+1)$，可以得到：  </p><script type="math/tex; mode=display">x_1(k+1)=-a_1x_1(k)-a_2x_2(k)+u(k)</script><p>对$x_2(k+1)$，可以得到： </p><script type="math/tex; mode=display">x_2(k+1)=x_1(k)</script><p>对输出$y(k)$可以得到：</p><script type="math/tex; mode=display">y(k)=(b_1-b_0a_1)x_1(k)+(b_2-b_0a_2)x_2(k)+b_0u(k)</script><p>根据上述三个式子可以写出系统的能控标准型：  </p><script type="math/tex; mode=display">\begin{bmatrix}x_1(k+1)\\x_2(k+1)\end{bmatrix}=\begin{bmatrix}-a_1&-a_2\\1&0\end{bmatrix}\begin{bmatrix}x_1(k)\\x_2(k)\end{bmatrix}+\begin{bmatrix}1\\0\end{bmatrix}u(k)</script><script type="math/tex; mode=display">y(k)=\begin{bmatrix}b_1-b_0a_1&b_2-b_0a_2\end{bmatrix}\begin{bmatrix}x_1(k)\\x_2(k)\end{bmatrix}+b_0u(k)</script><h4 id="能观标准性与系统框图"><a href="#能观标准性与系统框图" class="headerlink" title="能观标准性与系统框图"></a>能观标准性与系统框图</h4><p>对于$\frac{Y(z)}{U(z)}=\frac{b_0+b_1z^{-1}+…+b_nz^{-n}}{1+a_1z^{-1}+…+a_nz^{-n}}$，有：  </p><script type="math/tex; mode=display">Y(z)(1+a_1z^{-1}+...+a_nz^{-n})=U(z)(b_0+b_1z^{-1}+...+b_nz^{-n})</script><script type="math/tex; mode=display">Y(z)=U(z)(b_0+b_1z^{-1}+...+b_nz^{-n})-Y(z)(a_1z^{-1}+...+a_nz^{-n})</script><p>接下来，不断地提取$z^{-1}$项。比如对于$Y(z)=U(z)(b_0+b_1z^{-1}+b_2z^{-2})-Y(z)(a_1z^{-1}+a_2z^{-2})$，有：  </p><script type="math/tex; mode=display">\begin{aligned}     Y(z)=&U(z)b_0+z^{-1}[b_1U(z)+b_2z^{-1}U(z)-Y(z)a_1-Y(z)a_2z^{-1}]\\     =&U(z)b_0+z^{-1}[b_1U(z)-Y(z)a_1+z^{-1}(b_2U(z)-Y(z)a_2)]\end{aligned}</script><p>接下来，从最内部的$b_2U(z)-Y(z)a_2$开始构建系统，直到用框图搭建完整个系统为止，整个系统的框图如下方所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220618132242.png width=50%>  </p><p>对每一个延迟器前后设置一个状态变量$x_i(k+1)$：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220618133709.png width=50%>   </p><div class="note note-info">            <p>$x_1(k+1)$和$x_2(k+1)$的位置是可以调换的，因此能观标准型有两种写法。  </p>          </div><p>有：  </p><script type="math/tex; mode=display">x_1(k+1)=-a_1x_2(k)+(b_2-a_1b_0)u(k)</script><script type="math/tex; mode=display">x_2(k+1)=x_1(k)-a_2x_2(k)(b_1-a_2b_0)u(k)</script><script type="math/tex; mode=display">y(k)=x_2(k)+b_0u(k)</script><p>综合以上三式，有：  </p><script type="math/tex; mode=display">\begin{bmatrix}x_1(k+1)\\x_2(k+1)\end{bmatrix}=\begin{bmatrix}0&-a_1\\1&-a_2\end{bmatrix}\begin{bmatrix}x_1(k)\\x_2(k)\end{bmatrix}+\begin{bmatrix}b_2-a_1b_0\\b_1-a_2b_0\end{bmatrix}u(k)</script><script type="math/tex; mode=display">y(k)=\begin{bmatrix}0&1\end{bmatrix}\begin{bmatrix}x_1(k)\\x_2(k)\end{bmatrix}+b_0u(k)</script><h3 id="离散系统的能控性和能观性"><a href="#离散系统的能控性和能观性" class="headerlink" title="离散系统的能控性和能观性"></a>离散系统的能控性和能观性</h3><h4 id="能控性判定-1"><a href="#能控性判定-1" class="headerlink" title="能控性判定"></a>能控性判定</h4><p>定义离散系统的能控性矩阵：  </p><script type="math/tex; mode=display">[H|GH|…|G^{n-1}H]</script><p>即能控性矩阵满秩，即$|[H|GH|…|G^{n-1}H]|≠0$，则系统是能控的。  </p><h4 id="能观性判定-1"><a href="#能观性判定-1" class="headerlink" title="能观性判定"></a>能观性判定</h4><p>定义离散系统的能观性矩阵：  </p><script type="math/tex; mode=display">\begin{bmatrix}    C\\ - \\ CG \\ - \\ ... \\ - \\ CG^{n-1}\end{bmatrix}</script><p>如果离散系统的能观性矩阵满秩，即$|\begin{bmatrix}<br>    C\\ - \\ CG \\ - \\ … \\ - \\ CG^{n-1}<br>\end{bmatrix}|≠0$，则系统是能观的。    </p><h3 id="反馈控制器"><a href="#反馈控制器" class="headerlink" title="反馈控制器"></a>反馈控制器</h3><h4 id="反馈控制系统的特征方程"><a href="#反馈控制系统的特征方程" class="headerlink" title="反馈控制系统的特征方程"></a>反馈控制系统的特征方程</h4><p>对于系统$\begin{cases} \vec{x}(k+1)=A\vec{x}(k)+Bu(k)\\ y(k)=C\vec{x}(k) \end{cases}$:<br>添加一个负反馈控制器$K$:<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220611213830.png width=80%>    </p><p>根据上图，有系统的状态方程：  </p><script type="math/tex; mode=display">x(k+1)=Ax(k)+Bu(k)</script><p>带入$u(k)=-kx(k)+v(k)$，有：  </p><script type="math/tex; mode=display">x(k+1)=(A-BK)x(k)+Bv(k)</script><p>其中，</p><script type="math/tex; mode=display">|zI-(A-BK)|=0</script><p>是系统的特征方程。  </p><h4 id="反馈控制器设计步骤"><a href="#反馈控制器设计步骤" class="headerlink" title="反馈控制器设计步骤"></a>反馈控制器设计步骤</h4><ul><li>检验系统原型的能控性矩阵。  </li><li>根据系统的设计要求，找到阻尼比$ζ$和固有频率$ω_n$，并构造出系统的特征多项式。  </li><li>设计系统的反馈控制器，并且根据$|zI-(A-BK)|$找到系统含有$k_i$的特征多项式。  </li><li>通过两种方法得出的特征多项式进行系数匹配，得到$K$。  </li></ul><h3 id="观测器设计-1"><a href="#观测器设计-1" class="headerlink" title="观测器设计"></a>观测器设计</h3><p>对于系统$\begin{cases} \vec{x}(k+1)=A\vec{x}(k)+Bu(k)\\ y(k)=C\vec{x}(k) \end{cases}$:<br>增加一个观测器：  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220502180408.png width=50%><br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220611215158.png width=50%>  </p><h4 id="观测器的功能"><a href="#观测器的功能" class="headerlink" title="观测器的功能"></a>观测器的功能</h4><p>系统在下一个时刻的状态估计量为$\vec{\hat{x}}(k+1)$，它可以通过观测器得到：  </p><script type="math/tex; mode=display">\vec{\hat{x}}(k+1)=A\vec{\hat{x}}+Bu(k)+L[y(k)-C\vec{\hat{x}}(k)]</script><p>设系统的观测状态误差为观测器估计的系统下一时刻状态的观测值和系统下一时刻状态的实际值之差：  </p><script type="math/tex; mode=display">\vec{x_e}(k+1)=\vec{x}(k+1)-\vec{\hat{x}}(k+1)</script><p>结合$\vec{x}(k+1)=A\vec{x}(k)+Bu(k)$，有：  </p><script type="math/tex; mode=display">\vec{x_e}(k+1)=A\vec{x_e}(k)-L[y(k)-C\vec{\hat{x}}(k)]</script><p>根据$y(k)=C\vec{x}(k)$，有$\hat{y}(k)=C\vec{\hat{x}}(k)$，那么：  </p><script type="math/tex; mode=display">\vec{x_e}(k+1)=A\vec{x_e}(k)-L[y(k)-\hat{y}(k)]</script><p>可以发现，<strong>通过调整观测器系数$L$，可以使得下一次系统的状态误差随着本次系统的输出误差的减少而减少</strong>。<br>同时，带入$y(k)=C\vec{x}(k)$，可以发现系统状态误差的转移：</p><script type="math/tex; mode=display">\vec{x_e}(k+1)=A\vec{x_e}(k)-LC[\vec{x}(k)-\vec{\hat{x}}(k)]</script><p>即：  </p><script type="math/tex; mode=display">\vec{x_e}(k+1)=(A-LC)\vec{x_e}(k)</script><p>那么系统状态误差的状态转移矩阵为：  </p><script type="math/tex; mode=display">A-LC</script><p>系统的特征方程为：  </p><script type="math/tex; mode=display">|zI-(A-LC)|=0</script><h4 id="观测器设计步骤"><a href="#观测器设计步骤" class="headerlink" title="观测器设计步骤"></a>观测器设计步骤</h4><ul><li>检验系统原型的能观性矩阵。  </li><li>根据系统的设计要求，找到阻尼比$ζ$和固有频率$ω_n$，并构造出系统的特征多项式。  </li><li>设计系统的反馈控制器，并且根据$|zI-(A-LC)|$找到系统含有$l_i$的特征多项式。  </li><li>通过两种方法得出的特征多项式进行系数匹配，得到$K$。  </li></ul><h1 id="附录：线性代数知识"><a href="#附录：线性代数知识" class="headerlink" title="附录：线性代数知识"></a>附录：线性代数知识</h1><h2 id="矩阵的逆"><a href="#矩阵的逆" class="headerlink" title="矩阵的逆"></a>矩阵的逆</h2><p>对于二阶矩阵：$\begin{bmatrix} a &amp; b\\ c &amp; d \end{bmatrix}$，它的逆为：  </p><script type="math/tex; mode=display">\frac{1}{ad-cd}\begin{bmatrix} d & -b\\ -c & a \end{bmatrix}</script><p>对于三阶矩阵$A=\begin{bmatrix} a &amp; b &amp; c\\ d &amp; e &amp; f \\ g &amp; h &amp; i\end{bmatrix}$，它的逆$A^{-1}$表示为：  </p><script type="math/tex; mode=display">A^{-1}=\frac{adj(A)}{|A|}</script><p>其中，$adj(A)$称为矩阵$A$的伴随矩阵，它是$A$的代数余子式矩阵$Co(A)$的转置：  </p><script type="math/tex; mode=display">adj(A)=[Co(A)]^T</script><p>代数余子式矩阵$Co(A)$的求法类似于行列式求法，某一位置上元素的值等于去掉这个元素所在行列之后的行列式的值，计算得到矩阵后，带入如下的符号矩阵中：  </p><script type="math/tex; mode=display">\begin{bmatrix} + & - & +\\ - & + & - \\ + & -& +\end{bmatrix}</script><p>然后，(1,2)和(2,1)、(1,3)和(3,1)、(2,3)和(3,2)上的元素对换，得到代数余子式矩阵$Co(A)$。  </p><h2 id="矩阵的特征值"><a href="#矩阵的特征值" class="headerlink" title="矩阵的特征值"></a>矩阵的特征值</h2><p>设矩阵的特征值向量为$λ$，矩阵$A$的特征值向量满足：  </p><script type="math/tex; mode=display">|λI-A|=0</script><p>可以发现，对控制系统，其特征值就是控制系统的闭环极点。  </p><h2 id="对角矩阵"><a href="#对角矩阵" class="headerlink" title="对角矩阵"></a>对角矩阵</h2><p>矩阵$A$的对角矩阵为$Λ$，其对角线上的元素为矩阵$A$的特征值，其他元素为0。设变换矩阵$P$：</p><script type="math/tex; mode=display">A=PΛP^{-1}</script><p>$P$是多个列向量$V_i=\begin{bmatrix}v_{i1}\\v_{i2}\\v_{i3}\end{bmatrix}$的扩增矩阵:  </p><script type="math/tex; mode=display">P=[V_1|V_2|...|V_n]</script><p>对于每个列向量$V_i$，有：  </p><script type="math/tex; mode=display">(λ_iI-A)V_i=0</script>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>控制系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>电信传输理论-知识点总结</title>
    <link href="/2022/06/08/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BC%A0%E8%BE%93%E7%BA%BF/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    <url>/2022/06/08/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BC%A0%E8%BE%93%E7%BA%BF/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="电信传输理论-知识点总结"><a href="#电信传输理论-知识点总结" class="headerlink" title="电信传输理论-知识点总结"></a>电信传输理论-知识点总结</h1><h2 id="传输系统概述"><a href="#传输系统概述" class="headerlink" title="传输系统概述"></a>传输系统概述</h2><p>传输系统的任务是<strong>保证信息及其载体的能量尽可能无损地从源移动到终点</strong>。</p><h3 id="传输系统的结构"><a href="#传输系统的结构" class="headerlink" title="传输系统的结构"></a>传输系统的结构</h3><p>传输系统的结构包括5个部分：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220611204815.png width=50%>  </p><ul><li>源点(source)：生成所需要传输的数据  </li><li>发送器（transmitter）：将信息转化和编码为传输系统中接受的电磁信号  </li><li>传输介质（transmission medium）：传输电磁信号，可以是传输线或者复杂的网络系统  </li><li>接收器（receiver）：接收传输系统的信号，转化为可以被终点接收的数据信息  </li><li>终端（destination）：接收来自接收器的数据信息    </li></ul><h3 id="常用传输器件"><a href="#常用传输器件" class="headerlink" title="常用传输器件"></a>常用传输器件</h3><ul><li><p>放大器和转发器<br>放大器(amplifier)和转发器(repeater)的作用都是在传输过程中增强信号，减少信号在传输过程中的衰落。<br>放大器的优点是便宜，但是在放大信号的同时也会放大噪声。<br>转发器的作用可以总结为“再放大、再整形、再定时”(Reamplifing-Reshaping-Retiming)，其工作流程是“接收-解读和除噪-复现和转发”。<br>转发器可以保证可靠性，但是转发过程相较于放大器耗时更多，且设备更加昂贵。  </p></li><li><p>合路器和分路器<br>合路器(combiner)的作用是将两路信号和为一路，其合并后的功率为原先两路信号的功率线性之和（非电平值之和）。<br>分路器的作用是按照一定比例将一路信号分为两路，两路信号的内容相同、功率不同。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220613105155.png width=50%>  </p></li></ul><h2 id="传输信号"><a href="#传输信号" class="headerlink" title="传输信号"></a>传输信号</h2><h3 id="传输信号的频率"><a href="#传输信号的频率" class="headerlink" title="传输信号的频率"></a>传输信号的频率</h3><p>通信中所使用的一些频段如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220608205310.png width=70%><br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220608205758.png width=70%>  </p><h3 id="传输信号的能量描述：电平"><a href="#传输信号的能量描述：电平" class="headerlink" title="传输信号的能量描述：电平"></a>传输信号的能量描述：电平</h3><p>使用电平作为描述电信系统传输能量的原因有二：  </p><ul><li>传输系统中大多数能量关系（比如发送与接收）都是非线性的。  </li><li>采用电平值可以使传输系统中大量的非线性运算转换为线性运算。   </li></ul><h4 id="分贝值"><a href="#分贝值" class="headerlink" title="分贝值"></a>分贝值</h4><ul><li>相对电平<br>定义相对电平为实际功率与参考功率$P_r$之比对数化后得到的结果：  <script type="math/tex; mode=display">P|_{dB}=10lg(\frac{P}{P_r})</script></li><li>绝对电平<br>当参考功率$P_r$是一个共用单位值时，此时的电平值称为绝对电平。<br>$P_r=1W$时的功率电平值单位为dBW或直接写作dB.<br>$P_r=1mW$时的功率电平值单位为dBm.  <script type="math/tex; mode=display">1W=0dBW=30dBm</script></li></ul><h4 id="奈培值"><a href="#奈培值" class="headerlink" title="奈培值"></a>奈培值</h4><p>对功率进行以$e$为底的指数化后的结果称为电平（奈培值），以Np记，同样也有相对电平和绝对电平两种：  </p><script type="math/tex; mode=display">P|_{Np}=\frac{1}{2}ln(\frac{P}{P_r})</script><p>奈培和分贝的换算如下：  </p><script type="math/tex; mode=display">1Np=8.686dB</script><h4 id="系统的绝对电平和"><a href="#系统的绝对电平和" class="headerlink" title="系统的绝对电平和"></a>系统的绝对电平和</h4><p>如果是级联系统，每一级的增益或者损耗可以直接相加：  </p><script type="math/tex; mode=display">P|_{dB}=∑[P_i|_{dB}]</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220401143527.png width=50%>   </p><p>如果是并联系统，则应该去对数化后相加的结果再进行对数化：  </p><script type="math/tex; mode=display">P|_{dB}=[∑P_i]|_{dB}</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220401143850.png width=40%>  </p><h2 id="传输系统术语"><a href="#传输系统术语" class="headerlink" title="传输系统术语"></a>传输系统术语</h2><h3 id="信号和带宽、数据率"><a href="#信号和带宽、数据率" class="headerlink" title="信号和带宽、数据率"></a>信号和带宽、数据率</h3><p>信号的频谱上，信号延伸的整个频谱范围称为绝对带宽。而绝大部分信号能量集中的区域（主瓣）的频谱范围称为相对带宽，或者直接写作带宽。<br>通常，一个给定波形包含的频率范围可能非常宽，然而<strong>任何传输系统都只能容纳有限的频率范围</strong>，这是限制传输系统数据率的主要原因。<br>在数字通信中，用于表示信息的波形通常是方波。一个方波波形可以通过若干个基数倍某一频率$f$的正弦波叠加拟合：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220608105104.png width=30%>  </p><p>通过实验可以发现，增大频率成分，方波的带宽增加，其数据率增大。<br>奈奎斯特提出了奈奎斯特带宽，表示了带宽与容量（理论最大数据率）之间的关系：  </p><script type="math/tex; mode=display">C=2Blog_2M</script><p>其中$B$表示带宽，$M$表示所使用的电平的个数（即数字信号的进制）。<br>在此基础上，香农提出了香农公式，其中考虑了噪声对传输系统的影响：  </p><script type="math/tex; mode=display">C=Blog_2(1+SNR)</script><p>$SNR$为信道的信噪比，单位为“1”。对其进行归一化，有：  </p><script type="math/tex; mode=display">SNR_b=\frac{E_b}{N_0}</script><p>其中，$E_b=\frac{S}{R_b}$是每个字符的能量，$N_0=kT$为噪声功率谱密度。  </p><p>可以总结：<br>信号的数据率越高，其有效带宽越宽。换言之，<strong>传输系统的带宽越宽，则能够在这个系统上传输的数据率就越高</strong>。  </p><h3 id="数字传输和模拟传输"><a href="#数字传输和模拟传输" class="headerlink" title="数字传输和模拟传输"></a>数字传输和模拟传输</h3><p>模拟传输系统传输的是模拟信号，其不同的连续幅值表达了不同的信息。因此，模拟传输对传输过程中幅值的变化较为敏感。<br>数字传输系统传输的是数字信号，每一个数字信号是由若干个正弦信号叠加而来，考虑到色散问题，数字信号对于相位的变化较为敏感。此外由于<strong>数字信号通常是高频信号</strong>，由于趋肤效应，数字信号在金属传输线中的传输衰减随着传输距离的增加而增加，因此通常<strong>数字传输的传输距离相比于模拟传输更短</strong>。  </p><h3 id="服务质量-QoS"><a href="#服务质量-QoS" class="headerlink" title="服务质量/QoS"></a>服务质量/QoS</h3><p>QoS（Quality of Service）是服务质量的简称，表征了用户(subscriber)对服务提供商(provider/operator)所提供的服务的满意程度。<br>在通信网中，最早用户对于业务的种类需求并不多，只关心通话质量，因此早期的QoS可以通过声音的响度和清晰度进行反映。其后，随着用户数量的增多，QoS考虑了传输时延（通常以50ms作为快慢的区分）如今随着业务种类的增多，QoS的反应指标也相应的越来越多。<br>通常QoS的关键指标有：可用性、吞吐量、时延、丢包率等。  </p><h2 id="传输损伤"><a href="#传输损伤" class="headerlink" title="传输损伤"></a>传输损伤</h2><p>在传输系统中由于各种传输损伤的存在使得接收信号和传输信号并完全相同，常见的传输损伤(transmission impairments)为：衰减和失真、时延失真和噪声。  </p><h3 id="衰减和失真"><a href="#衰减和失真" class="headerlink" title="衰减和失真"></a>衰减和失真</h3><p>在任何传输媒体上传输的信号，随着传输距离的增加，其能量在传输过程中不断损失，这样的损失称为衰减（attenuation）。对于导向传输媒体，衰减是随着距离指数级增长的。<br>对于衰减，需要考虑三个问题：  </p><ul><li>信号的能量必须足够大，也就是说收到的信号必须有足够的强度，这样接收端的电路才可以检测到。  </li><li>信噪比必须达到要求，信号电平至少需要大于噪声电平。  </li><li>衰减常常和信号的频率有关。  </li></ul><p>前两个问题可以使用放大器/转发器解决，但是注意避免过大能量的信号可能引起的截止失真和接收机功率过载。<br>最后一个问题可以使用信道均衡技术或者频率选择性放大器（高频放大）避免。  </p><p>定义相对衰减值：  </p><script type="math/tex; mode=display">N_f=-10lg(\frac{P_f}{P_{1000}})</script><p>$P_{1000}$为1000Hz频点的功率值。  </p><h3 id="时延失真-色散"><a href="#时延失真-色散" class="headerlink" title="时延失真/色散"></a>时延失真/色散</h3><p>时延失真(delay distortion)是由于<strong>导向媒体信号传播群速度随着频率的不同而改变</strong>。对频带有限的信号而言，靠近中心频率的地方传播速度更快。不同频率的信号到达接收机的时间不同，从而产生不同频率信号的相移。<br>时延失真会导致码间串扰，是传输容量受限的主要因素。<br>均衡技术的使用可以减小时延失真。  </p><h3 id="噪声和干扰"><a href="#噪声和干扰" class="headerlink" title="噪声和干扰"></a>噪声和干扰</h3><p>噪声是传输过程中插入的无用信号，噪声限制了传输系统的性能。<br>噪声存在四类：  </p><ul><li>热噪声（thermal noise）<br>电子热运动产生的、在频域内均匀分布、无法被消除的噪声，又称为白噪声（white noise）。<br>热噪声功率可以表示为：  <script type="math/tex; mode=display">N=kTB</script>$k$：玻尔兹曼常量，$1.38×10^{-23}J/K$，$T$：开尔文温度，$n_0=kT$又称为热噪声密度。$B$：信道带宽。  </li><li>互调噪声（intermodulation noise）<br>互调噪声发生在不同频率的信号共享同一传输媒体时。不同频率的信号通过同一非线性传输元件（如放大器等）所产生的信号叠加可能对其他工作频率产生影响。   </li><li>串扰（crosstalk）<br>由于载有多路信号的相邻传输线发生电耦合，使得相邻传输线之间相互干扰产生的噪声。    </li><li>冲激噪声（impluse noise）<br>一种非连续的噪声，由不规则的脉冲或者持续时间短而振幅大的噪声尖峰组成。<br>在数字通信中，<strong>冲激噪声是差错的主要起因</strong>。  </li></ul><h2 id="无线传输"><a href="#无线传输" class="headerlink" title="无线传输"></a>无线传输</h2><h3 id="天线"><a href="#天线" class="headerlink" title="天线"></a>天线</h3><p>在无线传输系统中，天线可以看做是发射和接收无线电波的源和终端，同时也可以看做是将信息转换为无线电波和将无线电波转换为信息的发射机和接收机。<br>常见的天线是各向同性天线/偶极子天线/全向天线(isotropic antenna/omidirectional antenna/dipole)和抛物面天线(parabolic reflective antenna)。各向同性天线向四周辐射的能量均匀，而抛物面天线可以保证发射的电磁波都是平行波。<br>天线增益表示天线在某个方向上的能量集中程度。  </p><script type="math/tex; mode=display">G=\frac{4πA_e}{λ^2}</script><p>$A_e$是天线的有效面积。$\frac{λ^2}{4π}$是偶极子天线的有效面积。<br>对于抛物面天线而言，其有效面积大约为其口面面积的0.56倍：  </p><script type="math/tex; mode=display">A_e=0.56A=0.56πr^2</script><p>$r$为抛物面天线口面半径。  </p><h3 id="基本链路模型"><a href="#基本链路模型" class="headerlink" title="基本链路模型"></a>基本链路模型</h3><p>无线传输中的基本链路模型由发送机天线-传输信道-接收机天线构成。如果考虑传输信道的衰减为$L$，那么接收到的功率可以表示为：  </p><script type="math/tex; mode=display">P_r|_{dB}=P_t|_{dB}-L|_{dB}</script><h4 id="自由空间路径损耗"><a href="#自由空间路径损耗" class="headerlink" title="自由空间路径损耗"></a>自由空间路径损耗</h4><p>当接收天线和发射天线都是全向天线时，在自由空间中，其传输损耗应当为发射功率与接收功率之比：  </p><script type="math/tex; mode=display">L=\frac{P_t}{P_r}=\frac{(4πd)^2}{λ^2}=\frac{(4πfd)^2}{c^2}</script><p>其中$λ=\frac{c}{f}$是载波波长，$d$是发射天线与接收天线的距离。<br>将其对数化后得到的结果为：  </p><script type="math/tex; mode=display">L|_{dB}=32.4+20lgd|_{km}+20lgf|_{MHz}</script><p>如果考虑发射天线和接收天线并非全向天线，则还需要考虑它们各自的增益$G_t$和$G_r$。<br>此时的路径损耗应当为：  </p><script type="math/tex; mode=display">L|_{dB}=32.4+20lgd|_{km}+20lgf|_{MHz}-G_t|_{dB}-G_r|_{dB}</script><h2 id="金属传输线"><a href="#金属传输线" class="headerlink" title="金属传输线"></a>金属传输线</h2><h3 id="波动情况"><a href="#波动情况" class="headerlink" title="波动情况"></a>波动情况</h3><h4 id="相速度和群速度"><a href="#相速度和群速度" class="headerlink" title="相速度和群速度"></a>相速度和群速度</h4><p>单一波形的振动信息沿着传输线传播的速度称为相速度(phase velocity)，记为$v_p$。根据定义，在波上取两个相位相同$(ωt_1-βz_1=ωt_2-βz_2)$的点，它们正好空间上间隔一个波长$λ$：  </p><script type="math/tex; mode=display">v_p=\frac{λ}{T}=\frac{ω}{β}(km/s)</script><p>相速度的物理意义是相位信息传播的速度。<br>根据带宽理论，传输波形是由若干个正弦波叠加形成的包络波形，这个包络波形的相速度称为群速度(group velocity)，记为$v_g$。  </p><script type="math/tex; mode=display">v_g=\frac{dz}{dt}=\frac{dω}{dβ}</script><p>群速度的倒数$|\frac{dβ}{dω}|$称为群时延(group delay)。  </p><h4 id="波动方程"><a href="#波动方程" class="headerlink" title="波动方程"></a>波动方程</h4><p>在金属传输线中传输的单个波形会受到衰减带来的幅度影响和传输时延带来的相位影响，表示为：  </p><script type="math/tex; mode=display">v=Ve^{-αz}sin(ωt-βz)</script><p>其中$α$为衰减系数，表现为单位距离上波形幅度受到的衰减。$β$为相移常数/波数（phase change coefficient/wave number），其物理意义有二：一是表示为单位距离上波形的相移，二是单位长度中完整波形的个数。  </p><script type="math/tex; mode=display">β=\frac{2π}{λ}</script><p>可以发现，<strong>$α$只会影响传播过程的幅度，而$β$只会影响传播过程的相位。</strong><br>根据复向量的定义，复数的虚部只会影响复数的相位角，实部影响复数的模长。那么将这个方程向量化，则有：  </p><script type="math/tex; mode=display">\mathbf{V_z}=\mathbf{V_0}e^{-αz}e^{-jβz}=\mathbf{V_0}e^{-(α+jβ)z}</script><p>定义:</p><script type="math/tex; mode=display">γ=α+jβ</script><p>称其为传播常数(propergation constant)，整理得到：  </p><script type="math/tex; mode=display">\mathbf{V_z}=\mathbf{V_0}e^{-γz}</script><h3 id="平行对称双线传输理论"><a href="#平行对称双线传输理论" class="headerlink" title="平行对称双线传输理论"></a>平行对称双线传输理论</h3><h4 id="理想条件"><a href="#理想条件" class="headerlink" title="理想条件"></a>理想条件</h4><p>分析金属平行对称双线所需要考虑的理想条件的界定：  </p><ul><li>长线<br>金属传输线的长度$L$远大于最小工作波长的1%：<script type="math/tex; mode=display">L>>\frac{λ_{min}}{100}</script>在长线情况下可以视为传输线的电参数<strong>均匀分布</strong>，短线下传输线的电参数集中分布。  </li><li>发送机和接收机位于无穷远处<br>避免产生反射波和驻波。  </li><li>高频  <script type="math/tex; mode=display">ωL>>R,ωC>>G</script>高频下由电阻和电导带来的能量损耗可以忽略。  </li></ul><h4 id="特征阻抗和传播常数"><a href="#特征阻抗和传播常数" class="headerlink" title="特征阻抗和传播常数"></a>特征阻抗和传播常数</h4><p>特征阻抗(characteristic impedance)$Z_0$是金属传输线的二次参数，表示该均匀传输线上任意一点的阻抗，有：  </p><script type="math/tex; mode=display">Z_0=\frac{\mathbf{V_z}}{\mathbf{I_z}}=\sqrt{\frac{R+jωL}{G+jωC}}</script><p>传播常数为：  </p><script type="math/tex; mode=display">γ=\sqrt{(R+jωL)(G+jωC)}</script><p>对于高频信号：$ωL&gt;&gt;R,ωC&gt;&gt;G$，有：  </p><script type="math/tex; mode=display">Z_0=\sqrt{\frac{L}{C}}</script><script type="math/tex; mode=display">γ=\frac{1}{2}(G\sqrt{\frac{L}{C}}+R\sqrt{\frac{C}{L}})+jω\sqrt{LC}</script><h3 id="金属线传输现象"><a href="#金属线传输现象" class="headerlink" title="金属线传输现象"></a>金属线传输现象</h3><h4 id="趋肤效应"><a href="#趋肤效应" class="headerlink" title="趋肤效应"></a>趋肤效应</h4><p>传输线中，<strong>随着电信号频率的上升，导体内部的电荷更倾向于从导体中心向导体表面移动，因此导体表面的电荷量上升，内部的电荷量下降，导致导体的有效导电面积下降，导体的电阻随着电信号频率的上升而升高</strong>——这样的现象称为集肤效应/趋肤效应（skin effect）。<br>因此，利用金属传输线传输高频信号时，传<strong>输距离主要受到趋肤效应带来的能量耗散限制</strong>。<br>在实际应用中，话音信号300Hz-3kHz的传输距离在5km以内。  </p><h4 id="分布参数效应"><a href="#分布参数效应" class="headerlink" title="分布参数效应"></a>分布参数效应</h4><p>信号通过传输线时，导线周围会产生高频磁场，因此沿线各点会串联分布电感$L$;又因为电导率有限的导线流过电流时会有集肤效应和热耗，表现为导线有串联分布的电阻$R$;两导线间加上电压时，线间会存在高频电场，于是线间会产生并联分布电容$C$;导线间介质非理想绝缘时存在泄漏电流，意味着导线之间有分布导纳$G$，这就是所谓的分布参数效应。</p><h4 id="反射和驻波"><a href="#反射和驻波" class="headerlink" title="反射和驻波"></a>反射和驻波</h4><p>反射波(reflection wave)是由于特征阻抗与末端阻抗不同，末端阻抗无法完全吸收发射能量而产生的。<br>传输线的反射有两种：  </p><ul><li>反向反射(reflection with inversion)<br>接收端阻抗过小，电压为零，电流流经短路区后流动方向与之前相反。  </li><li>非反向反射(reflection without inversion)<br>接收端阻抗过大，脉冲电流变为零，反射的电压信号与入射的电压信号同向。  </li></ul><p>当传输线的特征阻抗与末端阻抗相同时，末端阻抗可以完全吸收发射能量，此时不会出现反射波，这样的情况称为阻抗匹配(matched impedance)。<br>当传输线的特征阻抗与收端阻抗未能匹配时，信号会部分反射回发端。如果反射信号能够到达发端，那么该信号继续反射多次。<br>定义反射系数(reflection coefficients)$Γ$表示传输线的反射情况：  </p><script type="math/tex; mode=display">Γ=\frac{V_r}{V_i}=\frac{Z_L-Z_0}{Z_L+Z_0}</script><p>如果负载大于传输线特征阻抗，$Γ&gt;0$，那么此时的反射是非反向反射；如果负载小于传输线特征阻抗，$Γ&lt;0$，那么此时的反射是反向反射。$Γ=0$时，阻抗匹配。  </p><p>定义形成的行驻波中最大的电压幅度和最小的电压幅度之比（波腹和波节绝对值之比）为电压驻波比(voltage standing wave ratio, VSWR).  </p><script type="math/tex; mode=display">S=\frac{|\mathbf{V_i}|+|\mathbf{V_r}|}{|\mathbf{V_i}|-|\mathbf{V_r}|}=\frac{1+|Γ|}{1-|Γ|}</script><p>反推可以得到：  </p><script type="math/tex; mode=display">|Γ|=\frac{S-1}{S+1}</script><h3 id="金属传输线的种类"><a href="#金属传输线的种类" class="headerlink" title="金属传输线的种类"></a>金属传输线的种类</h3><h4 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h4><p>双绞线(twisted pair)中两根铜线以一定规则绞合(twisted)在一起，减轻同一根电缆内的相邻线对的串扰。通常数百对线对捆扎在一起，并且用护皮包裹为一根线缆。同时，一捆双绞线中不同的相邻线对使用不同的绞距（周期绞合的距离，twist length），以减少低频串扰。通常绞距在5~15cm之间。<br>线材直径在0.4~0.9mm之间，<strong>直径越大的线材，其传输阻抗越大</strong>。<br>无屏蔽双绞线(unshield twisted pair)按照标准分为了3类、4类和5类线：3类线的单位距离绞数更低，通常用于传输话音数据。而5类线的单位距离绞数更高，通常用于传输数字数据。<br>为了减少干扰，有时还会在双绞线外部用金属网罩加上护皮对线缆进行屏蔽，称为屏蔽双绞线(shielded twisted pair)，没有金属网罩加以屏蔽的双绞线是无屏蔽双绞线(unshielded twisted pair)。  </p><ul><li>传输特性<br>由于双绞线容易和电磁场发生电磁耦合(electromagnetic coupling)，双绞线非常容易受到<strong>串扰</strong>和<strong>噪声</strong>的影响。<strong>冲激噪声</strong>也容易侵入双绞线。双绞线的衰减随着传输频率的增高而迅速增加。  </li></ul><h4 id="同轴线"><a href="#同轴线" class="headerlink" title="同轴线"></a>同轴线</h4><p>同轴线(coaxial cable)是由一根空心的圆柱形外导体和柱体内部的一根导线组成。内导线与外导体之间由不导电的物质进行填充以固定，外导线由保护罩或者屏蔽罩覆盖。相比于双绞线，同轴线可以用于更长的传输距离，且支持更多的站点共享同一链路。<br>同轴线用于电视传输、传输机和交换机之间的传输、计算机系统之间的短距离连接、局域网。<br>同轴线常用于短距离设备之间的连接。如果使用数字信号，同轴线缆可以在计算机系统间提供高速传输通道。  </p><ul><li>传输特性<br><strong>相比双绞线，同轴线不容易受到串扰和干扰的影响</strong>。因此可以更有效的应用于频率更高、数据率更快的环境中。<br>其性能上的限制来自于衰减、热噪声、交调噪声。交调噪声只在使用频分复用时才出现。<br>模拟传输传输过程中每隔<strong>几千米</strong>就需要使用放大器，频率越高，放大器的间隔就越接近。数字传输过程中，大约每<strong>一千米</strong>就需要一个转发器，数据率越高，转发器间隔越密集。  </li></ul><h2 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h2><h3 id="光纤的结构和材料"><a href="#光纤的结构和材料" class="headerlink" title="光纤的结构和材料"></a>光纤的结构和材料</h3><p>光纤的材质是玻璃（二氧化硅）或者塑料。使用高纯度二氧化硅熔丝的光纤和可以达到最低损耗。塑料光纤的价格虽然低，但是损耗较大，只能用于短距离链路传输，比如桌面距离的传输，因此目前主流的材料仍然是二氧化硅。<br>光纤由是三个同轴部分组成：芯(core)、包层(cladding)、涂覆层(overlay)。外面还可能有护套(jacket)。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220611210019.png width=40%>  </p><p>光纤中，<strong>纤芯的折射率大，包层的折射率相对较小</strong>。包层的作用是区别于芯的折射率，保证光不会泄漏出光纤芯。同时也有加固光纤芯的作用。<br>在实际应用中，常常将若干条光纤集成为光缆一同传输。有的光缆内部还有防止光纤弯折的骨架。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220522134518.png width=50%>  </p><h3 id="射线理论"><a href="#射线理论" class="headerlink" title="射线理论"></a>射线理论</h3><p>如图，光从某种折射率为$n_0$的介质中入射到光纤芯中，当光的入射角为$α$时，使得折射光恰好能够在光纤芯与光纤包层的分界面上发生全反射。定义此时的入射角$α$为纤芯端面的最大入射角，<strong>凡是入射角小于$α$的光线均可以在光纤内发生全反射</strong>。<br>根据折射定律，在纤芯端面有：  </p><script type="math/tex; mode=display">n_0sinα=n_1sinβ</script><p>根据几何关系：$β=90°-θ_c$，那么有：  </p><script type="math/tex; mode=display">n_0sinα=n_1cosθ_c</script><p>根据全反射的定义：  </p><script type="math/tex; mode=display">sinθ_c=\frac{n_2}{n_1}</script><p>带入到之前的公式，有：  </p><script type="math/tex; mode=display">\begin{aligned}    n_0sinα&=n_1cosθ_c\\    &=n_1\sqrt{1-sin^2θ_c}\\    &=n_1\sqrt{1-(\frac{n_2}{n_1})^2}\end{aligned}</script><p>定义$Δ=\frac{n_1^2-n_2^2}{2n_1^2}$称为光纤的相对折射率差。有近似关系：   </p><script type="math/tex; mode=display">Δ=\frac{n_1^2-n_2^2}{2n_1^2}≈n_1\sqrt{n_1^2-n_2^2}</script><p>定义光纤的数值孔径（numerical aperture，$NA$）为：  </p><script type="math/tex; mode=display">NA=n_0sinα</script><p>数值孔径表征了光纤的光的收集能力，可以发现$n_1$和$n_2$相差越大，$Δ$越大，光纤的数值孔径越大，集光能力越强。$Δ&lt;<1$的光纤称为弱导光纤(weakly guiding optical fiber)。  在渐变光纤中，可以把光纤芯径向拆分为宽度非常小的若干段，在每一段中，光都线性地发生折射。  <img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220522165644.png width=30%>  </p><h3 id="光纤的传输特性"><a href="#光纤的传输特性" class="headerlink" title="光纤的传输特性"></a>光纤的传输特性</h3><h4 id="传输频率-波长"><a href="#传输频率-波长" class="headerlink" title="传输频率/波长"></a>传输频率/波长</h4><p>用作传输的光通常频率非常高，通常以太赫兹计，其频率难以被直接测量，光线中使用另一参数“波导波长”(guide wavelength)来描述用做传输的光的特性。<br>为了减少二氧化硅的吸收损耗和波导色散，规定光通信中使用衰减相对较少的三个波长窗口：<strong>850nm，1310nm和1550nm</strong>。  </p><ul><li>截止频率<br>光信号在光纤中传播的最低频率称为截止频率，<strong>低于截止频率</strong>的的光信号无法在光纤中有效传输。  </li></ul><h4 id="模式传播"><a href="#模式传播" class="headerlink" title="模式传播"></a>模式传播</h4><ul><li><p>单模(single mode)<br>当光纤半径减小到只能允许一个角度的入射光可以通过光纤时，那么光线在两点之间直射。单模光纤的折射率均匀分布以进一步保证直射。<br>由于单模传输只存在一条传播路径，不存在多模传输时的损耗，此时光传输的性能是最好的。单模光纤通常用于远距离传输中。<br>在单模光纤中，光单模传输的条件为：</p><script type="math/tex; mode=display">0<V<2.404</script><p>$V$是归一化频率。这个条件称为单模传输条件，这种传播模式下不存在模式色散。  </p></li><li><p>多模阶跃(multi-mode step index)<br>多模阶跃光纤的折射率随着光纤半径的变化是一个阶跃函数。在这样的折射率分布下，可以认为光沿着直线进行多个角度的反射。  </p></li><li><p>多模渐变(multi-mode graded index)<br>多模阶跃光纤的折射率随着光纤半径的变化是一个平滑的曲线函数。在这样的折射率分布下，可以认为在非常小的一段距离内光沿着直线进行多个角度的反射。相比于多模突变，固定距离下多模渐变光纤中光路总长度更小。</p></li></ul><p>在工作波长一定的情况下，光纤中只有一种传输模式的光纤称为单模光纤，有多种传输模式的光纤称为多模光纤，按照折射率分布有可以分为多模渐变光纤和多模阶跃光纤。<br>多模光纤的传输容量小，传输性能差，带宽窄。而单模光纤中不存在不同模式的传输时延，具有良好的传输特性。<br>从物理特性上看，<strong>单模光纤的直径比多模光纤细的多</strong>。  </p><h4 id="光传输损耗"><a href="#光传输损耗" class="headerlink" title="光传输损耗"></a>光传输损耗</h4><p>光的传输损耗如下表所示：  </p><table border="1">  <tr>   <th>损耗类型</th><th>类型</th><th>注解</th>  </tr>  <tr>   <th rowspan="2">固有损耗<br>intrinsic attenuation</th><td>吸收损耗<br>(absorbtion )</td><td>在光传输过程中光使得光纤材料中的粒子吸收光能，发生跃迁的能量损耗称为吸收损耗。</td>  </tr>  <tr>  <td>散射损耗<br>(scattering)</td><td>由于材料不均匀使得光散射使得光能辐射出光纤外引起的非线性效应产生的能量损失。</td>  </tr>  <th rowspan="3">外在损耗<br>extrinsic attenuation</th><td>接续损耗<br>(insertion)</td><td>两光纤连接处所产生的损耗。</td>  <tr>  <td>弯曲损耗<br>(macro-bending)</td><td>在敷设和连接光缆时可能会使得光纤产生明显的弯折，光在通过这样的弯折处时发生的损耗称为弯曲损耗。</td>  </tr>  <tr>  <td>微弯曲损耗<br>(micro-bending)</td><td>在制作缆线的过程中不可避免地会对光纤有细微挤压，或者环境温度的使光纤热胀冷缩，光在通过这些肉眼不可见的细微挤压处时发生光泄漏产生的损耗称为微弯曲损耗。  </tr></td></table><h4 id="光的色散"><a href="#光的色散" class="headerlink" title="光的色散"></a>光的色散</h4><p>光纤中传输的光由于各种原因导致多条光线在传输过程中群速度不一致，到达接收机的时间也不一致，在接收机一侧会观察到单个字符信号发生时域扩展和畸变，这样的现象称为色散(dispersion)。由于时域拓展，色散会引起码间串扰。因此，<strong>色散程度决定了光纤的传输带宽，限制了系统传输速率和传输距离</strong>。<br>光纤中的色散分为三类：模式色散，材料色散，波导色散和偏振色散。其中对传输影响最严重的是<strong>模式色散</strong>。</p><div class="table-container"><table><thead><tr><th style="text-align:left">色散类型</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">模式色散<br>(intermodel)</td><td style="text-align:left">光纤中不同传播模式的光沿着光纤轴向传播的群速度不同产生的色散。<br><strong>光纤越长，相对折射率差越大，模式色散越严重。</strong></td></tr><tr><td style="text-align:left">材料色散<br>(material)</td><td style="text-align:left">光纤材料折射率随着光波长的变化而变化，使得各波长的光信号传播速度不同产生的色散。</td></tr><tr><td style="text-align:left">波导色散<br>(chromatic)</td><td style="text-align:left">在不同波长下，其相位常数不同而导致的群速度不同发生的色散。</td></tr><tr><td style="text-align:left">偏振色散<br>(polarization mode)</td><td style="text-align:left">单模光纤特有的一种色散。<br>由于单模传输中两个正交子模偏振相位常数不同产生的色散。</td></tr></tbody></table></div><h3 id="光纤传输系统"><a href="#光纤传输系统" class="headerlink" title="光纤传输系统"></a>光纤传输系统</h3><p>一个简单的光纤传输系统如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220526141315.png width=50%>  </p><p>在发送端，光信号一路一路地分别由若干个光信号发送机（通常是LED或者激光发射器）发送，经过波分复用器后合为一路信号，这路信号通过功率放大器(power amplifier)被放大，以提高信号的抗衰落能力。<br>光信号进入光纤后，每隔一段传输距离就会设置一个线路放大器(line amplifier)将受到衰落的信号重新放大。<br>在接收端，光信号在被解复用前通过前置放大器(preamplifier)以增强信号，然后信号通过解复用器后重新变为多路信号传输给多个接收机中。  </p><h2 id="总结：双绞线-同轴线-光纤的传输特性和优缺点"><a href="#总结：双绞线-同轴线-光纤的传输特性和优缺点" class="headerlink" title="总结：双绞线/同轴线/光纤的传输特性和优缺点"></a>总结：双绞线/同轴线/光纤的传输特性和优缺点</h2><div class="table-container"><table><thead><tr><th style="text-align:left">线缆类型</th><th style="text-align:left">优点</th><th style="text-align:left">缺点</th><th style="text-align:left">频率范围上限</th><th style="text-align:left">中继距离</th></tr></thead><tbody><tr><td style="text-align:left">双绞线</td><td style="text-align:left">廉价，制作工艺简单<br></td><td style="text-align:left">1.双绞线的衰减随着传输频率的增高而迅速增加<br>2.容易和电磁场发生电磁耦合，因此容易受到干扰和噪声的影响</td><td style="text-align:left">3.5kHz(单)<br>1MHz(多)</td><td style="text-align:left">2km</td></tr><tr><td style="text-align:left">同轴线</td><td style="text-align:left">1.不易受到干扰和串扰的影响<br>2.高带宽，可用于长途传输</td><td style="text-align:left">性能受衰减、热噪声和交调噪声限制</td><td style="text-align:left">500MHz</td><td style="text-align:left">1-9km</td></tr><tr><td style="text-align:left">光纤</td><td style="text-align:left">1.传输容量大，支持更高速率的数据传输<br>2.低衰减：光纤的衰减明显低于同轴线和双绞线<br>3.传输线本身价格便宜 <br> 4.中继距离长：光纤一般可以几十公里使用一个中继器<br>5.尺寸小，重量轻：比起同轴电缆和双绞线更细<br>6.电磁屏蔽：光纤系统不受外部电磁场的干扰<br>7.安全性高：理论上光纤传输难以被窃听</td><td style="text-align:left">1.制作工艺和制作要求更高<br>2.光器件价格昂贵<br>3.传输过程中不易对光进行存储 <br> 4.不易弯折</td><td style="text-align:left">370THz</td><td style="text-align:left">40km</td></tr></tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>电信传输理论与工程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>✨【置顶】版权说明</title>
    <link href="/2022/06/02/%E7%89%88%E6%9D%83%E5%A3%B0%E6%98%8E/"/>
    <url>/2022/06/02/%E7%89%88%E6%9D%83%E5%A3%B0%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h2 id="版权说明"><a href="#版权说明" class="headerlink" title="版权说明"></a>版权说明</h2><p>本所有文章全部为我手工编写。请尊重我的劳动成果。<br>如果您需要在任何涉及学术的文字材料（包括但不限于大作业、论文、实验报告等）中引用我博客中的任何图片和文字，请以标准的引用格式注明在末尾的引文部分。否则本人有权利向布鲁内尔大学教学管理委员会、重庆邮电大学教务处以及其他学术委员会报告抄袭情况并提交相应材料证据。  </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>3.移动通信关键技术</title>
    <link href="/2022/05/31/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/3.%20%E6%8A%97%E8%A1%B0%E8%90%BD%E6%8A%80%E6%9C%AF/"/>
    <url>/2022/05/31/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/3.%20%E6%8A%97%E8%A1%B0%E8%90%BD%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="51220d20318fb6db7bf3a39977be8fcb3fa252bbd8afb1cdd8d11f79508363f0">d23a4056e39b7e810998c80d99c7e17f86f9f2d02bab1f8b5f4197996369e4ef4d6fe8a0660640347502ef4b44380492c51296564ae0e59d62fd305484f1f65bfb42b6ef506813f24fc8365dd3091cce240fa4ed0730f97217459c9fdbe604b128fc5ad75a636807333ab20d8d950c8b6c9755779309ab639ccdd7b65dac00c728429fd28d3c838ede589b42d80d1e498e0f30b508ce37ebf49b2cab563127dbdc355e1cbc2c6bcf47d88b1aabe70227c3a8ca993ec3427df0b7a9bd022324b4c4a19cc58f7c26672309e602e92ef32f8048a7094f70da75af0b8115c42dc81ff9f6dad877f9f07bdabb8e3127be9199b6cb2d9bd4f253369350d8fe10293b76b1faadb309da77609df71a4ca22d79d70791733bf9478f4871c9446035da17e6f62a5145f12410196dce4949d4b6a80bd969eb588bed9239555a4b8475cf5871f3d07afe0a70fde1c2df0d597ef7ff07536f08622799b69eedc9f9f1ae883b5d501b52427b37c87cde033f12959a561fabe29eed31774954628cac4b5a840f04cb74c7827b8e36c720163a3ca88fe9c31670085766757f7a20d1e752e67f5f764bd09372ee85279659f7be5a1a4e73ac9b817b691a0bfe56a8be0ae684b4bc1bf9446b882a61643443b70735658cb2229088cfb401e09fed76c8383f7eb04b2c3d69ab5343e2c62fef33d6fafd78945d9deab59050837a46b724b9966182ba690d30c77801bcf02afac66e7e53af19105170a09c73978bd3851c2046dece37ce52cf899f7d82ba04cfbcb0ba580deae9ea22720737034104318d4d947f00126ca54b26179354000f5dd946b44c2fe3a44a2943fb39eb746b563813a170ac4ad9f2abc6605a00e3b36b2e76c56858111d9559166a209288b86c8c89171648b32bc57208d8a044a44d2a2ab2dfd4abc1efec58803736015c1034c8d4256ac4eb9421c9f7d8cf3651ac199b8ebef3c341f6a2f5e4223596f7df20c48a6de78d1ec64e8e5ce4f78488daf0841abf607365e6f9ec54c7279ada14200a487e4a9aaa44a0f729bc06afb4bf8fb1f597fd26444fe3e8b3d964d5d496defac69555312d7c897f5738c793edfa70a6fea66df8c7a574ec56149a1bad2ae6c0e11e50711d0cb7742a871b7009cd9d1baa33501ded507af3f03ff22181b8afbf13fc170ea20b7eb7c5824a6fd7266aad385e83706a80b89051499e20a431608002c8316bbf75f3eb8490e6802b41afecb253346eaabe05ba11c5ae838049b28b4b6905c79423a8dd46fdc592f91b3b6d5f70c18ea20d88c883264dc2bebb1dcc990cd7db97c064805b8c489523dda1b5401d0ecfbfaabfb214a2eee3555e1088cf97e6dda323eeb2ed73440f130c75857a893c88c7420b557d3fc8ff3fab089c58ff5c453e4da9a28a9d2a38cc223199e4afccb1ddab587c82244389f85d0c758532e59bd9b44ca36b5dfeaa65744806475261ebc6a04e7a59f0c4587d92cdb21a906f82cac5417f94031511b03c118424d9f8507dab88e617fdcbd3b65e8157bab00fa38ccc90ee4cb6fba970128216c56dcdeb2292c9acce70683b8cd8df048329d226d40a1ac894c0cb5fad8a7ecc053c001bd1b2e78b4cc5fd66ae20a86729fd3d9158558f7ae8a7a9d0d22c1556b5184751f0eea039ab3272e252aef8363fef7116bc95714e4500b71210b1348abbc37c5f74770b7efc79369b3027e6f679ba9387f387b27d9041bb3b17f2e0ed4ce2bcbeecc2d0e9b1f137fdfd80bbc9d9c53fd2a9ecdd40ef500e85ea7d7553f0eaac08e6dc97e820b1e951aef420f54b3645480fd460fb241c5b8b2edc8ed1c8e342a87e7fbb992f119853e04db9d0183004f868857361d4b86f8e7731de54d852d45e687f7f587640a8770e7c159d4480b20086ac11bf32bbe16a5a6454942915bd6ea38a9ea0b7a1c69b6fa604d2f9da5ca3ab918f2a6d7237fe0886589fa24ed42626982339d0df3adc4668c48fbd0dd3bc2eb47906c5ff06ccb13ab62e8ace8d81886091e024fa3266a8ccec643dd48549935b434cf55880f11c15f198fae07421ff32460f7bcb61c493a20f2f68bd0955deb28a9fa984404960ae96f79ef13446082477a76db977be9f38a587c30e267c8d2650490a9970cdb501b4f41cdfc4bf3d5f15fa30b3ef4423c0dd69f5d831ddf4444a23b0b4ea2cd2b66e7f17e16c2232c6e7d93c894b960c08ba86c18937048ec15217605de7a6a32ab4bea0054dbc1f7d8d8d61190666a0be4a46789f4ae7328b518665424a82274225906d19b1ad12d330ebfdd9601ee0b1785eed443269e3b26c75be953cdc6fa692b17a547b09d0ef276b671b7150757cb391709c52368cb31b4b6d1384c748f1384af3c78812a3936b43f11b71eb1bf0d31c1435f3fda7412ac8f518c5e1038a2982f1547cdbc6c8c92e06e4f59b565b7746e3f63b8a09e84c06ad1759126ffd24d28b47f2ba78db3fd733ee71d03ef98f78227c90cf5d010b9f7719a56da865069f999876deaa0f7e429f351ab61c4e4d6c29242c2fe0bea3217630884471a5b6550cde689969144940ebf068c4555490ef572129b88fc3eaef911bc1d0b442b9e0452bc9ddac9de58493757061c4e33b7efd7cc6560c962fa85d4ba90e75308112fde1bc70e9d9e69cb57177cf703ee9857c9f5575c2dafa7ccd8654e18648c79e018e6feffcc2b053a1e5f10a547cb2ff68399fcb0253d88d2d5fc3e7783413b65f890636e4370c9d969266ad3649d52c2c66b4c1589ce966a488d26b5ccf3bb8634c6f116d36be7ddf8e89397056cc5802362f21991577aeca694cdcc2fb988cc43eef1646ba61a55cd049e333f7e3f9d2b6f175749c39466a13c27965be6e6229076720b503f055578b7d7be3f2667c47e77c4fd56d5774a4dcfa2a33ad39111d3ad00fbe35cbaf346698c3585b6f21c95f413a905e6355137384b828ef8efea22b329c4b044fa2f0ce8bdc696a7843a8e6c6271d075a4e5a4771b00792cbe0b4dc7a22d3426da5d27d040f0d248e0f63ade5ca0be714246e36537565838a364273a8c8e141d0d736d435885ae94a36b609f028782f38814d1d85f3e24aa70a0ff91c6d0c816de9b0c4726250ad6821de76db2125165c1ad8527ac46b62590058ce34aabdc4773a33e89e7cab412e559c4d9f013d4ab2380692963877946fc450edc9660e2ce46339f1d41b7d5d5c7c1a0d253137f120f3d08948ba48d0c5229473edd530dbe30a182fb67fd1e7641ad2138e5c95747f1e88992e4c0fa2dd07f6f241b713650869c05d76032561219d9a3005af515dd5b2c146594cb634b3d1132bbc68d3f844c4c96f4d1409bc2c8785b42562e8fa31f5608d77b3e9c6320c806c05518f93d9d1c3cf6fa3d5b94c2833ff0051822fd41108da7d1d50740f837540c1565d409bcd9c1e6db9f829e10873329f833cef6f51e311d5fd9dd7b8a7ebfdbb4b3f673c1e70e914203a08c4d838c5fe6ff615b427d4a1bf4e82a2c0dc1f6ec675b78635969ccbc339a05191b10fcd4523422ede8f89e9837e6c589d8b305741475dd39b0319d5d2ae76e4ce45cae948f0dd42817c1e34c33ae3bce2730ab54393d980f41d3a1c2413b78a9bec7364e3ba37636404d693c9f3361cfc41e98ad6b775dc747debd26b14e919fac607dad018688fcc81549f78a371ad1eb4d722a93ccb672371625b2a21baae5493f81608c61dc525276d7693b2afb4cd23334385bcec1a019ad57dedd7a10b7c087e858f5e9ce8eacd35a6fd7c96375c3a7de51f6a39061619ddf31bae7a495220cbc10228cbd760c9e3c9fe51aef04161c5e88fe0a2f4ec9e79eb828750338ab4299b177f0b2417299236eb36b3d4c66dc51c1aa6e7640e0c2c673e14ec6a41ebca81b7373cdbeca34c67095543ae06ef154e2cbb3f34b56301f7cd349b3b6885d084bdf591fa49ff7aba44864243c0fcfd302252df281f0e6ae50c479fe4fa66a8b1fe0ae67cc2884c316a0f24b96d4a4959e8940543be79b5c042b226105f881c91f13f2b5383f618b5d37386a496d813386d83cf2ce2e1dcbaae66ffe4186193264c654b032af2143d40a8945849df74bd116fdd9f3acc3c8090c04ef0206db40492046d57d545ab86e3a2ab1288eeba9550332fa2f0ef163d0823e5d4d0654301752a36b54f15d5eacd62774a5f0da8f782bc71cb9ef386d37674292dcf8217006ffb0124e873ef8f71a17b3ea1c00df4c791b1c13bac7b178e3fff6dee0a752d3e74209ec46bf1e5d9e2e41bc0e850f63ba59e304d35e2bbcd7f38ec1e29bf6981652d5b5a5c712b9c789741b1139e7309f83696f1e38c97fb3ba3a9c2b74208a16ae271956db1d51c5190b8a5dddcc3877a6cbd5194b367c8eec896dead87a9a53a85310753f3588d0ce0c1311c7b8997354f9f5ce27dcab90d65e67c8029933f84b93e4b69d27a0a509233f6fe1e99b469446991e13853406481eec5d48b4286a677b468a14e91c71beca2c0bdc2b5e96f2852d867a151744a1de571f750d0d131ce92af363f766391085d08ea167044f4ca045618b42e604fe9a7f650b3902e472adbfe53e89db15817d48825330789e1033f3825ba194a5ac330d07112cab25438a19a057f9f03d06225203719d990681b14b19f2ef6da7dd5ab9f972b10367fa0a0e3704043197b1da74e93a1d3bec7ff85b1bfe2bd30a056f4a19430f833391def9f4742948f554e6fe395fef034e0b9012a77e0b4934511dc172c1a8c5265919dc8456bba93ab9f945ff5023c8750ae62b08e99afb9ff0df09ceb7d0e601daf109320beb2bf8de1dddaa188914fb59115082adb241b4af4d34e2f95541f51efdec0962f53f0c4f646c9a722e7ac38a624c5ae631396e54e710beb7bd02a6b18e51fea5f44e29ca6e0787d5cca26a7a6b4d2af371f505ba7c6cdbbd1ab806acfc3e7081a15f17c983a7a01f0873987a572daeb8fd42edafba3c4ad4fd1a553f95a25f8baa293cb62d85dc4266df27ba0df81a37a87e61cc4a6746932b3651745cd8ec77e1175fd32e793361d6838e48d542397d9178622499ec3bb30d3183e5c003977eb1722307a7ae1d78a60ce6a638ffcc1a5e2ea572fe32560998c8157ffaa43c26cf6cf689733e601d9cca11b0f285d53fe85d41066bb1e2d5047f452498acd5e195d69a3605d1309b7bda151f3dbd3f8a417fa190091a5a6861639d68d0905c377bf15aa50fd63a051995ec02dc7eefb855ae77bdc046fbdef04d520c128bf7d483b32dd5789fba955b1f9de61ba0ebc641f06daf74bf3abcc750fe1986678990524e02a5e4f87505c73199df3ba3c1f64b5eb1a22e7827be2786daaa24c6d28964b9d1e4ac017cfd28528f1f57e6462c1699e5633ee344332fb46eb4bfa548117b5086025323526af183ba1ec8a3082fcfc44bab7de6b8aca9a6f2959a3ce562ff7f698f92b364e3829f979dbbc3e586556566551ea612014117d49386cc1cdce12c56b818b4270a9fc482b62a67ded39677050d1476f5e12d41a916dde22cc684afdf6f2c7cd1862fb5ef979dc8d43065a0ec5608d91a571f234d2ea1d129991a95e51fc812c0e4fac4992550d30ca01ab1d6bb02d90c50a09e8e755d20072e83fa40c0082ad188a68de61786b6c422e06e47bf5ed5b34fd07317457aa34ae6a41ef3ed9d020532a80add3b79236575ef45ffac736d1fee43a18da29566485124b6a139472762ca3dc0603f2fbc3142141aae18bbd1b37e42b0165d7a706208da481dfd8adddf4acd0dd3cec2e09cff4799424174a45039c49b4d7e9436ff5895ad28fbc30c2eb99057d538360b1e9cb85c98c900af07d55fcd843625eb536b88fae7e1037c9008731331d1709dd55ed3892e2ec976f016dc7c3e9468d6a960605e8b39952fa3f28cc4e222ddd5892a407981ac80c7fcf7a10516aac7e8e282d7eb4e8e66eef6c26f1bf95d022078a8155d77c2e81060f5c183b56514988f0966fee2490c52c02a592df0897caa1039ec69327ca6af56cb85a98ef62bc42bb1cf72ee719a604c1800cb04d5d1174f7ecb75d9a0138b77a988b6f7c29678412a091893f209d286cdc788f920ceec34703fecc0a61ff086d1553f877d288b4e05e4e5d732f162f8d31499a1e020867af2fb9c473d778305289a13eacb427ad72dca431ee9c8d2285ab3fab2c2bcb32c8bb1630893ed954c952f73716d8a4f6b8ec5a364b8cd39e8d48c1c493066f904af5f18babe90af3b52ef61594aadf9048108cd06a992c7aff7c840fceab58ceef75bde5f8bc4280b954a7e2249de2cbdf1ee3098b3f72894ad8dc095741cc1543105e46988b5f0a7b643e69e865d2055f8d8f3f685308e3c765ae656d828325a3f90cd345c69bac52822cd76470fe166a1045e5e7da56078427374ec64ab8ae37d85824326a99b56a59d0eb140138b22735732fedb6254c396842fdd3a8291c8aabbc81c5cc151a83c33350a7cec9a0d0704406508ea071e1eeef13d255e9648818db8e320a118876761418fefb8f673178e3dfa34fc466496ded08b0443b78868d48ea5fe5003f86515a0ef6660445d996d4fccad3ff2544e43dab9031bdf62273a261add99f8a6bb4c26107675106fc78c6264aa2f010709654dd783cbf89574f46b10143f3ecae54be3e33359c6da5561e500c50b93a5374685054bcfdeef93cdbfda7eb1b7aaf9ed42478a8b91edbb86b2bc7c5948ec76614ce068a74410ccee31365b2b7cacc40daea8dee07386ccc0746021acba8fe92022778486e38f43ab736f93007b919743fca363ab494346464840dc2b0927656f504c902fd4ef480df7314d1c868cd75c11a6841b12de08ac226acbe1fddefa51c97125db6c6d8e062ac354c808b214826e584f7e02eb44440e12a5697ff32f0fd3962ce4c78b1cb21f4f57cf2fac42787b46f35124ed427c652829b5173f71f7f243d593dda6cfa4ff3125ec8334b27195fdf3843382e230c673d3ad332261fb422bb46cd1de1fd6df2584fafae8d5ca31d0eccc3914037cb91563ac94da0b5f505efdb15bf724c0fa4b99afd7ae6396277f0410859b9532009bca4a1682f6bc1770f7da63d2e7af3b909d88372a55a5a72d82d179d4bbdf7b10624e16e4983cb589672790bfa31a9580b5c82ed39b474a17c2fbb22fe233c48c769c1103eec4ab5186a947284fca0b9d0ee56c3a7a703aa2e7f7a3eee527f5e564369b71bc73c35e4d7899d085fdff80120c094a870c40fd18116f4ca261015a5c0c0d65ab1680303018a0ae28b3b0593b59ed887e76fc1ab836742a5026f46bbbc6dcf87c56572e82eea8b44b24249f238381d4a821806fec1cdf07b883d22ef0a71d7a294da15fd8d578ae0224da6fcb5cbac89802f307b98259a25766619cea0781e28ff3e0f6091ad898b324bbddd0a354e36ae811837ba1b3854713d145e644cec7183b1fee375252572e937467a79c8075977c4850163ccd3630652855660c33803d94bfb98c03aae2fd9795f52ed947dbdaa2a771f8b4d4a91075b7e4a21cfbab0a0d313b2aeaea9d8897fbeb534c58bbf09387f2ab86a9383e5b63846afcfea0c7766b21f7eb537d4186c224203f1b27c3df1ba935e930db31f984685af4d51cd8b13b013f0d68b8551d6ddc6e59a4ac3855ddce74576c6d7fb781bb2590d1ef30a3244ec44f8400f4ac2776fa16f35ca22c9d4b199c4b8a9baddf69575c8b8fa8366fc73886cc1a0836e3f3c624042925b77d52a60e2e408b8d32af4d4642b455268417de3ce196306a4e0eeca204cc6d51d999fe60c312a88a222466e04248c0308d327a4ab482d82e3b9fbd2b5033b5ae194b0ebe3cf23358985539f538142e9fe18cb549afbf3966fa67c612fee2c12ab669631b6dcfaa01f7d5f380f2b8b4a00563ee532dabbe9ed7f8a7d71bb810cbfde371066332b1eb499b00a454d65e3d788cad3d0249eb7c6da6d95fe069344b9ccdf67cf6e184fca1d6339fcc239fa28424393d43ba0cb162b68bea5f927672a6c6f5d3327401d50cd02a52412dd06b66cb3bb4742101f0516b4d2387c476f9fd657956e158d0ca3664d2239d58c969c6099f9a10a77d0e7ae586055926dafa0c83e997e7fcb764212270b9be0876eb4a3b41c418c8b1f36b9d0e40c412d29955a701314335017f78d7801e7d43795ea4378f3b7669686d3d38dcf1bcd7d400ff3d4e5649bdaa79f26a5b51715fd79bb597ee0defc36bca28853be08d538fcc8a349d5edf3b20d0ec81320e7e398feb1fa832a278f9132b6696c774ba611e883649bee8da5a5cc29e754b4c4130e2803b2519aee38e1eb089c977337379fdb4424758ecfd5f00aea160d4ceaea7ea4763dedfa02a091b0e6c6472af2abe1847ddf91e55557de981d9207984c35c7de9a62c34557ded47b7ec7499ad9d25037833c15f44d2fc3fe23692498af816e81e7cdeada71f25564bbfa489cd4bdd63dc3d986c155c23ebf8eb2f89113fe1ccae7dfe13dd0484a3f618e2fc602f9f7188cbcd9bb073c21199d14b8fe09b4d34b70f5c70fd8273ae1da9a151bbbd1f4a5f0f4a5f1279e1bf180dc150ff331cc7a7ab8b81250da44fef0d29d0cddfcadede3d5330d3a37eea7b6d055810e0949b7bd5eeee7c1cd4dee80837fa72e8f42a4ae8eeac3f2067e7d80e0f71367e003f5dae6d48c91acc9c85011c31b18d51061394057475e50ea0abb7948b5e1b86bfada1d5d5575097c55ddfec2f60a45b84dbbb1844a7e436f115915d51627814cc242a7316a2678fa0c9ef10a628a01e2f54a3f84d51e53cbeeaf4bd8687483aa87697f0a3d145c16ca509fa833300281b226f401c50864296e80ab32d3e0e0eb91030e63d9fbedc9db6f7eb0e03adf6881af0de9f1f67aaedf1550533020b2b86b782dc0981da1d8fafc5c0cfe97e9af996b32e9184fe9c2e079c03b65e14274311b0a7769370fb6e7ddcc7b707057a20ae3f869109f358b938e0ee048ac3836e7c8223b6f2bed659175e41e90c3ab604dce0dd3b5522a035f97405f568dfb4641e59d175071f7da08fce2cbfc07328350ba312932d8f9614bf606a5dfa5a35f261b48062712790f6aa7153a82c823506b67e4bc958c02132b6a511b9d34b3b2120f4c089b8be686d20e1aff2c619ea38ffbb7d6e69f62e0439968a92ac6fa358e9d81c11fd1667501e764b8103bc92f3011d2f162639f9d4451d464b5c2da636046dd13e12f06828dc6a3cb0bda8babb66735922096670b6073c79755d582d38b4fcd82e2912c69aae497601bd1ed9f4a79bc51df3a4ae8324c153a1817e8ed4783cca03ecd6a2495d5caf83722e20399d4df019c0ae64c8e72f462ad443b216ef0c4dfd06108a5e671f53299106ec9b477afa1dd25c32b4447796e2ae6adc6d45cc9ba98770cc9b406b72683426cfde32fbfcb95b98ab7f21241e75041fe565f9b302c116fdd4905f6b5896e656b00ef3f5d6f7d4badced6f9833a46afcf04e4819fd5e2b607e96fc4a29627129077a50798a70615606d8725d4e207d5c0213e81c6b89cbf9bbe4674367de097e2d8c5cb4c01670a12dd26e74858f23707c1a0b1df2ff7d3e22bb0f4a3e8727c4854a0911cebd6af03068f78783133c829a35a17824ca7a518c0101ba35644a605d8ca0a69f88bd1bd74ba58c8f7333625b5f123d9f88c3b8d0b65b2edcdffc77d3fabd8aa583f02f50dc7b5b5145c536358fb6e84487ece7e7c70f07f27753121225d32ec484b1ae13e09b3bf224bddc696059f64d53affcb88380831629cebe6844fc095e4c20cb47f023ecde450d5ed85d5fe1ae9052cb7194a624f419fa27941e6fdd01a15e90f4fa45eb355fb7232d0cfecda3ef4cc34f3bd8c4bac92e001b608bf266af63fd4a4dc057a98f18f7015662ce0899901fa993f9b8798cf6ddb31a3d3d2e961384b48cde8a5bc4b030dbfce681e209e9ddb28e5aec850ce5541bda87863a9ffc2483490c2635762a1707f35d8dd842503a60f1e405467781d07ab9163945857d67e19cbe8250fd2597f4db4c23ea3ba64a8ed32e8049fdf076e1454694984fa07448d5c72ed139ca0d3138336620a7292f5a155e06e23cc863634e6290c0d3a1b6f8709e8f87e573f07b6319ad0280a564c3533ad42c207b6a5180a701068feb3c2332027f09b54c51d32f24d7d406b35d8b8f53351f826a02150950cf5c70914032237961f7e6e474f742696f0bd0fe756c3b995b86f471a250b73f56bc78ec461029786c6bd784151b23fbb3d8b76b809622e0707833f6bd2b83466710dfb7a5126830b8ddb68d5ddf252ea4606b7e7a505bfca96fd51208e34e3a150538a787b433cfb670769c3f4f32a87fb9ee749997305a9cc16df59bb253ffd6d19bb803493a00f2699eaa985c5d161fe583147fe161a0040139c18eb7da74608056015f1982e744f43af215423ba65499c4c7f0c5d1649fcdeb5901437af9889aa28367138dcacca0bb331ad3f82b673f5ccee20cb5518c2cdfcf2bb033d420f451995c075c1d223aebe62f9b3d6c55aa33576cde11b5af1907fe03f74a2838782bbc43dc0beebecc07b07443557d255790424a764325635e0e455f7f4b28280e495618548696caaa91a443a0cac6fd9eb10c79d1db2926d1a2137848d3cdb3191cbb0f41d7add671678f58ddae90257941236201364854d27451b01810a55101e2d6a9df2a076ead49615a83b64a45582d28a01fd43ffa143f23b4f1da2edd0d41c2dd3b8bd841586c2306d437bfe01476d2978c3f58b908f8ecb40193cb0be37f50abe1d713196a2ca315facdfa24280d05dd6fa5aa9bb9b878f862db59d4c2e02f51ea633ca8fe8fbe1dcd6ffcd6c925d0311c1635e6235afd431c3b23bf279691bc765f29178f18ef1b59245a4ed610881b2c74a1c801ce38ac18aa01ef062bc5f0152866477471f201243396082dd26bfc45bf0ab073bb304b4c480ee4e90a62eab9ae607a91f47253b891fe60a77abb6826746a338b468b2199787791e71bbbf2b2c63563022787f89a057f755e32822602dce3d19a6d83692d0002831efb62b08accf3f1b99b064f09b83d1d6766f7e8b8130d0b7b7144b4e40913d4f1819bfa3367357fe9368d79f02ab1275b5f64212d983eba9af9546ec2dbe0684b949a196fb52debe6c76c548857057aefe7e92e73d70d962ed6cf094efed3b8afbbbdb9bdbbf47003649f618c20deae85d93f00fe862b008e3e993c13ad6c32f3b9447a454a1ae6804fb6c126edc91a8dea42cc8d5264b5003508eeed81492debb3d8c20efd7f67c670ff66128be94fbd2483889cb6e4f02b9091cbfe68b9fb6fc8beaf925735b7e04840d8d32763f1cc1d7cc758b6e12d448caf4eed86889eb7f20fc4f015c1fb69398f241129f6a182c36c6413e8feab0e84ef1bcc2582c822dd07ad879f8a5fe9c3c3c06d1b5861e84daa7c7df8a2016a380b115c65d05f9cd4830452ea35c62af384a5944c5a148b10aafadf4f4424e5f54d946c431293c62b827f08eae0d872ce912cd765569739c49d4f86611ee898336602e638895d8fa762b72268b2b5bcafd6dc7930f8476884158d93ae829db1e7c020492b8cfb8e2bc084f07ddadecae82d03ea0a0ecfb50fbcac4c33cce380bb811bc722dbb09349dc638843ef029b4ee650e04d88471e477ffde2a59ca78c7d037bded6cf34177153ee6cf5b57f2c30b202b3b7171bd736b8ea735aa52a4af6130622f610c0d0589a446b03c991463d9655d9a7fcfadd7a2a343dcf64a2e30b6dcb9cda099b852ce798fd1829cb771470989a1c629a82de6f47571de81c2d628de161ec578bc3971c95c405279721790215054e9f3e89240f8abf824348bf3da17361efd0eabedc9da30c329d30729a00e6db72bb7a7ece3add373190386b77f1f50d36e842d6901bbbb7a891f72054d7eddd37e224ad428bbfacf82c49e58bb19e209f90df3fb9a13c79ee1cefe670f4502c47b9817d2f302e9557462ad3291a482e09b3c95c072438d5f85b1bf4d322361f59d8a4dcc61f2a7ee0671b99195fb08d8d0fd4ad123069a725617896ecb3daf769b99414b63e4b80b6b863bdcab8a8130c24dcda1fa36f99083569029da4c7635c953f261c5c82bbf7fa68f0ce38bac0e69a29751a9c1feccf3c7f7b02afbe2d870f24029b14c8818f145c6db3843bf4e60b824db5fd7ab725576809f7863ed68050d7ac63ce0ddb3b54665d128066e493f94bcbfce083ff7f940ba3a14d52790ac669158d45d1f974e697e915d9159690ad768a4e08ac607d759907309b20889b22f7764b187ad802e870a100b6d30eee4fd6128440ee4cb1919eb40d3a17e0130d7183cc905afe7e2e880d77a77fcb60efc1632686b569405e156c879bf3e1d5ba17f0f6f27de51907f68fdcd2ccf26c95e5cd71feb08c97dd8c2178284efa425374c6eced7cf01c79648d9eecc0384108d58b3cbe874a8ab0075a9135f4e34693055dd8c3c50488ca68e731edbdf0d0cac63d4852c68076339a37765c51c51f987718e591bf0133273b40889acb866f7823e6a2cee034243663858e9d70a1640f5e7e32a94255d080a75a3ad2d30111042f8fa766aa460addcc864cfd72233583042abd680329807edb973d2d1c14a55e662d738b8e00b9ecf074cf0b2b93ef065f43394038d5e46607aa3437acc9d01d0d064305e34b6560e712cb7f138a020793f1fb8ed2bf617699316cb20d8ed53c17ac7386c5314677ec00308edb9383c3c317becc018f122eebc751dad2611bb5b846472ff6e130d006696f28cea50e8e02f5ed60d16a0b2fdae61cea4503ac4345acda9e808086ed0d8dc5cef1a29535c6b3f367697b389176838bcbf9c1344197061ece6395b6cfe3f6f69b7201a4649696716803bb4e9a9b54faafd49d38abef620792ab43ed9537b8dfdf0a71446934a13454592d0391391e543150d2a10ba0a9dbb9866da84f0fb8cb16f527e64aff31e4a529cafd1ffa05a8b3faf9f140b84dd8aae970c03bb53e533f3ba3dc4401e884ab498cb4b0b458ff2e8c024329b6504e3b6a2e3a6fb304c32a9773cf8092a062d62a951e9959849c7bddb01ae44074b9e73712d42ebd5e01dab01c6de5973e14ba5816907c82ec4553f2abcbacab36198980d0720094171f2edadb035900983759240aeac6d94b70713d69053dfa23c002704d1f29af94e599b6396ed6c02e9c300060964a8f301af613aa4e72834913171228a6b375a39121c2b9731fe3e17f6458e60ed3641d2c3fc9d05283a61a2195dec8c150391e49cdf5b567a555c18f45f8f78bb81e0020345d63d615caad890ca41d01740c07340e4a4e9aff3bdbf634e3e18ee3cb3a4dd02890f85713ae743805eecee679c068dfcc49e4eda79841e8a37db47c8d8e633cdb031e625d729498857d9732639e5a4f21cbd44cfedd65073da99b87142bff3de938032a4aeaa43dbb729f8f7c0eafc210b0a635b5a20c2033241925217f18d2296c5e20d62bd0af5cfcf9e203e5223f97f1d0e6ebab24f34cde5545e5d73d9e217db8c402ee4769e41725b14b6258c6fc94108461330dcc045334c0b41976eae8b5a61a69d4c0c72e092e31ac1106e18ecc351fbc3d618db4c7367c065252191b11744ed15f156c3cad5c0843661d85d7fe853d69430da5bef5c9136220cd7262faaf2b12d96dc088ce7525bbdf3fe29010a048078ac87a27e980f02990a6c766f93501391167406ad71080888b765d2bfa9fe9d28a834f89c0dc99b2df49d6d2e72d07eeb399d14ab3fc5b086cf1a462fa4c5ac6c6d597be278b53989f3039c5b08f8f32ae9f34b0b9c323be9725d5920ca56ec20349c60802dfdb1ba657d4bc2dd05648398b7401d06890138e3c245a07cbfc545770e9e9b15ccb84cab1248f15600a8c7009805190ac37c4d56338928b8d5c99f9015cfad30eed728c5351abcc3f1b2762c52b8c3d3d32e7c33684612f2e6412a7723926c03b5d4e05074479a256d3402b2ba61dd0d27a4b54edf9f71aaa05a1e79a33fa40c24ff92ae6826769da4d87c5f816c5880969d2511616639cae03574b7edf18327a8d52eda5d0e9d0491ee779bc1074da217d72e500058e3a8f6a09aa796e2d86b3f695ec972f944c96bf4d5dde704e13bfac7cfc1cbb057082f0da01a665fd2059139851b74fd60c94edd3e606611c23ac0c89dabc2dd9516c407835c53b42b4290fa4dc8c40a3aa8856a7a3faa812b4c7350fc773d46577315f0d2dcc3822142a192817eafa6737633203ca542f0f9e3f74f0ee5efb90481c3458b7ece388800182b8ca21bf1bf2358bfa35b85a3d4724ca649474ab9b8d9be7466fc05b0f1cdac6087494dcb8d07fa12ff9e5829388fd94e8052e5cb8c35f94bcf00069f22d4c44dc3267c33fb791ac6b8ca8530bf63341dae2f1c26f62e3508fdba718adaf01e108dee3b1682da5e743c3e56d9b02f9e6ada1b5720b7a02cd036a1d2caf6d9e55cc685ba67e53bfd73e84691f9856d21b3a33447de6fb97a13bb63de36ce7410e8f2c309d982eca6ceed5c9775b5a4f2e5067b1599744c750621608efed809af42b0195910cc8f9a9fd41846d9f60044c3c5b5abde74da5519a4f89a85d90fc4b90adc6ac6290cbddabcc24070e48ea53c2e48cd34fb97f12e165ea6bc61ffc7f14d8df26a00d06ee02b5652c4ddafdf9d45787440b5375336cb4e43d61e6bcb6adccafaf17188780ffcacd7cac6c59f6a8b06d8c7ba086ba4a68bd1de14cc3fd5ba04aba43d55598ba78bdf1dd273e54e2bd6407fdddac7cc5cc87883027c74b2e29546707cded781bfd3fd77cdf399d05c0518fc88d742ef79c8cdffc5ca9a271a72d721013ac14a4b4f21035eca4163d0931acb686329ddc7cbbc35d91eeb3b66b815e5cbacc337d86640bc61807ee21bfa06cd7c070949dfd949633a5c42841b9bcfec529dde5bc0711e54f7afe3437a9b62cdfac738df1b51ba198f8c812898c5516444a974322a588d11a791f4453f3b3e4064eb40066f5b4a7e6fc5b30bddc4e9c6246a371a3e8507c0c2eee0a63a71ffec02ed2c27ad78e5f271356dfca074139811834cd00c2160c8002e4044021cad7a05c3065bcd2a22d6ce6a280ac43f4e7cd09fe204ac24b91f44fe2f9f184cd9a184f0241ad3a3eeac7ba34bf87e32c0ca0ea56a395dd20991e80d23d3831477adc7782dc09f1abc1dcb8fc6ce711457f1cc6e5b913f03a9add190b0a90b061eced322a9135ce84ecd4c8936da9edfbecff6ffa9f3fcd380c07d4f19eaefc80c04f5c3c7a69a5eb95c6fca6182f5e4d1af5606db2e60aa4a6b5f83134fc6ad5e415243de52733ba688334a0dd30052c7673fbbc9161762a74364662612668e40284c73d55265398990e96fc233cec135bd454a6546322de2a2e2e3b6b83da8fd217ae8060ba18ab4c15b0e63ffe748473bab89f01a747d60ee8f540b4e34b10ba06c0a025ab7f73dfb93f0a14e88ff53d9fddcfce3feadf793117541986919fd516d9795e4656a84bb6219d595ed74d2354804212e2fde26caeaa4b15ba2401f1357b7ae631e6246b64d362ed2466479289799b6456c1fc04d8f85fc70a2a4514e7d02fb50b02492a5026777566096ce6e5296a89b1d4a78fe72eeddf832a4da9217cf57189119c9365bfe15e88b9b2e9336e4d1ff94e437bb94e187a0c4b1171c3b2a48ce08991b0ba263ca6b4e87203565f3ad19648ff30a1a45e77d8989be08fb8d26b30686e40ac909f44bdc356d9d9a527bee6747d58b90d9622103137897401f139b20d7fd76c0989466fe2a8a04877105a883c7af9e2d41664a2f828cd1fb8e313848c8394358a1d37df880daf6cefe49bb22dced38c21632e163a526b130d954962064c4950edc19a6a29e1288dbeb5e303119e8bd517d9185077b097d533a0f04ad8071b06534ade8666507832060d3979acc8d39134957d33f88c1d3fe177014b0c25c04ff8549a77e3cce7297a20559bdddf3488f83e3e7d05a933ceb1cb48dd36f2865851ac5f5af20d3dafa05d5edfcd798e5fd17ccafac68e0a45dea8c5328f18086c0ce3cb42bfaa5fc8e3d6430e2411ebbd8a11860c63385d3e4059171f2cd567b97ffa2db5d5b7c52d5b25cdecd88bd74eb68f5a4202f8b04a77f337b85466860f0742215e1b816b7d3e40cb2192598361b41179bd8b9963374cf3ba9737a933584771950131b75fc0dc1450a18064d4d48529b850cbe5512ba6246a26476da0e820570690c915c7be356463fab5e205b5bf75d39fe3efc9137cfb37bf27a7eec6258a1aac89380f68d7f7003b890094b20d898e964da2f1dbb18b6ebe11e00ebdbf004d0741af09f64c7a011efe5f91dd1cb66d5d4182cff9e7be17d043052d46373a3229a9f19f7be54a731b6b98555eecf2f453d100d6686c659e24be973a4d149aafe076da39f778c61a2aced00642c295e4021d5a60f4e58095c0728ff9e579a17cfbeaec9abdf1a63df64c789374964a969fa15a9b7241e8035afc20b6654e35eb0bd66a0af6d116110e22cd06bf45638b40d100ed08fe74466ff1b0a798e24aace4d4af8e83ae61c9a3f5f7f443b14e0ee3d9f2cec3d32a5a82e5052ff5c57adab5a544c6104e003196610f8053eaa64dd0e09ee8e09f74898a3b09f167244e0cda16f1a9854a3af94ab49d7eea43f3db82ad7a32d7aa3519cd4403f9dfd4cb14ee99455263a2f0f0cdb132cdb41b8b7e14ed457d0516b700f9c3be88f16c8ab339436d0930259e0ba0a4d8240e6b04b771012f196f2315673410929a9129b8fb6ea2975f405af799e299426f55b059463271d125698d42a03881b9eede38416e56fee5f537ba778c15e8ce88f2c556c29c68c6384096f60a4996d4becf1425b8d746e1ca795a3c7f8345cc7e75d4918352e124964303cf774ee86730a3e7c5bcecd700a13a31de39d493e2ffdfcfef63e7174759932053db2bf3429df33de7ea489c141d4c7d0a41bc3dabc28eaf8422628f68fd16e76eee7101d73662ce22ed1cea18e3a4c998cdad9ca874de860a3bf62d2e9d8f28810fe36e77a8002e4a49e0ad4599fcaa1e21464bba6dc0b70b9a31864f75967c3bd6b77473188973d3659765a48d11104fa852736c32fdaa302b3fee986fce42d13ae9b65d22231833f9020ac7d5e63360a7c52b2eb177f9e143ff409a79fd698641af9fa0a0583859425209cba76a5aea4a430878f2d7a70dc45084335dc9d9324e41637cbcfccc685f18bc8a33bb4c3a642268753aa8d330feeddf88a143026996dba764bb1cab4d02cf7cf6ab41f330924be66797bffcb5d682481b11c71b138cab8021d4246759f1aeb557c6c71040bb637fe81feee5b4b8c3b97472bf79766870a364ff86ae326398f67bff4e1c513e6c84cdf96cb2dbde714b5d21f89235917180334055db2f8db4241faf1684bd2ca7c0b1fe65c4fccc660595b91582d72189be7f72cddbb407730cbb141244e7da7dd6725879bf2e48b6f849beb987b0b0f437d03c5d60c3d6369b276968528cec33b5c41acf1db5e16ee365687cb0e139801b7fd99d925c749eb9c7cf2d2657239945e0a94442e1fec90cb2e8f6dfb2d66659a0225d1fcf306b9d530fde3a463d929ddd739dc7b8e4a39f078a470c13eecc8cf101764dd9e1959d0e71ea5e3b733bbc5bac3490c6c8bbd5fe14156a3283dc8c1c0eecf1177a1824ff7794a664df6efd10a12c5faf9c95331c230208ed1cda266ba5d004821ac636165e104a1525814bdbb7c279e4209d4b4e0c2ea9717658ecd3d5e13b534880e989e7d3fba6f2581c2aef2896ef18d4bff49a04eeea9b2125eb07cb7b4ba553d2f0b5f115c5ebb522f7b31c7724d331a90fb5a634a5e0b11f27de29f7ee96e309b181acbfa20e6b6ec7de04b8468244f81f58dfd44fa4d6072421487dd1622a12990ba8b16a9d0c49f4f7a51a2663c55e4ceb9789fd37f89a996c570eb58677a0804c743d3c7df76caaa8aa221da63c3667621380a21b436367e5efc32c217f796a2ed2139ba8f93cff428d83792253c1c660ff738e4a5e266d5e11df063c441376d236ba7d046598e06733df91b182fffc0a2adde2f9f7da2a26ff27f1c5ec6840c1c8bc152b901485b8a8fe56317e0bc3bebe0dbbe064a59b92334c0ac550e57afbff1ff8bcb9ce405a48b2523a2e6557f86d95cd0f8e8d2407744dcd9e9d4d5b6797c34f2f12f332a7cc05dff9cf7e43e85d4d8a557e08f387cd93ad3eba4474a30b2f18b0cb4f4041fc72394b0803da0cccdd90ef0257ad2d94652d4322aef0de15650a0deae3aeae076d7d264c0f7244232d18dc0315154115125901842271d7a9baec6f2583dd0b92f79ac72428a7202213b67cc51470413b3f21a6aebed4590b4a60553f8d019dc62e53e936ba9180690107846c3bdc0c1ccf0a92ce67658a68c1fc5af2ea9c1b8dae0eef8300be125420ed99712e7c3d2da77f401451451b86b1a2b6f8b9c93fb4b593ce4ce375b3ecb7ff2682a195b5f8680fb5aa3a6aa8f655047676a7aba2b429d3d983b958a642bb2e03751c0b8bcd7ca03f64cbdf4055361fb7494a1bb8a2f4e94481db9573322dd29fc46890c0650142308c311f8026e3c2238f7eaa50dd33264bc1e8dd392f3fb79a8c5d771c750296bda7f8ea89b6e6f221abc2017bc55d47895e6ca18caea25b8cec649cb50dff825ae2fb532ecbe91165adc7c5e28b8d2e982e1bd22f1f441e2ca3053157ed9f428f2606f6a74a7aaadead17716f362360fba1dcf55ab349b547e7a45752a767de3c628ad694878b52689ae933b3d1b1b023bb4f5fcedd2942715edbbe4386c9595d7d00969878aedf8d463fa476c56ffb9694cc74dc1a892dc2b11a3f17e1af6a48e13eb60f0290cc53431a5270ed723f78b46413d816c959f89bdcaa84686e45246f55adf22ef1df7a5c89712e5fe3d66ff182605b8e6e07f373cd7fd10d5a048f45ba618d9c2997c2137067a1f9daa7eb23f2fdbfd5c2f20ec2362f9f99eb3aed9b99b066b66720a93effb6c59abfb293d3ae9999758b36ffe4432a25d9310cb475e15c25a15fde3ff0b8469b7220ff0b1fb762dfa51791234458b5fbeda07746909825ac6a9995f133f07709351ea44d1e24535d2192e71a52302603cf0bccd6822ad2c9990cfe7fee804092cd6ce006e3360eeb1515943eb4d3f40e328b3255652e21e7f53ccec9fe60e26a39059dbda054573bae72e550d62d1a93148fbe04e488894057162f30144f34e6df9195443cc8b510aaef55e5a1c0144c2d63a6f5191a66b5c23c6acfe04a464cf10670a81bb0676e58ddd9a6d61cb57c92785fb8559f075cbaea93f8aee268b2f79677c3870618e7f6c28127acc5d59be30f69451e1ed4663a7412670c45a845914955a5ce4fe023df1d5acd86c04fe415954bdb5c51718a159b79c83c19c55365dfc7353204ab56811e8edea2408e53926aff8013740e2a536503fb7174aeb6a8951705833f2e03d924b1e8c909ab86bca4fdcbba902520c19c42a3438ba324a7b0ee751b5e6f3ab57efc7c5e02ce0bb6ee19ad89fb6bb5697185a3c43e85c4e3fe762f8aca6fda66f0d43ae4487f5f252d103741a5468fb9cf21348378e137ae56c1053610456173ea136e53743fa21eba3e8c0d8d5e04fee9bff698b7d9f922d5f6d96d3b6d6022493618bee63eaa1b4f32cd975b275aa0f62c6cb9f708b5d4e862934b7ce8937b207abd01b7002572281a7559700d709a9edf55b66fe8c59cf1d99d7825d41845521511fdb3ee839f222cfd27065f3d83146d22de527462e0f717f2d5fd081dddc4b043f9104128405420e67c8f6a09abbe2267eeb173fa736eb76663f4180d53479d2c94483d189a4bba5352836c0ff21d8233dc53d85552a7af23660a62537d912eff83bc356fc78bd14540457ba5d7e9460dde766c15959966a700ebb1ea4aa9968bf61236ae6054512c27cf1ea8d1b0b743cd66a3a1a5d419e072cbd6496ac97ad38dc02daddc219afee051e41bce5fd9d092944b1ab3b5721bcf8bb53b07a8c600cb94edd82af3f99a7398d54f87b56844a16f8cc2a5fecd08037da9dd7f33b892f2a2cfe43f00054c00086b68b31f7eb53ae039213e1c4439b1198c04203e46c525c7c35f7f411e57972bfb9ed02537a8cc033263da4e5ad0da9438a9386e71ea9088a4052813051852fedca2597ea06c9c5d93d985c6b71bbda6c7a787f91b618623dd0f57c190ab3b830eeb76e0793fd89df199fc30a13628755d8740b23e4c084f89db2176bae1406d1fc3bc21bf40db609f3a8012e5b9bd3b28c0c93c51d2abb8b9f285ed38b8473502bcaa24e5371feba350e9405dc62749706135e09343e7bf318642867f65d7942c80ea8f00d7178d6262e932299659e5c4df13550fcdf2b8bc2a8b557d505e494142c1c2da4eb7cc81bf9fc02fdbbb767c3ea398f9e8e6badd1b09488f158c1f8516f7007ceca9c5dba29f3f30da39217f596e9ef6097d5199a4888c5ccb649917f50add167feceb0f253b6a049a2bebdefbadfad565700b3d0ca299da5cf2d3dff89ea6689332e2826247d200851960b734ac86b15de3ddd2b727de96e7349f3a8997e6cff56f03f8600653a670bc96f9aba72062a7226aff624f8f60996ffb83eac475641dbf38139cce4a256a5d5d0f3b23f8a6457f6db946e9c742e589287e75fb8eebb22fe1c2efe35ff792b11ccd3cd2af3f74e2708842ff5c41a61116e253e1171d181c26d46bb7a85810ddb785eae65ad9a9d4cbef50b380071eae40e891c9957726c1452bd4a7d88b1928fcfb46a958226f968021a93201e0f4e0a2cda4c8f735046df5c8a5b5e34cbb0818531dcac20bebb4b2080cd1a2ee2124f7f623d613412fb3d61b9944b29ce28109fff54a459bfd33048f52aa8fb09e0df429e256468c76981242b33251bb36bde4f75a5c1a23676abc3ddad816da33a503b69dfe23ed2ec49898e99de34769a633433782ec1c5ba6528c3b2b177605c4a1e8394b8fc4467d31c0d3bd297e7144165fd9d9e637926f210f433f7729146bb264d38464c4a04d743a779a471ff5c4ceaea87824596badfe9f7f480bf50c488220913822dff794fe8f7211f311647db6b1fb93eead23278ebe2201556212508d61294a32a56c25cd3371ff20a4c5d24c55cd982e957d92552a2249f5283c86e5ee379299eb1c60b2a4b8fe6f6b7e323f4473a9228e92036a3378bcfd4df35db3c8c5c10c0b5e125eaa668613d93e4e5c10f0e7cb8e11511e6e94f49717138f9b8dc66a4faba9d5b1f6521dd6623af5c8680dcda5eddf194e160e2cbb074ed2149f236716f4e365884403ef0faf55424f7fcf16e6551ce587b3eafc5931053a977a22e1922b7c0a14540dc69105bf7ed3a09121edd226d2a032fb2f05edd44082ceb6cfa58ac7c80919c4f47bb578ea60875c1e2305cc6355b0b2c605118aa4fc015a36a4cfd53eaeb60addc0f2154468e45467ba5a3c75b20365e82bcc5d9986bb2ad472a8f12fdf3db84d08c214a4a5e6647ed56e3bc4bc68db10d0c224c19181ff2ce82ee42d58caf9da60d004e240aa22a52f79635dda3cdc60e4f11ee0ad32dbf1d600086cc9432008b77fdf3efa1ac8fc764392722a0d8cc88ce9d306dfa68e0aad937d362983102cae9770eddc834f48e4292c604b89fd5c3c048772a9201cecd30f9e6cae810c89380ccd4cf9b2723bdb61d730de3a9973b0afa963c96a79f3591f4d9f346f817ac30f7f2a07dcc32e354dd0e3df907454a7a652f7b8a569df23c10b42cae9ff485cdfa3038dbb72d3bf9be1882e2f9634318cf8676ca8f07fd314465dabed79874711fa06beb7f539c63a4dc0dd5071e82fda4d597281829efd22da2b2889b49124a69672e54d0631762049f1eb0e2314b6a808e93a15b256edd952e71baa3324876e5b35d955edb83c42de5a14677f376cf18749ea106025500299f6b3675c6fb7d2b4e1106e84e377d323e92f131a5a51fd518f1b0fe48312212ae1ea4ea26c3372f58bcbd484834ca7576a401ff8ebf1a917c7d00b02e0d49daf89b0e337877d988ef8e795a2a86761734b25adb853c81cd5ede7c161b56230addd828a7c20e72d18fc5e23024803d35ce0ba3632187e7947bd49b71830f1a9ff3ebe2f9eb4e2c6ee44de3c3eef6f5a0607cb35a1f470877da26779038b8e7b156bd75b2eb102c5b5272c2e2af9cf78b28bf329d614a36a0161089797483156e14a751cf147913cdc25becb54b5b3a2df2606b6effc0be3a81a0414a7fa1e3c020d48c87eb1c096aed939cb89200aab3c78d0e535e0e663862f32c1cf4ba819ccc8e607e2c51dd91560d0ebfdebdff1088d5ebc79005d0795a2de79159ec5f599762e5ff6c66a1c77a5419e0b8d115f3ef50989c47eba774823334fb0553807c7c611a17566500845d0913fd1ce37a3685a88b62e61ef06ae057996523c8b7b85344501b02dc5d4a9e427ea1ebf66f133d295faed49bb593eb50a163fd9b0eec57f5626c60d0118022129edb0908dd4b1890e2f2071477c605a929d1fc12ce1da2aca12585e98e831046cb88409fe5b409d0ddddeea4ea67a685eeb9507d6525d40ecbf9ce74f8e10896327c47df30e31f7844da017e58321dd74c92f0510b3965686855c104dae944d6124eca31d70055e400da06f97ee7bc28fcee8eb06464415dc289491ff4d7811e2314c9dd5cc440f7a1b45693b5e719b495c327e16aa890c2e937c3f8db2f23dafb81adcb69e55b0c3a83e41b8573b33ad3e804c0f59774134ab7b72f400313ccddb6c1b419ff45d51a535f05f96fbc8112f4844c3d49a3185706bbb76e65d3e2257f21ed5e647143e753aa80bf3f9ade816c401955775d6208c60b9bae5c3d3a5d33e6a6fff64295ce5275d10939835aa160080eee2a0d45fd0f2356ae754eb0a18b73fe378e9d470dfddfd8918440a236122d5944091f4cf62ad08aa7680ab0a1f24f8eba84d744e01a82b9b88d20ca0bf671fe15ee0e1d8fad79d73d1d802de13c384129be3441d2b882186c79820c034e29c7a7481ecbd6d41700df5f1466224c1b5a9a020f5bd01d785182c08ebcf31d4ff1408d044081d3c31fa59152f5a31d6222e71f74df87ee33db9c23cf63cf2721d9318b19dbe2bd63bbe1f2f1eb839fd62e9bab1f301ee86b07514049480880372af31e916a182bc56e03146962ae6d03cdd88d1fbde6508a736f66173faa095620c3cd9fc90b96e4902cccc4777cb9a01882949384d634407223eab67927ac2b8d7d775c087ae8e9019adaf924c1dc0300fc48410ec7c610e0cef21090983de75a623d5a74e2666e2c8cad6322eaad76214117b268605bdab9d4729e111a0f9acbd330ce429689b8322caac3e9cc234c87d836724183623e97186eb2ad63a26965ae41062a19b69c95641fb1ec8fdb56f2cf5543080209ac6223a3f2b5c9454eaab3ae3b313616cb27d0c67441d6b9f3c6f639ac1014ae90aab693e5d25f2784109ec3b84abaa21d7985df67bd6bc3c3f243449b7e4301e35ce946aa494abcd43af01e8f8fdb3b1bc362177ed5924e091b494bb8a85c211a031f10802dcd314c6b5baa6e16d841b60af632e8e635684a5aa364222d1649932d1edf85c90637f655725cedd30c782f2f5f8d2c55483a6abf14f468402abc60396caf2cffbf8f52f56c0a22dbc42e149ef12ac44870cda61e12f67f943f9e3ce727db8649af68875b6122900dbd6818f55da5cffec5ec51b68a505e360b55c7bbcaaccb83f9387489ce2be00ba9fa0674a252f1410a69bcd9c270b5d16602349beacc7dedd0277f8b061765e49ec66be705e90d3f128b4ba75a3a998723a182c5513d7b3395c5d242396c630a766c010043719ce3c68946322e17177e76598beb780ca638c0fa6ea042e6b58487bb8f7ff61d6464cb5b5bfc7ba0402cb056e0639876c2fe10be5a0a885b5d43c7f28c629bca300226731085814227b950657daa07f6243c5335ae4874766e2b31b18389d049960a3c806311b7f5722de89aae4aba688bdc5996f828e2376edf90a8f9d71ecb31bf3c0ab43ab3c0a806e756b38a519cb8bd5987ed808063f72949b7e48c05e8815d4040c42673b9a0d4a5306e2fd3e8a0a0672d38834832752aa78d149a776f24cd193d74559754d8011fb5456a06f2a0ac6fa741e207c2897af4bbbc955a888438203f6b136295cfea87fee0a98b2c0acde2aca23510789ce8ccfaa4c23d321b44df7ace25f36e70e1be9f9b58f6d8ff5312f28e9b2cd63717f0bbe3a92aeb7ec4f3a2b2757c60a88d38d04fb4b104d97a5d0f8b9cbeb531747caefb7d9d0b00acffd0a56f0da87f229918161befe27ca9709785ea1506c465ab7e711f00c77a3ac16ffccda2d51bf1e1e561ed5e8dae2585694f5d9964f8f39acafaa41788b6eeb2b33ae05e771a25e77c691280fc67fd4d238dc8b2b7d5407488bae466804fcfd2a7d1efdf7c140cab3bb58f115c32f7f6dfc5763200c92932c7bb4b1bad2d6c0de5e51a951a5373ae00f1c117c1303b028026d57aaa1ebe04eb1376671d535d96d0329f12572e2ae41f3302065d3b46b1b14359fb4b576534ebfab18124434b8c6a9c7da27053c4570c9ba5d84b0430a7e9cd7cef408f7225ca6678854a9303a8602885a65812035287325bfa43dd2f565fe38bf455c76119cb5e59ccfa8237e8f4930a14727141576428f6af5fd90e39cb2ca71859cad5983c3f14f9d318c297651c2c90aad35634ef9786dbec8ef72b34736d33e8a011582011a835e3de133fc2c0ca50b9e562f58b2e6adc8769004013d662650d4fcd95b97529ea752795324f61653af47ca02cdea332b8832c419503cb368bf386db3d81fa524eb8ab509b8d8d2e0563b1a951618d01a531ee555ae0d8311ba55e4eb71bb4f7a865bbe3792295ab4af1b64e397058e0e6842a52c5dcec3cad5af158239a3eb70c6b5d9c2d35497e703152cd287319d675ae6464d8306d4909fb6ea1e084252394a865bc824e979ffaeb4679c2bc9f25eb6e1febedf3c15a2ede57e77870581f9d2fb1345e8c415bb2643059e250f84a358fc8c6d9bcf0c6acd6faa250bedc96c04e9d9a35e548e26f40b84f9ddcce5426ae86cbb12d8606b2ad6b2dbda0e671e76d4395b29386f605412558b01917f55cf3496cad6a5abb386dcfdb8e67d6423c64a35343fb53a27e28925dbce75897b026cd6a3c72db667b5671cc579599a54cfc86ca4a880ecf8a06737254b9c719cbc99dd5cebf569bacbac5d45d1657b17c7cafcb88956eddb660638a419521c49dd93245b71a1ad87bc195466caff9af4cdb3f94336da53dd1408cb8f97d4479a3b2a7a4932d325b556018d23febc0f720e5c5f2a0c6990a4337ad439084abebda3f09f4015e26ee5938c49ed838c9c8481b4aece8412af6085a002b8cba86c62dec15bae897853ef4bb43741ba368e654406b51952880a8276db513da3227026042bbb85f0558ecb5686505fd42cce9d07e599c1471d1c5c53a8047727963198e2e42c9cdd43707ddb41e22904158c8b77a867a00a8cc1d7551842620021c53e3844ce1bf17beb4a994ef84f21ccbdbf63d6ec11523f812a3a0048600875de540cfe25fadaaa597f93f6d9750ffd8f021edb620b28615ef4f863fe4301380a8cb14478a871a157f57be36af83bcad148e041cca5c2f41a8183aed03be549f7bf5f309191b4678ee0671d7bd14674e2dcf2f1338460fd614f17cd40f478e02cf0a40e0241ba2b6ca8142a5a99b58eacd4e75d091d8e06adb0b4c593d57109eb553e78cd9a393bb891bff5a91438513bc94240aa15aa1852b175b3a9ac02f039f150896b6e3d42e2e18eca2ac88432ff9944ac94a48da99737ca871aa235fe045f17960c79dd08cbaebe02c7ade6bb176346655b9d75c78c3ffd68e343142bb9e4320bcb8c4223cead33cabe7081f5fff1dbbd6c9aa4b6b2e0e7a9abef4cbe3427baf1dcc5858e9053cf86626a012a57eb5920cb97f1db13b5af5fe187ad6cf52d1ff33f5e6a7a62c34de18e338b2d7d820c5b18d3cc0cd39c4857b10ee7cb71091936770d0955702f8b55e15bf0804bd96ab5cff689cce02015431ebf089c018e56f72940b09e3cb08b9ff564d9844cc8812d68b06f013a4dfd7bb0b268426b7f83c2cf790633fc4d901570c6a6652f51fbe1526f92bdcf8f7d815ce6695b0a0160f7c833fa18e7e323e52523e8e1698b2315d526f6e07c1c3fac5f73a241f1d924ebc6ab9c9c5874b6d22f2164f68406034fb511f0c5b663f903e3d1a2a4bdccd2a77fc82447edc0318730baf7acab10f367547cab9327c36c1e8d84025190ccd993d67d4b82afe0e15b9eacdec39cfa7ea7b1215865afc288e8677b8efcf407ec41337b9c8713d5642a19ca55d144746c21d864b1b8eaca1793d48775733e54313aa0182a9efde71881c9450f925d84cf9fa0a9f122f1ce78b00b760114a841f6fa28d1fd4d9bb95fddb9a4ca90a91ad6d5d7772fa0fbc1c321e51c6a0be7fcc72376c7b68a95611b9bb7dc4cfd67f893888cee3647d55b60e8b5a670d7eb5b3f7408c6d4656ad7c72e3d14edbea8a284e962a1eb000755ecd7f833aca1ce8e584444fd8cd81c59767698e26886fe9d9d7ef0da5352a6a07284e3fabcb2aeaa01466e3d1eb985a90ae640e2f17a890882a49cb1ccac706381a4325e1a665e5cf6a32a73867ddea74d6aba657956c2ff66a79c052f9176b35fb2da7c7e17295af65f4b1afc60d36186607156b00c5ecc462c0bb5ddac16ab302b2b92a13d5aff2ea911123252907f85bf82081629480f41c90d87f76ef4c52961abfbbf91d6d941310ad97fbae1ff856def5e6f4a2fb913fa860f332555237ef90a29e0b8ece612c132cec9ca591a5ea11271d771f1b6921a067a5474d261b2529a9836a6835b890c5a11e41879d8a5a094532ad0cf0d8f8c54bcbe3ace59df4dd9b218cb5e4164cfefd62ea73b19f07ec214182599866a13b85d8cd4f79d1369d19a953201f3881d631614c501a6b2b11acd26fb4d77ec16945fc5179b06e095bf1c78bb2b75ee99d8be67f1c6e737dfcd2229c160408f495928af998cc3ef4fa6f5df4276c38d500e848450f312f983f93550df64c9e09272f65ab0a7273c20971b9f19cd51a1a6ea0171e658234fc4e32df4f70c37ef4016515483e119db08ca51853e72620d9fcb94604dee481667d012b0dec195ceec598bd6d3e2e6e8a85abcf770e603456a03fb5d570a4961758412e4b2e3b45f3aa4cce099983b0b1b840ce215074ac9ae578d5b1a75e16ac21878e46954d77dd1f6927ab792a666cada8235425aaa41a2def647c2f9af7898040e1d00aaf01b04f786edc74ebdb1207d6b94413ae3cc2190f96c7d45da475355bed64eee0dd3fc4f159548c4507036a0527eba394c1dc6053feff5866636baee75ae6cb9ac904bc14bc631f45cd7626f04646796f78679c6a4bca855405ffae4bb9287f591f0de5256a7d5ae490e4819b474e35c908768b636ad1a58335126f60c199733b10d66386e8b77f5c1276550968b4403d9c4f764bf6fa2e2e5220baa99725058f2421af99cd25c79d2f5af401f451bd79394c63e8c12c80ad590b48d962bba296421291e387ee0a4233bf86d8a40492d4ef0aa54f774820af4fe200b6d2ad45afc5eca00279e96867ef790131a2308fb47f432bde59be27f02428c355e684635dfe5a34ff0752f88d6ab5fd41d60c435bf8c7f284368ba97cdf68974cd43985d44f13a02ccfd0f48aed2b8c264c1a8bc43d7684ff09b65f4876afc9446818af43745fe36c230a06f33e25535bf8f66ef7e8197fd9fd10f41250a29742d37565264af48c88246f0e6644845a8d544459769be3d14274e7431ffd73d917a2132a5da791637e688b68b3d594b26b7fff1c1f6efaae71c6482d8ec87890427c221be9fc4f8793ab3384aa82de6931924f33320fb118179d897155f6f20440308037918e360b526d02c7d2e98139c57a1ec8d25f3d32dda6555b3112b684446a6bd978f511331951ed171e1f2138068fe1a3bf9488376637aa85921e3a19063edbe47cc45fe2ce237f3260d996b3badaf9d8bd7dc68ff9270074f578fe18e3802375a3dc2d31a22a8de0b56cc9e7d48a4061eee083a79e9bc1ce3160948300dc261767a5c9cbc00137158c14ff318809e01fed322078baaff57491f9bfdd702f48f6c6d214eab97f273f0aafaf3c9b4fee8e3fdd14a09af0b4102d3786c85862b9a39641e611ff21539f0edc1502e2f04b04fda1979b762c26b2ffc5e2f77cfce3e514751af5b910bd96aba11ef1e1c9a9866224e40df77bfe018790e4eaedd11983f3ca102881ff167fbee55864a29323402b531cdac5a17fb9f6b67a1b6601afb14dd7569b5bc6f1ea4c536e4921974162630f589890f67826c290ba587e8e1d9a2c8295a2541cc08d946a3f67e9999b76042d9893ec18da3e5df12b0755b5615acf50ad5493c72f85db5ce4542bb44f2982955777df5e7d90ca7942c71c0d446a01d9d0f66f21d2fab0dae029c3c5ee7f3474f63229a0e29c72f5e57ae7e99292a3b282c36b332c689552513dfab24b1786c7e072cceb77f493e884dbd1c91869552d6a02bff431c9f5e3d06f29089bc096a5f46d976a5f56cb6d34c8af4d30f86d9caea4316c25d2a42395d62e00a584e0ec799c7030af94d06b39678e128f69318983db7689719c17b0ec5a3f6abbcf3329c9e9f98cf4364c93d80262842938a9ce385152d53231b197a9d7f3a9c8b737f84417314ed75a973150465c2d8c235f7f8e978aa2dccabfaed7ed29a162ee2abbe688e8ef586f076863654b9e2190e29414da744a35dc2315b04fb71584c310ece17a62e6c5e0e57d74623590c29b6006cb6b87709155d23da00d29337f32df7d0db96d60e9a7e2356e5c2c6eb55d8954f2f91060eedb35e8ff9b5c2e8f96583498ca0f5adf9216a0287795f8ce4849a1f742729619c427ad01a709958ef805f276c30a3d831addbecb6278b94fbeca97e0ff54282d4f75940fb3b21d0b5c3b65eb3ebe011c0d7e2eaade78b9c7f0aec67644fd191f02311d8ddb5ff519bcb2f3ad408bac5924e555b01a9a2eaba99b66cc322af705445f58ac9a6177eb4571e6339935e79dddbbb185ecb41a17f79fc941bc1163d3b2f33d1ac3087e7203f970921d4bdbad3abe8290dba0b21d581255e7908d4392ed5d37abb2118d8434fc2af25abaae510c9cf78983411e2001e7d98249597e91311db0689f3c12c3c65f90f55da5937f97197a835ba631499af6aa1a63b65460288a57196d1d6dee3ff8a1f29829967c572e4b82ccec6d8ef3dff90da6d5cfb2891b1a2c2ea075cd91728a678315aefd5464c349916e7d40be5f482a5aed7dbe7702114b9cac745dd1ba058f52bb387538a3bdb53be9cbb83a8d5382b5ff2faf236042e1e560eee2295e0db49f07dde7b1615d5eba5f4d626f362f26ceaf145b80100b43b3a9a5daa154b34f2d8e9a5025f5bc0614bd190a198c16ea91785514ac8aafe84a3f26098f7f53eac4e6379708e0cf8076956068429c58d99a2400a4eb751c4519cf00cb146ad4ff8100d9477fd9be06e0009d26d2d6c6549dc1bc8ece5909207862697301fe2eda1ab48e14d84564e3eb0170c1056a8fa0933c236114ee15d3eaad4ffbdc1c0da8d8a0be4fd6dcfa4553c5918e90eabb9074ee35923ed41fbc0cc3d7b4f1e9d42eb6abbb903f42720c241ca52aa01cb566ec687749dc88051794b66061faad3fa5e8ff2979a0d919d324a4f11883a2a03e7a9243d0d48652a19bab37a885dc2785aabbf81370c25403e8ac38858136cbe95ad24df96a0a9523490377c84a46c655f9ee23d7d088d73dcfdc5ce945d2e90801bcf3c77b89c2b6077327a982e36ef685edde3a037ced3b95a45e9b104b90b4717d0879b4dd2724dabd160ffb30346d743b787cf18bd3e2125d0ec9e24f15911a1b936b3625e96a43d135977513a033b41f426f01c67e389a796f37fd028b02a7eaf03858f2648964373eb4d9b2795eab784952f2c29d5ffbb0641e396acbfb4c928c45fbb1a5e1c846372163f04ebbaaea0f0390a17a03a79f86b2a0109014a7f21f745d215749e5f7626ba1b9e5bf2fe1940d02c32c646b5266f156cedde9c5bfa953606747e3b9307d9981f3e22af9e16ccd7a09d153a4ae83ed2961fd15425b1bf68332935f0043e941021233be48c9f9d303dcc638b51ba17f32000cb43cc64dab2ae188dbb1af89fad386708c5d50c9dd0142205eb2bc3b27d86dce13194a6cdec15781c8ce05e13963fd514678fed37778ccdb70a7f6253699721801e83ad9b063cf86b789c48880e69502c71783c715d25e09e085c7a93c5cd0321aed09202b3b1264d91a1371f4939dcc73505c87b238d13cf6bf2a7d4e129791ee080e468e72ab58a5403a592df845337dd511ffba0d7747bca6ef781ef4f0010ab204a6b51e68b7fd349cfc408f965d80ff708a55acc9cb5b9f2e9c9968fcc94b443cbb031ddb4c144af21a50b7d91cfc10ac6430295ed0e08cfa365e7d8bbdb31795da874981a15c67c6b9e28007b4ed06d8444487be6fcf834482938b1be399cac14cfd8fc48e4c712c80600d3ba3067472a741fed07bf7b4066cdc393f9046c1b04125696d52ca90a8ecdd23c38a19d2d1ba4b990fc9ad075234ae8c7919c96d17233984936184aefe3e4382e93702431817358db0dc00318a224e1c37f4781e7db7064abf1f9b96ad72494f0b8eaebbbbb7b82a50e400af502073f6301c86244682068fa52df935b75d72dba8067b570ef5a1e22ffd7e479fbe7a7728fcec8489656b30171da21744ba3b37eb3127ae395beb1d9adaad2f35c1e6bde5a535e58cf2e46ccacb4d43b69d646987377cabe9750b807025caed70dadbf3a0788b06ea88d2394f750a953c6fa13b71d9ea9242e91fc73379a791ab9e6c9fc6039d2fb7198ed13e254aa0ce421975f59efdec59feac9eac2fab24be73210b1c1a6675b04fd9412a9ac7c55ef79699450c912c7858f684bd29bfb9b866b37f8605783a36b6b00352b7cfd010ab895968bdea50d7fa57d83abb987b797353895a5f3ba06c31a75a7a8538ffc86de6696462e274619ff9b6291a5c08264767b536288c260189635ae9eecfa6e62113f17c338c7e36dd19971192e38232c7d28ba52638be9ae620d5bb152a83bd89436f153f1d96f5afa47bbf1857ae39cc1ebeb4e3fa18dc0fa312dd00d3211f1e59ae117aa9097aa33ebde7443ebd9547dc3ae62339aa8fec52e9698ee4c06c27cd23f275fa9c4d28b13b6821d5f586cb40c557c6eaf43b99f3ec690d0b473bf3a458ef517da2efed4266d530a29171588b15c3baea637be10640dd8778255fb965a528fe651c70e48f83433354a10c51c8989bbefa2d613828a237b85b9de3588823a9d4051a92112a83cf33bda2d9d3e3aa5326df66f78a198f3dd7739b9b89cf22ed52e638a67e5990af8577455dfc93ba7720b59342240c0bc662992c228338287cb697f13e60080b4eeef796515a8eaa5ea4ed5c892746c0eec946d7ad74b1817b73f49fbe7dccd9472082d8c3dad2e26e9320916b0e090acc3a8a8e9bf59fe474a839e0a6fce346d66a20e31e54d8d062fec91412e1a52c83707f0e3c90cabf26767499e62e86acd24baade6a2fec4f90dd429e37fe080d51b0f9b2e3205df091a08da0ac850185ec1a8cf039a49bec173c2e0d7a0ee750842c6a9e87ae995d2174fb107a7b24af702c08c84985c30f65d154dcb7c85fa2a683b9eb05d975d833f63325b0cc3358236c93a1c8a25a6338db7fbdd4fd3250083ab6d0ec866d375eae31d92bda4a842c03d876d4af09d9e540ebf172738de6f3d9dc481f0c9c938832da58b2a4addb3271b67f224177c6c13dd93e88e39b80f4cd002fddf3daa2628e1cca644344480bab432aa601c12f211500a04e98ed9542b17c997b1da29d405cb54f9a126e875d59b8049f689b07c84d6c6d3fc3215b30d3b370efc73777c348df42a230fa5c6204570cabda654050372d7c6f541f5e6f489dbc6b0e3eb4e444e3b5c54760ec9a8d84a48b0c2fa4f5a2408188bc353c32cd6907f1796c1df357bdd4049644c2d80e23faf73c81d09f78692f468cbc4e410388738b5b598cf7a03c365367139077622baf3350b29d9e451c221eedaa91ba2faba8626640888794e31a07e3aac9ed42a5c6cd2a9df7864d890a9e2442e09a00848d85c76d8e955c00c8d33393abc61b98e1daa74b7045d6082e487ecad4a5c8a60e387a401ad42cbb983484e692a989775811446ff0c84a74330b03ba517e739ac02ae7daa1e29984ca0bcdab5ba2611e5336f3bb5a421faf7f5d60070c477a7bb6ea58de5909639b405204086e00a00cdd3711fb364285b07019b5a7fdb9f66cb7a0d835f9c5862d247e45d0af54c933082604badd03c5fb63993c1be4ba21b895e2643dc58b37098378225116904abedfa0d1dde27cb9a9945599a2daf4e77be6e6aee9fc33da1c92427afc967372ade3e604cccf42f8258825ac60224d45ebfdcbd70d1b8bffdf7dcda459c3e7142094fd82c1943c802276b5fff311ffe06b72d320e68fc52658ae99b4f42edf37725ac5ac123d31f578c0df782936ecebb2b1c0b731d433af0a1957296e5ece17b477c61888e93a73e19dbeb45eeb86588aa028596368992049a1730f038191d3c171b01e5100cdf9c59aed6efaa63ca58d764ee5369bed2fb749fd2883dd3462e4aee1116caeb10fe280be351951904cce4681c1fc7f4eb3ef61fdad1e39ffd8283d96127826f76ed784fd048b803d784af2a2e6c02cb97064ba81b194b4f8967238590f01a40180945ef56a93d35745ada46019c0d9d45fa3f4d98cfd5c407364ad7f80deeb2bed21f167e27ae4a14c957d9628c609f3b173d9214e1f136eac24bd826dc1085bf065b37511be188b53041f13de857bf82571b5e7f6d3c50dd2ae4bfec4c520d56d21d1e737e40430248b477c5776419c702d561cc5378083fadb82971ead8d1893a4ba04c856d325233a5616bd5c1f03f375de02725dfd2febcd3dd03c0ea346bf7ed283d33f1815f4ab579cbb33799ab6a651464adf1951f45d0ee5992bc38e94c4ccae49888b14c865967a0b0fb23ec34f6d3ec6f30b8badee9ff87afdbf8e96bf2e566a5cf7c52fdf13045228c5f8a6701172c758881aac0833d7c7ac61063cd43900cb1c127f11b9ab406c1af704b9be9f7c39a372686e84dc9bbc9727ab99e508ee93afc2cc12bfd0964ca1689f61035b4e547265090cd40c929d7fee5abb5af7be069503c125c0fe4ebc4d931504a7731684a1c321425e97a37bb3e1a752f46256414d387fa4bc198b744983f5baf995a2cdddc020f7ec6edd165b79d4c1abd83b23cf3a937e663b3e75160c59dc814c3afda0979219a5484a8b5cc18eab29c6adef4ad0823d34e9fc32293135d3b19b9ecb141f4437fe2bbcda8fe7e2e4faf7b530da11097c826f0c0ddcd0e931bbeb75df224afb394905f21857e77497536fd555f8320193662b54fa8bb37d8afcb5edf563075bda12fcf0c85fba55b91bf52b46e8201fc4288a34ec57294ca76140493fec6f3a8ff86eacfa49341954a46a9da003e6a37de6a947f6bb2ad05cb5037b7fda2329871c72279accd4c2e0d44eb1e1bf950545386bbf90069d009e7af12bf3f5dcc615c048e838612dea0ecbaf294cf62986927b34d5e0821ee9c1b82ffb5c0cb602c987738b45a347b935048a880be3ceea1ff0f4eb972d989f47776254bbc07dfc0047da9fc9e76cf7ad4d3deee41710cc18ff544a7297334f977a026186b997002b3ca57761bc0a60c25e17da6c391a7cd23f83da43d01fb0f4648e4a8d1847b8fdb570f1c1953c335cba0b7f46622d4651363b228b15a4b102a009daf938ae202aa103e3868b84d6e0a0730bda351e37e70f24d7610f048851f5f4cb0c776318a367dd5c1ef4341c14dec7d1c48650a8e0898ad460729400b4de908066da7ef66118d138bf217d0353c8674fa17fe9f93dfaf0bc0612ee804ea5f1c51f8cde5d41a01be65ab71d777a7dc484b448eff95c754a1f0f10b3fb24a68fb98390a624bb2bf34af58a53a292515a306ad0afe1f75c38fdfd56734550f405d23649f99b2cc301c75b19d0e84caf587755321e25e21bb61edae6f5f1410de64352c9f89905313db8cefafa0d07ce95eab5c64ebe00924a26eb20089fb6aa469624a35d59387921b54e154a64781fbe8480397590d9863ef54eee46e682d5e18501b47a78032a1c7e365d9e08e6edda4c34a86214f665748dffed7225a9f9828db26ea01858cc3078796469c3f60e151b287b123757df6ceb845e1e75b21c4cb2641c7ac051023d913537301edfd1fb7f2ccf7fdbe7c73e1089ed6c0e778825b2182a9cbe7247efae68bd925bd1f8c53e9dd7a7d199052071521d1f5ef2c5f7778c06727e151c72afbd7e9e15659c72d2d3f00566f9f89e034eb1632d628fa57f0f39e97c0cbedb59f3649d7276fb930feae11db0f9386dba967bcebb354e6175d4e6547f752df7a253a456d97ef9e900ba88b92b22860e66b75ac05951e7524c10456d609f7346e187a7a1574ae300315d66e0cd394cfe307d708f1448ac46e2e851a29b2f090be21999cbaab400c0e4b4a8c8529c4b957e07c7a2b884736f504b96f796934fc3504327338e93b706cf3e7f204ba92566ef88523cb789f646104e631243955e64fa5b76f461e4222ff13d98d0dddb5fccbe4c0add42db648a48ddfba8160bbf76f45912b7411d4f5598cae8f4ed9baab519dc7c4b3944d67f8c5201b7a431ecfe08b524d91949df355e9d879f9eeea11065011bdb87e4e6cb9b6ef7df1f0b07513f29c1a8a6446cea1c87c9edb7235785821fa4eb333c1a94e1f37ba0e23b0e44abb9476f04de8b705e2dc9d58f9346861b52abb136fb8766e24f75dd1efbed01122e12692114016c3efba260d32765acb68ae4b7f0442820aeb152a18b346dded93bb07a723b5cf2fb226c1b64601c81c791fef7aa80faa4951d730462656daf5a8cb98abdf33ad634a4a84202c31354ddb81769d169c5b9e59ee481ff778c71aa6812885963103131dae8fcc2014894a5d3671ba903f36dd282ce7812462cb325c66bf080ef7d0c0f72d3f356baf01869b6cc561cb5920d458ab4eb96fd33cd8cbf71da5ef771c73bbe7cfe045dfab03af985d15c51d5138e6b0d51d0f429bced968fd2e29783828fc1507d53ee14285982ae2572b219dee13f537bd8d40396447a3e7e57400ada8867997076eb0687fed8804da1c11778aa6e7bdb85cddc534355f8dd955cd1680f5a2d5e1fff9503b3cdbd59486dae1cc20d6d2208e9a41828a9dcbb76b544ce6583a4cdf449ae993d110b88137fca6c8ccacea9466d55de06a846d9be7a33832e1f5561da8f2a98e1af4cd23624cb2aeb19418aaa1ccb7c4b032e7787ad6ed730313d72a190497ff8800af44b677066070a0525983d4da1df135b759b26f8cee4d8b8e25086dcc48872b0852bb63ee648b268ed2e052d4cc133fe3917854a36662e17995d301852d4200f367fb58ac1f4783817fed20a5dd1959f67e55463e4a4ca01469ed3161a1bb240aa3af3ac9a6da79e5bcc6ac1068339a14cde59e2fcd0e916248f96480c968022246b10246e90aec5fdb200199e8f9d91b26fe445690a2b44923955b52c8627e8665574863dd2e729d307228968b735934c76f677d5b092286fc646a83539cca318bd40a173a9711cad541541d9740261cd7bea3dcc36e4392af9ee9e55f2e5b8d76b01205b29437e71a2d05e62930c36457f92bc1f5ecadc125460990c2c432077640de669f288b2e8b85de33cf3f88e18df1d2522f6f307dba2e18773f98aa3fb85c811137404f596f9862fae4b259e368bf56ba572fd4999cf9499936894e58156b92e7254f171837b1040a761f78f12bc8152f0ea807e5b972903f054edf334d2f079cb463aca52245481f08efae4ae960014a1ee04433abc4c5894e77f17b444635b40f83e77e53c6283403df90e84fbd0035662f8c778acf6557360e0bb90da76d0af4bc6d392b912d4d1b1a2b65ca425f519960c351179856daf6bfa97e497ca8ee62afeea3ae843ed47a84a0e27fe159779589b03a8db2421368ce9ba9b28d5fd58674ddb97a879f9463e20fecb6a87877825fd0e07aadfcedaa5f9655ee1bdff8289c383f5164d469263ddbfe4cbf2d71a69f6db1a2eff08ac5c16debab3697b4549e18f8c851472739f219ab69ab9c9c49eba05141bcc54ce9f42284e148e6536ecf9deae539fc3e9396dcbab9e14b82bbc3002545a9d5d82bd89f0564f6126b59af88a67f1f8799b1b4c70408d7a9aa8f4b24b4c6edea5a0e7849eac7213819f7598e45b65ac8033659e110334bd06294127c4ba0629cbfd0fc67a6db73aef1ce609cffc1847d5a15e19e507372a45b02833241842b3eed5889869dbcce9740cfbfdbafcfb5791db172ef2bc921e03d065d6a216bec5b65ea058e9fdaffd1092bda67fc0afc75eb123b1050103a31ac2da02c1bb3f7828b61f9157bfe7e995e2f74119938235733474b11293c1ae60cb047efd3f476d891bbff1d5de4eb5119dbd77b6892f69aa1fda5498745905609f6a0eaa08f9be9a77890d2bfa43acef6ffc1b1cd994dc051adee12637bda990f99c7f00f0097e84b42fcd3cd1df41739c5639995911c92182e5ce517affbbea68285d19e82ebe6925c45c76e6acadb4610b64f10292108cde92450618838719f7dda7a8ac8a03b912f7e420ffd563be490cc185c8a2767e7ec0de581d4c6efb1cfe99be78f50b584470a0213c9cbac09dd4b2fe2ef27b1be0718890367a026259071c3dff969f9af236944e74e7fd91ca1ae41a26046c7b42ec3bf6a800c7c27e52d2c6823d6b7221e25e2b1a0137aa3e194b9e5a5a5e4adda253c5efdc0c660580b0b6eba8b87103d7bc53d64c7cc47c4587813167014d9aeb311156c8a09a40d32c8e314f650d00d5f0914eca4a1945ee795cd7c0c05558ef1633508dd9c235e3eca9a4aa1ba8bbe152c57fe5d64e80014c0699b2e5d7bbf0c58fe61b7370a114d0b8cd1c5b71d02c9c38481a3c08bd3955073c83d1b45aff5f7d82710aad27c839bba99d006a51929ccb50ecf3c105351f4fb717243181771d350580c458974c867aa29ad5d47a4f0cc0b863a82ec138c332d5c42a7b0f390b9495301ce8beb8eee291f3023e51d926d5486533b0d699d5bebec432382faf43fcf3dc17e4f23fe98a6d813ee10e808e2ee7f645e4be6d4a81404ad853fd30b683a7438bdf62cd6aefad025e15e051f0dcdb90291ed3a47af10e12bedb05a1065d625d15896bf17674bde6288a349d41a42c4cbf612e5d01da17d0cd6e64dc3445edbfdd2dc64d84b8b1d005adcfcfac18d191b9807512fc66d717388736532b13661afc1a8752a9773c0f22103f32e812eb8c3b60c4e9f1af3e94208ae5af3ffc41696ea03a186271dfda87a866030e71089a250ef7581a49d012511a664dd1863a4d9dd2eed28d39227579d65bfe7081e61629ef3f51397316cf49a61ba5bb4d268080e1c9b5c599966c83a5928b2d44b72477ea7af905b7c6dc3ba98bfc9712d47d75c6d36ad57f76f96351c39c8c742cd3109dfe80167633e1ca4730529e5bb9620703bf9748c4d5d6ce386538108a3638fd5489ae793fcf29b45d472b1f613d19dc5113398d7a00425528ac089a046c9cbc97e9f6b2f7b61247f3a8bbcf345b1f1860bbd182d40e38ee47854e90e68598a8d4e9cd7a3da46efb683ed64e7facab08ac0d76be5c5860cbe74b8f0d38958b4d469fff945761ce6d68a179a9ccc1c8ab3e526147b7340dd9947405724befa59756d80ae9864830b6ca60cead01390c964a934d529d579dd88b3f4455b75b511b1f9020c47446dc16019ea95a4886e73d0af8fb7f5382ff5353e7b6afb5b2964cb5c0f71a14d21f87de2196504d85c61be4e65f16cbc9e9d607688f1098ebc962ce361093c0d1588a064ea32fc5292d1f302091c9020d10ef29828e9c001075c64e6b71398e630496c9be8be779e6693a7b08f91b765405ac78ce17ec34949815500c58ae336b660beca10d8f688f79b4abcd17e29f4945db288746951bf9aa11b6eff701aa430d803abf6832eeb915cd914424c700e9935700fffb3373014477ca53d3a885d55fc71b6b0aa0ad06d387823df528b6ac690fc65cae5b453f75fa587a6d02b8ca658ee334f46fcd52af7c1e0c19924fc830d1fdf496047a2df5ef6b0d495e5048682d5d2aa2914e74247b0a694a095fd42747fb7f9c8f7c69e7e3f56d7076f3c4f721549667d0cc38614faf3377497b3f85b29b63077c5346426108591aa4144123d22f7eb0437c0e1de0ae49d125a9804b490d835a96e3c1926e9265df713a28340e3a17a6006f017be5b33e1d21010854cf5684888af54d9860ece92ad19827c932d32f33ed6cf4c95ce19d7dc24118b92f95725bbcf5407440fefd3c5ca07bd1162fe2f5b63f33cb31be73e4cab34c6eee4577c83c99990cb40f6d3da2420fae22237fd340e101d2673f31174d5656a4bdf410f8427853247df2d41c6f9c6a4b492d1fec963568fb3e209f97a45e5ad54b4960bdd5cff6180f26cb5d22943d1bc62eb618ca20721cb88f4e5138bdcde8d60e1d8719af1a627b32b4b6c99d72b344377adf6cf704cab165ca6fac04efc0f435753063b5512ca5bde472c5549d4be1be802662991622fe3155a0138e7b170b2bea8283b4b3a102022311ea29946a3a1bf6fd97c185daebf88877cca5157a2b2f66345cedd114a59c9e2f9c9548a1503acf5a01e70855689abc90c9d0461ff35d2822ca78b946a0c4959698995e67f54c3a4a06b4ccbe888ea016e4c50dc9919d63c13975e50db431b55f077a6e45699d9f3335133fc7eecb4ba0f7c5b3d2e1db393113b7b16c6eaf25283d1ae111d0f7775f5f72ce2e08bcf1faf9b64effd24882a6295e9ce55ec930424a6769bed201cc450cf00eb2454f0e4bcd9674db298b648bcabccecce5ee844d70252fc5e3503e23fef075cffb2ecdbce21e373b5e0cb4942ef5b7a648a098a90bb808145ac1b9e54d816e0894cf4f9755e729cbe8affc65e19feb5831cbe283909ebac229472dd46d9167eb656344c048e6a9c0d93633f28972d035dc90932a76a49bec83fbd5938ad454b93ae3fe73eb6b0bdac038dcd448d02cf360212678a74b042a8dee14a77ac30e57e3c1fdee18bec0feb49e9124a1d2a5711ba8dc9512eb1981afff3239520ebcee6eb7dc39a5f01fe8f18e7c191699101a3440a51ea3aedcb5c0cae2ba52b58cd648e9a16e7b4aa6374fe769f7d010e2d888715ce44d55f9dff641f1c3e3c028a0692c6b8e0d4b7232ecf50ee4593649c6f47b4a90f7c980b02eeb27c73cbe483c04b0813392561135dc43e1f0290bf2739e4d748b425d9bff9fb98c7c8dc2ae350b63da63092656cd0eae60503f3049b2200510085d39d0fb405bccd5381151393d3db3267ad324b5c18cdf366c34f66271fc87c22a7f828d8213a896920d0e0207d53cfcc6b62a3524acbbd56120c13c5cf01bb55e9f4a8be2534d13458b1f58a0c139082cfe8e05e657eb668a157b463c77bfab7836c4be7aff05e8d3bd034b80c583e3dc7db5838fac69e93df6e925968b74b9e8de9139f2fd400a2fd4858d55a613034c5b9f47937b52e08cc537c328556743ae1794d6de778866af977f4e33e5bd1a6dd389ea4af2560b35189f25763de01c0a0539082f9ad9dc261f905b6e50764395f386c495c2422085637bd9abd6cc1e214d7f19430f1dba2aa831511102ddd84c174ca2b0908f4de0a81c3b0d22dd88a0a7b674b87965cf1071d2ae41bb59b56df121466554564a2f86ef2ceeff05b3f1194213edd9d22104d4c0f1b1509d0e989c04c62e92b5483f9981a5dff85010ec9b4c3aa08022cf4be45744a7fcfe8f561a86ad3164fbb8edf4d977b580a4885592a379e52c3eecaa29b0463cf3f2c010a4da808f3a7e074c1cd4b0cc080f21e9cbd5e9de1582d7874227322cdcccc6a2f1fc54f95fdf865a2a665fb8d3d2bc5352bd68394ea200a2523b67668bb354281df591f4f8fc9f468dd65f04409a4471a6dce4aa9253158861b00a53fbd53fd2409d9c31bd3c4b383540882555f9732b9de09879725b13467eedf481024c4d4c924c9b1d5f6c472bfa82dd73533e30a3e2e42d35b87711c5c2f3379fa4c407634e0ba6c180595001431f881f41beb58e889673292954e5afa80c52ff93eee9a1709ad984024a361c6ba67bd67517cdf77c2951418b572dd5ab35953f96e63ded5829b00f915846e985029d4e80e9099b4db4c2f0776f00e443134bd09c005b5628feebf604d59216abbca8c8f3024cf0c0a9a80437b57bfd24cd773a3b1b0fd78e37f6f3d81ad8fefa0f322a6c060cbecc904b407b764ab1d5c092b1a3b8fd820c760f98d89a077fb4c971d557d2077f034fd019543c5fbe090aff06a9644da734bfd5bdb14fb2f1b16377ea732489f01082360d4297701d42d494fe748410be42543ab5fe403b44537e1e91e594731a80d6ec682ec5b68c5f6b9549ab97129e60aff4b80f5b8015bc5644331bd9b8b1242ccb0caf6235172029972e1ac786dabe2f6757692cbde65448e6ccdd173b8fc2c0e9af6d0805792523ffb5e9a3f8908e1e411050e34891ae4095318304a93b620aff3bd45a90667bc2f5a9675fcea67f389161e4a63b65b905b611ad1bc3eafb5f1c4135f03a524b3bbc3c7dff7c71cba17fa28c030df8a9ff98c4b7111ee406f201c01b4423f69cc393ac4157c5eace62f15a021bc015723a62679af82fe623e096590364bfe895797a54658d5ee981b7e81db40d2f9d06d4f4c64082b244b1b94df8f3e4374cec4ea4d6b6f917773d5f701692aaff744c0df185e2267a01e56e89f0805c618c6f5a265d81ac4ed8808980212d79d02648527f7f2fceae0b97c92c26c5fa7036747a717a3987eef9736f85f9c4e207bb7a755a1331c09477ee0277e019370dcfd3d10bc1959e6195f3b010c21c00b078bd518951d6451acf09e1c1b8df7531f25471f1d5e7dd3e93461a8ba538faa88ec2f71e520b74503003d42e3d159d999a6bbd8d8a981c054965bf404927dd5d708583b91562fde1ad104e74bf5ade4901e74e344de369f46ad9cdc9153deffd3c58a826e703109d126fe18c52ca99db7fb7d8fa1d6b7a5ca08a277e11d2c1f3a5b13410411ec1a49729e67246deed8d5bb469849569e907b52e21cfbb576496068b2d1e8190fa62d84d66800a2b8f1eee72464b7e0dfba680b947e7b8a9ab0cb9f2e467c25c4d6c7c0c23b9cc1a781c1a034995c7b8d518deff7b5ef1703ab53077e46eebf951f468d09698b670ed5da26cce5a165123cfb3a8ef677e7281ca15dabfeebb43475fde212da85e05f0c12cf28038dccb71a7df50ec8cbeb4f541c208ad1df8dc1025587d9862ac4693a5f3f4cbb5fe809dae15e924102e655c41155d5c4806e5dd76ba5d11cacc74404e252ea1198ea202b9848fbe207b7653658a9fe6889a4e69ed795dab9f42f865f8eaed2d4dceb4c6064899d9dae30d3aaeab582c9117cfe81ff1aa7ecf16efa145f790b6f0370552f271122f8a673a749e082b94e94c7caaea552bf011aac92230b3745ae1546769efc16f0d11651f8d3a6adfbd8b7a71f3d7fefc29a29ff71718f5c75f88d67f9a9acd6458cf8ccb007c4f655f3dab6fa8e65d293e72ad70b5c64e4d9c3ae6209b4bf27933d6d47626eb21139c5f6d96e0b64c7553f9667c77ac62f034fbac86df2176704105dc4bb870a1c97c951d3884778d979b516354808643a1efda21a77768f473523a8dc7ef9c188153df30e9da607603a69eec8ea6504eaf0cad3199fa8c03117aea484aab34bbf20384fdbe3a7f01b550957952d63e437f0557e3a4b2e94fd1932685871c1f258bb6562a6ce554bc72a01c7b74d17287e7975bfb35d9f48ce68de732730548d103ab6da28e3841647ec115e25e9b0b365f320ffb15fdb4ecdd64bd03aafeb1e1875ca690c650c6b1ad379b641e9d910449d0dc60a8032dd583923a3eff9f5a7ca9da111c12df7ae2415622cecd430b1d45bff823831fb57b6a134ea3682ad5e817f4ab169839cc09603ba540ae56f7278e1ad697e6c5f72d4a9345b4d4d47de9f5b497b81e0108d494fabde5471e8b05d171069679067aef5b09b3adc75973a0de019f835a91cbfefa05a325b90944c84ffb5c349280bf203f1f299ccdd8f2c033b75a87e028f6b05b2083e10c161cf712c4dcd660db1d98c2edd52446b9e3777504a9d39b113e7348ca7350cf25b605df80f62320cadd70e0be2a499d7ed9170bcd7110deec62fc3d58b28afa26360610ab0fde7c769eade6087f84934a66d17159e2bdaee006b0c52921bb85e7cde32fcb1ac36bd1f0536482deaf214f2788b4da12db5d83996f29896bcb9b6ea97cbbe8c215e3a36205b5dbd12d9beddea5b6bb0286e14099966b6ddcd6b24dd8cf564e6872c1029f1b3279445a5eea62c1b970dd80bba9f821ce3ead98c4e96a98d61a26cf0b8d844fdce0319bd6628f8c720522867801311c821796146b73b2e2e54a6f76feb5f466ebcbdc82e51bd46fe182d86ffa5b0b69ddca81896549d958eb74950b6c0244c49080265e91a2ec183b08c81d7038afe5a87531b69775f43c0a0e5eec4fc7c8e5926905cee727bce689ae9dc4ad86d5ef2b314db4685bf65c08b05746d2eb103966cb3b564ed32971417dbed9af356a8d5919aa66c345edc4af26c75f1d975fced5f786aafcacfeb1a18045de276d2d166cd52b2a2debe8ac235a1955979debb79653304eed9881e8a2ea567aaab66df1897671f2c64e79cfd88b0797548791e2745f7cc7874366f78c017206aaa6461f4b7b8efcec2ae7472589eefc8714241ecb24fc1be8928933c86cf6e6002fcbed8926e2d092b655ea2c2f16cd76ad7ac801756849195a673e0381d99999d482cbac188135a22c7cf969a0459053f83baa7cafc96e7e03ab90b7631a9962e383c4b38f91c4abf42d62aac109bf77f9ecec04a573f274c4922ffdbc48f157310c4e32b711af62bc45ef471c5d3ae4657938131b7c4c91396c478e8a09c7ddd646a39002959a2d706adaf15b331303ea18d2d18cb36f8247a3eaa18b0dc2de91078ee80ba9c68f4c54fe073c22d52bf84554bbf0ff31440521316894287b024ad3b0c8d9d8f3d2442e826779a19bb1c53769ecbe9db85102c4c854295be32a0cd8776ef15e2e630800b2279375c24d6e40a787dedd64117f83278f1d1057b285f91ba8a17913983596fe9d10fbb28c72361b62da1e1f682a66f9d4cd0895f9beb4178366224792c0b831cf4fc218368ae36514799e76b8e7e1c1879075e767092a2ef1e390cf231d8130e447603250d33cc6eb84cbcb2afb461dba15c9c866e00a5a72c207228d257f1289bbd48ff2c733c79c233d8a2016841a285c23999c065bb711fe89bcd98aaac65d8ab967d191ad895049d92c7b30fbef313269a09ce4a4c3887f9cd2f55072aa7e08dfc8f3c7ee3aad0a091e0b34cb23973840fac6a76a5ed72487fa0f6eef31d02074c08121ba691c8caeb1a13a628ce8d38b3e57f06cc24c6a980c17c3dc84a6fc8cdf1bbf11b6b993a01de9828c4243fff8c70e133e9a9aa863828186093fa6c7a9a97917fe2341530c72e836f4fa5910fde460b6568589b1c76a7d19215d9ef6165e997a117fe604cd5b25f37a649aa459192b23ad1e7a70e4ea3d749d29ed7ef86b7cab8ec98602831986e3d233106cd3c357c50046e9139f714bb57610b2c07c57285412010d415d317aa2083d4265614336fe14bd47d6e5b05efa0e9f1668be17764c17276bb11b3b488ceb9c2b5f1f9ff0dbe6be5892f5f3f698dc9fd3266a3c960027fb0fb4e84e2c6098efd862d5fa4cc3e2d13deb79eae54e0c28c22d30e10c382e35fae06b5748b8ab2166299ce91ff5f6c4a843ebc9040ae6e5ad449f4cc92132bdda9987d4113fd04d559e6437c084a2a9aa35100be784a96869b4bb0e90cd439cc8544c1e134c8ae7216916a0724b448a8bc650e0b78c04042042333a95a0d628610a537bddd38c7bce04a7fe8d9dd6ca104e6b89b3666c917c87e7ebfa5b644e4e6d3eb1a28c79093b77292d4d4a28486133cf4477ba2e086541b70819252e582c5c000ef8f4381a16fc3a96417f37ae2a7fe78c34c014786b7a374f17e642e38526c71f493de252b17ccfae49b48c7490d113f22ee8ae2b5adb4216302a3e8ad805a47aa42bfac42a8d4469988e2dc45b0fab368052d34fa7ef01f3d47a2f859a17755bda9af976083b856a831bd4da73f7662a2c72ed5744379e46f27701f248d039c75f837790409f23f4d192981154fa7606a1832fe8d2c9d55c8293ef8544cb3fbcc810749f46c96597e47b70a44cbbeed47d0d6cb507b700f1c2e76d433cf0b3734fa569a76c78310934a7dcbf3eae35272afc439de84aaf67229f5ca0e9bfbe94d9642fcf8df43d44d752681a151e13d883a231a982210c86ed902015da3a2a2208e87fb5cbf66199971ff3e18e6c95abda8284e567b99782c323beed1edb2e667ea1009a4270d54699fab45478f2e53a7fe02c7dc178aacadb92eceea258c35a58d383f848da23ee83113614ea4ddb0a40b0e375cb9f54bf1ab8b8296deaee34b1e6e64ad94488cb2fc29623d7b1ccbd9940944b0040361dd501a19ad46df8c107d3276634b7e54d9d179e26409d69bf27444e0f2b011432ab3abea57090aa7b0e4a715c755ea2f2851f1f7fa0551d0bda9d2bd74ed5f560f4d82f352a934effda61bb6a056a1b5b06cea7129e596ad2c758bf36f0642860c9e014221bd6fb012bfc3c9ba5ce475e49f6f80e2765bd1a8b5b895bd3d57e7ce266f1c75e3631f784279d2e75ec9d009585b87c24bf78abe730576dbe42827929c7c76f1f40b9de3481e1db0ce34413ffb712a8759bc61627b3bb44486f60f82f786dcab940045e79c4c4a097c9ac4c8eae065a730b64ce404f68890cd16d69d8b1a9bbb71cc7f0508dd41289ba7f5a98184e8ad2ec8cdfb31c08f0b64da58ffc663889a94dbfe0f867cfdc7bba0012441aa969738ea254eb63ffabf278973322d4c774bec49300aef9bd8639856a8f0e61a88e06a62147fc04cb7efe9189d6cf06002d3eaa1ca15f0b619bd58a32e83730ed4e6347c15356804766190e5665101922c02c14d65ff196e006ff63fbdbbaff87e45cbd9d3aa1dea12a673bd14034e6ae911fc2ab4e1210825ded1b5eafd4c07d9cfc4b92c6ec54f7a9f5bd3bfd08d40db07efcc51f7014e431914cd6a8674973a4e0cd31c653332fa2e85ed79cfede803cbd7a65b1856afe06bc98e708f8e057048a2106950ad9c96dc7ccc2f009cf6985bad46813cb1589ac56585d209785278ba47c6051f5b78a6c15332e3d3deee73494c9d2c86a817d93e425a2db0a9a211d18887531c5a05409236593ed24115a3065f768f1c7027a76edd8d06f4bd1f20e71fa8b5dac760b49847b2d980b698cd49ae614188c601f1850ee026dc1de5c47f5186951f45cd1d640533b537a9cb2bb6e211f4e1e4d27dd07ded1d2b920b4be5c04cb906dc3176367b91caf5b2727e1f3177dd6b7abbbbdec4ad2bafec4e2c8ee2c7af39aa6f20a6b25e6df30f7d393f665e2482ff4abfe8a7ca3a4b39b467cd3ebc480307086509c11db823e07ab4d3d02f49c2ec1fbbddf5f92c2c180a7af545a604ff005bac583b03bb0650103e8b4aee63bbddc00e0d0e935e1b7128cfc4d42b8b2fea140b0677d46bb38135345c2e74bfca737a37c175d71cf1bd6f49c69596847b093347c35e46608b4a2295ab2a398f0fedf1b14de8a3d4cd01f8fd3427de27e019de758a8207084bca72a7108293611144ea2182c6fab93c30d6509e874066982558f9da778afced82a9b093e22aa963f383d08783a1e861fd920760dc82beb6ed3f5c6226252ad077e41242d713d282ffe3783b703fa1d7ef83a35158c4fcfea0fb1214ecce4839a8cb1c482645e6d4a814233b6f6fce044e4e883439c9750a067392611392bfd0a4001ea5f2a1d1a1a73e8f7cac3b8ba3d9a890ff8ab61b68fcf644b1841dcd36ad02363ddfd9fd6396e92854e8dff562c485a4829ce01350adb4cad3c48436cac917d81582fbccf5282013b8881010929d1148d664c100300f9cd2cfc43ca7ada9870fe3ab4ea6d3cc0f52677a24381ae6605e9f15fc35dff7647c7e4e2f529b38777be752e57034fbb9905d29858ae3e29d1cc1909c2b5acfe16aea8e54b1cbd2bcc42eac227657686075dd4c685c1a5d69731a8149587bfeaf5b0ad564d856cc50514f8a64fdca0c32b0d206570e1ecf7acb6f1ff599a16cd17212e6d5453d1d8f375873c572fd83c98aa968e570af99c8d3d439c317b3253a8278e80175e12b7e31f6b819ec9c87073a5bf521de46abda10842f095898e144e841c0f7639ebd1e7c438f6aeab332547521529b4f8f915b75097b047487cdac4f0a81ecee0a96f5c14e4fd0dc16ae7026ed181ebdb4ff65587d6510b5dcb9295719062cd3651ecf00a8114762e53f6cf22710509cb73d9b09b39ab1f14df2f0ad14ac93bfb1ca86fd06095a3c07d898d6477e07bab928a474f7f07c208078b6116a98f643de4bd69659fc9624c00c1a54e2ad323904b290dc85ffad6f97e5b522cc4fb95176a5ccace0995fbffab4b1ed79771c105c444ea4aa91716b19505e29aaec91109acc07960028816548ad02b4cc06fdfeb59992a3a1b938190d9e032c3992fdb51c2e94e8f04b4f767bb9d1f94f20973a01e3a3734924b65b17106b58e16c9f66e523e1029369bc3b82dc733187009b1b0d6e1417214341453a23da2ece36319680b1546fbe62290a442a7a64a9393039564d3430e85c67e0d1cb12ba885d2c258f2d62ba962a7c237682d11e201fb9970abf104ebf7d6af530397d75931bc23398e4aa5fc9273ea35ba2c07d0a94e9414739ba4bb68bb4aaa5ddcee33373d09c45b8aba0750d074e30cb2aef32e6e44a793e28d8b5b0ae840b769cb2d63413d5e0cbd17eac3b09b57694023755813055ff21e5ab1751f00dd15739a1203d5d8b7e8b9fb72b5d2419c1f7798deef557536acfe3a513907faff94034eef60fe9a90c4d4b3e8f7c1d4a45e3d07b8607206aed077c6d67d710f57a3db8d4150e9a64e3106123de7482f4f48099bda9948bc8d861fd7a8a67e29e37ffbacd0f946c8657f8404baa8d07a295e7069048478068f6255e2b8c1f6bf21f5b68add12a8e97257bfcf64a8a347829ad1e7ebf3a449f4ea52f3988e09070f253040a31bbca167026b7e0afb32feab36c0dfdc8450f5aed2486bd13577a5da7885ff494172dc08e1e6fae131d6e3ad324ca9f093d9db070bcc84a12909a15b017bcc0bc7a6abe88bc5c82f921c424b943d5ea0949ea86b42e48b6801ac4339510f5ae3e3fd2c209087c345c82ae71332a3a56f1802c550fcbe0e4fe0ff49eae13120228b030389461b4d6498bcfe6bbe769c587f3015d06334374d694faa41260b108ecf0723ac89293f7cc101c484ea9a9756d101ae50f83532ccd0d9e23a0bd01fc2bf24176aebb78f014724fb630d9c0da375274a0f3119a07a075bec91ba1476573d4a9f2d96e892cfd945a08191ef93fa66c617b263afcc181965ec37cfa8b27e905cec76cee0618c77497af65e9c97f869759d0f950697a1f7dd7eac2fe702249be86e6a02732388c542b1542ee662a5827c5b935b941ff42b0f02e3c325a5f03d640708c34acd5c2b72169065db476595b786d5f29d7fc3434136c5884d4689fb726e74897f843c7132997ae3f8cdb5fda83694065852b856f7b9f88fab49afcbd768878a6a49709ff9f5fa9ab7ea77b3c01861f547bec0afb2ce79ecf53e39764e2a97af96a0e6734430662b763e78932920881b268088e3d7767155a02c7d6755bea3368396da46aa3c73837e3705a14fbe597750da73daaba73862b49cfd9cd4f7059b9c4024952164b5addfff1f30e4ba803ecd12a9f6bf18b9a78c08710cf1923102c858e3fa16b9fd87b4a16699655f077db93cadc470ef619ec74819195bd14e66581be69e0a2250de4cb82ac506a48ba60d70e679ef12cbb2175c8d9eeb97bd08e968ca6841cd6fc595a67f1cfeda178b81817d87aa788a6987d06ca6c2da988d3cffd8695ed8e34184e42d539bc6c05e4586ea869d361768901509f7195a6bf1d3ba6d02efb9b460c1df8b9e9bed0de205c277b6f0bf4bb264207b50cd45b8d146e25580d1253ae5482ab6e5a786bd8a9da656028580e4be81925b4b388cfe482e50d109411a6e634c32bc719a38f4aa7cb1cbafc90d09046339c8d6eacb13a503a5c10667152f5f1fe997ed8af3121f5d6e6d1f9bcb21d96b27d5f140f161473b3b3a6c60302c7f6c1979ac3b3c9058b5d3ebefa19e967bda2ad58c3d53a211295c036724da6fd6a9eea0e21d216dc042efcc9502b8f24425f3599e137a7ee786f5058042d3bd12f1c2e0572e667297daa097a1ef45317ac3605ee43e9a9157873bf735ca4e1011fb13c5ddad13d82ae350f850ff84aec5c30e9c340a4247560252a5738513c7f2b5dab46c477524c778ac87192b70db31f6dc04abfc52d5636ded3092d261ef7b2a3cf752665a65bad281b53245afb47fad56497d7640ba03e6d8c962851106673c326b30ec6b0b58b422f84521f6cd19eaa6a9c9b9f4f4b3521f3041ea7f6f788fcc36eee8e605f069f2dc4ef58c03525afa3469e26729aa4894eefe98cda7c941b8d2774d2d88e0ee50dcf17d0fc587eeda009c4ec3ffbb05c108d91377f3da49901092f93781e41cc84f80a3d1127361eeb7674e4a089690ebb7e1ce45be7309e40d9cc259f93f16416640001d5eecc4296cb942a1d3d1e69bc3ac70c0307bff895e942ec547d4c35ba0370b5f3c880b8d532e58ef056f9bf2d920a18a8a3ee6cc644d006a9957c991d6c40b1e6698497b8cf499c89cd4e0be3503e665db84df2f281eebca05b5c8edcd7d61375d1541aa511d2c8e45062bd2e46ad4864cd9597d1cd98c987ee45ffea6c828f93e50c6544aa1ba18c2da0df28a45fc6d019cd7c35adc03b906da6a2a4004d2e26a0136ddebd95abefe04808ff3988e8c484bb7c1adb0499d2c8dfb99c83532604ec2b22bfc2b9f6fd461c9681e29cda10dba7e9836ea509aa7bae86ffc6e007deb6ca4d3f466da88ed147b11920bf61dcd007bf5e445fa10af08267a8927a7c9b6df3be7d6fb365e71c7c1a99160ae727542e0b909dc366cb35c3c2bb99a51f23765c8a20d3cd38c196829c33cf786d07f2ae12af82be5a0d13bb6ecbce74a4655637ada8d69274e51fc1b8dae55d70c019e5844a30862c0ae663ba04ba3cb5098f27f1e679b75587e2e119b73c7cf1a797fbdde134932a734e84989a8a9a6b64eb1d252ef7fcc7daf2d92449c9bc6fa5c72d6b2830457bdde591e2342e995adae9637d0174d8c793a49c1ca42aa8c3d6ad92b8463f9cbb322c7384fbc8274c1dd4aef96c42e73c6aa7d4a799c9e57588504b7a4f629d47c828ed9714365877d040e6ab19085a78b87044b445525a5a8844ef59c7b4c018103b5c0bab96854b1d26d9aba11b91066a4c302f12aeae0b5e383d48f93c4dabffd723a3441ad5f5f0f664bd307de3cdbaac3b1652268df3f41b1596047c4151644ffb774bf95262ce6d4faf4a65bd4d7c93f480b09ec5860cb9c7544da1ab278bb4f7e343235557639ceb034b0d44c6e29e5a66e6a27fe4be5948606d04e412a6814cd0c7b028611c7b32d93927e62d6a171fb3ab82e2f785a228dc8eefed0f3c3e6cd89d7a5d6d04ab9324677284ec97291d491630d25a0f84f2901bf6446694a643c0a8684124cf3a53c50e267a0c6ff59b51de11840a8ae653835cd0143a038923d3c7d31ca832a16e1ed40098dc34d472026a39ee76ea98aed64d6fdb857e0d2d54c2891380922fd26006388bbf4a4480732412b8840f92f0ee8fe2470ebfec5e620c2f2151819229c3d8a3fb187e8b6b401f450b6c2a26873b63fcd4726f7788733a95de93a27355ed1a0762334666bdd10df41af317b9f34ea8651798468c87ce8e4ee6790d5df389302f9dcbef002e7703280cacde3a4730b38032b21f57c52464d1e26cf63e0f53b39c4432054467e6b7d617969fb50eabead2d58e30bfdcd8ecc4bf225fdadadb4c0e3f135ead71643cbf4128ca6e7439c5791e3745d03a1200794b0513cb70c2c1bb89e91bdbf26dddcc76feec33be46d2f8443b999302b519315efea849b9220ea232f755a5287ef05fcace71602d71b0cfb5e42e5c366e53fa39ba94caf760f7e7f3b43b6e8997c18486187f8e95f6a75bc159322732096c7f8d608ab0eb1c8ae6ef05ab34585709fe3ee6ee12171fbe6b75bc500680116ebb05fe1d0ce20b88b344f1837ad5e405dfe635bdca935e9cde8bd8d5fa165e4e766ca32c89591293d1d11ca855bbd1f26b1b758b376fef193288f70c09ff15d1bd2be2188101bdc58d0d3ffe8e95d2ace67108962371b35e1045026356aa8c2ff4189cc6ad9a1510451f1ac9f0ef9bc4b394a586e12021de083ff336d1f01c47041dff2b58f1f796756e6c39602882440556f584e958d19a30c09ef76065b17032abae55b441d33e4d057ecd7aeff08867ab030ee4bf03db1bf37d5ec6dfc4dde6ac0546f74ea4e6384c863b73a98c1f822c5cf9170459bd779ba797ed72d9c9c81dfe7f0efdad28262ff7bed641f3c6687cf00afbefe67f69e697d3d4b28e55935dbe5d2a8cec590e66cabe907cba5945749ac39d9062839ed1341d4e4e98f5dd1f5fdb27c5fdd8282fd9132b313f8089ec68a3c8aac7292e24f9eccc65366e998ea2a808b8900595242885db9bad9d2f4e5e929a969e560e92716d7ad225ef0225a7a5589ae25b18ddafbdd1b1324ad24be213fce18c94210af9bd82622890f875369585c21667859ac9ac40aa6dcfe294dbd0f10ecc1d2c21b81cf6e9033d7c4a591a8451df12e4aacc2e79f34bf2016d1b2301beadeb900a278265ed99172bb06b28bb43c7626b6ee3e0664e0b9b61141271e44d3a4db2a8c805737666f99598f0b7b459aa823ed6700de30f5ee23156291505722a8a2025b9733a15ea6e8a6c84efdbbe0d9c8bf2aec712ade7a8efbe7b1ab2cc189a1b1b747dbecf816bbf3639c40e617ef1014cbdcd6a886059d7b0955f490ae599e4806e47ae5a0181866a4de0b074a4a8ca8d2d08a1f00c6b1ea7e198e2a859ed6ed5ae4b1c811a0f6059a3e8afd13ae77ef936f81c9df67717b79a86fa7d7675dc82bfc646c70a1e63cce574f5e0f0b17636c30ab7b7e4ac2461a8f52935df0031e1bd8cc5623250f1eebca633807b443c328a66664641a3009f9fe0182de4a978257d64a7081d03a07224e03c38de9c8543b57dea63adf5c002112cf138ec818d91cbca9e717885641d0e410f090e3795b5ce9451225ce9a42622fede8e33beb6c110d011d67fe092fad505bb484394f53ee5978fb1c20b77d0ced7527e3809a62e5be78fcc36d899b9194aa50caea56dfd8c4322c679a1f0e9cdbba80b3df6704a8eba0c57f97f4f937131bbf3e7a628924a639c57869533f34938a5ac419c497c709152ba52e3054b6fcec084e9efb3f1a460f015c0f037bacba69c4aa5f71ab7712f76db7bf342496613be070ca8704442bea2dd6df8ac9a19ed99c4d0a92a8cb6e8f91483703ff75b55057d06e12df79a6bd634e32dbc7dbd1d8f57c1bac926838da9d7987f60b73679b944c2bd858ba357da4bf1a8ad9da9f59079a240f0d1e2c1b35b12d2977e066b074d55e39dd0c13cf14e44c918777794f7b05f6d8e6054f522fa1b6e729c2fc0ddbb9cfce42514626c3157711937133efe5fcf6985eea1bc89c3b2af4d2221c2de8f653adfc3102009075a4760271557e6fb94b9c5451dcfee706bfc676f6a19baeca8fdf8d57e4289d5d93187336b997163bf4ea53b2f449e9e26f939244dd7535daae0c35eada4091618485d076b22b4d9a94bfe470b176e476ff587a8289f8446b3b951c6462da12e1390c2ab6d3417531d090cc6d0d1a593864f7f6b4014a2fc6fd3a9c07b4a4e382809d5864260e07bf47e5af11235f014a2403f95b520912d738fd760156183705dc84757df5c00b4c40bc7b24265bfee0e3bba004741e3ebe6495909d2ec3c798f63c2df09b993c7dc7a8c2a69313f714cf4c3521a0c44be4ce7b111d299565d94b7c49d45811504dcebc6f91af9bc6bf35fd40503423f00ae710f9a9119f4fcea532e649d36f234080f16535bc4e92eb7a0065b84faf4a651dfb5a4dc38907c642275501c88dceee55c1bad515f2ac29f6ccbdcf5daabecac70c557644edc359eae2510e8ffa88b27c558edf15604871d69fd2841bc9e27d8d1298e39ab4a9f5ecf71961064891198f16f3142b6cc79edb5b52898a4b7d4324b452a5cb3683321e1d4cd638ce3904179030dd40e3bb505e46d1dc07cc7d2eded44b925b467a10dcf1a1d249c1c8f34016173e3f69db81d3c29e9a814afe2d4ae8c0f1dbc5de5ebf0530a97c628ad82871b74cfe01c5dc2fafdc7da24285d8f8a6d81bb8d4682dcda693ad3461204cef05f0a02af790d546ef16dc7f212a1e886f6fd12697940633c88d3d87a98ef94c3e826e2faee861b7babe86cfa2ca76968b5ba479cfcf5d249a5be194a1ea91c57df18a646f2becc8d407f7a2c114baf8831926d3b52befa80dccea5a016b2e27da9f68208aa91c9b9ec40f3720fd08131ab2910fe226e4774c7dfe0c777b9bdfbfff5ebfbe062a4eac1089e233297c7760df554a3df1f91b4c2c60d16efd7b926a2a5769fcea97639a0b7d9d3ae0ecc581fcf549525e8e189d193875c434b0b2f294f90adab38b067f8b5fee98d4d820dc3ede4146ac66fe5e457a10bd9278c6a7c8fac53e23b38b52cb56d56f9a5d5dab3e1754507c76f220f2c5f0f756363d0f2acc4603ccb2527aaea1f60da35fee8fdd12f9f6d52649a992af1d65911a7afa7c03580ab074c1fc4954ef0e6e9af2cb106894a243ae0541d30436d0b8305f9f54158ca090e455a8b010016642dde8ff6f80875ffad9297a103e603d1a28a190f4d2c8f9d0ef66a9124babb2d5cd57452913ccf2650cf3e3824716509430459b9e1b5b649248118947271c3ec66f4fbcb1cec56899e5620d9dc2b5f8677a6bd3f3ef7ab282835ba8a2a3393eb82a4fd2ebcf083b8a74d66bec856c869fea2494c6eb4564da43e2b4e3fa17c6f75e02d64871414741c8b84115b288511dceb2ed92ec50134c3d321e5f1b0526e38676a42a5b2300b457135bd419df0248548d008977a138152c5c766ad14a1d4ea8c5c72dbc5f380216113fa8005365d2bd14dc4c7c472db7416fec1de1c8c53f1f500a1b9c65eddf42aac6e67af0ec462e944efd07736ce67ac50deda715549ae0ab6b47028e51fc82898f56549140b2431f140e2c906b893c11a4cb18c799b851d53ba91550cca60d7f8c9381b0373b4f179e0988395ff4163edeeaefd0eb023fab64eb832efb9720abca5bf9d37259b3eca4357ac4f9f7340cd610f471bb5dad07245363fa7a84754b20615bf6f190f2061534350852e5e7d909e28b09d5dc5c20138b2dc586c1be8546dfb10ee9a02a2ea2ae2149b5dddf09ec4c5b6470fa183102dd51649a3e462777e99d29aa95d1344d719ea2334426830ccca41c2ac017160f625b2086564ec11394b0228557845aa6aec74b675dd03c79edc8ed442f6663c3d96c19b2a893d6a02d4603ad0cfa91eaf3cd46d471088c8a52a2ae9cece4f6f850d49cdd53a2c90085f77363214d310492f47073fd09d9b7506a2238fe58f428992cbd7bb4a61fffd6113c7dbe3dd6410f8ebbcb1c0303d526c1e21c29558be1da4e99a37fbcfc4f0841d16b69d9c074a285e25edb598e073bdfe1f8866f86014a6b122715314e241b5f0fdf3bc22cd470f2dba1f08b3a2002c118898f12e977f5758bcb81f469162ffef20af932182a527480a8ac243c4b947ae1db7116df5471a6baf224cd021609b961cb7043db39824cfc619bc8331a559e062f3e79a37e639cf1b5bf319d2aa45c4dc6ffbffb1b0c8a9b94ec8c4511b8048f393a2ffce29f335a2f3982077826d2fada9d550fa84afdc1cd202236313c19380544a2f8a506a0c62160177ed72d1f5e4de9befe78b83c3ba3972720749d6330ef5467238355aaa35f910b1071f3ed95163179e94ef3f3b4a82fca86f93a17aab72e8ccd6fe942fffc9ba06bc147b5abc4c40518583b1411fd2a7270c5a406e23d4c0b5187c3bee7fc6bdb182d136da74d43e8b2b3f2c9e5865b18bc69914fc0d852d9c16a357309ccb568bdf43ceaef426057691fb6c2724df7255564255e984a73be697c7827b693994c023a5592567bcde62e63e512d56caac9685651b01c6654d492faa1d5818943b532d867767f28996c9a34540d38ac9ef5c531dce7dfadf062897d4f08b235daff030a18bcb8476799f61d289083852807faee70c75d54fbe24dbd1c8264d5604d3ff382ad539a35a5124e7808f2f4e55d690403a30fe68293287ad60bf1f888879201bd6c660acf87142a8162dd291e17b96e34bd32386f71240c9aeced00d34ffbc49ccfda9e78b0da8964f083aba2b1a5f4c9253c03d770eec343b06d3ef304763ae8528dfce35c28530d7d25ff8569a1cd316da945ce29dc1ee2abba4149965469075b697f4bb3391633fce9476b6e1d2c2b13e64a3c3e9b9b097d3ff2cb14f1538143dac05eaf2cef1ba79280ade72dbd8e775205f73a06683a09b8cd41223823a0c20623f98cd110f06a1a4b6e34010b380a40cab4f7d9bb29b20dac459660c961b99439b20513161a56bdbc882758dbe94e29ff2bfce67278e0ec1df35c70201a36b23116e6ae38e4eeead9eeb688a9c39e7ec24233e2dcb93c593e5889a7b433678406d70218698e4b93e9b9aede30a93e952e25d75f691484b75834e2a6a1f70c7f330db4259e6f38e3c2f20662411fb4c30dae85ed1be2aa516f0e1e88d00a1c86a1c009ed5841f9f7d5b9c4398b05b9c0eca7c83a259803d02c7aede042bf66356ae5a011611a5fa5ef76ea58937e78c1f5fa70add9d73127dde66420a9fea53a906c61b399fc3dcd27247fa9eae8fc244e56d00f4e3051896fbe001527683f7df4e785d61e33e7371fb0bea309d37613e98b7371632e6a788d12f138c1052c3e385848cbd408b6b8e9d3d611037ee2dd937d35bc9547ad37d6f64916fadb1922c0f7701e281b892f49b3f1c82aa885697975aea3447c7c2462e158fbd8a48ac4632f866e4b521d03e4eae89b2d8cc7a5ac38fa8b18705b1fa279c361fb1caa284b23709745c2336c1d7d96480aa54b86f710015a8ce23f6ca7ae203414ed8eb9c9d4c4d7e4a0ca7787523fa65480d0b8f929b6c96ae4405661746608c8077288f7a0c9fca7bba6c3f620eecf6b4386ad1694ab4ae046830c49c83e6be6e91dc81590b8fb199cbdbc055be802bd4783bdf33b96338174e4f5dd9fa839aea1d6e1a8bc6b715718f89a37493afd1c1c57033d9d9ae5e284e0c072daa52a0012511798fd4205b5304d4954b80c8c5932f4f5bc5fee0a2ddd521482b871801fa6879ce6cbac367e223c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">诚信考试,不要作弊</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>移动通信</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>4.传输线工程与施工概要</title>
    <link href="/2022/05/26/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BC%A0%E8%BE%93%E7%BA%BF/%E9%99%84%E5%BD%95%EF%BC%9A%E4%BC%A0%E8%BE%93%E7%BA%BF%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%A6%81/"/>
    <url>/2022/05/26/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BC%A0%E8%BE%93%E7%BA%BF/%E9%99%84%E5%BD%95%EF%BC%9A%E4%BC%A0%E8%BE%93%E7%BA%BF%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%A6%81/</url>
    
    <content type="html"><![CDATA[<h1 id="传输线工程与施工概要"><a href="#传输线工程与施工概要" class="headerlink" title="传输线工程与施工概要"></a>传输线工程与施工概要</h1><p>传输线工程设计可以大致分为两类：新建工程和扩容工程。不论是哪一种工程，传输线工程的参与者有四方：</p><ul><li>投资方：工程的投资和需求提出人</li><li>设计方：为投资方进行具体的而合理的施工设计</li><li>施工方：将设计进行实现的具体施工者</li><li>监理方：为投资方监督施工方的具体施工是否达到要求</li></ul><div class="note note-warning">            <p>需要注意设计、施工和监理不能是同一家公司。  </p>          </div>  <h2 id="工程设计流程"><a href="#工程设计流程" class="headerlink" title="工程设计流程"></a>工程设计流程</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>在需求分析阶段，投资方会提出工程总的设计目标和需求，同时设计方往往需要协助投资方考虑各方面需求以及设计层面上的实现问题，并且根据投资方目标给出具体分析。<br>一般来说，需求分为：功能需求和非功能性需求。  </p><ul><li><p>功能性需求<br>功能性需求即工程必须实现哪些功能，以及为了向其用户提供有用的功能所需执行的动作。功能性需求是需求的主体。  </p></li><li><p>非功能性需求<br>作为对功能性需求的补充，需求分析的内容中还应该包括一些非功能需求。主要包括未来可能的扩充方案、环境影响等。  </p></li><li><p>设计约束<br>一般也称做设计限制条件，通常是对一些设计或实现方案的约束说明。比如指定只能使用某个工艺、地形地貌等等。  </p></li></ul><h4 id="可行性分析"><a href="#可行性分析" class="headerlink" title="可行性分析"></a>可行性分析</h4><p>设计方需要对设计需求做出是否可行的判断，这个步骤通常紧随需求分析之后。可行性分析包括：</p><ul><li><p>技术可行性<br>包括理论技术手段、工程过程是否可行，设备是否齐全等等。  </p></li><li><p>经济可行性<br>主要是工程预算可以满足工程设计的需求。  </p></li><li><p>社会、环境影响<br>考虑工程对环境、周围的生活居民等是否有较大的影响。  </p></li></ul><h3 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h3><p>方案设计分为总体设计和详细设计。对于较大的工程方案可以分阶段设计，一般分为一、二、三阶段设计。较小的工程可以直接进行一次性设计。<br>方案设计需要考虑到：  </p><ul><li>保证需求实现  </li><li>施工的工艺和方法  </li><li>根据实地勘测进行设计  </li></ul><p>在总体设计中，通信工程需要考虑线路施工和设备施工，并且做出概预算。<br>在详细设计中，需要做出工程中每个阶段和每个部分的具体施工方法，并将这些设计写入施工图中。  </p><h4 id="概预算"><a href="#概预算" class="headerlink" title="概预算"></a>概预算</h4><p>概预算中需要考虑：  </p><ul><li>设备造型、工程材料  </li><li>时间周期、工程量  </li><li>人员开销<br>上述费用称为直接费，此外还有管理经费、临时工棚搭建等间接费用  </li></ul><h3 id="施工、验收"><a href="#施工、验收" class="headerlink" title="施工、验收"></a>施工、验收</h3><p>施工方按照施工图进行施工。在施工前，施工方可能会将整个项目施工分包给更多的施工公司，在选择施工公司时，需要考虑其是否具备施工资质。  </p><h4 id="监理"><a href="#监理" class="headerlink" title="监理"></a>监理</h4><p>在施工阶段，监理需要深度介入施工工序，监督施工方施工。通常监理方式有抽查、巡视和旁站。<br>主要注意，整个监理过程中需要详细撰写监理报告，以保留监理证据。  </p><h4 id="施工的意外情况和施工图变更"><a href="#施工的意外情况和施工图变更" class="headerlink" title="施工的意外情况和施工图变更"></a>施工的意外情况和施工图变更</h4><p>施工的意外情况可能包括：  </p><ul><li>工程建设过程中遭受地质灾害</li><li>由于设计阶段未考虑所有影响因素而导致的居民投诉等问题</li><li>发掘到古墓古迹</li><li>施工开始时缺少必须的生活资源和必须的电力、柴油等能源  </li></ul><p>在施工过程中，由于意外的施工情况而导致施工图的变更，此时设计方和施工方需要协作交流，建设方需要更改预算。<br>在施工的初期、中期和终期都需要施工验收，验收主要需要验证工程的功能时候完备、可靠性和稳定性。  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于施工的四方而言，其主要关心的内容包括：<br>对于投资方，其主要关注1)预算控制 2)工程结果时候符合预期 3)工程是否具有后向兼容性。<br>对于设计方：其主要关注1)设计需求：功能合理性和前瞻性 2)工程设计的可行性。<br>对于施工方：其主要关注1)施工成本 2)施工进度是否符合预计工期 3)工程材料和施工方法 4)施工和设计是否符合。<br>对于监理方：其主要关施工质量是否按照投资方预期。  </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>电信传输理论与工程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>5.计算机互联网：IP协议群</title>
    <link href="/2022/05/26/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E7%BD%91/5.ip%E5%8D%8F%E8%AE%AE/"/>
    <url>/2022/05/26/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E7%BD%91/5.ip%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机互联网：IP协议群"><a href="#计算机互联网：IP协议群" class="headerlink" title="计算机互联网：IP协议群"></a>计算机互联网：IP协议群</h1><h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><h3 id="IP地址及其演进过程"><a href="#IP地址及其演进过程" class="headerlink" title="IP地址及其演进过程"></a>IP地址及其演进过程</h3><p>IP地址是整个互联网上的每一台主机/路由器的每一个结构分配了一个全世界范围内唯一的32位标识符，从而能够在互联网中寻址。IP地址由ICANN组织统一管理和分配，中国用户可以向APNIC组织有偿申请IP地址。<br>IP地址是一个32位的01比特序列，为了保证可读性，通常每八位转换为十进制数，并且前后两个八位字段以“.”隔开，这种方法称为点分十进制记法。例如：IP地址：11000000 10101000 11001000 00000010利用点分十进制记法写作192.168.200.2。  </p><p>IP地址的格式经历了三个阶段：  </p><ul><li>分类的IP地址：这是最基本的编址方法。  </li><li>划分子网：对基本编址方法的改进。</li><li>构成超网：无分类的编址方法。  </li></ul><h4 id="分类的IP地址"><a href="#分类的IP地址" class="headerlink" title="分类的IP地址"></a>分类的IP地址</h4><p>在这一阶段，IP地址由两部分构成：网络号和主机号。网络号表示主机或者路由器端口连接到的网络，网络号在整个互联网范围内是唯一的；主机号表示该主机或者该路由器端口，在网络号对应的网络中是唯一的。<br>根据不同用途，将IP地址分为了5类，依据网络号中有1到4位的类别位对其类别进行识别。<br>其中ABC类地址用于一对一通信，称为单播地址。<br>A类结构中网络号有8位，其头部类别位为“0”，主机号有24位。<br>B类结构中网络号有16位，其头部类别位为“10”，主机号有16位。<br>C类结构中网络号有24位，其头部类别位为“110”，主机号有8位。  </p><p>D类地址是用于一对多通信的多播地址，其头部类别位为“1110”，其后为多播地址。<br>E内地址的类别位为“1111”，保留为今后使用。  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220529152515.png width=50%>  </p><p>A类地址中，网络字段号全为0的IP地址是保留地址，意思为“本网络”；网络号为127的字段号预留作为本地软件与本主机之间的通信，称为回环通信，网络号为127的地址也称为回环地址。因此因此A类地址的可用网络数目为$2^7-2$。<br>B类地址中，128.0.0.0不指派，因此B类地址的可用网络数目为$2^{14}-1$。<br>C内地址中，192.0.0.0不指派，因此C类地址的可用网络数目为$2^{21}-1$。<br>对于每一类地址的主机号，全“1”的主机号表示该网络上的所有主机，全“0”的主机号表示该网络上的本主机。因此在每类地址的最大可用主机数目都应当减去这两个主机。  </p><p>关于IP地址，需要注意的是:  </p><ul><li>IP地址实际上是一台主机或者路由器与一条网络链路接口的编号，当一台主机同时连接多个网络时，其应该对应数量、且不同的网络号。这样的主机称为多归属主机(multihomed host)。  </li><li>路由器的功能是通过多个端口连接多个网络，因此，<strong>路由器的每个端口将拥有一个网络号</strong>。也就是说，一个路由器拥有多个网络号。不过，当两个路由器直接相连时，可以为两个路由器连接的端口各自分配一个IP地址，此时两个路由器视为独立工作，也可以不分配IP地址，此时可以将两个路由器从逻辑上视为同一个路由器，这种情况下连接的网络称为无名网络。  </li><li>同一个局域网中的路由器或者主机的IP地址相同。此处局域网的定义应当为上一讲提到过的“由一个交换机和其连接全站点/主机组成的网络”，因此，使用网桥或者交换机连接起来的多个碰撞域具有相同的网络号。<strong>由于传统的网桥或者（二层）交换机不需要和其他网络进行通信，它们一般没有IP地址。</strong>  </li></ul><p>这样分配IP地址的好处有二，其一是IP地址管理机构在分配IP地址时只需要分配网络号，主机号可以由得到网络号的组织自行分配。其二是路由器仅根据网络号转发分组，大大减少了路由器中路由表所占用的内存和查表时间。  </p><h4 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h4><p>随着互联网中主机数量的增多，分类形式的IP地址的弊端渐渐暴露出来：IP地址的利用率非常低，每个A类地址的网络可以连接百万计的主机，但是分配到A类地址的组织往往主机数量并没有这么多，这就造成了IP地址的浪费。第二是随着网络数量的增加，每个物理网络分配一个网络号最终会导致路由表太大，导致查表时间和路由器成本增加。第三是两级的IP地址不够灵活，申请到新的IP地址之前，新增加的网络是不可能连接到互联网上工作的。<br>在这样的背景下，1985年起在IP地址中又增加了一个子网号字段，原来的两级地址变成由网络号、子网号和主机号组成的三级地址。<br>某些单位可以将物理网络划分为若干个子网，但是单位对外仍然表现为一个网络。发送到这个单位的IP数据报在被这个单位的路由器接收到后，按照子网号找到对应主机所在的子网。<br>但是IP地址中本来没有关于任何子网划分的信息，这一部分信息需要由另一个单独的比特串表示，称为子网掩码。简单来说，子网掩码也是一个32位的比特串，其中将网络号和子网号标记为“1”，称为1语，将主机号所在的部分标记为“0”，称为0语。路由器在接收到IP地址后，可以用子网掩码与原IP地址相与，从而得到真正的网络号。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220529162707.png width=50%><br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220618164312.png width=50%>  </p><p>如此，子网号的大小可以根据每个子网中主机的数量进行合理地划分，从而增加IP地址的利用率。  </p><h4 id="构成超网"><a href="#构成超网" class="headerlink" title="构成超网"></a>构成超网</h4><p>划分子网虽然缓解了IP地址利用率低下的问题，然而由于IP地址的格式限制和日益增多的设备入网需求，IP地址面临着枯竭。2011年，IANA组织宣布IPv4地址已经耗尽。<br>此时，为了解决这个问题，互联网工程工作小组在1993年发布了一新系列的标准，其中提出了无分类域间路由选择/无类域间路由（Classless Inter-Domain Routing，CIDR）的方法。这种方法可以将路由集中起来，在路由表中更灵活地定义地址。CIDR不区分 A 类、B 类、C 类地址，消除了划分子网的概念，而是使用 CIDR 前缀的值指定地址中作为网络 ID 的位数。CIDR把32位的IP地址划分为前后两个部分：网络前缀和主机号，其中网络前缀用于指明网络。此外，CIDR的IP地址后还需要用斜线“/”其后跟随网络前缀所占用的位数。例如：128.14.34.7/20 对应的32位比特串：10000000 00001110 0010/0010 00000111中的前20位：10000000 00001110 0010表示网络号，后12位0010 00000111表示主机号。<br>CIDR最大的作用是路由聚合(route aggregation)，也称为构成超网：一组路由汇聚为一个单个的路由广播。其具体做法是从第1位比特开始进行比较，找到第一个不相同的比特数，保留前面相同位数，然后将相同比特后面的数（到末尾）填充为0。由此得到的地址为汇总后的网段的网络地址，其网络位为连续的相同的比特的位数。<br>例如：四个前缀长度24的IP地址：<br>212.56.132.0 /24 → 212.56.<strong>100001</strong>00.0 /24<br>212.56.133.0 /24 → 212.56.<strong>100001</strong>01.0 /24<br>212.56.134.0 /24 → 212.56.<strong>100001</strong>10.0 /24<br>212.56.135.0 /24 → 212.56.<strong>100001</strong>11.0 /24<br>相同的前缀有22位，保留相同位数，将相同比特后面的数（到末尾）填充为0.<br>所以很容易得出聚合后的地址块为：212.56.132.0/22.<br>路由汇聚的最终结果和最明显的好处是缩小网络上的路由表的尺寸，进一步节约IP资源。<br>在路由器中，应当从匹配结果中选择具有最长前缀的路由，称为最长前缀匹配。拥有越长的网络前缀，其地址块就越小，这样路由就越具体。  </p><h3 id="IP地址和MAC地址"><a href="#IP地址和MAC地址" class="headerlink" title="IP地址和MAC地址"></a>IP地址和MAC地址</h3><p>在计算机局域网一讲中提到过，MAC地址是表示一个设备的物理连接点的地址，通常烧录在硬件设备中，无法自主更改。MAC地址在物理层和数据链路层中使用。而IP地址是一种通过软件实现的逻辑地址，当设备切换网络或者是网络状态刷新时，设备的IP地址会发生变化。IP地址在网络层及以上使用。  </p><div class="table-container"><table><thead><tr><th style="text-align:center">地址类型</th><th style="text-align:center">工作层</th><th style="text-align:center">物理/逻辑</th><th style="text-align:center">地址发生更改的容易程度</th></tr></thead><tbody><tr><td style="text-align:center">MAC地址</td><td style="text-align:center">物理层和数据链路层</td><td style="text-align:center">物理地址</td><td style="text-align:center">难以更改</td></tr><tr><td style="text-align:center">IP地址</td><td style="text-align:center">网络层、传输层和应用层</td><td style="text-align:center">逻辑地址</td><td style="text-align:center">容易更改</td></tr></tbody></table></div><h3 id="IP数据报的格式"><a href="#IP数据报的格式" class="headerlink" title="IP数据报的格式"></a>IP数据报的格式</h3><p>IP数据报是IP层对应的数据报部分，其由头部的控制信息和数据部分组成，如下图所示:<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220530130833.png width=60%></p><p>IPv4首部为4字节对齐，即首部长度必须是4字节的整数倍，如果首部长度不满4字节的整数倍，需要添加一些冗余比特。  </p><p>IP数据报头部中需要重点关注的几个字段：  </p><ul><li>总长度<br>指整个IP数据报（首部+数据部分）的长度，单位为字节。IP数据报是可变长度数据报，因此需要一个字段表示数据报的总长度。总长度字段为16位，即理论上IP数据报的最大长度为$2^{16}-1$字节，但是实际上还需要考虑下层数据链路层的数据字段的最大长度，称为最大传送单元(MTU,maximum transfer unit)，因此如果IP数据报运行在以太网上，实际上的IP数据报长度通常不超过1500字节。<br>IP数据报越短，路由器的转发速度越快。  </li><li>标识(identification)<br>IP数据报中用于计数产生数据报个数的字段，占16位。虽然IP数据报是无连接的，不存在顺序接收的问题。但是当数据部分超出最大传送单元限制时，这个数据部分会被拆分为具有相同计数的多个数据报片，在接收处需要将计数部分相同的数据报片进行还原。  </li><li><p>片偏移(offset)<br>IP数据报中表示某个数据报分片在分片前的整个数据部分中的相对位置，占13位。片偏移表示的是该数据报分片的起点位置。片偏移以八个字节为偏移单位，每个分片长度一定是8字节的整数倍。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220530132219.png width=50%>  </p></li><li><p>生存时间(time to live, TTL)<br>为了防止某个数据报在整个网络中无法交付，从而一直消耗通信资源，规定该数据报在网络中的最大存活时间。最早的TTL字段以秒为单位，但是随着路由器处理数据报的时间不断缩短，如今TTL表示该数据报在网络中可以经过的最大跳数，每经过一个路由器TTL会减一。TTL字段占8位，因此一个数据报在互联网中可以经过的最大跳数为$2^8-1=255$。  </p></li><li><p>源地址和目的地址<br>表示源和目的地的IP地址，按照IP地址的长度各占32位。  </p></li></ul><h3 id="路由器的工作"><a href="#路由器的工作" class="headerlink" title="路由器的工作"></a>路由器的工作</h3><p>在概述部分提到，发送数据的过程中，数据从高层下到低层，层层封装。含有源IP地址和目的IP地址的IP数据报交付给数据链路层时被添加上具有源MAC地址和目的MAC地址的头部并封装为MAC帧。<br>路由器在收到MAC帧时，根据MAC帧首部中的硬件地址决定收下或忽略。<strong>在路由器的数据链路层，原有的MAC帧的头部和尾部被路由器丢弃，IP数据报交付给路由器的网络层。在路由器的网络层解开IP数据报头部，并查看头部的源IP地址和目的IP地址，做出路由选择，并重写IP数据报头部的部分内容（比如TTL），然后交付给路由器的数据链路层。</strong><br><strong>IP数据报回到路由器的数据链路层，数据链路层根据APR协议（一种IP地址和MAC地址的映射）查找下一个路由器或者目的主机的MAC地址，并将源MAC地址字段改写为自己的MAC地址，重新封装为新的MAC帧后发送到下一个网络中。</strong>  </p><p>需要注意的是，每一个中间路由器中的路由表只包含所有可能的下一跳的路由器端口地址，以此来减少路由表的跳数。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220530174420.png width=50%>  </p><p>从上述的工作模式中可以发现，路由器只根据IP地址的网络号进行路由选择，因此<strong>在整个通信的过程中，IP数据报中的源IP地址和目的IP地址是不变的。而其MAC帧中的源MAC地址和目的MAC地址会不断变化</strong>。<br>其次，在IP层的互联网只能看到IP数据报，网络层将下层的硬件地址体系和细节完全屏蔽，所以只要在网络层上讨论问题，就可以使用IP地址研究路由器/主机之间的通信。全世界存在着使用不同硬件地址的、各式各样的网络，在这些网络中实现物理层面的通信需要非常复杂的硬件地址转换工作。但是只在网络层面上研究，连接到互联网的主机只需要各自拥有一个唯一的IP地址就能够方便的通信，因此使用IP地址在网络层进行逻辑通信节省了不同计算机之间的硬件转换。  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220613140000.png width=50%>  </p><h4 id="路由器和交换机的区别"><a href="#路由器和交换机的区别" class="headerlink" title="路由器和交换机的区别"></a>路由器和交换机的区别</h4><p>从计算机网络的角度，路由器和交换机有如下区别：  </p><ul><li>第一是工作的地点不同，路由器用于不同网络之间的连接；交换机只用于局域网内部的连接。  </li><li>第二是适用的对象不同，路由器适用于跨网络的通信；交换机只用于局域网内部的通信。  </li><li>第三是工作的层数不同，路由器需要与广域网连接，因此其工作层数包括物理层、数据链路层和网络层；<br>交换机不会涉及到跨网络的通信，因此没有网络层。  </li><li>第四是工作方式的不同，交换机接收到数据包后根据头部信息对照交换表进行转发，其过程是透明传输的；路由器在接收到数据包后数据包的MAC帧头部和尾部被重新生成，IP数据报头部的一些信息也会被改写，其过程是非透明传输的。  </li></ul><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">适用范围</th><th style="text-align:center">通信场景</th><th style="text-align:center">内部协议结构</th><th style="text-align:center">传输特性</th><th style="text-align:center">地址类型</th></tr></thead><tbody><tr><td style="text-align:center">交换机</td><td style="text-align:center">局域网</td><td style="text-align:center">局域网内部的通信</td><td style="text-align:center">数据链路层<br>物理层</td><td style="text-align:center">透明传输</td><td style="text-align:center">MAC地址</td></tr><tr><td style="text-align:center">路由器</td><td style="text-align:center">互联网</td><td style="text-align:center">跨网络的通信</td><td style="text-align:center">网络层<br>数据链路层<br>物理层</td><td style="text-align:center">非透明传输</td><td style="text-align:center">MAC地址和IP地址</td></tr></tbody></table></div><h4 id="主机中的路由表"><a href="#主机中的路由表" class="headerlink" title="主机中的路由表"></a>主机中的路由表</h4><p>需要注意的是，主机在发送IP数据报时需要向IP数据报头部填入目的主机的IP地址。主机中也需要有路由表来指明目的主机的IP地址。在主机刚开始工作时，一般路由表中会有一个默认路由器的IP地址，不管数据报要发送到哪个目的地址，都一律将这个数据报传送到默认路由器。默认路由器在找到下一跳的最佳路由后，会通过改变路由报文（使用下文中提到的ICMP协议，一种应用于IP层的控制协议）将数据报传送给主机，使主机的路由表中的目的地址由默认路由器的地址改为下一跳的最佳路由地址。  </p><h2 id="地址解析协议-ARP协议"><a href="#地址解析协议-ARP协议" class="headerlink" title="地址解析协议/ARP协议"></a>地址解析协议/ARP协议</h2><p>在适用IP协议的通信中，源主机如何知道目的IP地址所对应的具体主机的MAC地址？——IP协议中使用了地址解析协议(ARP,address resolution protocol)来表示一个网络中MAC地址和IP地址的映射关系。  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220530143511.png width=50%>  </p><div class="note note-info">            <p>从功能上看，可以认为ARP协议属于第三层网络层的协议。但是从其结构来看，ARP请求被封装在MAC帧当中，因此某些资料上也认为ARP协议属于第二层数据链路层的协议。  </p>          </div>  <p>虽然网络层使用的是IP地址，但实际在传输数据帧时，最终还是定向到某个MAC地址绑定的主机。IP地址和MAC地址由于格式不同而不存在简单的映射关系。解决这一问题的方法是在每个主机和路由器内部都配备一个高速缓存器动态地更新IP地址和MAC地址之间的映射表。<br>具体而言，每一台主机/路由器都有ARP高速缓存器(ARP cache)，里面有本局域网上各主机/路由器的MAC地址以及它们对应的IP地址。当主机要向本局域网上的另一个主机发送IP数据报时，需要从该主机内部的ARP缓存器中找到目的主机IP地址对应的MAC地址，并填入MAC帧中，然后局域网把该MAC帧发往此MAC地址绑定的主机。<br>同交换机/网桥一样，ARP缓存器也有对地址的自我学习功能：  </p><ul><li>当目的主机IP地址对应的MAC地址对源主机未知时，源主机通过ARP进程向本局域网中<strong>广播</strong>一个ARP请求，其内容包括了<strong>源主机的MAC地址和IP地址</strong>，以及<strong>需要查找的MAC地址所对应的IP地址</strong>，这些信息被封装为<strong>MAC帧格式</strong>。  </li><li>局域网中的每一个主机都会收到这个包含ARP请求的MAC帧，然后解包查看需要查找的IP地址是否为自己的IP地址：<ul><li>如果收到ARP请求的主机的IP地址与请求查找的IP地址不同，则该主机忽略这个ARP包。  </li><li>如果收到ARP请求的主机的IP地址与请求查找的IP地址相同，则该主机收下这个ARP请求，并且发送一个包含自己MAC地址和IP地址的ARP响应。这个响应的发送是单播。<br>同时，该主机也将源主机的MAC地址和IP地址写入自己的ARP缓存中，以便今后通信。  </li></ul></li><li>源主机收到ARP响应后，将响应中的MAC地址和IP地址写入自己的ARP缓存中。  </li></ul><p>如果所找的主机和源主机不在同一个局域网上，则需要路由器按照MAC帧的操作将其广播到各个网络中的路由器，由这些路由器进一步广播寻找自己连接的网络下是否存在这个主机。同样地，目的主机发送的ARP响应也需要通过路由器转发到源主机所在的网络中，其处理过程和MAC帧相同。  </p><p>由于IP地址会不断变动，ARP缓存中为其中的每个项目也有生存时间（通常为10到20分钟），超出生存时间的项目会被自动删除。  </p><p>需要注意的是，这个过程看似和交换机/网桥的地址学习过程相似，但是最大的不同是ARP的对MAC地址和IP地址的映射的学习是主动的，需要接收者发送一个响应，而交换机/网桥的地址学习不需要接收者响应。  </p><div class="note note-info">            <p>网络伪装主要是根据每一层的协议伪装每一层的头部控制信息，或者篡改最上层的用户信息或者控制信息。<br>ARP学习过程中的最重要的是安全问题，如果有主机在接收到源主机的ARP广播后可以伪装ARP响应中的IP地址和MAC地址，那么会引起网络混乱。这是ARP病毒的工作原理。  </p>          </div>  <h2 id="网际控制报文协议-ICMP协议"><a href="#网际控制报文协议-ICMP协议" class="headerlink" title="网际控制报文协议/ICMP协议"></a>网际控制报文协议/ICMP协议</h2><p>ICMP协议是一种用于提高IP数据报交付可靠性的、<strong>位于IP层</strong>的协议。ICMP报文被封装在IP数据报的数据部分：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220530174706.png width=50%>  </p><p>ICMP报文分为差错报告报文和询问报文。当IC数据报无法正确交付时，路由器或者目的主机会发送差错报文给源主机。<br>差错报文具体包括：  </p><ul><li>终点不可到达：路由器或者主机不能交付数据报。  </li><li>超时：路由器收到TTL=0的报文。  </li><li>参数错误：IP数据报头部的某些字段出现错误。  </li><li>路由改变/重定向：让主机知道下次应当将数据报发送给另外的路由器。（比如之前提到的主机中的路由表改变）  </li></ul><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220530175246.png width=40%>  </p><p>ICMP的询问报文包括：  </p><ul><li>回送请求和回答：由主机或者路由器向某个特定主机发送询问。该主机收到询问后需要发送回答报文。这样的方式通常用于测试目的站点的可达性。  </li><li>时间戳请求和回答：请求某台主机或者路由器回答当前的日期和时间，用于时钟同步和时间测量。   </li></ul><h3 id="ICMP应用举例"><a href="#ICMP应用举例" class="headerlink" title="ICMP应用举例"></a>ICMP应用举例</h3><h4 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a>Ping</h4><p>ICMP的重要应用是使用分组网间探测(Packet InterNet Groper,PING)测试两台主机之间的连通性。在Windows操作系统中的用户控制台应用(cmd)，键入<code>ping hostname</code>（<code>hostname</code>为要测试的主机的域名或IP地址）回车时，主机会默认向指定的<code>hostname</code>连续发送四个ICMP请求报文，目的主机回送ICMP响应报文，通过发送和接收的时间差从而可以计算两台主机之间当前的链路延迟。<br>举例如下：<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">ping</span> l61012345.top<br>&gt; 正在 <span class="hljs-built_in">Ping</span> l61012345.top [<span class="hljs-number">185</span>.<span class="hljs-number">199</span>.<span class="hljs-number">111</span>.xxx] 具有 <span class="hljs-number">32</span> 字节的数据:<br>&gt; 来自 <span class="hljs-number">185</span>.<span class="hljs-number">199</span>.<span class="hljs-number">111</span>.xxx 的回复: 字节=<span class="hljs-number">32</span> 时间=<span class="hljs-number">37</span>ms TTL=<span class="hljs-number">49</span><br>&gt; 来自 <span class="hljs-number">185</span>.<span class="hljs-number">199</span>.<span class="hljs-number">111</span>.xxx 的回复: 字节=<span class="hljs-number">32</span> 时间=<span class="hljs-number">43</span>ms TTL=<span class="hljs-number">49</span><br>&gt; 来自 <span class="hljs-number">185</span>.<span class="hljs-number">199</span>.<span class="hljs-number">111</span>.xxx 的回复: 字节=<span class="hljs-number">32</span> 时间=<span class="hljs-number">37</span>ms TTL=<span class="hljs-number">49</span><br>&gt; 来自 <span class="hljs-number">185</span>.<span class="hljs-number">199</span>.<span class="hljs-number">111</span>.xxx 的回复: 字节=<span class="hljs-number">32</span> 时间=<span class="hljs-number">40</span>ms TTL=<span class="hljs-number">49</span><br>&gt; <span class="hljs-number">185</span>.<span class="hljs-number">199</span>.<span class="hljs-number">111</span>.xxx 的 <span class="hljs-built_in">Ping</span> 统计信息:<br>&gt;    数据包: 已发送 = <span class="hljs-number">4</span>，已接收 = <span class="hljs-number">4</span>，丢失 = <span class="hljs-number">0</span> (<span class="hljs-number">0</span>% 丢失)，<br>&gt;往返行程的估计时间(以毫秒为单位):<br>&gt;    最短 = <span class="hljs-number">37</span>ms，最长 = <span class="hljs-number">43</span>ms，平均 = <span class="hljs-number">39</span>ms<br></code></pre></td></tr></table></figure><br>注：为保证安全性，“xxx”所对应的IP地址最后八位比特所对应十进制被隐去。  </p><h4 id="traceroute-tracert"><a href="#traceroute-tracert" class="headerlink" title="traceroute/tracert"></a>traceroute/tracert</h4><p>另一个ICMP的重要应用是tracerout用于跟踪一个分组从源点到终点的路径，在Windows操作系统中的指令为<code>tracert</code>。<br>其方法是利用ICMP<strong>时间超过</strong>和<strong>终点不可达</strong>两种报文对路由进行跟踪，具体而言，tracerout从源主机向目的主机发送一连串IP数据报，每一个IP数据报中封装的内容是使用了非法端口号而无法被交付的UDP数据报。当第一个数据报经过第一个路由时，由于数据报中的TTL为1，收到第一个数据报的路由器会将TTL减一并且向源点主机发送一个时间超过ICMP报文。然后，主机发送第二个TTL=2的数据报，并沿着相同的路径发送给同一个路由器。由于TTL的限制，这个数据报最终只会到达第二个路由器，第二个路由器也会向主机发送时间超过报文。<br>如此重复，每一次源主机发送的数据报中的TTL都比上一个数据报中的TTL多1，当数据报刚刚好到达目的主机时，目的主机解开IP数据报，但是由于其中的UDP数据报非法，目的主机会向源主机发送一个终点不可达ICMP报文。从而主机能够识别这个路由上的每一个路由器和目的主机。   </p><h2 id="互联网的路由选择协议"><a href="#互联网的路由选择协议" class="headerlink" title="互联网的路由选择协议"></a>互联网的路由选择协议</h2><h3 id="自治系统"><a href="#自治系统" class="headerlink" title="自治系统"></a>自治系统</h3><p>互联网允许与互联网相连接的各种网络使用不同的内部架构和路由协议。定义互联网中使用同一个路由选择协议和度量的路由器集合称为一个自治系统(AS,autonomous system)或者称之为自治域。一个自治域对其他的自治域所表现出的是单一和一致的路由选择策略。    </p><p>这样，互联网将路由选择协议划分为两大类：内部网关协议/IGP(interior gateway protocol)和外部网关协议/EGP(external gateway protocol)。<br>内部网关协议用于一个自治系统内部的路由选择，称为域内路由选择(intradomain routing)，常见的有两种协议：RIP和OSPF协议。<br>外部网关协议用于用于自治系统之间的路由选择，称为域间路由选择(interdomain routing). 常见的协议是BGP-4协议。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220608161839.png width=40%>  </p><h3 id="内部网关：RIP协议"><a href="#内部网关：RIP协议" class="headerlink" title="内部网关：RIP协议"></a>内部网关：RIP协议</h3><p>RIP协议是一种基于Bellman-Ford路由算法的，一种基于距离向量的路由选择协议，最大优点是简单。此处的距离是指的路由中经过路由器的个数，称为跳数(hop count)。<br>RIP协议的特点是：  </p><ul><li>每个路由器只与其相邻的路由器交换信息。  </li><li>路由器交换的信息是本路由器当前的路由表，路由表的每行表示到自治域内某个网络的<strong>最短跳数</strong>以及对应路由所经过的<strong>下一跳路由器</strong>。  </li><li>路由器之间周期性地交换路由信息，通常是每隔30秒交换一次路由表。   </li></ul><p>RIP协议的功能是让一个自治域中的所有路由器都定期地与其相邻地所有路由器交换路由信息，并不断更新路由表，使得每一个路由器到每一个目的网络的路由都是最短的。   </p><h4 id="RIP协议的操作"><a href="#RIP协议的操作" class="headerlink" title="RIP协议的操作"></a>RIP协议的操作</h4><p>对于使用RIP协议的自治域中的某一个路由器，在其收到相邻路由器发送的RIP报文后，进行如下操作：  </p><ul><li>对于从相邻路由器X中收到的路由表，先将这个路由表中所有的下一跳路由器全部改为X，并且每一行的跳数加一。  </li></ul><p>对于收到并对其更改后的路由表B，本路由器会将这个路由表B与原来自己的路由表A进行对比：  </p><ul><li>如果原来路由表中没有某个网络N，就把这个网络添加到自己的路由表A中。  </li><li>如果原来路由表中有网络N：  <ul><li>如果B中的下一跳路由器与原来自己路由表A中的下一跳路由器相同：  <ul><li>如果路由跳数发生了改变，则对跳数进行更新。  </li><li>如果路由跳数与之前相同，则什么也不做。  </li></ul></li><li>如果B中的下一跳路由器与原来自己路由表A中的下一跳路由器不同：  <ul><li>如果B中的路由跳数比A中的短，则更新这个条目中对应的下一跳路由器和最短跳数。  </li><li>如果B中的路由跳数比A中的长，则什么也不做。  </li></ul></li></ul></li><li>如果3分钟过后还没有收到路由器X发来的路由表，则这个路由器相关的路由都设置为<strong>16，表示距离不可达</strong>。  </li></ul><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220608163708.png width=70%>  </p><h4 id="协议格式"><a href="#协议格式" class="headerlink" title="协议格式"></a>协议格式</h4><p>由于RIP协议通信是一种短而少量的通信，RIP协议使用<strong>用户数据报UDP协议</strong>进行传送。  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220608164003.png width=30%>  </p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>RIP存在的最大问题是<strong>当网络出现故障时，需要经过比较长的时间才能将这个信息传送到所有的路由器</strong>，可以简单记为“坏消息传的慢”。<br>具体机制可以由下图解释：  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220608164924.png width=50%>  </p><p>如图：当某个路由器$R_1$到网络$N_1$的链路出现故障，路由器$R_1$到网络$N_1$的距离改为16，代表不可达。这个信息很有可能经过一段时间后发送给$R_2$，但是在这个时间内，$R_2$很有可能预先向$R_1$发送了自己的网络信息：到网络$N_1$的距离为2，下一条路由器为$R_1$，这条消息简单写为$(N_1,2,R_1)$。<br>$R_1$收到这条信息后，误认为可以经过$R_2$到网络$N_1$，于是将自己的信息修改为$(N_1,3,R_2)$，并将该信息发送给$R_2$，$R_2$更新自己的路由表为：$(N_1,4,R_1)$。如此重复，直到最小跳数变为16，$R_1$和$R_2$才能都意识到与网络$N_1$不可达。  </p><p>这样的机制使得整个自治域中达到稳定路由的时间变长。<br>此外，RIP还限制了网络的规模，它能使用的最大距离被限制在15。由于交换信息是完整的路由表，因而随着网络规模的扩大，其开销也就增加。   </p><h3 id="内部网关：OSPF协议"><a href="#内部网关：OSPF协议" class="headerlink" title="内部网关：OSPF协议"></a>内部网关：OSPF协议</h3><p>OSPF是另一种内部网关协议，它是一种分布式<strong>基于链路状态</strong>的路由协议。<br>OSPF的特点是：   </p><ul><li>使用洪泛向本自治域中的所有路由器发送信息。每一个相邻路由器将收到的信息发往其所有的相邻路由器。  </li><li>发送的信息是与本路由器相邻的所有路由器的链路状态。链路状态包含两个信息：<br>一个是相邻路由器，另一个是路由的代价，称为度量(metric)。  </li><li>当链路状态发生变化时(比如代价的变化，或者路由离线等等)，路由器才向所有路由器用洪泛发送此信息。  </li></ul><p>最终，所有的路由器都能建立一个链路状态数据库，这个数据库在全网范围内是一致的。  </p><h4 id="协议格式-1"><a href="#协议格式-1" class="headerlink" title="协议格式"></a>协议格式</h4><p>OSPF协议使用IP数据报传送，且长度很短。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220608183052.png width=30%>  </p><p>相比于RIP，OSPF协议还有如下特点：  </p><ul><li>允许对不同类型的业务计算出不同的路由。  </li><li>可以将通信量分配给多条代价相同的路径，进行负载平衡。  </li><li>支持子网划分和超网。  </li><li>由于使用了洪泛方法，OSPF需要让每个链路状态都带上一个32位的序号，序号越大状态就越新。  </li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">路由协议</th><th style="text-align:left">基于类型</th><th style="text-align:left">路由器交换的信息</th><th style="text-align:left">收敛后每个路由器内部数据差异</th><th style="text-align:left">协议格式</th></tr></thead><tbody><tr><td style="text-align:left">RIP协议</td><td style="text-align:left">距离向量</td><td style="text-align:left">整个路由表</td><td style="text-align:left">不同的路由表</td><td style="text-align:left">UDP数据报</td></tr><tr><td style="text-align:left">OSPF协议</td><td style="text-align:left">链路状态</td><td style="text-align:left">链路状态：包含相邻路由和代价</td><td style="text-align:left">全网范围内一致的链路状态数据库</td><td style="text-align:left">IP数据报</td></tr></tbody></table></div><h3 id="外部网关协议-BGP"><a href="#外部网关协议-BGP" class="headerlink" title="外部网关协议:BGP*"></a>外部网关协议:BGP*</h3><p>需要使用外部网关协议的动机是：  </p><ul><li>互联网的规模太大，使得自治系统之间的路由选择非常困难。  </li><li>自治系统之间的路由选择必须考虑相关策略：<br>由于各网络使用的度量可能不同，性能差别很大。根据最短距离寻找出来的路径可能并不合适，可能还需要考虑代价或者安全性等等问题。域间通信需要人为设置某些路由。  </li></ul><p>因此，BGP协议只能是力求寻找一条能够达到目的网络且比较好的路由，而并非寻找一条<strong>最佳</strong>路由。  </p><h2 id="网络地址转换-NAT"><a href="#网络地址转换-NAT" class="headerlink" title="网络地址转换/NAT"></a>网络地址转换/NAT</h2><p>专用地址是一种只能用于一个机构内部通信的地址。专用网络，又被称为本地互联网，是一种使用专用地址进行通信的网络。由于当前IPv4的地址已经所剩不多，所以现在更常见的方法是对一个专用网络采用专用地址进行内部映射，而这个专用网络对外拥有至少一个有效的全球IP地址。这个IP地址和专用网络中设备的专用地址之间的映射关系由网络地址转换/NAT(Natwork Address Translation)进行。<br>所有使用本地地址的主机在和外界通信时，都要在装有NAT软件的路由器上将本地地址转换为全球IP地址，然后才能和互联网连接。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220615165924.png width=50%>  </p><p>需要注意的是，专用网络所拥有的一个有效的全球IP地址同一时间之内只能由专用网络中的一个设备所使用，因此当NAT路由器具有$n$个全球IP地址时，专用网内最多可以同时拥有$n$台主机接入到互联网。<br>对于内部设备较多的专用网，这些设备只能轮流使用这些IP地址。<br>当引入端口号和套接字的概念时，外部网络的网络的IP地址和端口号被映射为内部网络的IP地址和端口号，理论上如果外网IP地址的端口号足够覆盖内网所有的主机和进程数，即便是只有一个IP地址，通过不同的端口号也可以识别不同内网主机和不同内网主机的不同进程，不需要设备轮流使用IP。  </p><h2 id="IPv6数据报"><a href="#IPv6数据报" class="headerlink" title="IPv6数据报"></a>IPv6数据报</h2><p>IPv6仍然是无连接的传送协议。相比于IPv4，其主要区别为：  </p><ul><li>更大的地址空间，IPv6的地址空间从IPv4的32位拓展到了128位。  </li><li>IPv6的数据报由两大部分组成：基本首部和有效载荷。其中基本首部的长度是固定的，其选项放在有效载荷中，称为扩展首部。而IPv4的首部长度是可变的。  </li><li>IPv6首部为8字节对齐，即首部长度必须是8字节的整数倍；IPv4是4字节对齐。  </li></ul><p>目前，IPv4和IPv6通过双协议栈技术进行过渡。  </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>通信和计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信工程</tag>
      
      <tag>通信网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.介质传输理论</title>
    <link href="/2022/05/22/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BC%A0%E8%BE%93%E7%BA%BF/%E4%BB%8B%E8%B4%A8%E4%BC%A0%E8%BE%93%E7%BA%BF%E7%90%86%E8%AE%BA/"/>
    <url>/2022/05/22/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BC%A0%E8%BE%93%E7%BA%BF/%E4%BB%8B%E8%B4%A8%E4%BC%A0%E8%BE%93%E7%BA%BF%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="介质传输理论"><a href="#介质传输理论" class="headerlink" title="介质传输理论"></a>介质传输理论</h1><p>传输线类型主要有两类：金属传输线和介质传输线。一般而言，就目前的应用情况来看，介质传输线指光纤。</p><h2 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h2><h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3><p>光纤的材质是玻璃（二氧化硅）或者塑料。使用高纯度二氧化硅熔丝的光纤和可以达到最低损耗。塑料光纤的价格虽然低，但是损耗较大，只能用于短距离链路传输，比如桌面距离的传输，因此目前主流的材料仍然是二氧化硅。<br>光纤由是三个同轴部分组成：芯、包层、涂覆层。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220522132920.png width=50%>  </p><p>光纤中，<strong>纤芯的折射率大，包层的折射率相对较小</strong>。包层的作用是区别于芯的折射率，保证光不会泄漏出光纤芯。同时也有加固光纤芯的作用。<br>在实际应用中，常常将若干条光纤集成为光缆一同传输。有的光缆内部还有防止光纤弯折的骨架。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220522134518.png width=50%></p><h3 id="传输特性"><a href="#传输特性" class="headerlink" title="传输特性"></a>传输特性</h3><p>光纤中携带信息的光通过光纤芯的内部全反射沿着光纤径向传输。由于用作传输的光通常频率非常高，通常以太赫兹计，其频率难以被直接测量，光线中使用另一参数“波导波长”(guide wavelength)来描述用做传输的光的特性，定义波导波长为光在光纤中传播的速度$v$与光频率之比：   </p><script type="math/tex; mode=display">λ_g=\frac{v}{f}</script><p>光的传输特性由光谱(spectrum)表示，类似于频谱，其反映了光的波长与增益的关系。类比于带宽，光谱中的线谱宽度/线宽(linewidth)表示光束光谱的宽度或者吸收特性。<br>光纤传输系统中的发射器通常是发光二极管或者是激光发射器，其将编码好的信息转换为光信号然后发射。通常发光二极管的支持传输的线宽在60nm，激光发射器支持传输的线宽在5到10nm左右。更窄的线宽意味着更高的传输数据率。  </p><p>光纤按照其内部的折射率分布可以分为：阶跃光纤和渐变光纤。阶跃光纤中纤芯和包层的折射率都是不变的常数。而渐变光纤中纤芯的折射率从轴心沿半径轴向逐渐增大，包层折射率不变。<br>光在光纤中的传输可能会出现多种光路，平行于轴线的的光的传播模式称为单模，而有多条折射和反射的光路的光的传播模式称为多模。其具体物理意义为光的亥姆霍兹方程解的个数，在后面的内容中会详细解释。<br>在工作波长一定的情况下，光纤中只有一种传输模式的光纤称为单模光纤，有多种传输模式的光纤称为多模光纤，按照折射率分布有可以分为多模渐变光纤和多模阶跃光纤。<br>多模光纤的传输容量小，传输性能差，带宽窄。而单模光纤中不存在不同模式的传输时延，具有良好的传输特性。  </p><h2 id="光传输理论"><a href="#光传输理论" class="headerlink" title="光传输理论"></a>光传输理论</h2><p>由于光的频率过高，此时不太容易能够像分析金属传输线那样将光纤等效为若干段等效电路。在分析光在光纤中的传输方式时，通常有依据光传播理论分析的射线分析方法，也可以有依据电磁波传播特性分析的波动分析方法。  </p><h3 id="射线理论"><a href="#射线理论" class="headerlink" title="射线理论"></a>射线理论</h3><h4 id="光传播定律"><a href="#光传播定律" class="headerlink" title="光传播定律"></a>光传播定律</h4><p>光在两种不同的介质界面上会发生反射和折射。定义光入射的角度与垂直分界面的法线夹角为入射角，反射角为反射光与法线的夹角。当光的入射角为$θ_i$时，其发生反射的反射角与入射角相等：  </p><script type="math/tex; mode=display">θ_i=θ_{refl}</script><p>同时，折射定律认为折射光位于法线和入射线决定的平面内，且入射光和折射光位于法线的两侧，有：  </p><script type="math/tex; mode=display">n_1sinθ_i=n_2sinθ_{refr}</script><p>其中入射介质的折射率为$n_1$，折射介质的折射率为$n_2$。<br>当入射角大于某一角度入射时便不再出现折射光，这种现象称为全反射(total inner reflection)。这个角度称为临界角。有：  </p><script type="math/tex; mode=display">sinθ_c=\frac{n_2}{n_1}</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220522144004.png width=50%>  </p><h4 id="阶跃光纤的子午面射线分析"><a href="#阶跃光纤的子午面射线分析" class="headerlink" title="阶跃光纤的子午面射线分析"></a>阶跃光纤的子午面射线分析</h4><p>光在光线中的传播路径有两种：一种是光始终在光纤的轴平面内传播，这样的光纤称为子午线。另一种是光在传播过程中，传播轨迹不在同一个平面内，且不与光纤轴相交，这种光线称为斜射光线。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220522144352.png width=50%>  </p><p>对于子午线射线，其传播路径如图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220522144629.png width=80%>  </p><p>如图，光从某种折射率为$n_0$的介质中入射到光纤芯中，当光的入射角为$α$时，使得折射光恰好能够在光纤芯与光纤包层的分界面上发生全反射。定义此时的入射角$α$为纤芯端面的最大入射角，<strong>凡是入射角小于$α$的光线均可以在光纤内发生全反射</strong>。<br>根据折射定律，在纤芯端面有：  </p><script type="math/tex; mode=display">n_0sinα=n_1sinβ</script><p>根据几何关系：$β=90°-θ_c$，那么有：  </p><script type="math/tex; mode=display">n_0sinα=n_1cosθ_c</script><p>根据全反射的定义：  </p><script type="math/tex; mode=display">sinθ_c=\frac{n_2}{n_1}</script><p>带入到之前的公式，有：  </p><script type="math/tex; mode=display">\begin{aligned}    n_0sinα&=n_1cosθ_c\\    &=n_1\sqrt{1-sin^2θ_c}\\    &=n_1\sqrt{1-(\frac{n_2}{n_1})^2}\end{aligned}</script><p>定义$Δ=\frac{n_1^2-n_2^2}{2n_1^2}$称为光纤的相对折射率差。有近似关系：   </p><script type="math/tex; mode=display">Δ=\frac{n_1^2-n_2^2}{2n_1^2}≈n_1\sqrt{n_1^2-n_2^2}</script><p>定义光纤的数值孔径（numerical aperture，$NA$）为：  </p><script type="math/tex; mode=display">NA=n_0sinα</script><p>数值孔径表征了光纤的光的收集能力，可以发现$n_1$和$n_2$相差越大，$Δ$越大，光纤的数值孔径越大，集光能力越强。<br>在渐变光纤中，可以把光纤芯径向拆分为宽度非常小的若干段，在每一段中，光都线性地发生折射。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220522165644.png width=50%>  </p><h3 id="波动理论"><a href="#波动理论" class="headerlink" title="波动理论*"></a>波动理论*</h3><p>由于光是一种电磁波，也可以使用波动理论对光在光纤内部的传输进行分析。<br>在光纤中横向电场偏振方向在传输过程中保持不变，设横向电场的偏振沿着$y$方向，其满足标量亥姆霍兹方程：  </p><script type="math/tex; mode=display">▿^2E_y(r,θ,z)+k_0^2n^2E_y(r,θ,z)=0</script><p>其中$k_0$是真空中的波数，$n$是介质的折射率。<br>在纤芯和包层中，令$a$是纤芯半径，有：  </p><script type="math/tex; mode=display">U=a\sqrt{n_1^2k_0^2-β^2}</script><p>表示波导径向归一化相位常数，表示光沿径向发生的相位变化。  </p><script type="math/tex; mode=display">W=a\sqrt{β^2-n_2^2k_0^2}</script><p>表示波导径向归一化衰减常数，表示光沿径向发生的幅度变化。<br>定义径向归一化频率为：  </p><script type="math/tex; mode=display">V=\sqrt{U^2+W^2}=n_1k_0a\sqrt{2Δ}</script><p>类似于金属传输线，光信号在光纤中传播的最低频率称为截止频率，低于截止频率的的光信号无法在光纤中有效传输。截止频率发生时，径向归一化衰减常数$W$为零，随着频率的减小，$W$便不再为实数。截止频率发生时：</p><script type="math/tex; mode=display">V_c^2=U_c^2,W_c=V_c</script><p>在单模光纤中，光单模传输的条件为：  </p><script type="math/tex; mode=display">0<V<2.404</script><p>这个条件称为单模传输条件。在单模传输条件下，光的传播模式为单模，其不存在模式色散且带宽很宽，可以用于长距离大容量通信。    </p><h2 id="光纤传输特性的影响因素"><a href="#光纤传输特性的影响因素" class="headerlink" title="光纤传输特性的影响因素"></a>光纤传输特性的影响因素</h2><h3 id="光纤的传输损耗"><a href="#光纤的传输损耗" class="headerlink" title="光纤的传输损耗"></a>光纤的传输损耗</h3><p>光在传输的过程当中的主要损耗依据来源分为固有损耗(intrinsic attenuation)和外在损耗(extrinsic attenuation)。固有损耗指光纤自身的传输损耗，外在损耗指光纤在使用时引起的传输损耗。    </p><h4 id="固有损耗"><a href="#固有损耗" class="headerlink" title="固有损耗"></a>固有损耗</h4><ul><li><p>吸收损耗<br>在光传输过程中光使得光纤材料中的粒子吸收光能，发生跃迁的能量损耗称为吸收损耗。通常，这些粒子只吸收特定波长的光，因此吸收损耗与传输光的波长有关。对于二氧化硅，其衰减在光波长为1400nm时最为显著。为了减少吸收损耗，规定光通信中使用衰减相对较少的三个波长窗口：<strong>850nm，1310nm和1550nm</strong>。  </p></li><li><p>散射损耗<br>散射损耗是由于材料不均匀使得光散射使得光能辐射出光纤外引起的能量损失。总体来讲，散射损耗是由于光纤的非线性特性造成的。这些非线性效应包括：瑞利散射、受激布里渊散射、受激拉曼散射、折射率扰动等等。<br>散射损耗中主要考虑瑞利散射引起的损耗。光纤制造时，由于熔融态玻璃分子的热运动引起其内部结构的密度不均匀和折射率起伏，故对光产生散射，比光波长小得多的粒子引起的散射称为瑞利散射。  </p></li></ul><h4 id="外在损耗"><a href="#外在损耗" class="headerlink" title="外在损耗"></a>外在损耗</h4><ul><li><p>接续损耗<br>两光纤连接处所产生的损耗。一般而言，光纤的接续方式有两种：活动接续（比如接头）和固定接续（比如熔接：将两根光纤芯融化后相接在一起，再加上包层的方法）；使用活动接续可能导致两根光纤的纤芯位置出现偏差。常见原因还有两根光纤数值孔径不同，折射率分布不同等。  </p></li><li><p>弯曲损耗和微弯曲损耗<br>在敷设和连接光缆时可能会使得光纤产生明显的弯折，光在通过这样的弯折处时发生的损耗称为弯曲损耗(macrobending attenuation)。同时，在制作缆线的过程中不可避免地会对光纤有细微挤压，或者环境温度的使光纤热胀冷缩，光在通过这些肉眼不可见的细微挤压处时发生光泄漏产生的损耗称为微弯曲损耗(microbending attenuation)。  </p></li></ul><h3 id="光纤的色散"><a href="#光纤的色散" class="headerlink" title="光纤的色散"></a>光纤的色散</h3><p>光纤中传输的光由于多种模式或不同频率在传输过程中群速度不一致，到达接收机的时间也不一致，在接收机一侧会观察到单个字符信号发生时域扩展和畸变，这样的现象称为色散。由于时域拓展，色散会引起码间串扰。因此，<strong>色散程度决定了光纤的传输带宽，限制了系统传输速率和传输距离</strong>。<br>光纤中的色散分为三类：模式色散，材料色散，波导色散和偏振色散。其中<strong>对传输影响最严重的是模式色散</strong>。  </p><h4 id="模式色散"><a href="#模式色散" class="headerlink" title="模式色散"></a>模式色散</h4><p>光纤中不同传播模式的光沿着光纤轴向传播的群速度不同，因而在接收端产生的波形时域扩展的现象称为模式色散。模式色散的程度和相对折射率差以及光纤的长度成正比：光纤越长，相对折射率差越大，模式色散越严重。  </p><h4 id="材料色散"><a href="#材料色散" class="headerlink" title="材料色散*"></a>材料色散*</h4><p>由于光纤材料折射率随着光波长的变化而变化，使得各波长的光信号传播速度不同，在接收端产生的波形时域扩展的现象称为材料色散。材料色散取决于光纤材料折射率的波长特性和光源的线宽。  </p><h4 id="波导色散"><a href="#波导色散" class="headerlink" title="波导色散*"></a>波导色散*</h4><p>在不同波长下，其相位常数$β$不同而导致的群速度不同发生的色散现象称为波导色散，波导色散与光纤的结构有关，也称为结构色散。  </p><h4 id="偏振色散"><a href="#偏振色散" class="headerlink" title="偏振色散*"></a>偏振色散*</h4><p>偏振色散是单模光纤特有的一种色散。由于单模光纤中传输模式可以分解为两个相互正交的模，其电场沿着$x$,$y$方向偏振，这两个模的相位常数$β$不同而导致的群速度不同发生的色散现象称为偏振色散。  </p><p><strong>多模光纤中，模式色散的影响程度远大于材料色散，波导色散的影响最次。</strong><br><strong>单模光纤中，模式色散为0，色散主要是材料色散，波导色散较小，偏振色散一般可以忽略。</strong><br>色散描述的是光纤中的光信号时域扩展的程度，而带宽这一现象在频域的表现。光纤的带宽建议单位为每千米带宽，表示为：  </p><script type="math/tex; mode=display">B_0 \vert_{MHz}≈\frac{ɛ×10^6}{D×Δλ}</script><h2 id="光纤传输系统"><a href="#光纤传输系统" class="headerlink" title="光纤传输系统"></a>光纤传输系统</h2><h3 id="光纤传输系统的构成"><a href="#光纤传输系统的构成" class="headerlink" title="光纤传输系统的构成"></a>光纤传输系统的构成</h3><p>一个简单的光纤传输系统如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220526141315.png width=50%>  </p><p>在发送端，光信号一路一路地分别由若干个光信号发送机（通常是LED或者激光发射器）发送，经过波分复用器后合为一路信号，这路信号通过功率放大器(power amplifier)被放大，以提高信号的抗衰落能力。<br>光信号进入光纤后，每隔一段传输距离就会设置一个线路放大器(line amplifier)将受到衰落的信号重新放大。<br>在接收端，光信号在被解复用前通过前置放大器(preamplifier)以增强信号，然后信号通过解复用器后重新变为多路信号传输给多个接收机中。  </p><h3 id="光传输器件"><a href="#光传输器件" class="headerlink" title="光传输器件"></a>光传输器件</h3><h4 id="耦合器"><a href="#耦合器" class="headerlink" title="耦合器"></a>耦合器</h4><p>耦合器(coupler)是光网络中一种可以将多路光信号合为一路，或者是将一路混合的光信号分为多路混合光信号的光源器件。在第二种情况下，耦合器向每一路上分到的功率单位权重系数称为分光比/耦合比(coupling ratio)，以$α$记。换句话来说，耦合器可以根据分光比向每一路分配不同功率的同一光信号。分光比可以与光信号波长有关，分光比与光信号相关的耦合器称为频率选择性耦合器；也可以和波长无关，这种耦合器称为频率无关/平坦耦合器。<br>对于频率无关的耦合器，最常见的是将一路光信号平均分成两路的耦合器，每一路信号的功率是原来的1/2，这样的耦合器称为3dB耦合器。另一种情况是从一路光信号中取很少一点光信号用于光网络的监控或维护，此时后和其的分光比在0.90-0.95之间，这种耦合器称为TAP耦合器。频率选择性耦合器常常用于低损耗地将1310nm信号和1550nm的信号合为一路。  </p><h4 id="隔离器和循环器"><a href="#隔离器和循环器" class="headerlink" title="隔离器和循环器"></a>隔离器和循环器</h4><p>隔离器(isolator)是一种只允许光单向传播的无源器件。隔离器常用于放大器或者发射器之后以避免反射波进入这些器件造成损耗。隔离器的两个关键指标是插入损耗（insertion loss）和隔离度(isolation)。<br>循环器(circulator)则是一种具有多个端口的隔离器。  </p><h4 id="复用器和滤波器"><a href="#复用器和滤波器" class="headerlink" title="复用器和滤波器"></a>复用器和滤波器</h4><p>复用器(multiplexer)是一种将通信资源（时间、空间、波长、码型等）平均分配给多个光信道使用的光网络器件，对于使用波分复用的光网络，可以使用不同频率的带通滤波器(filter)进行解复用。<br>优秀的光网络的滤波器需要具备：1) 低插入损耗 2)损耗与光的极化无关 3)对温度不敏感 4)通带截止迅速等特点。在波分复用系统中常常使用级联的滤波器。  </p><p>复用器和解复用器可以用于一种全光交换机的内部交换网络构建，如下图所示，这样的交换机不能动态改变路由，是一种静态交换，但是具有可靠性高的特点。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220526144925.png width=50%>  </p><h4 id="光放大器"><a href="#光放大器" class="headerlink" title="光放大器"></a>光放大器</h4><p>光放大器是一种用于增强光信号的传输器件。光纤通信的传输距离一般比较长，因此需要放大器对信号进行放大。<br>光通信中的再定时比较困难，一般不会使用再生器。<br>光放大器可以通过在光纤中掺杂一些金属粒子实现，常见的放大器是掺铒光纤放大器。<br>如前文所述，按照放大器在传输线路中的位置分类为功率放大器、线路放大器和前置放大器。  </p><h4 id="光探测器、光交换机和波长转换器"><a href="#光探测器、光交换机和波长转换器" class="headerlink" title="光探测器、光交换机和波长转换器"></a>光探测器、光交换机和波长转换器</h4><p>光探测器(photodetector)是一种利用光电效应将光信号转化为电信号的光器件。常常作为光交换机等光元器件的基本组件。类似于电交换机，光交换机将从某个链路来的光信号通过光探测器转化为电信号，然后将该电信号通过波长转换器转换到另一个波长上，实现不同波分信道的转换。  </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>电信传输理论与工程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2.无线信道</title>
    <link href="/2022/05/18/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/2.%E7%A7%BB%E5%8A%A8%E4%BF%A1%E9%81%93/"/>
    <url>/2022/05/18/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/2.%E7%A7%BB%E5%8A%A8%E4%BF%A1%E9%81%93/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="16f816f7ef7b039c669f636b7e803c1c8fbbc25cdbb7b4db06c013d83df094ce">d23a4056e39b7e810998c80d99c7e17f86f9f2d02bab1f8b5f4197996369e4eff227dda5a676a78418b8a2552d8f68892d2609ac62371f47fdca5ebb900579536159694470e4455bb0b35d8a4991421e4d13fecb947ff71307736fccf99f86d7de76e07e218398151771f8b77d03bdff75e0cb962d9a766ed9e1eeb424b96dff0cfeb884a02aa45ddcb53c4fe574bb1127e4336582b7c8b7fa7cf6601fec503c58341496b89cc52a89635cac91901358ba4438e13cc2aa761e1fb9e729386d41a96b623136cd548d62ab97a30e69555ec13519539ab7d4c637973e37a69c003e68b4dfb4b4c38043ecbae35642c3d299cdba0240d22782a01f9a9ff42c1be1c6af256a3eaaa12da2d8601306db33becee2d1f5adf17219ceb65dafa5afd938823b670c7ab4b237bf375832c4a9bb10cd071f1f0e797e90f3e52877218ae9abcb84f1e0250eb2f4f330c005a64862e909923c6581b4129cb214f4c412e2f440353afba5f9f53047643d089e1fdbc5740020366b961eec81bacec94bd9bc4dd9728a27a94e40a7121e7ec4c716654dd957aa009422058de92f6c101d9d32ba1faba303250f7a238aa2cf442654e4a86480384d87015910769d778a7bfa2d28d833ac6268a8c76547aae0d2914d9e5af61b2a34c1cd3dcd4e64942e4b37159246121d5cd6a81fb32f19e5cbb190d168c45092a42ec94f00d242fa7a8a58cd469af878ccfdaa9cd66c792010d64d0bea3c814a532fd9d3f788f4a24d593129ba3f990f7a6009d89031faf7d533f7979f011ee4a46bb66bc907d97d58053e70091af8d4accac4ca6d726fd725fdb263689ba66012e75589097732a6ab8089059a83c333f875620407d79c9745efd109085ae891fa188bab190d277a0219fac1c79ff9597d895c8b89421c3e3b3cc06b557cf2790838af2529a2d837e990b4c91a349d1f7ecb99cabaf5dea6172fbfb89593d478e1e86d8782bb83f5e789707fe613ce9862c4c6daf58e1b3546ae89a53dd313cf7ff2dfcd6b4c743d87fe6a4930bc22f0a96662b19b2fed3daa88f102e496d1a28841194775959b2ae657737360b2e00604ac013e55b8663f97d15db218958f50ba46d5cb3fb58c9f1c4d58264760d07f834589d069310b982a9fc66cc86e0e15c774fbd085a7729eb7972f166ea01d452d409ab4f1e6d3f88630e4bd14c3dca953eed25c80d83b6b2f438d95bd07e0ce4de416fed1b8826719bc8cb52b46d6032451c7d78276dcc0c73e387de641c0acc31238cea65007060bb3683d5e8012f2085501bd412f15f1baadcf947a13c8b775cd7ed6a8df5c461351fc6daacd89f6f6045a7bc3890c3816d052e19a86c1d6512bbafe77cbfdf5796da2aa8ef6984b637cc0b5992eb047ccd078de543f557c54eac90c834465499c79186aa891a36d7ccb6bd5eb378f2b9977d6ad6a404a23b6bf9824e73691027a8a2f3a0e1d61b8000da083b9e6bdbe41d82b2a9e5b5e2503aa5565e224f3d26f4d71e5f6cb820ac58f4b7871e4ff387a3a0c7f0ba81df6cb291f91ddb958246760b30a40ba45d84482865cd225aa65524a95f95a4fe355b3120cddfab071e7c6da16e47d8286820c9c7402fc4b064b9f09a4fd2c50ff2b607b71b90f802bd0631ad04ab3b63e7f4518f0117d3f0bdb7ec252437ede771daef7a6273c5286b0bfb011ae31ef9e8d2c21ae51af9febba3dda321dae08d29f479ef939fa82464e1a051c8d8649ae9598f6b4c7d07a4b9693746f78a20739f6bad219b6b99cd939712de5b09ae5961473aa462b0ec1ab9fd005daf5b711bed37582e92bfc75aabb5fad6766cbbb0da9594d8fcea0b6a3f09e4e8c83cd6e619ef9a8af84285cc3d8355ff069ca18162ee14d577f2529d36969d0cd2f0e8a3605d3a53cc04baaf9a3b5b8fbcae0c49b302c66042dcfd254c59c2cc7d2beda7139f0fbc87dfabbd23666fd988766320ea43b8a562f1577453fb58c263a033d33ac6cc00aa7309acc6b039f4eb23411b72b9ef4a421b24b47d633be68c0f88895db379b67420a980da79615c2e581e3a293428a1c16b2307aa6749c22bb2de1e0c64e2467d5aa05be5004cc448125ec836b25b9ae21f31b1d6b40f85545298595d6108104caf3691b93915c89f49a809ea1d6d99b0544b143c157cbf1118f6ca7c454b93127764994157da090658a64bd71471009056649598d1b7b7dfa92802bde787009ad168cab00c0f4f5fef2f635d3754822fa7e1fb93bf375412e17550e3a962c917ff695c900957a6901273244026003293115e81ca216a8667c6de349c9af87d36d1fe1fd7f2957e38e66c2d69eac60be6853c370f2987ec0e3549c90946bf9437458241e52e3d8500dcb5fefd4185c45fb160b3fe6e97cc35686e161a8837afefa52007b2cefb3f1b08cd07f3340935f676f36f35f09842198d81146924a34833fcbbe391a8300eebb063b4abe301f3bdaeb678274a7f2239c33e4121c7d96a0c283781727a2f15d43a0417a6dac49cc4d1674317dd3747d1f32953eed366b3f75e620623acf8cb015d43f75f97d90ee349b78632500095f92de6b32ac7993a4a2321bf0d0b4610daed3baea46b5762ebc5ddf6b86aaf68e637f147bbe92f9e1aa097a56d9da133e9f44b8f4c790f65074bb809501c9622a9e3f3f6512a5c80bb10fd220faa9ddb96483e4be797db039137bf6da0251c47c80d2e7a7b45d59f09ba5c7d428368cce3e9aec7f2c0dc8de5016766f770d438b3c88116d178eff553658dda01a97d6bfa36dc1d433fd516df87f0ac125689fad7f58911ecfba60125078c09a2ba31d33a50e2b76f5c7f14622f5683f5701b0b9b6223b121ae83c6540282d92e9b475d8b943defeb533cea4ca81c29b8ced8bac147f4e5107b0db05cb7f5aa10d831a536909e5b346f7eb2fd29691d37f841480568149523a80bfe06aa461d1e7838edbd0f17de3789a7199ff67fc5195cb9684005e1873a0f5845511a8703905e6f254c49540dd86002338cb38bd16ab2771315429b9fc11047f1dabdb101d6df244f5052b1594df0ad792beb2157e3fa1bab4b7d24dea8540bf17506e32bb936346dced8b1dfaf6163d72aecb2c30f63ce7abf7845b2cb41787c29826314bfeaeef04b0914372e2f14b6b9bebbd29a71b500dc9df12281ca210337301e613d7e412af5d5eddc380ad66e7e98d6bce0d8f6d35b3ff9bb1d5959ca55489755f9c13b329281e6943acf14b3ddcfcc6440c78d0afbbb0642b8e206ac71a24abc39ffb3b306b23cb3ce2a54f8dba06e3aafda303557bd910c1ce56e3134a9917061b8099e2e7601ac413c5bc03b68db6f081527c19b790cef23ca2e87cc3386ee8151e6e8afc37802bd333a8d278f1d168a52dcc5d718e128e285be29db1b503e8150e94e65c28920aab23f5b30335372d7484f375365aa9d8f765256b87a8b138115dae8d961420b1e1d7bb639731eeb67f06f580f4be26084df63c9406461c406fca3fcfb7e1d7232ba219caa89816d083c8465c8adfd610fea52966bdf0accf43fbe866b9bdd1e32b071f4a55ff5f6fdf1273df316d23923778730d24c90ccc43d83a86bdd23f0a2ac2a6b2472796a81487d030be374d64a5dbb345f2c6403042c1f9f0d7de661781cee9372cc991ac7f72c84492b3702601b6cf3a219b6f9e934c1153067706ed8138daa743cd30ad9faf3bbff391db6a8191cdb01c030ebef62d4a7d2b9bc5817c5a88d09ffc270b444f0180651a2f8fd5741915a465234202f20e82204e0cd2871a6e34efa85bd7f023dd24a8792f380394e6d3a7d98e174baf96b13567311d60e0926fc733e818dca6c52f18a2eab38d5b72af7048a0645892d4b50203011fa5a8500de1d2a9af943dd1a09140ad2b792cba6b7feccb7ff12c163b28822e9ca0e4f33b7369e73ffb931fc63153fff87657514e53cf26c940e2c297dad917eab115a9a28d65063883e273d5e5d6f516d8214df60bc18a0db77f8c525f71430092dd23ff662312a4d12715db397e9afe20ab73a69f46770de48861cda26919882f321b9f68217c252992aff4ceb51d8361482bd22ec7e4eeaf632e4b40de96586a457967d716004ad1630a41b38df5ac5fae5e65a9f1a8781792970b8e1f2a7309237d11d7075c6baecde9e2911fb25b33fb9e04a6612e8d157f8b6f818e1850c396d7af1a17a8e12fe41c425d6a8c2b5adf61374fd4f56a0c0d0b188845dc37e02c6102abc500eefa4051e4bf7c83a83eed895ef71bbeccc22aa64786f85aaf99a4cff44e7193a2f393e3cf8c215bc3f2c5290d5040193b03ad41efc3e83993f6729d9cd846d061634541d9580f74aef4d025174f675b64d903e689eca975f053d6e14da11dc7696963f8fb73b97061fbd83c102b559422547ab99ce6b7c9d791b078efb9776642768d12edf35ac976a46740ed370eca30884552a56ff39c16cb22755686bf3b20146ffcfcf78b55c7fd18f33dba93d2f45308d0da1d59dfdae031e44f301f3d91ca08b98b5de9f64450488354b486d23e9b57ebc5cceef8a6e0870d510fc30c5c00fbd05863fdf9aa7f8e4e21f9987b4b3f0e4fd10cd71f9d3505f3b44dd5d26d9626149461b980bd5077b709f1af695a33227bd41d0a881d52e45a16d21064d78082e74b269e322d705d3a306f745b0202f94c6f7cb3edc589afb61f85b01d2d21de85d0b69d50e5776d3ae0d63aed3ef3eba6cee1b3119e1a7e0e7a3829212df2ec97b6a2789ea1ce17f9471e8b10b1782b4b96796b8e8d4050961768e6e20709a73fda166877423dea8a79190fdebd713237ebda7d5f611ed8471b203b0e9705f03425328138ceb2455ccc4bb7597ffd2c8f887809f4c6344433a49450283f4b23be9c6be2e66c311ee4a8ebf24eb4d3085c69de3c328b48aab341cba027b21c4541e338c8b23d02bb3242d277a95a911eb984c4e461fd0bed79f842517cf0a6bda7e9eace8211f62b3c49e3598bd15c844176e922a52b5c702bcf2a5ac17fa298852bff8bb1bb790bf73da99ac6ddb5d8351d8627b6b8f89c85965f1cf656f192c9996770453c15cdae852acb5feb7b329bff9b0e8779913b0a922ef88ef4f39d4afc335aa4ee6771566f23c3d1edd6298f8d18d7ab3b034051308a39db4038688a466df31f50af0e290a5e53abf206f78b5c79cd0069c8df278ee55028d4727c014ff34b19a0b9a54e51b1dbb916de61b6ea0bca3838f1d1620038dcfb893048bf9c798964aa2a77ab438aea85feb1e09c38a3be04f81e28a595d289ce858993d85e6e8eecef27388da6300c7954c1c7b0e8d01c808076b0753a75e2f684925ad1eb8d798ef12d86d3b91e676e264266595558ca2d28010a5be0e8f7e4817aea2a8c9d6f20b6173eed278690f9fd1c354a7e46274c6eea7b9f0d2a952b0465c4a03f4d200b341c62a4ea132882c75fa8d008672a5c7e48471f93d506efa0d91ee4e41d3da4997d2256074cf4597cf051b9f50159cf84573981bc72f2e4d7755004a4d3801e610626bdf9377985d3c649bebc4143975e2526cd85dcdcc56d2fd0863c112eaaf0ad34d963cec1eff7e6345d95a3d5d4bb49f2557fe0f0c9dc8961f4d87f2f199d2a85406a17f39a6bfa21e708bdd92543422c950e274e793b1e4f6f0829d1cf4e0b8f7dbd12194d138a888d1c5c9f0283a1147dc6286f16365c755af8bba5a78513266f3cea3938245e01432f8c0dd0edd369167c3126ad1f23923655663cdcbd2d115966230e4a3407c22e7f68460e95f79875b7856a235a2f95ef4642a31c01670640cc3ac55c8e37e7b0b78fce67ab21f87be6aa0c283ad6060a48e8bdbcd64ede252a5a69e2bc676de190a7e4bd92d3e128af92cf4e6582305c66466dd16e0f2dd17b7747db73e317ebebae25aceec02e7a0d4f3f2795bd347f09b1694f9407cb487eb9c746dd880375730dd198e5fdbec51e0f91772cd715227062c07670e9d4ec1934d79af20d63096c97ee2e1fc97d312047d357d2323efa19f01a3463e15a5e598d07873014fd8ad87b8af867a1121b585de1c84e350c7371b3d31b7f852622c9c3f352a286e8da8e272f3a7c3c9a28c7081d7635dc6e5d43948b9544585d1c28b528262a5cd15b9c98c3e357f16c35e613ed03c7ca27991326cd81ff5e0b3782d99cbebd545ee99295d3f8f73473ca3bce183abab65d1ecb808dc2faf98c32ed934bb79b90da39f80cf215b8f8682cf6da4b755169c3ea5b69a3ce1adf820c18d2aedc889ac1fe3a6a5f955176a88154bd5d47a8e9f3f1c3b0449ec9aded5923c7819aa7230b8874dd2eb90d31c4bbbed01a28e67bdac25ef60599d5f0fe95a9c78059ae5a5cc54c4653b3c1228aaa08110b3fcc219caa02aabddbb461d183ba02d396cc30688475eb0a70eba907829693c4e0a453e85f12b0ae7cebd7c81bdaa9ee0b47d4e7a0d150653f98b4a87095a46108051dc2f60f43789cd0735557ce95df92da56077d0af35e1d90d9bdd89292481eb9842ac89de746d46a4bd2d377c853f39c2c6764bbda0f69ba0e11e85f5b0fccb59c5965d1a407263b11773d4aca648e440bcbd55d07749f21b1875320c4d0257411f5a5a3b3fbb133f5a375638e10c49efd63f33bc5784b8a280ba0912458aaa31ba1e29121e2c98d51e4561348e79863e8e621f8cd65dda72d42d5800b701017bee9782844b0b598053892ceb1ca78c876339cbcaad8b3496f872c6ca7e452fa926b0d135c73a0037082b71f15d7ce72d6122a6cebf51bef9c2d75b13db4c325e809efdb4e83516daded0e53d1b5e6379e593a26402ff1cedaf57114dccd2e57e89810c081663382ad3fa9e5948e84fc47125a864aa1ddf8d59ea74767bba6afae3b353dc5672ba667c5803130dd10fcac4d614f6566b556239c69bb0fcc4a3c0445c42119ea386537b962a740e79004e7419ace0c988b15eb2c02cc2bc04dcfa37b93ce4fd04970008a494d2d2d4a0f891b346d9a58662d2c3789c97260af70da3b601ce103bb9fcc44b22b5e45b12c5943d78bab80905cd095d7241b022bc23c47a13143490aba1d66a3ce8cfa48ba1f4eada879183075a11176269794b5facac69677836f304fe59094d9342e1146769e4944cf9197a580bb2e3e1433b8c730682f0c703457a958d408b37651a4f0db2348b4b3706ae2a28f6a269d5acb50103f01a826aa0cd98decde6749caf18b2881c3c90495f6c43330c0cfc5ace0c992a3ecbdfb5e72eec3682691ddb97377f6d5773982ddaf72b7a5614552e322366f217cb50e57b2158673ab4515c956199cca185862a0d29c169233ebefca79dc62b9e8f65896890d66f84564c5b0ab3f7d68e8abe9b64e007b04d0d9869c1baf472a518016726fc28746d56aafd6123e8153e12e0f516c451180e56cddc04610859e5f3c5a1501ffc32edc58504ce773589b63f04951aa5128eef33e5b8917f0a664e74658e54eefa2f2cb852f88029dcf531fd5b2db2c6647e72f4fc3462fe3e4996a5d15543da030cbbbf167d661c5579283d3218f30c0be94013505f04c86c5e8c5d70c5ab9a6174d8ea93ef36ca27b34c9fd52953d739a7e3817e54f927bea0ce97cf8b5968f938a0266368d61cb14d6167f4b3e420491e72666c6d36146bcc27ab8b382e3ccfb56917529f6cb08191dffa236d90065532133df7c9ff1bcf4cb5c27f00c8a799cc3427f995d8add712742ea1bcb287f60ae08e8dcdcba74eb45b4b0b3102848047e596323a79b7f2551f04ec3c758aff2a9a07bbaf72806477663d5f37c57d0331862277329f19e0cc52082aa623baf200fbc57d3c98adc0afb5dcd91c65dd0f23f4180389eced8e51d5006d0f174980b15f263c796a7a89b71de7a6ec508cc0d8cde087eae4d8121aae0da5066d23103364eb7d62160900f3d8ff3eaa70074d6a906aa7904cf854c456bbe268e4a11db1214c26fd5f4421290872d5208727f914448ad759ca9de395391a548ed50adf1795040ade0c7112de3f06b4dd784430fb5528572fa99fcd76c45a1010f3d59ebc81d1612cca9a4d31426227fbfd01cab4df921181d5899df44853cea28fd608652bd13f9e4c0f6bc25467145dc40a339f843a079444d8c170ebf58b81093133ab3bfe6a4aa887b850972756e69134951119ff9a2e88e9364e9dc9d01739b352866a624772f47cb653b261f6e2390527f7a1ab5ee979c5c21f977190376a78ced0625bbff9ccad17798717291ec4c066617ffbe6e3c695925e85d505fc8e725f042f45347cee37b16e457137843d419a94ca75c1da6e87dc90bd132345dcb94c44289514b78d0d44b3deaaebd8cb1aed2e7d94db1d38e1b4fc4810f702d35567f214b0ae0ad1fbf7d70e23f559e8f32cd113c4fc414cb2b9a941dcb62659c134afa179761c225719a4575b449f074b217694616633345b6148788f765902f63807000f016f4ce05746ba640ac6c9be70b047cab8b85538993dc0557736dccb432e40b68b8469db48c0bde4a4beff2910025696812d8c2c3a84f2add8440710cdd0f85f79a1d246e19efd0e283d6a7362bd09cf97c6c8d70fad2ea0e83348a045dca50026b6c9c76f397492e8ccdae6f75d8123fe72e96478287493799fb851d33e04e38275052e294bcb2775f671137f70e159bf7ae7fb08adfb8e538226b7f0de9fe796a2ea8028e2b9fe57a1b79279a561bac3c58d34a341393296c47a67f98cca8921a524d0e91884bae821a018e375c7f2e0ab8dfbf311f5604be1e4e8f014619df7c5d192704b1d3a0dc877b788743671d3aa5616c5f5a24fc6c4cc6c11e23cad9188606fa71d0d5c383acdc981a73c9535100d51469e65a2ed1415fd1ccca55b095e1c651f4c4282566e6018134474d73017bebc2d08c984a966956a613809ea4c975ddbb0ac549ce5a0f241c7be95f71e169e1873550a03ebfc4969f910b957d42b7146747d62efc908a4ec881e94d72a3b3259e68a46b7ba0b49376d56f58bdbf3985e454f4a123520a309a16f84c6d969c75485e40904b6cb0dafb6a8ae25244d07afab200fcdcb46e8b34bbbc606c91655a44b6c3e38d3b38b737a613a6b6b68f1949c16afc02a29bae1147c928743ef4d86161df4db1affa5430ad50fc687aeb6957acebd8a591ecac808dff94efd2d46ade2abfaf16ae8959db3e477c6ea025f10478e34f97d9d213df16c26ca0aa6fe1dd295c6fee08f709ac86989e83890bc67e55babbefcd54b701c8f8a8d5d2c34f9170c21932e92db055f6e69c1d5185ba348294489e88dd8c5325e797f27705423e0359eec29df2c9a34d9a538a8b6f8a4baaf684ce85cafc555817e39efe7671edd1e521904e2f342c66c423326eb830a2a07446f23bbd77d4f971bd82cb957e324533bab00fb3494fa0425392705553461059f9029e6bf4121c75bce4aae30a98d8c34465c26d120e6954555c866d9e1b023019344d93305af859079fa9ed1dce71093a57704d3952622dcfd9d39a24b83384bed82db1e64742a24781e2ba1eaa12d96dce3e92a75abc943a3f113fde1a019b49b8eb9f8f30ec858eff28f95be9acdffaaee407ba8888a95cd488569cb002380c59e280205a2d7712e7951a4699268f44c838272a9b56bc1e57d558ccf1343ec867013431e4145cc8fb904cb7466450428bf6ecffce1ca64b34fdf7ecf7c02b4447d6a5bb61856dfe21a52872bae69fbe0c68317787e93e92cccdeb92557474b82bf3a363b168eddcc4f30cee4bdf5261ce0629d237696c3c6a45d4427ce7fa3d2c66e656e89b758b8b9080f5734a7b6729a403f169ed5a55d3c48126e9de9bf0ecc5b48f146101629c53e5864bf92999ac038cb365870621874b6adb75f70b319a9beaf6754adf761d6692f43ac6457855f210dcadaeee05766235afd4548988eb516a9dd1fd4fc9bd9bedcf66623ccad55ec7253bece95bb57daf6382ee6de65539e828bd832d744904dd11d28d4405bf92a7be5ee43f7d215c6d3e2e89e2108a84b67cce7bfe02c5ad9e680ea6895f71be6e4b1a22a0cf8186864ccec435d2878ce3fd3ead0cdb55c638e8f0f06029a84fa27f6175c5cdefb47a5fe3a66c2933555625d195c77625eb24575a8c82679e66db6350a21c566fcb7f7d2999255570004cfb3d0bdf053fb6fd150b279d9b1e57d52fee0f5880c5abe91f33ca73cf3d7dc6dbcd7aed70b851d47c34d322ecc754c3415ed11c38c5a1c9d2c4c67615316bc0ef19f28b4cf574f076a96ccdd612950bcd204f358cff5aa7daa74dab4a0beb778642f9912e0ee1fe4fef9b0c73c3e045d89e5ae6e6cb484af4ba050081436490da6029310d6dddac9218446627a5593d588f207920c45f2ab6acf3075151dfdff6e041d780219eeed40fe9a5edb7ed419da2fe114a7d197f5a9ccf5bb04bc95cde889f053219399db683c26a5397f214a16e3c22fc59e880b3c8a7e3134c4ebabac3ca7fa2fc3a66e093ec4872a1789794bc683758e242a368eeda99c611d165189f20e11b0fc4e9f7fb02b517f192c09c7a53c3b6a1f554628845ddec6825ad7bf6797682ed6353ae12dc1b04ebf863ff1dd1a316334f243ed0da65837decd90b661dec5d5fe22dc0ddb945abc65c9f24d70d3fcab036104ef0519e4425e51edd9eb2860971888643e172f4ff32c674c9d04046aca2cd9d82d18ea392dbb24ab8594e7456d65c827ac654e5c6e59c451432c86f36441054288c65b513d19d35052fe5c56f73eb5e7140ba23db2d6a1fe2fd2a166cc6091c9bebb0f0bc3ae8207cb940cb7e047adab8d14a578580352096395bc8efe85c26ddb69d7cdd4663e69b99c2c71074c7b0f5e1f4130191b38011dc0adf129cbf054ec70a7a175817dd34b325c541c59ab85916b3e31ed03cd832acc37db710ca7c79a8a09331572033d5969a971f307532635f4a2b6829a917749c82227d483f2b7ed902f800bc373cd695c38c60add70b934c5a236ef712272077e91326e26ce971cde3f9611c69479bc2ca737165d99edc0acef2ba160d6190f6c5f193bcb132dcdc9cd1a99a6e2ec7709978eaf8520056bf0d68064a2f67436352fea2a01ba9d5e60695e0e8c09caa773644b1a5c0880645c21e1378e7859f4acc6433385406a2ff9c52648756da59daf0430b930e5eb6c7c6ae4738d5cc86d5de80d86059f981d31372e904aab5173e53060fddd69e774ba5a27708bbc39b0c9449e697482023a18f2263949ca6287bf4282e4225813d4f65f811340b24a2518015a74a6e1ecb64669257a5971fd545ce83cd98842f83b052858f5f8d659081db449a3d6e8210e64102879f10cf96b83b92178005cb19e47d06675b635884dcaaebabde4f66f66db6f9195ff229f1bc09654687abfa1d4b5da63377268b6cebea8dc9b9aca927fb37fee4b6628981663ec74c6089907749053659729002fdd2760d0095518bed4b6e756987850f23f3963decbb44d5c2a6fd8e9c830e1681be01f03a11530f751e9595a86b2295f2b791ef0cee04bb87f864b0a1974e15760e3b5f70c4fe0e12ab760d3f512985abbd00255a85377a3917ec72e57f837f212c886a1f2b380d90d91373c1e6fbeb01d66e52a3d2ca5f000d91494d0ca17b9a65c86f8227c591ca0c560fb200201e32851316b7ae84456dc3417c962c393760ce1435a3bcf929ca32edeba3cdccf042d55115c9d20d0a6a449b02130553f7226c51a6085857d47868b26a9d3f9a3d3c037452ee913df70d8e438969a61fffb11ca0837020a3e011d1890dffff720d8dd225b4f7c6ccc7feb64e6a379b63ada0bcda1d4247b4531e19ca04ceb811f928e54bbb6884f4005a054b5056edcba9eaab945b628b15ad582d59a2586d514c9144784a989e3606413563d9f940081355b36402297b68b78855752f73e50d43ac1def023cfc8dbc67faccf79c02534b4ffba1281961ad7c636f81b7f5cdb1d54bb7e2055cbf2e1b662adb22b80b45c250c0ad14929adbd033a837776b20707eeae1f31ad8c5b5f3d18b2c4c4e0aa64ba53a17911d8afb6070a210dee68b2b7c1fc107c9f949573d322b56fb74ae74d1f91fde08e910ef66f9de78ffdbb0bb581a4587b815cd23a6acc609449ce5bb5688695634cedf9470da76335544605fd745b15dfcd3fdef8aa4c21ad883fbf479f10b05fd5fffa8ede5a50583e9362dcac76aa454c16664117d07681b9ddb818578cdcd080a923ee0c6de459c8f71bfcecc63fbb1de836cd9734e1d9b3b8aa7bb818300813a1abe73688278017dc51560d05b8a46fd2198cad9f931669cb9d6b630787477eb642f4dbfb2ff0393e7812c0b807618d86fdacdacc45d6283bef9e301634d254bdbc6d43423f9ca2dfd04c114298136afb737d8eba3356c6fe0e9101b3d3c999f94f9ed3e8b58e2fcc077f0f91f67f56a6da7beef7da4324e9fadd4c3bd0596922cb964f4d2c399051a64a672f9dd3d3e2483bc168075396d8c6012d1878494fb9d5661804720beb39cb51cfaa315bdda17952a3adaecc8903141fa8579c4555636eb227ce530b090e07fd2795898a21ed398fdba58717b93e0f34087a8ab777b15f28dd29baf7234bf4ad824434d05d8d6eefdbf4cb6f8762ce4e195ca0c6254ca581e8423e4efc411de6598564ae1a5025f9c5ce779f341cf7e57fbfc9f8a74da857feee4698c528416d4d01392561c6aecaa8f943baef38a57b0ec13215dbeb4977c4c7ebafbeb22c84c3b00f0243164f26be8f2a99c3bc8e74a7c0e5840e36afc3bd0e6637d598ec5b72a45c78ae269845780d257a7952de28d08ad4a05e1776b916dde696cce54a65ae40fd01a351a690d8cb023f57650a4f8662ecb91f807b781dbd216d1b79b8f344add0950e896983daa6c1d882b397400063e5011eb6a6ea8cde3d159619c2669b1ae661c8078e8564a253d6bf63cd8c186831fbcbbc7ee560de7cadfcf03dcb90f2a9d17d7d8b2ceeb637ad7bccba63fa089648568cca5281595a7478a457815ad507e365abb45597742da0db66f36c5a796c0595ec86a54788d67e039ec5eb62f22d95d1cef45a760955f3ae912cdf4ef6d73211045465b699de6f41999c343a79d1b9928f877a638c161420f4e031aebcf6254e14b01300d552ee8913e820469f28823bd7d13df183603cf78d8c0c01981777f43ce3e66fdf654a75188a44948a3c8c1370f8905904b04d1b6abca3185806fd26588f36aca10c6511292bcd0339ef810e58831b0824e2c2a332a8db8324daf1183fef01ed95f011f5291654a8c5ac10557c428d5c154de7f4268b5140c9f16638db47d023cb33a17ceb6d4fcb96ac12716dc7f6cb59613e14540a694ca814c4baf8be323bbf631f42a62bd3bb849380c6d8edd60013b1c7113ab44a9b326d2ff94cb135fd0350d3db107896fe4a851de6615c392aecb7983878af279e5d54508187d2f5e262d1683d28b27c7f0a9ff2f95dd6f412765fb7054237dca736176f97e46a7d56e845e789c6ecb74a448984558f73507bc47ec2e25f53eb11ec9da436d9e1d330ecd26db0144de05eec56a0cd8b91b6d97472e96a19d26235ffc4d9723c85c5d8909f50fbe44036f4b5fa7da1991e9393a240cfe8c392c436f2719af1d2335726b6e9095464185321371eeaaebfde4b92607d15537a4e85183b8911a8b1c171894a14c2705b2487f442b39b3333dbceaac2b9cddb3deecc9b4c65f3af4084a618207934864a7b26f15224cdfd92af4d96dd30d7edc9f52398de47e15801e11d23ba7deddcbedf13ca39beedad36b1893adf4b3485f1c862c31f04e0dc29f4df7f642bf12fcf36a8517f9e81ea79375d612a15ae08e6589c66c3ac96d593ae0cb08f2dfdf72af0aa76c6eaedcf792dd290ccaeefc37fcd180d34361f06761f22eb2c8f1d32b25265a0386f5a5535beb5285258d8f85162c3d0d82d236f1802499e239bff159d5c7a19327d4beb235ef9c2ef0f3b84af401feeb77d3585a22450859164fca47128f9024e52895be40e4eebe865afe34b9b5199d84e79d4cd6076d3e72b5376d92553a925afa64ff07db23a5f1205e77899cff24fbd62038a777da4c7acfb3a6c19ba47c43e8b2dd6502fded476630c71c3ed49292362cd28f105340ae84c18a0d0a6a4ffb855e3bf0b1c8c27d837d9ca4f546eaa5f501986f2511b147eb62eb402ac8584b9da45f6e94071d621825aeb3bb7819021fde2f9a471a0dc076e7f915a7280b464de2a0f53b11f028ea6602b3e5d5730837a823b1f8a22ad4aa595e86b76ea083e7ebcd3f6f01bc0d4e15ce4dafe9aa8506822e4d140bd9586d560501f75495e48697fa27fd3c4cf92d0334ee3c9b712f1adc49140d48cc0bb1e1872db1f5100daea43df922f95784eeadf68503f9b9a788ef7a25f2f95484f85b1019fffb0eb88ae66e38be2f5ece60c6001b2ee99f1beeed1cc0501784612d2a112833ec46d38ef98f29065a1679aafee1fb2449fccfcd467f3434d46f5d0a8d6e3895bda9a5a185baaa2cb84706344a9f630a98c337f7a39c639b3f9ba9d7b4a2df255b0be3aa67582df865e6b600100fa1aabbc16a42c14e40cb1ce6649bf1b5cac64e13aef312e02049089951d528ed7b3dcfb38aa75d5eae3370cf9bc517e0ba6d1c7a047b8b454813900a487d7e0dcc5db086f8093651685999c64e0a7901e306353afd375906042dba5475ab0025d2145f58957ff8ee7a2a3c9ae8c1359fca4f1b6fe595f6fd670ef30c923fa35c70f8e4a7b29937aa85e94c31a37cd245415b4b3d5ae613a94f66f105d535c80deb07dc9bd7d8dbf5b13fe08045713a6ff1b8551c50460c5a20defd1594589e17db844a9e0285fac885db35f6d23d12059512581f1b15343a3fea9645083bc3511f3877507b949cd930899560a36acfee15ef421d7a97e361f4058912a32972fde87fe1f98e79a97d4163ac0fe514f7a0660e7252e4fd612b3c3ab971fe666bcc4639a9ef3df1bc68dbdf22c0d4e13fadb00480fe7730729144cfe26f79206743e89d2417b765430a248a3889e9ac7d673b919c07afe9399b56dcc8112ae8bf633fc4958babe7895a14d6f9e0ce30015f5a116189107c06a7d5e49c25f9721003bb5f9109b011bd326acb212f2eee8f6e91ca06e29d5fbc2641dea85a2a33fb86c927eec46a8dede98a483166e78b297eb0eb43a1f792b9448c89edb2016930c09c8d241f24ce4ee96ad1186e30f33fb12549a2948d9a09687c70baadca69517d771ce92ebaa1def51f8a9b83140ca94afd821718a42baaadbe7268f717ce34f2c69c7fe545b11f648e08cadba06aa6cec4934f8444fad8607f59248908ae7c0dafb2edb268073326aeb6c0516607cce28eb59fb7eb2d2239e6d071aaae21096d178aee86008ee30cf5096f704360b115b49d8b6cca6f9089bf6c8ecf11df4c63130701001ec719f06744db2254baa3ffec9b3e35b6ca6c9aaa51973141262e54c869a33e4363139a23c1bb3dc4a6f9e77f3cd61cc4b6200d67884d3d619423f5f58ec41f7ce7bf92b3bea96a5640de4c7e7a27416ac633d29953b38e9e91e6c3072a00fbf3ecabc72dcf5174d61a2be91276728039e2c6ce1bba52aded197d1b77375f6c175296e660b8896a1d597d5b60941d06c2089e599d1a2f9851a84befd4b09f44063847c8f6a70039320ddfe0f923a8071ec740e2ea8d276757f59c52d6f5fa8eefaea115f5878f7fefbc4bff52b3ce45bdc97de1139738a907ee705ab49708610c2bd12753eeb3c4ea03cab734be0f7a1c7cdc16af24f9d6bf7babbfdedf8b5a814da04d7e8ddde38e43783ece78b6b6604506285720ee23de3e88e07e517ba9cd03c1facf1e0f3921cb1be5d10db92f9a83398f9d571fca5218957ad6479b0873930d35e32ed4c26884c9498ccc707e6eca30c7d05d419c703492314754eb07c6eab3b11422d89a3a759f299162174ef3ec64d20e58aa10e65811269e5d609b77c1be365145e4bb1015a270b5846c99becc23e630e5bcb5cc1e1f0fbc90972ae4882d134c652267992b4eae91d1f5408b6e0880ca86bc7693c68f9582258884c339d171d8af9c2d78ca5f9a93b422980e3f74aee5946c7b47ef61ac4547d1c9de03f58e5e9276a0a7cf0aac4d8cdc29b4bbc41cf578abd26e2fa4dd496a14a5c773eb2e2c6302f832a838e6ead68cb8b164af9e2f4ce67ec34cae165c4bbc169160fa01e5e1dbee4d6afbc7ef01414613890780c5354f3ed9ac3703b0ed275341b41de87b0104dc53c6adadd74231d9e2331071108459776a55e75d1fbd9a7e0a39b8e406599c446cdb5f182446cc8110d091b08d983a853f6e618392846be3bb95aa46295e7d04ff9f3e0cb62be8aabc1626f1867289f33567a36c2556e5908fa6035b6c7fb96d033a1f84914b32cf8765b3e7b93fad66509e9f10cb96d2287a67b462181b8490f1abb66a29ab518c13ff93d8ce64f68f44bbe94185e4d10637d45e0fd16a4e708471b804e66e3a92825445dd1aa0a0aedc0174915f3cbe95eb0adf25bcc2f81c7c3945e58fb6129999c94b3bdc6a4ec21029869c03ac61d92dcf7aa69e11cca745c18e166724a6274ba0694a90561ab74ca536952ae03cf748e3bfdf3035179bbfd62afda5f7835e13ba4ad225be2babd5f5aed694783755a702ec4e3f0584f289a72c8015eb6844ebc3588af3cd2c78094c65ab610d2ff46162342443cfdfc7c78a5ac056e647ba588f2f2f47cf3d305bd05d1048ec9b2ed1b731c846bac7a830d436b01edd9d211049d331518fc0d61d925fb67deec3ba5d23a7ed14d52c9c579c82025f5bccd0af8c6184b551170402888bbc9dcca54c7a64ef8a5a986210f8e9bb44557229b7b5b5b462f3cf8d79e6c96227860a522a0dcda4fcd4652c7e041e1a3f30b072775cb49004d6d939f1c9ede1b67738a5355bb6d72db38f79117ad1770fec805a9c0f3d7b043b977453c3ee65bc447a526849d3183df62bd683a1aa989aa92177caf6479c3c7f9af601711e9da94ea1d9d48e1fc479cb2f1fda659694adf0f0235e4d74651676cdfb034c2aa1331b5996f3277365bd9854c345beaaa99f53f78336990846789d38af0e74be5ded5086709c2f2b33f41ec98ff22a0b615c6fd377e0d220e16292d695cef5b2e69f313374eeaa7b7255a4716068629672f59bd4767e7fa392e5fa5338e5174798a29a736f2685775afb02173bc06d002c85711fcf30602dd36f6d146b381144b7a5cf35f871a715881309e91ad791e9e1890a5f17e7785061c9f283090370284e1fd04957eae38e85a66e1a817a00e66da83e353081a86b93252d7e1ae76dfaf1b1b612bf4940d20301e4391baa78d0e7d872d2a891dbd406ccdc430990e948a00d7523d33b8b548c3ade2b32b3fb0408161110e00667e4641a338edc2f560a8da61c4699c1d6c1b2e760f40b1ab6f5728cd24547ac94913f83200a6d3b59d249ab9e8177957f0cacbd531119af481e38fb64ba545caa97f3c9b2f835b4b54e4abd7b07258aaddc3035c72498c63c0e1636f2c1ec940aa336d1585bad0f6ffa014e42f3b0548fd05c0edaa41d576c7394f72ee1ec0e5a067c914712cc3bd61843d4a582779c432c6a5696a58c85f102d9c4a752a864c40c3121c1839e2a13676a0c25ba0d379820769f199f58b569d0b0b636401025dfe3a92fa925822aef4a3e97fd4ffef741ec478e6c1c12636998149037105e22b7c5912eeec97668ea8e63f33e002b25d9186d19fa9f56ce82d6087e0b4be88f55064228ecacdf44b33211de029c165b0297d94058d5106a9e7986714ec86bb663784e07f1d9793acd3313c6dbca6014cbb9d02d89a39167c825559bd0165b5c770ca6677253155859407822efcc0e38a92ef94d7fbf8891e0eab8e8ae78eae1a6138ebe8fee0e109fd97818d8bb641df976d4d85271e2395402800fdbdd1c57344d717365eae4c09e8ed511c1fb40a3fe8a2cf6e15aec2af07e644175c311bd94a3814bea57e4f154b2b8f722619907ae827a7b044c0f1dcd11eb7886ad52005660f193498961aaa1b6b8355d3b195fbf3d30d2a4d170cd2fcb3c3e2108f490666f4680ca5e21d01357a24415a4e580a1604da20a7795eb6b0ff880597a0194eb35a68defb0069de4a02024a762765acc4d8ad377b03dd6658d4450c7cd27b8962ba81611817d88f9e74e8d54b99daf69db95b27e82c3fc652e36c48b9cb1bea03464e03a67840e9ab05010cfed5b5d0bdb2dc778b3054a9da5e4d8aa1379377fbc8389a5c05fda53b2479af43f9bb764b677bd59a3b82db5fd6670ed8aec47f6faa214ededd8183945531d71c7e57ad82cd14debc31ff86dd6115217ef68bcf0d32700181eac78b69d4069bf5216764842f1ddb743ba91aed778c163d68ae4cd216a20577aa684ecc58ec0fd34465c3eda1a251364733237a316488f9f2d97104931d4dadd477d67faa076a328bd2c386b486d6ff856f63e38bf4c043c28751389bc223cda9b86dfbdbf634f12b1d323432281636ea6934fa1495621d2f38b02f59abd4007062020451579f07ac8e7d0283e3f30f19e588ba68e5a978a411637e872683696b44e225d6e2b4cfb58ffd1fa756af73947ce917600908447269933913737ae216dd858c808e0706d6580381cadf4c179b62bcb2509dad90ebef116cbf75a3cbbd8ed7860f18c3ec389b9559b269c60aed86af0e2ddc7af4e372495f9f50f39101377329ecc396e4ad6fe305a9ab9f332be6f4f6991eeb95fd40a7efb6c25ba06ecbc0c848f54f11b1d91fe8e3040e7b8fcee9f68f00f23e2dc7f2a963ab6e6dc8874ebbdface89d9ba3e3482d8be9b2c3754d77a3f19725dfd03136748c63ce1c1e46266b4f7e7fc02bc60f223ea38616ccc1bb6b5d62e76d1888d3c75b10e558cbc5a386e66ee3b75da3d35350123b172f24c45a876e5fa30ccf5edc4c2219a6b3ff32fe145f09e02c5dd3d209e2ca4c7aaafc92080799f786876f69cb1f771d18416abc55811d66a5bc3a2ec7c566ac581f74a522b5bf4b1859c1aada4de5ba16d359c9a889238329a5b4c2932353e77e37c464943f78554422ad2ddde8f636de581c4f5e5d04513a683bf058fa51f32ac5bce91b3773bbd5bddbe81bc2eca3005726e72b34018a5453c812ff3ce7fb11ad19d282b10de559a87d370b4cf218865badab61d5184136dce4e1aacc7a92d612f697d3b4a255f9c87f50135722544ee63ecbe83f4ce1353c8670e355b15088b4f551914a4bdaa2598906101b35bb33d538a0f01665576bde54d9a63660b2b9ae3b24deaa04bc544672b3882bdea06f8f31c86bc9d6929f1bdd51f3bbaa8235f6861de733f8227ba0cc382ce52321084cc9a3a8b9efc52eddb95ed42cd196ca157ffaf53a961d8b347d6a9e644f684c18123cdbeb21a5bbe9ae8cc37e0825bfd1d8f05d56c065cb3a8316b7989ea985254eca022527ae8b7e032430227f73394900462511495b86d094e54a6922f2db5336cce7cc8be2a1c5a6fe24d488427d10ad247acd828a36681c8b40fd06fce78293854f5a0742080e67c42c6b89b4fb682698290512b4758e22777d638958114952e1508deb4b2a160252004c49242b316d992258d1c7044578effff4e9d603977e3ed7e7c7451fb477da401b9c5c1855499e8f94b90df4324483a004f7214d494ea02b2a2de89e0368c6c6ba35a38ed26a704c46dc4db829935d76374cf7f78bde753eac6c25e996cfd08c483e983c50dab4404d6c4214945a6f7c13d659ca312fd5dc8a4cc2778024c618294b3cdd4499e5f70203f040513aed2d6d2f5707bc0c62481f28a2ffb68e980eb0cad42034b52e4af8ec952b8bc2dec7dfe1e234c60afdd8eabdf5d392355bde5a0f0a0355824f6dee352b149d8f1930b9acdde8f5798c4283efacc6f99f27163c8c80a681d46f8f52f17cf1f041103b02ed0467a9138dbb15b69f6d75fe4918a24f6ff14d6ca888bb759afd675600f238c142fed36fc321d33b7d055b37670175a830ed26b1970cc3d6ef2e2ff5b7b2320ab466514836a0fdf3042eb480bb3c6fa852833e7eaeeffd666d4ed3a60a63f4c58941132a1dfd7b13443dd6c6016d3cec626b5563570090c934f4b43bafe67ff7d24081447a0e3bb5c686655e155e82e192899a55b82841c6eff8a926e2aeb5c8772768c2f23f1654d4dd6a2cd7332cebecf0476c357d63aaaae9720c6f8eace92b910c5e046b2dd0d733a7a00153e8c91d87a5f6b21c978e59b717b1c6b71fee4349b7d88cb28486734ed5bb341560222dd26b976c6913b0cf324be09f6312458e07b86fbc56f3730ab1e577e2671f961e210311a878c1fe42913592a7ca77916ae3fcb37c9567ba5f834d0beff0fa14054f6073e43d93f71e690fad155f7b9f1f1be6085f60a9e4db32b0215a8eb0f3e2932a8de04582eefbea28bc31e8f52840523c77747d8835a9bbf5b07243562bcef44fca76e28a3b6b8cb9ba087d4da7e0edb82f894a5048fa519646ffd50962a8f070cd3023a0e7d5299ed03262f8abe5d518bba631c2bedb2f22d22e69b1777e5c153eeb9496fb50302e86efc743deff2a3c7266f63cfb44cbcfa21829df395bfc33c7ec578d1ce18489b16fc9c1a12a9d25510f68d92027e56c98c0d1a7a9766ff0c7999c5e97d349314028c143217997e46240f259332eb48c5e78a570e9e925badb2a5d07d0cc7efe42a0760718f37515ca2c494b6207cb102a3ace81d818a44e658c2ec3df3fdf264d2e08a56b73383fa0a474f1d829279b9bd16bdfdd5d79ea977ba37ffb89a872f418d275ffb5e6c9c37777ce9986fa687a7f1584779720dd57fbfa9fd0a14b9f14624a7b359fbdbdd62956d5ce8d2855ecd5995159c3e1cf5f3651e034a4dbd9dac0f444891aa0dad9309957d379808aba3ea458d7c388205fcbde0b7e1a81f44f45ae7100be789ec6e494eee565ae9b86bcbd3e0cf214b95317550e792d3f83a885ab623590fe2d8b633532912d5ac28bf029fbd41a83f45386ee4a3a4ecd756d96d4a0d0df8894740468d547786fd76123310df4973aae68e3502727a593423a48da0907c85fe4387385d31c2b3de2a7d198988c6fdd35b877ef6615c13b9c4313c94f4d59ab9fb7ebf12a7ef7ae2b059d67ad40b05aebd0535ff84b583889cbe0ef166830a941e2a5acc6b64dc0e5d4f67a4a547c60999d8f5c79c08a66633001a1cf1d3b5b22c995d8b421f0c00dba74266d790ffdce50e51c7b4bd98209c34bffe561a136e0351f815e005c80130b7a53e207a41e2268844fcced7f65f10cfc32f87b47f52ffa6ec4f57ca6915dfd21e621c1cb24662d1d2021078c5c403bb153d160b416009fd497a606dec3bc21bf4ca11d4f3677d09f39d7f32434dff18d440715e840852426db563fb338ecfe5a7e74722658fdd38dbaed6b1cc5b4ba5ef5a9ccb045af6acb4b91ee9bcba94f5db7af86aaaf42a89ba08b81d23e8966fa426eed76078ebf862c950f26bb58c043e0df00996f5a6c5d1d8f73e190bb275d9c0cc1cd3099b189a3a5e185df5b7d177b12930bcf3b5fb7f3d05c9ab0e7e5ac29d327435da06946097094d8001fb24b692a583178b1f45c1f404b9e7c46121d9e010bb5efa4a52879bdcad8bf8f838212db07b87423c751f76e9ee47cb813788702b7ee8aab871114b94d352bdc2358411123427cf283ca140c893793bce46dd0d7bf2c62ed222d365d5a2b944a6344bd62ab151046f78191a1f9e9a77e30f535b5a1a8c39dca88fcfc39c72c9f6c23c0d82389bb776b3fcfced0ceba3e170c87a0ca90a40ea0d6a09a2ca851669484e5b278ece995112a05ef313440894739482bf66a41454c71cfce0751c84ea7e89131d28c2b5b5773779be15e278ef2114e8b5bfe1fe150f43182e84b2e8e4650cfa77fc4f55bb29e8e1c2d6bf2b4250c5e6be33f05e3b87bba77409ffabdf65d30a0303af7212011b3b9c3adc8a8cea128cf438b340b9c715c627c406de138bc2420e3792b6549be869aa53325e4fb7e6b2d6a58907f9fbceb5e28038a70129586ed0617ca8950bfbea700b21b82f6dca612851e711c8388dc63fcd17bf9ba5cfd2956b00171c91d3c095b4daa10614998748ab20c3f23509fa697794399c85f3e31ffb324a2b8690565886a297da7667b66e845e14d4c948dba124b9a82f05da238e0b59e7e4f22517631b449ad8df902ea8d8b23193060227d3570f57ba21da072960234cafe4f256be52605bcf1ddb236899af1327330d08ecb5b8b8aad26032dc5ccb84f0af53abcdabe1581c3b7bff95e7b194d610ad26b74d6fcd2764d6e060fa0cfb754be43f6c8f916871b7f70fd37a2c22645a09f838bec68d4b40071a25f486369e2cbb063c18378d301caca59d2fecfa6a90a2cf9f7aa045ca8b2aa526451349ade4149261832a81b01f5f9109e7d318b8ee1ec273b8496e442a37460c4bc10a17c7b131d65a9e7f0ca9dfee89b7567a96d064767cdd9a0099362df267f0f52c9c987addc78f3f5f1cee221cb0640b7032284e4627c57e3d3b9ea21e4d836ce890aabf7a0f7ad16e227cf71f52c94ce3752fc35909ac60d09830ae2620ecbc5731915a39906ca1b97dfeddce26eb8bd75536f8cb2237c3e02f464ce89c0cac720b9e5709e90747441c855b5408728951fb389f8cfe8f997184ee8eebb8aa3555ebd750ba5ebd8acf9f3578acacbb20b1a88019d4b8697ca62be7b5f799d0bdfdd847ba431eff4f3a40bcbd2994dae83dde11720bb33a0b3ea9c3a59a7f03bccb8c1825c503e378c630de47f9475fd0d52b9bc75ce3252d0d2011c8c53d4defd48426cf78a042cdeebba429c770198e1bf4551ce26420d030bf87fcfb76c308a257cddd109584055d7c72a3bb658b5ab2d9add67e7800accc43f02b480891dff132da2c81747fbd4411cc345da779ccefe90a2b642bf2410f59bc24c54f9b1e165bebf79e9f870dde12905eb31a55bb08a5da971ec90ab7fec4e36ad3b739a5693a0771ab7cf8fe19dc060c27d3c9d5b2a3c8be783402b265cec030230e128342047644bf99c875c3c6f758fe6c91b93a72445dbb7e342c85333ef47c42fe8669b4c7528a28cc769e53887383fd6113d7cfb56bfbddd9155ac4c8a682a19522ea359ac089874edd7e22b91e0081e91ead098ce60a00015c0821563083dbe6f8979a955705029432481d319371bd84e06d43d10bd8d48bb7b2f91bc57ea66b9dcacdc8b02ce7ec9c9fda967fb8ea3873c458aad2cccca026da22fb1f842949563fe1a4612bf0b42c95b488a25b1670dd55e166d819e901fdb72f085a49ff6e3a53214155d79264432f786d1705e264b184f3ec3a54fb3ed8e1ac83b3430144763bf488da4403851001a76f6e3aefb8dbc13e73a1a3984f1f2d005116cb7643384448df36d13137566ae433721b369c72020a1bb44c360018255ebf6e4b287bdeca9b290392816e0f23e70f3e55d48a104f3d81d3376f4dea20896dff686397bc244ef4f6b021fa771a0de6cd9bcbce681b612931b2f7339854e6b408ec1d681bc5b966572d442be3b56b35ace0031ec257f0dc195f4df658cb09fc6afb9649a491dc9cbaf6ee4f5b1601d89d13509c543508d8f94fd508a04df56e920643d0de3592ce9a6ceabaccfa3cfb4993e4e5d133e40eb90021c2f26899b74dae66910e826f1ff31b4488d12b4a8bcab891f7f19ed283777bce7ede3873fc39f62bdc4dd8fa2c0e6201f5d25488f9f6d83095b87854fd47bbd7afc6f52542b3f362285b546724474bd90cccc95a779752f7c17e8829646dafd181e9f68b8011a8fcd63d0ab27452c78ff544c086540ac56321a3a7c62e995b487a525e5dda90891d8cdf9fbf57e855977f200ee08fd7f10caf659e17b1ace60ea153d3c4cf756aab6a437f51034818d1c8a8919da1818df577d2dbcafa99d4ae9e302832dcf460dc5b8547b60d0e95f780f2618b1dab9cae73d6df42ea3c943156bb7f260f6b842f0384de3e1699d320ab7eb863cc27a4744bfe6d4f5d5cb4b850e836df0bacc19fb420c7c89f3c54cb93bc807fe9cfb73654c2c28a3bae0a3fa512c74201d611c61864f27dcabe543efda8c7cb3a8f33a64a8e4afc19137332a6f53d5795176569cf3d15e29ba7d6edce3a607be887bb72dff829ec28bda27242ad668471a18a8c2789974482d9033a5187b6999365ff39a8e220026886a6281212e39bdc3cd30c82459c3034b7afbaf7800ec810e60ce83af423e2326d5efe7ce51f2371478cb0d0ff2cb0045edb47d97124dbbf4fa766bb1dc33ca260d804b4e5971a01f49675626ac06cc19d99d053958e1897ee53102b17dc0e5a4ecd481ebc3cf3f7a3e298ab910d6b1a712e2fb4ef0878a6ac5e5d55e7c6acde9331a328ddb95640291618fbc52839cb9093af862f266832387ea5cd38863fbad0324bbec60914dc45b35d0192552b89c4c07293326581f0598e526d308731c1d7b22913cd3874f3887b68604495abbe2a335e8b61f1fd57ea9c5b294bcd8e4b3bfd7be8cb84f37ecc0c2fd12e92d232933922c6d38233334f84574a6c55f8a4fd90d00178acdcc4ce4189f99174ac53840f84f6ac118965b703e311a04fb778f27368797447262ac4f62d60f6946639ea234d73adac67ea058893d812bec8d1a795b0b71b1114dd30df6d46694e8d0b1ecfa44705d0871580bbf5cf3e40344780d6727fe31b174666f2fe093217fcc43ce06fec6360f790a3e1b010cd9394ca6e9f0445fb2a9037609b7f420c5e2a272911f3e22ff8cd1db2579597c3d2c64b46efe50e23aad452e2d3e732251a30b839ff6edd921f4a09a82a1a5b28d0e33ce4191b12e648185d0f75dcf63bc7f474f5bcc3b39dcab845953084701a5043cac2461f75b00e99049da65ab534bc6ccac3fa17284538bf205347612940bce1d8b1705c42ac0f0b8a46beea5d249ba490aa6ecee28ff3ae18681dbebb6b36e375d8217c40e93d270dfea628d1855d6c650e7aca3800255998c1b882422dc35ee66ae1a7746de36efba1428106e27fb0de72775aa7c3eb06d69d3e7efa37b271d46133aecde6ef946eb5b37631f4d19119dde768f0c0477b3340db5a8da846c6e91aed86db76f7da5dba5fa44ce655120e94d0937ff93ab68b57d45c60dce1475cfde6cea1888c636f9d16415bc8a4560d2f22ad9a45b48986de2ee4429500b75a4b42463a2f12c6d25cd531679eb3ab95246757f28275109b4d334561555192520bc037366d90e57ab21b5ac82444e2ad2d0f295825f0dd686b5c3cd4d3bf275fa80299a72733f72ee74422258e7564bb052c94a38b27a4d15fe9d4b29d94bd746859baf336f48dc0655d072da88e3993719f98a96cc5b612f5451d1efb2e63f14255621630dd0a5efa0df7a459e849b7d17f3a124c57b7f5f05c011300e8a3cb1243515341a1afb4571dbdd248c610e0a3b7d53ae5cddf17dfe0f836c220d1105d38b781ead8061483d8c5f96db93b7c04b2e5b7aed4775061100fa7aa39e657ae805e3923981a9f66741c2759eb706439fab19df4929b95ee3e72d4608399223384c280fff6ae8bf470b183a312f1a6e3c7711e77b63059d71197e73f18e98b930fd27f76efc1208578c64280f8643f1b7cb0d4574fc6fcc4af3e573575ceea77c3ed17f72872d8dcb6878adf0b87ea0ca8cc585de41fd132d845832ff538eda4a781cdad2b7333ab649aa128a547a3e665c47040078cedfb654b1e84f0955601b7d413e9d586a43fee13720e7f3451bd58b5517ac791702b170bba64a710494bcce96936270b98b7a354e392a609a970fdba9ddafff2d087a32c2d7cc738cb3bee2805978789a7296118a2643fdbadb8571e6efe6c7b849eb218b95b08ee1eda79a0fb984596aac281762e003cf355c30a324402f0de869e6aa0524f3140530e6f01247846b2c639d4574cc8bc316162f21fefc09079619f70ad4d3293f8680bb7e9b5cd62d4be828093dd1c5e5222a0b7a8a79bcc3779942f4ba0b418d3841edf6bb2f39f427e5dceedcffebe93a8b03dd17f233e91ada54bdd661a2db4102e19aa5f785351ae6563e81faa22645310931512a7d6e221a3c6ba7bfbe1a958ca6eea566e6cd275cb35a8036b8a8e7e462ab13f2be9dbe7ab5e294c9ec6ac4c0f5ed8681ab9aff8a0b8b94f59c1c5d9e7195ab5fcdc2d2c7f0a4f6913454fbf1f9d5477012794a165ebe84e880fa3857f7104c4614f3a4e86df87efb2ca062d0a6eb6a426584d44c727e3dfc6da080c58deb965ad22e6f797b1f9722729b68cc6ffa9ebc89c4f08763931cedd11af984451838c4704f9e8a43182fc18c0afd84fdb5be07947c5cc0efef9d8851feeb86e178316efb75d8473b777a89129cf891767cc7d522ae4a17f76a54dd9a9412ea2a2eddea568bf6f92420e833d091c258fb995c118f3266e8087e102e0b62925f8c5ea0717a4dcdae0aa6c635f33f59788e414f130fb44f9781a2d125fd8c7e1abc5d01e9924e7ccb02b186e57f26f9ab97f791f09cf5f600f442613d8943a3040e03fe0cc29e405610298c7b514f9fafbc389fb9b2051788e1c23e709bab81bc7119c16f54d3777a0c74d2e72ab0f83885dd9c2feaa2f91a790122578ccd23dc44f4b275763ac272f61bfd95a4276f96390a5d3c42c6cc17ed0c0824e1ceaf30efda5b9e560b0adb6ca3506660c4cd64c4b82b2c937a98eb4abe3380e0cefd7ef189f8c004381d5176175f368507af798979ec240dd3e3ee2ebd1a8082d4228dfe5561f56b0b71b194b06d16e64caabc4ccb658cfe3efb0def0feb04d6a2038b549141636a6307248ff32ad5017cb4af0760d41f11760472886324f5c57b8a4a914732dff845f028bddd42df770444fb3274ba6471c1026629bff87ab54ee89e33b7777022444dc57edbdfcb8c48df0556211d683c734f263927452db4e87542aaa05ff34090fd4b4bc26a13472b0558529d63038d0bcb0a41fc8c6d4ece617678372ba38f8448992e1e99813ab3a3c6c13af966311a845465c0177ef148063118c74333226eb5c5a86e66f240734abca6300f8bfafaa6a959262fef03517c89ff4e64085c551b12bbefdea1024d1b05523c15f40a2be47f5a65a27a19d5e47d570b99be7b6ee7aaa87e5a914d16996248555d75c774546434a52fb083dc1847eb25c05fdc08b1d63998e9df97c3fb5795fd4568e6c93be698a955effb5fdca6c6793fbe37fdf15fcb703a18dc7819dfc1053ba467641da5f115ec00523cf0084d3983b433946e2e9187d9d9996d9315ecd71373aa16ca60e775ca55710003c547b8f49b5711f8af3b859ca69c8afcfb696c59720597ec9439ecc554756bfc3db00ec59b236aac8eb49fa58aa02cdbb24fbcb7d8d2b3eae9c85a8acf7935d005afe33c3ec58032ad27be0a038fa46e1b2d367705e95c877ced054e625f6fdaeb3b7b941d49a34150f7c44d3a8033b71a6b27ce3e2433afb568df6b9db251ed4b21d2b31d1f347b2d1bac27f01f10aabf1fd0ce5ec564edfe2932e800daf2f1a8cc59a2aef966fdeaa824842b1352403f65548b9a40c2ef2467a9b75ab10e9a2a20c8810e12391dea7291d232e91003848258ff6a8198d25b3616bcc9a9970b62d8f7d63c9b3be616aec6408719b758a742350c55457f1af2f4a143cefc82f5f5d580f8d654a094d5db39e0f274434c33e7cfc714921711ffe7002734781d3f2ca7c4910d71b3900c1dee94435ecd34bb283a9c67189a665ef4eba27f5a923c8a9301bce1d5770301022a3bdad70e3000962878cb1f62a8bb06a403153264cd07427db8862c681480ea2dd9da0f6881bea5d78d16af6acd0992eb2d5243f76597d4d7678685d4d8d9aeda47d7f410af47d1219c6df3249dca205c1a5dcd4f5c2da70d7b49a6e7ce25824a2a99744368adadf824d8225531ae79e52647304dcfd121c5549b9309e1dfed080fa2a9d1647807938eaa1a882d939a53175486f9507d25e4680425e7138cab960c2f517947c392f1356ad6944537294591e706a5db44b8f5ab45924837f3bc67ab9e81e687fd995299e2feda37f73fa9c09925c11ade7019ea66fab3517cc0140b71764dda4599498b7b3bbb4806f84398ac2d2779afeaa4b6f3e8b591e5ec6212a8fd7ae5a0ff81a251c270c5cce905ce3fb0d99da8e780058e2fda6121b11a889fb51063a8c063e509e49d5529db0ac08d4d0a1fab954130bc32fcedc1008cb87ea1f6ef0cde19434452ab05533f01241849f031f8b830ce39e154fca6f15f487cff0674f5f839fe308ff5d9b39c4669d30643ff18ff10ab8de82b5f3c14c2a2f7e08213685f4d46d0cef9c0d05253b3c653cb514897339bf56f3514ca13249ae6498102ef8ced2f25b77c69ac99116e59db36fa1e4974785ab8dc9d96dfcf9a61801d9500614ca65075e57da3221a0a413f03a4f45df230bba0977377bea859c19eb1da4198eac8d17b51a3df6fa9d15cdad4e6cb266f76dfac2768726162024ab682d034fa301b964fec22e97428a65521c86d1fd7ce54228d251cf46871dcf2f748159c3cd1f77f3b4622d54c83b4822816e42f0b62b9869c81e1701f4fc59bde10e24e980a98d019947ce88e0025c8e4b509d6fab5036d7399ea4a07d235391fdbd6e0c5731d8afab8008f1bfd5cda460d88e23faa02fd9e806c9a2ff1716f2f98e34239029392a6f7fa17fad666f0347a3af17e62309d5c3a53aa5b7ca75d4afe4be77e9af7f69c1746900b0e19d3945f7b42726c6bb1db3e255927e818d01d01f3b74ef5f0732024256498efdf0ab92dcd323fa3e09c6f2390264e8d11c246986688ccd4b1d9a5111b9705363cd58e9a7fc1300d5063a3a1ce549cd05ac5af49394983dc6c87e89595736f0dc29e84b6a389939d152964631a33c3911dd52ec9e2cf6ae216cd06326713329bf263bbbb62b48d920703da3f3de0a592595e3795b299929478290c5faf4ed01b1ebec6e7ff5e8816f5a87898e0925b81e2e994395bb8e3631ccd583d3956230a2ea615aadffec583be5b762d60459f1831a026b6c9cb0c0c15e35db900b37cd2a60a28509ef0317be80f627d10526c3a3dc588695dc93fd42ee6a06693055fc7d32baa54a558078d631dad4e8317a188af3fcfbc0991a9fd591cdbf43dd41fd6b6881877f4377fc7e061ffde8fadde5739606ed606dec3cb49cb7f094a699397c1a919cf3914dea294b6816f3ac449acd5d97652a0a1f3269f96d01a2b09613131f9ddcf6861311ba9f127dc56236814e4030eb6c35387196daa2e537828b55f2dc52b771da504ab6a3e382fb1d6e49a3b81681f2c1d995ba403027949f8df64d0a2c9825c3774b63954c2df7c467a52331b1acc8d7f61effcb091cb242fa3fc0bc11bc39549e41f8f4b9084eb606894a08ad0d413e9f804170b170e34e4760842ad271e4b17cac0edc84260b45a960f4723a920174b7314d3c2cc865f323fe28f17fb4cf903e422328fd0b26afb40c8b4274e8481a2ef9a7b872d99d54e068ae6cb6b710d8c71fe5c8e3b8ad02293919b5ff0cc1e432d4fcbf3b6b077f2cd5cf06a981fbc76172eea72a26358debed72537c43afa55731b9de7a8116f4ad599b972db89c64c6ba157ec362e51deac1bd4507fd7815c57b903e1da397cc4838a15384a43d4fb46511825361b8748fe9e484ca3848d709ca9a437f57686ed50d85b55c8a5a8b3b074a3cd19578a7fc7747892a4fce9b7a4d1379f4abcb41d8ff6295ece46e937980804a003406ab13ac68b3bffcecc452959b4799a6aafa9c6df5cc90a9b63ae24f8efa56464477635475ef6f9a8384499da98793903f5343a7bacc0e5f28ea5eb7af67702e86c0a8637eebcf15006e4576acf6c1a4e6e432ad26b158ad614a7f9e61310fbb5ca31aada2186bed4fb1d116893314b9f82b18eaf9298897e5a6853e5fc5b56ad12659178009204a63afc93c3b0468cc1e50f999d5221ddea5b7e98ef85e8cfd7b1974302d0c42cb09df100edcf2dccc78313f38c60706db989b432f570bfb4e5ff53a4f0f191ab093084991e7490e3a6f311eb90c7239c015bcbfd7797fb129a9101f7ae33b437ad7f89c447b8dc3be2f7f00fd2603941275aafd03791532976d154a1a686cc6c8cb6f9d7fc894fc1d1cea4838b8ebbb284c25f406fdfcc26279573e499ddeea3e00f05cd226b991b499bc953f463030f1c0de69110db3064164bb66d5a8f636d191801bc85bee8b88a0a2b09ea6704e47f9a7222534e9fc18b4e91a4b11698b27ec6e7fa106531f1b03ecced3128ea55ebbfb65a4f1cb55b3cc6944e067d69f82ae85efbd072d6494b0e70fb956d24e23ae56c2d7adceed30f23343ab2917a19fac5abf688c0df1b8dbd5a6d28a2189ab91e925ed8798feac5d6011e1c8b059e78bea9128db092b022427bf227a230670d8d1e94605f4e75d28532724be917a7c9f98cef45f7f2c95cf947c3a2fe83b5902d8be6e747c46eaaad3be8da6779e4077c77c6c34eab62173c37489a3c64b2108bf2c2200a5e171ee6c5bb749e205ea6eae0937a7f3beab684345196f4bf7801ce5b6fd81b6211fccae2cb6c73053eace6360175e2b2d98552b0b47af71db33158019e5090c35967ff6ddf96ed7f3511bf3aac48cafa6a1265eddd02d67157c6bd5ee9adaa82af4e10d068422569ad2b9e359143517b77d3a0e22f6b2c3a0775b18337370014f0c2f8bc36a6ab9f3be81743df13df4212420f2b36e9949da41d86e2c2e0746e2d02727f78b559241337dd03dd4c1616dc1bc6a11e53186ab447a6da024ee5e69e0771476d7711720efc801f4398cdfdc84032e5fe439db9736780b66e59ef54bf7f467c5b27658c0018104d86bea5e267ce018909b9f2b5d998d9ee29e9907ca54130c1f2f7d496d36d4cd7ce06f515bd730956406579d3363edccded1a7f1875f70875fdad813f67e18343883f74dfb39d7b59e3e097e9693c39f15792b575a3794bd6935933a91b5c204bb4a75066b3a6d7caa3ca2de4982df584f3df28e9af52bd62efbacee769c94b17ba0874a1cf64b92c3ca4395d483996ec70635b114bbcd84c068eaf680ff1f41d947f8d9b50cc6bdf6fe48b04e35b7d444d777af2a184a81a4188d074fc900692648eaab5785997727e191340ca07183fc98401172a6ee5697c97ca4cf810327eca907e4a9ce6dda487f3b13c83ed02b7f78b1b8e6af598245c8d693895fdd8c376a6c8cbded69602605278f760064e4493adc2ad68749106287aa2eb9137936185a04177b6d98384471f8afcc1dd98e9f5fc73cc07db2e053a8586bd61a15421d6427bbf1d8d473df62a42f6053624275342ed2d02a1047da3b00c5f3f3c80228f6d3a9a726a74d54b4d6775979e8f0a90f12300c68b75b66e253e9d6de8fcf21a0e8799e4fefe5bbe702794539f9eaa1aee5601451bf093791b408a7cf04b7b1dc08be6bf4676dbb186b71cb68d480c6b554bddd7fe76696614f62065e0b7c61b4c0bae3bd6821114107bc54b7a6ac4e896dc3e0939f7001412ac5db2a14241223ec6b652811328f718961947f469b0dfd30a5e1533cf2aa08df784d36b22b80437c360084697da3505e06b36990ee5d69419304c22e588fcc6a354bdb78ba498fc200c265ff5b00f82d374dc18f86092d41698c97ecd7f829e9bee0a0d6b37f0383cc05346cd0451c6011c51f065feff1a7d26b7cfb3b20b17f9c6aebb2d079965a3d037e4173dca267d26a53ee947b08480b59a8bfb52601550d8f2f0ef3246d99859c6c244fb97a37495117cba3b34a24b25d61ee18c1d2d61e5b3d1edf6d573b6263b0d528680e9644b742e8bf8c4be63ecb6dd4746f5b81f045fe4473e9425c9ac19ac169e9467f3d1c75af7f4abd020f931d8d8ac6208296e72cb92eac7ef480030478ea16805a51d555161991d06b29d249dbccf69eb615acb9cf74a3524997dbcc8295442e60833a29e8c28dd9b1624ca905f7f12117aa39389da9bfb55b2c52be48d88ef070242fa54babeadb7d9640997ba61f4284fcdcd1b2b27b6643ffdbac572ea309cc2dbb4b4af6b14dd6263490ab9ddd1e53f2e05ec58913291719fe9d405a59a44cf93d762ad153d04b3a0a5d53e84ba98020ea015cf5f2b91de96aea8d4280a308c0d322e914720d07d0f74b2e7a6475ee595b630a3a16e2b10fcfc689760000d749cef84856a1e5de146c704c79cfd8b0954b43bcd80ffed6de00a8dbe95f9c3293e5d9cc1b09cf6c3f864187184c3d794212ea81ea9b5e64a7adcb7c0b1ddccee53fd731be4903319d598a013d44e7f218f81c869a0aea127978c4b3474ae567972359d334243ddd69bb0f9038ab46547f3993a03814d03b9f54304c6256f1d9ba05ae78b007c7e95616390db7c3aca520d8e5fc5f0f20623251ed12b299509362aa2a146dd39ce10a92f963d40c33d6d587adcd27af96a6c5cd08cd5b61880b5bfddfad0455c4ff66d29c9dd25710469d69e60e25fd98a43adaae14cc7f36582cfab64ccc846fffebb0e3b380c96266784766ba2aa64c0aea47a156c5f201fb893d08b3f7127f1206ed30fc88484c06be159d82d76502544384588d8611d68f66e4412afacb56bdadb6028cc252a73663cc2b5d4d56a9f1b1d6584dc8607f01e9d23a9274e5e9aa995ce5d28d20533128e7340ecfe1afefaa5aabcdf3937dc11f8f4e0452a79371a133a85906d2593c7d18b0a34d9ab00c7192c8aba142993d86cc81d4c483c1c015e73083b6e9f2d73e60bef7592de5261a633236af652969f91fdccf958ea6d56c86555be47ef3023e9bcc80ff8ece34f3193ab55bb30d50a86b53c7f6aea0c7a38a9706dac0338d77d59857b353f1200255b6d7a0cded297a2839b017343d60a878460ca32329be6951eee2b3fc59e40fa0b86413ec775721e0f11b12a160bd075c2a602dc16aeb426157c010c4c8898070e32c70d01fddeca87bcf3fdac7d9c1f2a2e22ad0a4c65386d7a9ec22346ef6587598fd5e3f724cd2326b16eb379cd6839214463b8b918fcd1bb97950c47424baeab218e18e9bc9b5816d5170386b5b6b3265b44fe592347f839f4bdde97408b3a1f1b377e1355dc95e6471c4bed517ccf508abe970df61a9ad6a5b6a2edc82ec087a1e0f1ed7ad97d5ace2cf5677e709d36093131b82f85d6c436c029cc66fd3bb9b94bcafe009a7cdbdfefe962bbd140eb87a5917441fde382ecdb61b477982dd5ec9399d8e81f17665a6abbec860fdeebf49e27e12df0cc5303ff9b238e89134535c88ad754e8f39a42bad5f14a727d7bbdea5ea573de70f72d1d336c4d6fa4966655dc791acfdf1a151c046b0289b2175e52ff99e63b3ce42f9b22b9c33cf75c88401e403a8d50b3e91e3acc3813355e4207e555734f65bb86c9b3f07006b03a0db7ce2ff6d45e675f585bff0f7ee5554fd1b191e3f1068600c6ea3f2d9999cca7b2a675faf7dced79a822edaa79f862f912ece70e07709aadbbe439555a16da28c8210085215735ebc18d54ec5a7b8906847f9dd4680fd9c1a4641beee2318e4d2aafd173be7366340c39dfa44f46809ab6c7a05bb22a301e7bc1f66bbd3d62a4e03a2fc0550d4ebcc8f26f794a4d497d653448fcfa9b013d43b6f7b8a86b7526334b51bfd13a89563f9bff66532895061d0d2a53fa2019ef2ecf05ffc11e4597f3da8963c5212a5f433460acacfe5776a5a7a6abdc103f852d19917ada182e1805ad969cab9b3d2737d4bcecab62bf875a14550c8fa0f5322b155b34bffad00f7b1d98cb83e5a0eae02dc3173e162ab72ef511f9b96e94120f417d808f3c2321400a9cc85d923a921f888b80ec97d36e92c1bc88ee7800bd27330f7ebd5bc2edcea01beb9871c3aa0edc70961cacded4456d6e629cac0a75907fc30b3a08cf1fbc1b1f25b1ae3c7d294465c8d91a16a7ebdd12c727ca1a2e4f2922494f76f9fd47bd63d317d8e39770a9d56631ae2e348d8064df18b96d1ce2f98515bf524fbf509ca3b6d5d6117ff77b4268adedbddb8daa874f147edbc934898a4bfb92589053ae1b58c67aa63e77ba0d56ae49a12d65daa83b16748f5119065410cf13d3c15810ec1c95f6d0837dc5f6c0b6785ca12078d3a5c3b5c338470e791e6e11098de4efb0f85c7d40ace78617c47eee363be11dd74f95a406431ba92cb588959eee605f35c38d63cfd6d134d77e81cdca01d7ffa9f5651dd69900fc0d2429d5333757dc322bba9c5920b80240592943025e82b584c19497c1049a72cd0fef84775ac48c42ad7375cd54e2a390e3a0ffdc7afcfc23ea4ac0734d8986bc36d49b659a13d255156f82fa8bc13e7bcb2a8b37154c3081d04e2b71e6c3d5ea0dbee533c70317ff102d70ac35229847245793cbfd7bc7254490032f899fbcf1d73ecfa91f814ed22486dfbe984382c41f618eec0128959ccea4f9ff014640f286936738525fe77ce93aaadbce5e7b23069b8a9e4ec694ff77addf4631af68952dce5eefdc8fb7f38fd11226ec3d231b63a5e36cea26c503064d26c19326f7565a3fc98d324e01b1ae0520a5007c7b43ac8794a7cd101d503277fd3e29d502a9806c3d8b63179df3e62cb8c5436d4f54e7d851daae6a156bc372cb580f7bfd9bd44969b0d4a585da3a2db9c027fc979c8b20dc10cec7fe2a7ac989754b7f26f1df28ad3c80570f8229bf8aae5324a24ae5bc8dcdabc3d1b9def06a1f5ab11df7f563fb5607e336a084c96a25e027823a1004b75539304428ac4f91719ee773177428b89f6ece57f6f7a9531ca77fe386b2ff490b63e8e610ccbe055eecf4139bf02842628cd8036a0f8585cd2fa38793e0f7a55f7f778823dd349830aabe5da2a75c4e1d7e9c3f586d371ac7d65316d015780c51df26606ecc001a5e8de7a835ca2f43ff179d9ebf73e70714403166df6d19cc42282fac48362d6a45980c1f1f2a68ca06aaa7360f45a72e77db03c4116ece410620ec1584d8650cf005396e80daa139b5263f108d0f7c3728cd4e251e1f1cb0711ca1a3c89d67b54144d6585db586a663a93cae3306ee9d90f85373a935882e64a80dccd2c4fad3372a2bcba29b0268b161e28176cefc8c51657a75caa8250ffc48b98e51c470bfcf4e2202157bd0c7c125587b4186a5b425ecc9097d972a628e04d903cb5df295f474c77a812daecf8fb175492e2c1701e2888743642ad9a0573aef14e2f11bda19aca4524a61f0db437681ae161d32f4085f235212946000c11f489ce9789450c51ff12faa4b58da848db6ea799a25aecb00c5c110a3f429796131a0018c2b6537b539906d6a9bf5969d88f6f93afafc2d8d3ceaffafb038b5888f39e4bbd4ec799f8705533240e54a2503a269bb2078286e8481ea420947878fd2dbbcb59dd7e4475ceadbadb756e09e088d08de287bf5ec2e75081bd64b03622965accde194b0957ff85cdc697a22919b3225af787bc74fd0cba8ac960da60d09891d29ed95ba5a734a46b52f533c034de5aee1c3cfa59193372190777d24763054b3ca8f0cff216ed6007f78f8b5aacecbbbc0fc2da35f983a4f5cdd6bf748bd1d6c21b21b6ab269049e1ba4b607db50a93c4b90d9175d7ad341e60a563d557d0048d5eb012523d775773a8ced41fa0b12d0e8fbeab1bbdd0f5c58bcaa4aa2af76cc3136276c7e00a59d01ca203540262c9619aca8982c46fd9b7dbd0bde78a4ee22f87ed288022589719b436b21c326d0fdede1d2489ab3cb84b25e451b68f76c18202cbf356adf11b3f5ae11683d424e9ea202b26286f217e815febbccc2f02882476f3d30de7868fce0d294d4d0afad1cb2a112faa2e451ace4485bc703dcfe59bebe33e5faeac8234bf99b8aa2ab2bfca7adcf1ed280a31abe803c3fad30d2820e5963223a29b73757176c10f715aed571c2e4d6260c8a210d29fccff3366a9beb078799a7d26f2e0608e63b5281de5ef0d39094a1b654760574e5ea1bb2d87a5ba02858c2f85951e3871356c09f076e1f85d9d34a41abcf29dd425dad61a854b524697dedca6eec38b2b73aedcc81e5be21bc12ad998e7a4d601ae1569bb13255f7cbcb39065b3ceb99c4877ac30020b9aa0855b1072c03d30d005dd7ff036eafc876f35bcb89b67370b41781acc0cce15f206e758bbc2bba1ce3a3bebb2bc0883a9aea5ca90e043535e3631d06b82f7c058fb08bf469900d4638b5a197f8f5e8abc235e5e11531cc6d33844216ef03c1249aaf710c8028b410226340d1ce78fed3e3f92cc45b3e1bea9a64a990f8981060f9f510f5807770889a455cd3796498fb88d1ec566ad183bb2f27f4e4fb3d64e996c44c2090b0bbd94d217e00c0cbe7aa62ab9173da9646a126942a7e99fc393dfe5afd1fc3024cf592740d9572b5d6ebe80822b171f65bc124798ff7b78ab3df752404e6723f5914c7957289811764d65278714024ff3c94a2aa0a2e7950cd6fa563cefad164e61472ec3213b58fa27c530ba1393e00ab02421ea</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">诚信考试,不要作弊</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>移动通信</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>4.计算机局域网</title>
    <link href="/2022/05/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E7%BD%91/4.LAN/"/>
    <url>/2022/05/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E7%BD%91/4.LAN/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机局域网"><a href="#计算机局域网" class="headerlink" title="计算机局域网"></a>计算机局域网</h1><p>局域网诞生的初衷是人们希望可以<strong>通过某种方式构建一种来去自由的网络，使得各种站点之间能够自由地共享资源和收发信息</strong>。在这个网络中，新站点的加入和旧站点的离开都不需要花费太多代价地、轻而易举地实现。<br>局域网最主要的特点是：  </p><ul><li>网络为一个单位所拥有；</li><li>地理范围和站点数目均有限。</li></ul><p>局域网具有如下主要优点：  </p><ul><li>具有广播功能，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。</li><li>便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。</li><li>提高了系统的可靠性、可用性和残存性。 </li></ul><p>局域网的主要构成有：  </p><ul><li>拓扑结构</li><li>媒体接入控制</li><li>传输媒体</li><li>线路布局</li></ul><p>这些主要的构成要素决定了局域网的通信效率和开销，本章只讨论前两个要素。  </p><h2 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h2><p>通信网络中，拓部结构是站点之间相连构成网络的方式。最基础的拓扑结构是网形和星形，由此衍生出了更复杂或者更简单的拓扑结构。  </p><h3 id="总线形"><a href="#总线形" class="headerlink" title="总线形"></a>总线形</h3><p>总线形结构中，所有的站点通过标准的硬件接口（称为分接头）直接连接到一个线性传输媒体上。站点和分接头之间的工作模式为全双工，使得数据能够在总线上发送和接收。最基本的总线形的数据收发方式类似于广播：来自任何站点的传输沿前后两个方向传遍整个媒体，并被所有其他站点接收。总线两端是接收器，它吸收所有信号并将其排出总线。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220515111944.png width=50%>  </p><p>总线形结构中，由于发送机制类似于广播，总线上所有的其他站点都可以接收到来自某个站点的传输，就需要用某种机制指明接收者。同时由于总线形的广播特性，其必须要采取一些机制/协议来处理多个站点同时向总线发信的情况来避免共道噪声、保证可靠性。<br>解决这些问题的基础是各个站点以帧作为数据发送。总线形中的数据帧需要包含含有目的地的头部，总线中非目的地的站点会忽略这一帧，目的地站点会从总线上复制下这一帧。同时，各站点以某种协议合作轮流发送帧，具体的发送方式通过帧头部的控制信息确定。（这一部分的控制称为媒体接入控制）<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220515113815.png width=50%>  </p><p>总线形是最简单的拓扑结构。在物理层，由于通用的硬件接口，站点的加入和离开非常的方便。但时在上层，新加入的设备必须要通过某种方式立刻知晓这些机制。  </p><h3 id="树形"><a href="#树形" class="headerlink" title="树形"></a>树形</h3><p>树形结构是对总线形结构的推广，树形从一个称为头端的点开始，延伸出多条缆线，每条缆线可以有多个分支。每条缆线可以视为一个总线形结构，缆线上有若干分接头。与总线形一样，来自任意站点的传输将传遍整个媒体，并被所有其他站点接收。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220515112911.png width=50%>  </p><p>树形结构中，每个分支可以看做一个相对独立的通信环境，所有分支之间的通信资源可以共享。由于是总线形结构的推广，树形结构也同样需要考虑在总线形结构中遇到的问题。  </p><h3 id="环形"><a href="#环形" class="headerlink" title="环形"></a>环形</h3><p>环形拓扑结构由若干段<strong>单向</strong>链路组成，每段链路的首尾通过转发器与其他链路的首/尾相连。数据只能按照同一个方向传输，在环中沿着一个顺时针/逆时针方向循环。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220515120133.png width=50%>  </p><p>环形拓扑结构中，数据同样以帧的形式发送，每一帧中的头部携带地址信息，地址对应的站点会将环上的帧复制到本地，当帧循环完所有的站点，该帧被源点删除。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220515120602.png width=50%>  </p><p>环形结构中也需要媒体接入控制，最经典的控制方式是令牌环(token ring):环网中用于授权站点发信的工具称为令牌，只有在拿到令牌的情况下，站点才能够发信。令牌在整个环网中传递，站点拿到令牌后，进行发信，发信结束后，站点将令牌通过环网传递给下一个站点。如果下一个站点不发信，那么令牌继续在环网中传递。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220515122722.png width=50%>  </p><h3 id="星形"><a href="#星形" class="headerlink" title="星形"></a>星形</h3><p>每一个站点通过两条点对点链路与同一个中央节点连接：一条链路负责发送，一条链路负责接收。中央节点的作用可以是实现广播功能（此时在逻辑上等同于总线形），也可以实现帧交换功能。<br>一种最简单的星形结构的媒体接入控制方式是：在同一个时刻，只有一个站点可以发信。  </p><h3 id="拓扑结构的选择"><a href="#拓扑结构的选择" class="headerlink" title="拓扑结构的选择"></a>拓扑结构的选择</h3><p>通常在选择拓扑结构时，考虑的因素是：  </p><ul><li>性能</li><li>可靠性</li><li>可扩展性</li></ul><h2 id="媒体接入控制"><a href="#媒体接入控制" class="headerlink" title="媒体接入控制"></a>媒体接入控制</h2><p>媒体介入控制(Media Access Control, MAC)规定了如何协调多个发送和接收站点对一个共享传输媒体的占用。所有的局域网和城域网都是由必须共享网络传输带宽的设备集合组成的，所以需要一些对传输媒体接入进行控制的手段，以保证有序、有效地使用带宽。媒体接入控制层的关键参数是控制的位置和控制的方法。<br>对于控制的位置，一般有分布式和集中式两种，集中式网络能够提供优先级，可以上各站点使用相对简单的接入逻辑，并且避免了对等实体之间的合作，但是集中控制点故障会导致整个网络出现故障。分布式则结构复杂，但是可靠性更高。<br>对于控制的方法，有同步控制和异步控制两种，同步控制中，对每条连接都指定了具体的带宽，这样的方式资源利用率不高。局域网和城域网采用异步控制：异步控制可以动态地根据需求分配带宽。具体而言，异步控制分配带宽的方式有三类：循环赛、预约、竞争。  </p><h3 id="循环赛-round-robin"><a href="#循环赛-round-robin" class="headerlink" title="循环赛(round robin)"></a>循环赛(round robin)</h3><p>每个站点轮流拥有发送机会，在轮到某个站点发送时，它可以选择发信或不发信。一旦该站点完成当前一轮的发送，就取消自己的发送资格，然后将权利移交至逻辑序列的下一个站点。<br>循环赛的例子是令牌环网络。  </p><p>循环赛机制在只有少数站点需要发送数据时的效率最低，因为在这种情况下多数站点只是纯粹地传递发送权，站间的循环会造成相当大的额外开销。  </p><h3 id="预约-reservasion"><a href="#预约-reservasion" class="headerlink" title="预约(reservasion)"></a>预约(reservasion)</h3><p>将占用媒体的时间细分成多个时隙，不同的时隙上不同站点发送数据，想要发送数据的站点需要先预约时隙。预约具有高公平性的特点。预约适用于通信量长而持续的情况（称为流通信）：比如话音通信。  </p><h3 id="争用-contention"><a href="#争用-contention" class="headerlink" title="争用(contention)"></a>争用(contention)</h3><p>争用技术没有任何控制机制决定轮到哪个站点发信，而是让所有的站点粗暴地抢用媒体资源。在负荷不大的情况下，争用的效率最高，但是有非常多站点需要发信可能会导致网络崩溃。争用适用于短而零星的情况（称为突发通信），比如交互式终端与主机之间的通信。    </p><h2 id="IEEE-802-局域网体系结构"><a href="#IEEE-802-局域网体系结构" class="headerlink" title="IEEE 802 局域网体系结构"></a>IEEE 802 局域网体系结构</h2><p>IEEE 802系列标准是IEEE 802 LAN/MAN 标准委员会制定的局域网、城域网技术标准。其中最广泛使用的有以太网、令牌环、无线局域网等。这一系列标准中的每一个子标准都由委员会中的一个专门工作组负责。IEEE 802协议致力于研究局域网和城域网的物理层和MAC层中定义的服务和协议，对应OSI网络参考模型的最低两层（即物理层和数据链路层）。<br>下图展示了IEEE 802参考模型：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220515131505.png width=50%>  </p><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层*"></a>物理层*</h3><p>IEEE 802参考模型的物理层结构和功能基本上与OSI规定的物理层没有较大差异。IEEE 802参考模型的物理层功能包括：</p><ul><li>信号的编码/解码</li><li>前同步码（用于使接收方的时钟同步）的生成和去除</li><li>比特传输/接收  </li></ul><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>由于IEEE 802委员会在标准制定时没有形成一个统一的局域网标准，而是被迫制定了几个不同的局域网标准，为了使数据链路层能够更好的适应多种局域网标准，IEEE 802参考模型中，数据链路层被划分为了两部分：逻辑链路控制层和媒体介入控制层。逻辑链路控制层的作用是向上层提供接口(LSAP)，并且进行数据链路层的差错控制和流量控制。与接入到传输媒体有关的内容都放在媒体接入控制层，而逻辑链路控制层则与传输媒体无关。<br>MAC层和LLC层之间相互独立，不管采用何种协议的局域网，对 LLC 子层来说都是透明的。同时，对同一LLC层也可以使用不同的媒体接入控制协议。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220515133635.png width=50%>  </p><h4 id="逻辑链路控制层（LLC）"><a href="#逻辑链路控制层（LLC）" class="headerlink" title="逻辑链路控制层（LLC）"></a>逻辑链路控制层（LLC）</h4><p>逻辑链路控制层（Logical Link Control layer，LLC layer）是数据链路层的两个子层之一，它涉及到物理介质拥塞管理（流拥堵和差错控制）。<br>该子层的两个重要功能是：</p><ul><li>保证在不同网络类型中传输<br>通过在IP包上加了8位的目的地址服务接入点和源地址服务接入点实现。  </li><li>流量控制<br>有一个8或16位的控制字段用于像流控制的辅助功能。   </li></ul><p>逻辑链路控制层提供了两种无连接和一种面向连接的服务：</p><ul><li>方式一<br>无回复的无连接方式/不确认的无连接服务，它允许发送帧时：    <ul><li>给单一的目的地址（点到点协议或单点传输）  </li><li>给相同网络中的多个目的地址（多点传输）  </li><li>给网络中的所有地址（广播传输）<br>不确认的连接服务类似于无连接的数据报，其中不包含任何的流量控制和差错控制机制。<br>多点和广播传输在同一信息需要发送到整个网络的情况下可以减少网络流量。单点传输不能保证接收端收到帧的次序和发送时的次序相同。发送端甚至无法确定接收端是否收到了帧。  </li></ul></li><li>方式二<br>面向连接的操作方式/连接模式服务。在两个要交换数据的用户之间建立逻辑连接。并提供流量控制和差错控制。  </li><li>方式三<br>有回复的无连接方式/确认的无连接服务。它仅限于点到点通信。提供的服务要求确认所发送的数据报，但是是无连接的。  </li></ul><p>现在由于上层的标准化以及另一标准DIX Ethernet V2（与IEEE 802只有很小的差别，但是DIX Ethernet V2参考模型中没有LLC层）在标准竞争中的胜利，LLC层现在已经不常用。  </p><h4 id="媒体接入控制层（MAC）"><a href="#媒体接入控制层（MAC）" class="headerlink" title="媒体接入控制层（MAC）"></a>媒体接入控制层（MAC）</h4><p>MAC层接收来自LLC层的数据，负责执行与媒体接入和输入发送相关的功能。同其它层一样，MAC层利用这一层的协议数据单元（PDU）来实现这些功能，这一层的PDU称为MAC帧。<br>以EthernetV2协议看，MAC帧结构包括了MAC层的控制信息，源点和终端的MAC地址（物理连接点的地址，通常烧录在硬件设备中，无法自主更改）以及2字节的类型，用于表示上层协议的类型，同时MAC帧包含一个用于循环冗余校验的尾部。<br><strong>MAC帧的最小长度为64字节(即512比特)</strong>，最长为1518字节。<br>需要注意，MAC帧前面有一个8字节的前同步码+定界符，它们不属于MAC帧。  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220523145310.png width=50%>  </p><div class="note note-info">            <p>在广域网中，使用点对点连接协议(PPP)来接入ISP（同属于MAC层）。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220516120100.png width=50%><br>PPP协议非常简单，只提供点对点的接入功能。它没有以太网帧所要求的MAC地址，它通过自身的协商过程实现点到点的数据传输。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220516141531.png width=50%><br>将DIX Ethernet V2帧结构封装到PPP帧结构的协议称为PPPoE（PPP over Ethernet）.  </p>          </div>  <h2 id="IEEE-802-3的媒体接入控制方式及其前身"><a href="#IEEE-802-3的媒体接入控制方式及其前身" class="headerlink" title="IEEE 802.3的媒体接入控制方式及其前身"></a>IEEE 802.3的媒体接入控制方式及其前身</h2><p>IEEE 802.3工作组定义了以太网的标准技术，考虑到以太网通信以突发为主的特点，其中的媒体接入控制控制方式类别是竞争。具体而言，称为载波监听多点接入/碰撞检测协议(Carrier Sense Multiple Access with Collsion Detect,CSMA/CD)， 其技术是由最初的ALOHA协议不断改进和衍生得来。<br>其名字中的“碰撞”指的是当多方同时发信时引起的冲突，这种现象在最原始的局域网中非常常见，因此局域网域又被称为“碰撞域”。<br>这些媒体接入控制协议最核心的内容就是规定了如何尽可能避免碰撞或者在发生碰撞时双方的行为。在局域网中，碰撞是必须要解决的问题。  </p><h3 id="ALOHA和分隙ALOHA"><a href="#ALOHA和分隙ALOHA" class="headerlink" title="ALOHA和分隙ALOHA"></a>ALOHA和分隙ALOHA</h3><h4 id="ALOHA协议"><a href="#ALOHA协议" class="headerlink" title="ALOHA协议"></a>ALOHA协议</h4><p>ALOHA协议/纯ALOHA协议（夏威夷用于见面问候的方言）是一种非常简单的媒体接入控制方式：任何一个站都可以在帧生成后立即发送，并通过信号的反馈检测信道以确定发送是否成功。如果发信中遇到了冲突，则发信失败，该帧被丢弃，经随机延时后源点再次发送。<br>随机延时的目的是减小双方发生二次碰撞的概率，这样的手段称为退避(backoff)。<br>ALOHA协议虽然简单，但是冲突数量随着负载的增加而迅速增长，在ALOHA协议下，理论上信道的最大利用率为18.4%。  </p><h4 id="分隙ALOHA协议"><a href="#分隙ALOHA协议" class="headerlink" title="分隙ALOHA协议"></a>分隙ALOHA协议</h4><p>在此基础上，分隙ALOHA将信道时间分成了若干时隙，时隙的长度对应了一帧的传输时间。新帧的产生是随机的，但分隙ALOHA不允许随机发送，凡帧的发送必须在时隙的起点。因此，冲突只发生在时隙的起点，冲突发生时只浪费一个时隙，一旦某个站占用时隙并发送成功，则在该时隙内不会出现冲突。在分隙ALOHA协议下，理论上信道的利用率提高到了36.8%。    </p><h4 id="信道利用率的推导"><a href="#信道利用率的推导" class="headerlink" title="信道利用率的推导*"></a>信道利用率的推导*</h4><p>定义如下参数：  </p><ul><li>帧时$T$：发送一个标准长的帧所需的时间</li><li>吞吐率$S$：在一个帧时T内发送成功的平均帧数（$0&lt;S&lt;1$，$S=1$时信道利用率100%）</li><li>运载负载$G$：一个帧时T内所有通信站总共发送的帧平均值（包括原发和重发帧）（$G≥S$，$G=S$表示无冲突）</li><li>$P_0$：一帧发送成功（未发生冲突）的概率，发送成功的分组在已发送分组的总数中所占的比例；$S = GP_0$   </li></ul><p>对ALOHA协议要想发送帧的时候不会有冲突，那么在发送一帧的时间前后都不能有其他帧发送，这段时间称为冲突危险期，时间长度应当为$2T$.<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220516131136.png width=50%>   </p><p>一个帧时内生成$k$个帧的概率服从泊松分布：$P(k)=\frac{G^ke^{-G}}{k!}$.<br>根据上述推论，对ALOHA协议，$2T$的时间内都没有其它帧生成的概率为：$P_0=P(0)P(0)=e^{-2G}$，带入$S = GP_0$，得到$S=Ge^{-2G}$，其最大值为0.184.<br>对分隙ALOHA协议，冲突危险期应当为$T$，$T$的时间内都没有其它帧生成的概率为：$P_0=P(0)=e^{-G}$，带入$S = GP_0$，得到$S=Ge^{-G}$，其最大值为0.368.<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220516131908.png width=50%>  </p><h3 id="载波监听多点接入"><a href="#载波监听多点接入" class="headerlink" title="载波监听多点接入"></a>载波监听多点接入</h3><p>在载波监听多点接入(CSMA)协议中，想要传输的站点首先监听信道，判断是否有其他站点正在传输。如果信道正在被使用（信道忙），那么该站点必须等待；如果信道空闲，站点可以传输。站点在传输后将在一段时间内等待确认(ACK)，如果没有收到确认，就假定发生了冲突并且重传。<br>根据信道忙时站点的等待机制，可以将CSMA又分为：非持续CSMA、1持续CSMA和$p$持续CSMA。  </p><h4 id="非持续CSMA"><a href="#非持续CSMA" class="headerlink" title="非持续CSMA"></a>非持续CSMA</h4><p>非持续CSMA的策略是：  </p><ul><li>如果信道空闲，则立即发信。  </li><li>如果信道忙，则等待一段时间，该时间长度服从重传时延的概率分布。  </li></ul><p>非持续CSMA的缺点是，传输结束后，信道容易保持空闲，即使有一个或者多个站点等待传输。  </p><h4 id="1持续CSMA"><a href="#1持续CSMA" class="headerlink" title="1持续CSMA"></a>1持续CSMA</h4><p>1持续CSMA避免了信道空闲的时间，其策略是：  </p><ul><li>如果信道空闲，则立即发信。  </li><li>如果信道忙，则等待直到信道空闲。  </li></ul><p>在这种机制下，传输结束后的碰撞概率会随着等待的站点数目的增大而增大。  </p><h4 id="p-持续CSMA"><a href="#p-持续CSMA" class="headerlink" title="$p$持续CSMA"></a>$p$持续CSMA</h4><p>$p$持续CSMA既避免了信道的空闲时间，又更大程度地避免了碰撞。$p$持续CSMA的策略是：  </p><ul><li>如果信道空闲，那么站点有概率$p$发信，或者以$1-p$的概率等待一单位时间。  </li><li>如果信道忙，那么站点等待直到信道空闲。  </li><li>如果站点已经等待了一个单位时间，那么站点有概率$p$发信，或者以$1-p$的概率等待一单位时间。  </li></ul><p>在这种机制下，$p$值的选取至关重要，在一单位时间后，期望发信的站点数目可以表示为：  </p><script type="math/tex; mode=display">E(n)=np</script><p>已知$0≤p≤1$，当$E(n)≤1$时，信道中不会出现碰撞。因此，$p$如果足够小，$E(n)≥2$的概率就越小，发生碰撞的概率就越小，但是每个站点的等待时间就会更长。随着站点数$n$的增大，$p$应当动态地减小。<br>$p$持续CSMA看起来是三种方案中最完美的，但是如果采用静态设置的$p$，$p$的值要设置的非常小以避免不稳定性，在$n$非常小的情况下，会带来严重的等待时延；动态设置的$p$下，新加入的站点需要知道$p$的改变，复杂的机制有悖于设置局域网的初衷。  </p><h4 id="CSMA机制的选择"><a href="#CSMA机制的选择" class="headerlink" title="CSMA机制的选择"></a>CSMA机制的选择</h4><p>考虑到复杂程度和稳定性，在使用非持续CSMA的情况下，一个传输结束后，信道会保持空闲，浪费了信道容量。在使用$p$持续CSMA下，无论是动态设置还是静态设置的$p$都会有性能问题。1持续CSMA冲突的时间不长，并且由于其随机时长的退避机制，大幅度减少了二次碰撞的概率。因此在IEEE802.3标准中采用的是1持续CSMA。  </p><h3 id="载波监听多点接入-碰撞检测"><a href="#载波监听多点接入-碰撞检测" class="headerlink" title="载波监听多点接入/碰撞检测"></a>载波监听多点接入/碰撞检测</h3><p>载波监听多点接入/碰撞检测协议(Carrier Sense Multiple Access with Collsion Detect,CSMA/CD)综合了上述几种载波监听多点接入协议的优点，其具体策略是：  </p><ul><li>如果信道空闲，站点立即发信。  </li><li>如果信道忙，则等待直到信道空闲。  </li><li>如果站点检测到碰撞，在传输过程中，站点会主动发出一个干扰信号（称为积极干扰信号，jamming signal；在基带总线中，这个信号是一个高电平信号）来让整个网络中的所有站点知道碰撞的发生，之后停止传输。  <div class="note note-info">            <p>任意一个站点在检测到干扰信号后都会发出干扰信号，使得整个网络可以快速地知晓碰撞。  </p>          </div>  <ul><li>发送完干扰信号后，随机地等待一段时间（退避），以避免二次碰撞，之后再尝试发信。  </li></ul></li></ul><p>CSMA/CD大幅度的减少了碰撞概率，但这不意味着采用CSMA/CD的信道就完全没有碰撞。由于信号在传输线上的传输时延$τ$($τ$的参考值：<strong>电磁波在1km电缆上的传播时延大约为5μs</strong>)，传输线上的站点可能依然认为信道是空闲的。<br>由于局域网上任意两个站点之间的传播时延有长有短，局域网按照最坏情况设计，即取总线两端的两个站点之间的传播时延为端到端的传播时延。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220517164059.png width=80%>  </p><p>从上图可以看出，<strong>在站点发送帧后至多$2τ$（即$δ→0$）时间就可以知道所发送的数据帧是否遭受到碰撞。</strong><br>这段时间称为争用期，可以发现，<strong>在站点发送完数据后，在争用期时间还没有检测到碰撞，那么这次发送一定不会产生碰撞。</strong><br>具体而言，<strong>以太网协议规定的具体的征用时间为$2τ=51.2μs$。</strong><br>对于10Mbit/s的以太网，争用期内可以发送512bit。争用期的单位也可以用bit·s，称为比特时间表示，因此上述争用期时间也可以说为512比特时间，即争用期是发送512bit所需要的时间。  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220517174238.png width=80%>  </p><p>从上图发现：<strong>在这种情况下，只有当帧长度大于$2L=r_b×2τ$</strong>（在上文的例子中应当为512bit）<strong>时，源站点和终端之间的任何一个站点才不可能在源站点和终端之间通信时认为信道空闲。</strong><br>因此，以太网的帧结构最小长度为64字节，即512比特。  </p><h3 id="二进制截止退避"><a href="#二进制截止退避" class="headerlink" title="二进制截止退避"></a>二进制截止退避</h3><p>以太网使用二进制截止退避算法(truncated binary exponential backoff)来确定碰撞后重传的时期。具体的退避算法规定：  </p><ul><li>基本退避时间为争用期$2τ=51.2μs$。  </li><li>从离散的整数集合$[0,1,2,…,2^k-1]$中随机选取一个数$r$，重传后的退避时间则为：  <script type="math/tex; mode=display">r×2τ</script></li><li>集合中的$k$在重传次数不超过10时为重传次数；当重传次数大于10时，$k=10$.  </li><li>当重传次数达到16次仍然不成功时，则丢弃该帧，并向上层报告。  </li></ul><h2 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h2><p>整个局域网中发生碰撞的概率随着站点数量的增加迅速上升。网桥是一种能够将碰撞域划分为两个子碰撞域的器件。各碰撞域中的碰撞概率相对独立，但是各碰撞域之间可以相互通信。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220524163250.png width=50%>  </p><p>换而言之，网桥可以在保证两个局域网相对独立的情况下，支持两个局域网之间的相互通信。<br>数据帧通过网桥时，网桥不会将收到的帧在分装为一个新的帧，也不会改变帧的结构和帧的内容。网桥只是单纯地根据帧头部的信息决定是否在比特层级上复制这个帧，然后转发复制后的帧。对于站点而言，网桥的工作是透传的。  </p><h3 id="地址学习"><a href="#地址学习" class="headerlink" title="地址学习"></a>地址学习</h3><p>网桥需要判断某个帧是否需要通过网桥：如果帧的源地址和目的地址位于同侧，则网桥不需要将其复制到另一侧的局域网中；如果如果帧的源地址和目的地址位于异侧，则网桥需要将其复制到另一侧的局域网中。交换表的作用是为网桥提供判断源地址和目的地址是否同侧的依据，简单来说：交换表中只记录分为异侧的源地址和目的地地址，网桥会根据交换表上的信息进行转发。交换表可以预先烧录在网桥设备中，由于局域网中站点设备“来去自由”的特性，其交换表需要动态改变，因此网桥需要有自适应地址学习的功能。<br>简单来说，可以分为如下几种情况：  </p><ul><li>当某个帧的头部中的源地址不位于交换表中，目的地址位于交换表中且位于异侧，表明发送侧局域网中有新的站点加入。此时网桥会将数据帧转发到对应的目的地址，并记录下源地址。  </li><li>当某个帧的源地址位于交换表中，目的地址部存在于交换表中，目的地址是否在与发送侧不同的一侧的情况未知。此时网桥会向另一侧的局域网广播该数据帧，如果有站点接收，表明目的地址位于异侧，网桥将这次交换记录到交换表；如果没有站点接收，表明目的地址位于发送侧，网桥不会记录下这次交换。  </li></ul><p>为了让网桥有适应拓扑变化的能力，会为每一个学习到的地址设置老化时间，一般为5分钟。超过老化时间的地址会被移除交换表。  </p><h3 id="静态路由和生成树"><a href="#静态路由和生成树" class="headerlink" title="静态路由和生成树"></a>静态路由和生成树</h3><p>网桥需要具备路由选择的能力，当网桥收到一个帧时，它必须决定是否转发这个帧，在多个局域网连接的情况下，还需要决定该帧转发到哪个网络。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220525134459.png width=40%><br>最简单和最常用的路由方式是之前提到过的静态路由选择。在静态路由中，网络中每个结点内部的路由表由根据某个算法生成，结点根据生成的路由表定式地转发帧。只有当整个网络的拓扑结构发生改变时，结点中的静态路由表才会改变。<br>同时，网桥需要解决的一个问题是环路的问题。<br>当网络中存在多个网桥的情况下，可能会引起网桥环路，环路会导致一个数据在两个网桥之间无限循环的来回传输，从而影响整个网络的性能。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220525134615.png width=40%>  </p><p>生成树算法是一种解决环路问题的拓扑结构生成算法，按照生成树算法，整个网络的拓扑结构最终会以一个无任何冗余连接的树形结构。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220525140451.png width=40%>  </p><p>最小生成树是在生成树算法的基础上，给每个网桥端口赋一个代价值。如果没有任何特殊考虑的话，每个端口的代价都相等，这就会产生最小跳数的生成树。算法包括在所有网桥之间进行简单的消息交换，以寻找到最小代价生成树。一旦拓扑出现变化，网桥会自动重新计算生成树。<br>生成树算法需要各结点之间的信息合作，因此应用生成树算法的协议称为生成树协议（STP，spanning tree protocol）。  </p><h3 id="网桥和交换机"><a href="#网桥和交换机" class="headerlink" title="网桥和交换机"></a>网桥和交换机</h3><p>使用多个网桥将多个局域网连接在一起时，<strong>多个网桥的集合可以看做是一个交换机</strong>（或者称为2层交换机，因为其只涉及到物理层和MAC层）。因此，可以说网桥是交换机的前身。<br>交换机工作时，实际上允许许多组端口间的通道同时工作。所以，交换机的功能体现出不仅仅是一个网桥的功能，而是多个网桥功能的集合。即网桥一般分有两个端口，而交换机具有高密度的端口。<br>由于交换机能够支持多个端口，因此可以把网络系统划分成为更多的物理网段，这样使得整个网络系统具有更高的带宽。而网桥仅仅支持两个端口，所以，网桥划分的物理网段是相当有限的。<br>在数据帧转发的方式上，网桥和交换机有所区别：网桥在发送数据帧前，通常要接收到完整的数据帧并执行帧检测序列FCS后，才开始转发该数据帧。交换机具有存储转发和直接转发两种帧转发方式。直接转发方式在发送数据以前，不需要在接收完整个数据帧和经过32bit循环冗余校验码CRC的计算检查后的等待时间。  </p><h4 id="局域网定义的变化"><a href="#局域网定义的变化" class="headerlink" title="局域网定义的变化"></a>局域网定义的变化</h4><p>通过交换机，可以将整个碰撞域划分为更小更多的子碰撞域以进一步减小碰撞概率。极端情况下，可以使用交换机将每一个站点分割为单独的子碰撞域，即每个子碰撞域下只存在一个站点，从而真正避免了碰撞的发生。事实上，如今的网络中每一个站点都有类似的功能，其物理承载设备是网卡。在此基础上研究只有一个站点的局域网并没有太大意义，因此局域网的定义不再是单纯的一个碰撞域，而是<strong>将由一个交换机和其连接全部站点组成的网络</strong>称为局域网。  </p><div class="note note-info">            <p>在这样的环境下，媒体接入控制在只有单个站点构成的局域网中也没有太大的意义，但是上文中提到的许多媒体接入控制方式在无线通信领域仍然适用。比如基站与移动台之间的空中接口就会用到分隙ALOHA协议。  </p>          </div>  <h2 id="局域网之间的通信"><a href="#局域网之间的通信" class="headerlink" title="局域网之间的通信"></a>局域网之间的通信</h2><p>如图所示的两个局域网通过网桥进行连接：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220525162338.png width=50%>  </p><p>在发送方，用户数据传递到LLC层之后在LLC层封装后加入对应的LLC头部，然后送入MAC层。<br>MAC层收到来自LLC层的DPU后加入包含MAC层控制信息、发送方MAC地址（源MAC地址）和接收方MAC地址（目的MAC地址）的头部以及加入含有校验信息的尾部后组装为MAC帧，然后将该帧送入物理层。<br>在物理层，MAC帧以比特的形式发送到交换机/网桥。<br>该帧的比特流被交换机/网桥的物理层接收。<br>在交换机/网桥的MAC层，MAC帧的头部被检查，交换机/网桥按照MAC帧头部的地址和交换机内部缓存的路由表在物理层以比特流的形式将MAC帧转发到对应的接收站点，如果可能，交换机/网桥会启用地址学习功能动态更新路由表。<br>在接收站点的物理层这个帧的比特流被接收。随后交给MAC层，MAC层去掉其头部和尾部后交付给LLC层，LLC层去掉其头部后将用户数据交付给用户。  </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>通信和计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信工程</tag>
      
      <tag>通信网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微信小程序开发入门</title>
    <link href="/2022/05/08/YF408%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    <url>/2022/05/08/YF408%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="微信小程序开发入门"><a href="#微信小程序开发入门" class="headerlink" title="微信小程序开发入门"></a>微信小程序开发入门</h1><div class="note note-info">            <p>本文是逸夫408实验室本科生同学的入门培训资料，受委托发表至本网站。如果有任何错误信息，欢迎反馈至：794358907@qq.com。  </p>          </div>  <div class="note note-warning">            <p>随教程的程序demo：<a href="/files/小程序demo.zip">关于微信小程序与后台数据交互的demo.zip</a></p>          </div>  <p>本次demo的所有代码将采用文件形式发送，大家可以直接将文件放到IDE中。其难度相对而言较大，建议在有一定python和微信小程序开发基础后，仔细阅读并理解。  </p><h2 id="前期准备工作"><a href="#前期准备工作" class="headerlink" title="前期准备工作"></a>前期准备工作</h2><h3 id="小程序部分"><a href="#小程序部分" class="headerlink" title="小程序部分"></a>小程序部分</h3><p>为了避免申请配置域名的麻烦以及等待的时间，进入微信开发者工具后，选择申请测试号（右上角）：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220508220605.png width=80%>   </p><p>进入如下网页后，点击申请地址：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220508220616.png width=80%>  </p><p>然后请记住你的appid和appsecret：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220508220717.png width=80%>  </p><p>同时，在详情——本地设置中，点击勾选不校验合法域名，web-view（业务域名），TLS版本以及HTTPS证书：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220508220727.png width=80%></p><h3 id="Python（数据库）部分"><a href="#Python（数据库）部分" class="headerlink" title="Python（数据库）部分"></a>Python（数据库）部分</h3><p>首先需要安装MySQL，用来进行对数据库的操作，官网网址：<a href="https://dev.mysql.com/downloads/windows/installer/">https://dev.mysql.com/downloads/windows/installer/</a><br>安装教程：<a href="https://www.runoob.com/w3cnote/windows10-mysql-installer.html">https://www.runoob.com/w3cnote/windows10-mysql-installer.html</a><br>注意，千万要记住你安装时配置的数据库密码，这在后面操作中十分关键！<br>还有一个可视化的数据库操作软件Navicat，官网地址<a href="http://www.navicat.com.cn/">http://www.navicat.com.cn/</a><br>，进去选择产品——免费试用，试用期限14天，到期后卸载了重新下一遍就行了（老白嫖玩家了）。其界面如下：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220508220823.png width=80%>  </p><p>关于python，python版本建议选择3.9。在第三方库的安装中，有几个必要的库：pip，Flask，PyMySQL，PyMysqlDB，SQLAlchemy，crypto，mysql，mysql-connector，  mysql-connector-python，mysqlclient，request，requests，wxPython（注意看清楚自己吧库安装的地方是是虚拟环境还是自己本机的环境，下图显示的是安装在本机环境中）<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220508220931.png width=80%>   </p><p>如果在file-setting中无法安装，可以试试在命令行中使用pip安装。命令<code>pip install XXXX</code>。以上所有库如果有始终无法安装成功的情况，可以来找学长咨询。其中crypto库的安装有一点问题需要注意，按照网址<a href="https://www.cnblogs.com/fawaikuangtu123/p/9761943.html中所说的去操作。">https://www.cnblogs.com/fawaikuangtu123/p/9761943.html中所说的去操作。</a>  </p><h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>Python代码文件main.py中，db_name语句中需要在root后输入你的数据库密码：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220508221026.png width=80%><br>解释：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220508221113.png width=80%><br>①：MySQL用户名<br>②：MySQL密码<br>③：MySQL 端口号（默认3306）<br>④：在MySQl中创建的一个数据库名<br>其中localhost意思是本机的IP地址<br>代码整体应用示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#db_name=&#x27;mysql+mysqlconnector://xiaoshi:jc16636683CJ@Localhost:3306/cyst1&#x27;</span><br>engine = create_engine(db_name)<span class="hljs-comment">#创立线程池</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">示例:</span><br><span class="hljs-string">engine = create_engine(&#x27;dialect+driver://username:password@host:port/database&#x27;)</span><br><span class="hljs-string">dialect --数据库类型</span><br><span class="hljs-string">driver --数据库驱动选择</span><br><span class="hljs-string">username --数据库用户名</span><br><span class="hljs-string">password --用户密码host服务器地址</span><br><span class="hljs-string">port --端口</span><br><span class="hljs-string">database --数据库</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure></p><h4 id="补充：创建一个数据库"><a href="#补充：创建一个数据库" class="headerlink" title="补充：创建一个数据库"></a>补充：创建一个数据库</h4><p>方法一：打开可视化软件Navicat，右键连接的mysql（本例中名为xiaoshi）,点击新建数据库<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220508221336.png width=50%><br>方法二：打开MySQL客户端，直接输入创建数据库指令，<code>create database name;</code><br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">mysql&gt; <span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> xiaoshi;<br>&gt;&gt; Query Ok. <span class="hljs-number">1</span> <span class="hljs-keyword">row</span> affected (<span class="hljs-number">0.01</span> sec)<br></code></pre></td></tr></table></figure></p><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>还需要将你的appid和appsecret写入下面划线的单引号里面：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220508221423.png width=80%>  </p><p>以上配置好了python中的控制程序，之后调整前端的设置和代码。  </p><h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>小程序代码中的IP地址记得改成本机地址127.0.0.1（位于app.js中）。  </p><p>解释：地址“127.0.0.1”是回送地址，在任何时候都是指向本机地址（一般用于测试）<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220508221525.png width=80%>  </p><p>微信小程序前端部分大致分为两个页面，编译后首先进入首页：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220508221624.png width=50%>  </p><p>点击登录按钮后，程序会读取你的用户信息，根据以下规则，与数据库进行交互后会将你的微信头像和昵称显示于页面上：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220508221632.png width=50%>  </p><p>而点击跳转页面，将会进入：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220508221639.png width=50%>  </p><p>在点击图中按钮，选择QQ聊天文件（随便加的）之后，小程序将给传入后台一个密码（变量名“<code>nishisha</code>”，值“<code>hehe</code>”），服务器端接收到此变量，将会从数据库传送部分数据给小程序：  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220508221649.png width=50%>   </p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>这里特地提一下python文件中的AES文件，它的主要作用是加密数据，以防有人拿到部分用户数据后推测出其他的数据。这里演示一个简单的使用方式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">aes=AES.UseAES(<span class="hljs-string">&quot;zifuchuan&quot;</span>)<br>q=aes.encrypt(<span class="hljs-string">&quot;呵呵&quot;</span>)<br>print(q)<br>a=aesdecode_bytes(q)<br>print(a)<br></code></pre></td></tr></table></figure></p><p>在进行了加密-打印-解密-打印的操作后，它的结果为：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span> EPU0DIzAJEsfC0OvcLgnkA==<br><span class="hljs-meta">&gt;&gt;</span> 呵呵<br></code></pre></td></tr></table></figure></p><p>可参考的学习资料：<br>高级加密标准（AES）是最为常见的对称加密算法，微信小程序使用的就是这个加密算法。<br>对称加密算法是指加密和解密使用相同的密钥。<br><a href="https://blog.csdn.net/qq_28205153/article/details/55798628">https://blog.csdn.net/qq_28205153/article/details/55798628</a>  </p><h2 id="python代码解读"><a href="#python代码解读" class="headerlink" title="python代码解读"></a>python代码解读</h2><h3 id="sqlalchemy库"><a href="#sqlalchemy库" class="headerlink" title="sqlalchemy库"></a>sqlalchemy库</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> create_engine,String, Integer, Column, ForignKey, Table, Sequence, Text, func<br><span class="hljs-keyword">from</span> sqlalchemy.ect.declarative <span class="hljs-keyword">import</span> declarative_base<br><span class="hljs-keyword">from</span> sqlalchemy.orm <span class="hljs-keyword">import</span> sessionmaker, relationship<br></code></pre></td></tr></table></figure><p>sqlalchemy是一个python语言实现的的针对关系型数据库的orm库。可用于连接大多数常见的数据库，比如Postges、MySQL、SQLite、Oracle等。<br>通过orm将编程语言的对象模型和数据库的关系模型建立映射关系，这样我们在使用编程语言对数据库进行操作的时候可以直接使用编程语言的对象模型进行操作就可以了，而不用直接使用sql语言。  </p><p>适合学习下的链接：<a href="img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220508221859.png width=50%">python 之路，Day11 - sqlalchemy ORM - 金角大王 - 博客园 (cnblogs.com)</a>  </p><h3 id="json库"><a href="#json库" class="headerlink" title="json库"></a>json库</h3><p>使用 Python 语言来编码和解码 JSON 对象<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220508221859.png width=50%>  </p><h3 id="requests库"><a href="#requests库" class="headerlink" title="requests库"></a>requests库</h3><p>requests库是一个常用的用于http请求的模块，可以方便的对网页进行爬取。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220508221817.png width=50%>  </p><p>使用例子：<a href="https://zhuanlan.zhihu.com/p/137649301">python中requests库使用方法详解 - 知乎 (zhihu.com)</a>  </p><h3 id="flask库"><a href="#flask库" class="headerlink" title="flask库"></a>flask库</h3><p>Flask是一个用Python编写的Web应用程序框架。<br>（Web应用框架是一种开发框架，支持动态网站、网络应用程序及网络服务的开发）  </p>]]></content>
    
    
    <categories>
      
      <category>YF408实验室培训资料</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python学习路线</title>
    <link href="/2022/05/07/YF408%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/Python%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    <url>/2022/05/07/YF408%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/Python%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="Python学习路线"><a href="#Python学习路线" class="headerlink" title="Python学习路线"></a>Python学习路线</h1><div class="note note-info">            <p>本文是逸夫408实验室本科生同学的入门培训资料，受委托发表至本网站。如果有任何错误信息，欢迎反馈至：794358907@qq.com。  </p>          </div>  <div class="row">    <embed src="/files/Python学习路线.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>YF408实验室培训资料</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端方向</title>
    <link href="/2022/05/07/YF408%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E5%89%8D%E7%AB%AF%E6%96%B9%E5%90%91/"/>
    <url>/2022/05/07/YF408%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E5%89%8D%E7%AB%AF%E6%96%B9%E5%90%91/</url>
    
    <content type="html"><![CDATA[<h1 id="前端方向"><a href="#前端方向" class="headerlink" title="前端方向"></a>前端方向</h1><div class="note note-info">            <p>本文是逸夫408实验室本科生同学的入门培训资料，受委托发表至本网站。如果有任何错误信息，欢迎反馈至：794358907@qq.com。  </p>          </div>  <h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>大家好，这一部分内容写给选择前端方向的同学。我们对大家每一部分内容的学习有基本的要求，但这也是大家达到看懂demo、进行简单编写的需要的掌握的基本知识点。如果大家想要进一步学习，做出更加完美的页面、更加完善的功能，那么希望大家进行深入学习这些功能。望大家充分利用好官方提供的文档以及其他所有可以学习到的途径。  </p><h2 id="二、微信小程序"><a href="#二、微信小程序" class="headerlink" title="二、微信小程序"></a>二、微信小程序</h2><p>微信小程序的学习包括基础学习与设计实践，其中基本学习包括WXML、WXSS、WXS的基本功能，在学习demo和设计实践的过程中会将这些知识结合在一起，了解他们之间的互动。学习完基础内容后，开始学习前后端组合的一个demo，这是包含了前端、后端与数据库的简化的一个案例。<br>我们在下面给大家推荐了一个视频课程，和一些有关前端开发的文章和技术文档。此外我们会给大家描述所需要的最基本学习内容和学习步骤。大家可以以此来检测自己是否掌握完全。  </p><p>小程序的视频教程：<br><a href="https://www.bilibili.com/video/BV1WQ4y1T7D8?from=search&amp;seid=8840839384230125738&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1WQ4y1T7D8?from=search&amp;seid=8840839384230125738&amp;spm_id_from=333.337.0.0</a>  </p><p>参考文档：<br>1）认识微信小程序：<a href="https://www.ruanyifeng.com/blog/2020/10/wechat-miniprogram-tutorial-part-one.html">https://www.ruanyifeng.com/blog/2020/10/wechat-miniprogram-tutorial-part-one.html</a><br>2）CSS flex布局语法：<br><a href="https://www.runoob.com/w3cnote/flex-grammar.html">https://www.runoob.com/w3cnote/flex-grammar.html</a><br>3）微信小程序官方文档：<br><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/">https://developers.weixin.qq.com/miniprogram/dev/framework/</a><br>4）图标库：<br><a href="https://www.iconfont.cn/">https://www.iconfont.cn/</a>  </p><p>在大家学习完之后，我们需要看看自己是否以及完全掌握：<br>第一步：学会使用微信开发者工具，知道项目目录下每一个文件的作用；<br>第二步：学会基本的组件：<code>&lt;view&gt;、&lt;image&gt;、&lt;text&gt;、&lt;navigator&gt;</code>、表单组件（<code>&lt;form&gt;、&lt;button&gt;、&lt;input&gt;</code>），学习基本的css样式的配置；能够绘制出一个基本的页面，了解文字，图片如何放在想要的位置；<br>第三步，函数和api ，理解刷新函数setData<br>第四步：小项目demo：（demo我们会单独发一个套学习资料给大家。）<br>以上的基础要求是不完全的，我们希望大家预先了解基本的知识，这样在看demo的时候就不会那么地困难。<br>在拥有以上基础之后，我们就可以开始看实验室祖传demo了。大家在实际操作中会遇到很多奇奇怪怪的问题，但是没关系，遇到问题学会搜索，主动找学长学姐问问题。还有，什么问题都可以问的哦。<br>看demo时候的要求和注意：  </p><ul><li>把小项目运行起来  </li><li>看懂前端部分（小程序的）每一句代码，知道这些代码的意义  </li><li>大家看一下已有的注释，发现注释错误即反馈给学长（包括错别字哦，因为这是以后还要使用的）  </li></ul><p>扩展：希望大家学习http协议相关的知识。（不强求大家学习，仅希望大家了解一下）<br><a href="https://www.bilibili.com/video/BV1KV411o7u5?spm_id_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV1KV411o7u5?spm_id_from=333.337.search-card.all.click</a>  </p><h2 id="三、结语"><a href="#三、结语" class="headerlink" title="三、结语"></a>三、结语</h2><p>不管在哪个阶段的学习，希望大家积极的探索自己喜欢的东西，用自己学到的知识去实践、去创造。遇到任何问题都可以来询问学长学姐。  </p>]]></content>
    
    
    <categories>
      
      <category>YF408实验室培训资料</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>后端方向</title>
    <link href="/2022/05/07/YF408%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E5%90%8E%E7%AB%AF%E6%96%B9%E5%90%91/"/>
    <url>/2022/05/07/YF408%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/%E5%90%8E%E7%AB%AF%E6%96%B9%E5%90%91/</url>
    
    <content type="html"><![CDATA[<h1 id="后端方向"><a href="#后端方向" class="headerlink" title="后端方向"></a>后端方向</h1><div class="note note-info">            <p>本文是逸夫408实验室本科生同学的入门培训资料，受委托发表至本网站。如果有任何错误信息，欢迎反馈至：794358907@qq.com。  </p>          </div>  <h2 id="一、-前言"><a href="#一、-前言" class="headerlink" title="一、    前言"></a>一、    前言</h2><p>大家好，这一部分内容写给选择后端方向的同学。我们对大家每一部分内容的学习有基本的要求，但这也是大家达到看懂demo、进行简单编写的需要的掌握的基本知识点。如果大家想要进一步学习，写出更加高效的程序，那么希望大家进行深入学习这些功能。望大家充分利用好官方提供的文档以及其他所有可以学习到的途径。  </p><h2 id="二、-数据库"><a href="#二、-数据库" class="headerlink" title="二、    数据库"></a>二、    数据库</h2><p>大家先学习基本的数据库操作，再此基础上学习如何用Python操作数据库。<br>实验室的项目基本使用的是MySQL数据库操作系统。我们在后端程序中使用Python的SQLalchemy框架来操作数据库，但是我们还是希望大家也一下有关数据库的基本知识和理论。这样有助于大家对数据库甚至是整个项目开发过程的理解。<br>这里对数据的基本要求是了解什么是数据库、表，怎么用终端命令行去操作数据库（基本的查找、曾、删、改、查），什么是约束。<br>以下给大家提供了B站视频，大家只需要学习P1-P15这15个视频即可学习完基本需求。我们还会附赠学长亲手整理的命令集。  </p><p>视频资料：<br><a href="https://www.bilibili.com/video/BV1Vt411z7wy?p=1">https://www.bilibili.com/video/BV1Vt411z7wy?p=1</a>      </p><p>使用数据库可是化工具（navicat）：<br><a href="https://www.bilibili.com/video/BV1H44y1W7F9?spm_id_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV1H44y1W7F9?spm_id_from=333.337.search-card.all.click</a>  </p><p>（说明：我们只要求大家基本了解即可，如果有想深入学习的同学可以看《MySQL必知必会》和王珊老师的《数据库系统概论》）  </p><h3 id="三、Python使用到的框架"><a href="#三、Python使用到的框架" class="headerlink" title="三、Python使用到的框架"></a>三、Python使用到的框架</h3><p>Python包括和SQLalchemy框架（操作数据库）、Flask框架（实现网络请求）。下面我们为大家提供了学习的视频和实践时候的参考文档。大家在掌握简单的基础之后就去看demo，遇到不懂得直接搜索或者询问学长学姐。在大家学习完Python之后，就可以将这两个框架当作你学习的拓展库。大家可能开始学习的时候会有些生涩，这就需要大家在后来的项目联系的时候与自己写前端的组员慢慢磨合。  </p><h4 id="一）SQLalchemy"><a href="#一）SQLalchemy" class="headerlink" title="一）SQLalchemy"></a>一）SQLalchemy</h4><p>对于这个框架，我们可以把它理解成用Python操作数据库的工具。数据库我们使用的是MySQL数据库，在后端程序中，我们可以将这个理解成用Python语言代替了原来MySQL的命令。</p><p>参考文档：<br>（1）初步使用：<a href="https://www.cnblogs.com/sddai/p/13730604.html">https://www.cnblogs.com/sddai/p/13730604.html</a><br>（2）基本操作：<a href="https://blog.csdn.net/qq_43713303/article/details/106766700">https://blog.csdn.net/qq_43713303/article/details/106766700</a><br>（3）官方文档：<a href="https://docs.sqlalchemy.org/en/14/">https://docs.sqlalchemy.org/en/14/</a>  </p><p>基本要求：<br>1、    如何创建数据库积累并与自己的数据库系统建立连接；<br>2、    如何用<code>class</code>创建表；<br>3、    如何创建会话；<br>（以上三条知识应该背下来）<br>4、    学习基本的数据操作：增、删、改、查<br>5、    过滤<code>filter()</code>方法。  </p><p>（说明：大家可以把参考文档（2）当作学习和字典来用。想深入理解这个框架的同学可以阅读参考文档（3），这是sqlalchemy的官方文档，英文编写。）  </p><h4 id="二）Flask"><a href="#二）Flask" class="headerlink" title="二）Flask"></a>二）Flask</h4><p>视频资料：<br><a href="https://www.bilibili.com/video/BV1pb4y1m78N?p=2">https://www.bilibili.com/video/BV1pb4y1m78N?p=2</a>  </p><p>参考文档：<br><a href="https://flask.palletsprojects.com/en/2.0.x/quickstart/#a-minimal-application">https://flask.palletsprojects.com/en/2.0.x/quickstart/#a-minimal-application</a>  </p><p>（说明：在这一部分大家可以跟着视频中的方法，用web进行操作。而使用小程序中的wx.request()函数和使用浏览器URL搜索是一样的道理）  </p><p>以上提供了B站的视频学习资料，大家只需要学习P1-P11这11个视频，即可在项目中运用Flask。大家需要掌握如何成功地从前端发送请求，之后又怎么从后端给前端返回数据。参考文档是英文版的，这里就需要在大家想要提升自己对flask的理解的时候去慢慢阅读了。  </p><h3 id="四、demo：（demo我们会单独发一个套学习资料给大家。）"><a href="#四、demo：（demo我们会单独发一个套学习资料给大家。）" class="headerlink" title="四、demo：（demo我们会单独发一个套学习资料给大家。）"></a>四、demo：（demo我们会单独发一个套学习资料给大家。）</h3><p>以上的基础要求是不完全的，我们希望大家预先了解基本的知识，这样在看demo的时候就不会那么地困难。<br>在拥有以上基础之后，我们就可以开始看实验室祖传demo了。大家在实际操作中会遇到很多奇奇怪怪的问题，但是没关系，遇到问题学会搜索，主动找学长学姐问问题。还有，什么问题都可以问的哦。<br>看demo时候的要求和注意：<br>    把小项目运行起来<br>    看懂后端部分（小程序的）每一句代码，知道这些代码的意义<br>    大家看一下已有的注释，发现注释错误即反馈给学长（包括错别字哦，因为这是以后还要使用的）</p><h3 id="五、拓展"><a href="#五、拓展" class="headerlink" title="五、拓展"></a>五、拓展</h3><p>扩展：希望大家学习http协议相关的知识。（不强求大家学习，仅希望大家了解一下）<br><a href="https://www.bilibili.com/video/BV1KV411o7u5?spm_id_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV1KV411o7u5?spm_id_from=333.337.search-card.all.click</a><br>扩展：域名，ssl证书和https（这个很重要哦）<br>认识HTTPS：<a href="https://www.bilibili.com/video/BV1KY411x7Jp?spm_id_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV1KY411x7Jp?spm_id_from=333.337.search-card.all.click</a><br>如何申请ssl证书：<br><a href="https://help.aliyun.com/document_detail/156645.html">https://help.aliyun.com/document_detail/156645.html</a><br>如何申请域名：<br><a href="https://help.aliyun.com/document_detail/29716.html">https://help.aliyun.com/document_detail/29716.html</a><br>Flask配置ssl证书：<br><a href="https://blog.csdn.net/qq_41427568/article/details/101025193">https://blog.csdn.net/qq_41427568/article/details/101025193</a>  </p><h3 id="六、结语"><a href="#六、结语" class="headerlink" title="六、结语"></a>六、结语</h3><p>不管在哪个阶段的学习，希望大家积极的探索自己喜欢的东西，用自己学到的知识去实践、去创造。遇到任何问题都可以来询问学长学姐(qq:794358907)。  </p>]]></content>
    
    
    <categories>
      
      <category>YF408实验室培训资料</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Lecture 9 微带天线</title>
    <link href="/2022/05/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%A9%E7%BA%BF%E4%B8%8E%E9%80%9A%E4%BF%A1%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86/9.%20%E5%BE%AE%E5%B8%A6%E5%A4%A9%E7%BA%BF/"/>
    <url>/2022/05/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%A9%E7%BA%BF%E4%B8%8E%E9%80%9A%E4%BF%A1%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86/9.%20%E5%BE%AE%E5%B8%A6%E5%A4%A9%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="Lecture-9-微带天线"><a href="#Lecture-9-微带天线" class="headerlink" title="Lecture 9 微带天线"></a>Lecture 9 微带天线</h1><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/E534E9ACB4AC10CA6C0164F0FF949289.png width=100%></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>天线与通信传输原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>15. 离散系统的状态空间的表示和补偿器设计</title>
    <link href="/2022/04/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/15.%20%E7%A6%BB%E6%95%A3%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4/"/>
    <url>/2022/04/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/15.%20%E7%A6%BB%E6%95%A3%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="离散系统的状态空间的表示和补偿器设计"><a href="#离散系统的状态空间的表示和补偿器设计" class="headerlink" title="离散系统的状态空间的表示和补偿器设计"></a>离散系统的状态空间的表示和补偿器设计</h1><h2 id="离散系统的状态空间表示"><a href="#离散系统的状态空间表示" class="headerlink" title="离散系统的状态空间表示"></a>离散系统的状态空间表示</h2><p>像连续系统的状态空间，对于线性时不变的离散系统，也可以取一组系统的状态变量，使得在已知$k$时刻的系统状态和系统输入的情况下，可以知道$k+1$时刻的系统状态有：  </p><script type="math/tex; mode=display">x(k+1)=G\vec{x}(k)+Hu(k)</script><p>上述方程称为离散系统的状态方程。$G$称为状态矩阵，$H$称为输入矩阵。<br>此时系统的输出$y$可以表示为:  </p><script type="math/tex; mode=display">y(k)=C\vec{x}(k)+Du(k)</script><p>上述方程称为离散系统的输出方程。$C$称为输出矩阵，$D$称为直接传输矩阵(direct transmission matrix)。<br>同理可以得到系统的特征方程为：  </p><script type="math/tex; mode=display">|zI-G|=0</script><h3 id="状态空间的表达形式"><a href="#状态空间的表达形式" class="headerlink" title="状态空间的表达形式"></a>状态空间的表达形式</h3><p>对于描述系统的差分方程：  </p><script type="math/tex; mode=display">y(k)+a_1y(k-1)+a_2y(k-2)+...+a_ny(k-n)=b_0u(k)+b_1u(k)+...+b_nu(k-n)</script><h4 id="能控标准型"><a href="#能控标准型" class="headerlink" title="能控标准型"></a>能控标准型</h4><p>如果系统的传递函数以如下形式表达：  </p><script type="math/tex; mode=display">\frac{Y(z)}{U(z)}=\frac{b_0+b_1z^{-1}+...+b_nz^{-n}}{1+a_1z^{-1}+...+a_nz^{-n}}</script><p>那么系统的状态空间表示可以写作如下两种：  </p><ul><li><p>其一</p><script type="math/tex; mode=display">\begin{bmatrix}    x_1(k+1)\\x_2(k+1)\\...\\x_{n-1}(k+1)\\x_n(k+1)\end{bmatrix}=\begin{bmatrix}    0 & 1 & 0 & ... & 0\\    0 & 0 & 1 & ... & 0\\    ⋮ & ⋮ & ⋮ & ⋮ & ⋮ \\    0 & 0 & 0 & ... & 1\\    -a_n & -a_{n-1} &-a_{n-2} & \dots & -a_1\end{bmatrix}\begin{bmatrix}    x_1(k)\\x_2(k)\\...\\x_{n-1}(k)\\x_n(k)\end{bmatrix}+\begin{bmatrix}    0 \\ 0 \\ ⋮ \\ 0 \\ 1\end{bmatrix}u(k)</script><script type="math/tex; mode=display">y(k)=\begin{bmatrix}    b_n-a_nb_0 &  b_{n-1}-a_{n-1}b_0  & ... & b_1-a_1b_0\end{bmatrix}\begin{bmatrix}    x_1(k)\\x_2(k)\\...\\x_{n-1}(k)\\x_n(k)\end{bmatrix}+b_0u(k)</script></li><li><p>其二</p><script type="math/tex; mode=display">\begin{bmatrix}    x_1(k+1)\\x_2(k+1)\\...\\x_{n-1}(k+1)\\x_n(k+1)\end{bmatrix}=\begin{bmatrix}-a_1 & -a_2 &-a_3 & ...  & -a_{n-1}& -a_n\\    1 & 0 & 0 & ... & 0 & 0\\    0 & 1 & 0 & ... & 0 & 0\\    ⋮ & ⋮ & ⋮ & ⋮ & ⋮ & ⋮\\    0 & 0 & 0 & ...& 1 & 0\end{bmatrix}\begin{bmatrix}    x_1(k)\\x_2(k)\\...\\x_{n-1}(k)\\x_n(k)\end{bmatrix}+\begin{bmatrix}    1 \\ 0 \\ ⋮ \\ 0 \\ 0\end{bmatrix}u(k)</script><script type="math/tex; mode=display">y(k)=\begin{bmatrix}    b_1-a_1b_0 &  b_2-a_2b_0  & ... & b_n-a_nb_0\end{bmatrix}\begin{bmatrix}    x_1(k)\\x_2(k)\\...\\x_{n-1}(k)\\x_n(k)\end{bmatrix}+b_0u(k)</script></li></ul><p>上述两种形式都称为能控标准型，注意其一和其二中对于状态变量的选取的顺序是不同的。  </p><h4 id="能观标准型"><a href="#能观标准型" class="headerlink" title="能观标准型"></a>能观标准型</h4><p>如果系统的传递函数以如下形式表达：  </p><script type="math/tex; mode=display">\frac{Y(z)}{U(z)}=\frac{b_0+b_1z^{-1}+...+b_nz^{-n}}{1+a_1z^{-1}+...+a_nz^{-n}}</script><p>那么系统的状态空间表示可以写作如下两种：  </p><ul><li><p>其一  </p><script type="math/tex; mode=display">\begin{bmatrix}    x_1(k+1)\\x_2(k+1)\\...\\x_{n-1}(k+1)\\x_n(k+1)\end{bmatrix}=\begin{bmatrix}    0 & 0 & ... & 0 & 0 & -a_n\\    1 & 0 & ... & 0 & 0 & -a_{n-1}\\     ⋮ & ⋮ & ⋮ & ⋮ & ⋮ & ⋮\\     0 & 0 &  ...& 1 & 0 & -a_2\\    0 & 0 &  ...& 0 & 1 & -a_1\end{bmatrix}\begin{bmatrix}    x_1(k)\\x_2(k)\\...\\x_{n-1}(k)\\x_n(k)\end{bmatrix}+\begin{bmatrix}    b_n-a_nb_0 \\ b_{n-1}-a_{n-1}b_0 \\ ⋮ \\ b_2-a_2b_0 \\ b_1-a_1b_0\end{bmatrix}u(k)</script><script type="math/tex; mode=display">y(k)=\begin{bmatrix}    0 & 0 & ... & 0 & 1\end{bmatrix}\begin{bmatrix}    x_1(k)\\x_2(k)\\...\\x_{n-1}(k)\\x_n(k)\end{bmatrix}+b_0u(k)</script></li><li><p>其二  </p><script type="math/tex; mode=display">\begin{bmatrix}    x_1(k+1)\\x_2(k+1)\\...\\x_{n-1}(k+1)\\x_n(k+1)\end{bmatrix}=\begin{bmatrix}    -a_1 & 1 & 0 & ... & 0 & 0 \\    -a_2 & 0 & 1 & ... & 0 & 0 \\     ⋮ & ⋮ & ⋮ & ⋮ & ⋮ & ⋮\\     -a_{n-1} &0 & 0 &  ...& 0 & 1\\    -a_n&0 & 0 &  ...& 0 & 0 \end{bmatrix}\begin{bmatrix}    x_1(k)\\x_2(k)\\...\\x_{n-1}(k)\\x_n(k)\end{bmatrix}+\begin{bmatrix}    b_1-a_1b_0 \\ b_2-a_2b_0 \\ ⋮ \\ b_{n-1}-a_{n-1}b_0 \\ b_n-a_nb_0\end{bmatrix}u(k)</script><script type="math/tex; mode=display">y(k)=\begin{bmatrix}    1 & 0 & ... & 0 & 0\end{bmatrix}\begin{bmatrix}    x_1(k)\\x_2(k)\\...\\x_{n-1}(k)\\x_n(k)\end{bmatrix}+b_0u(k)</script></li></ul><p>上述两种形式都称为能观标准型，注意其一和其二中对于状态变量的选取的顺序是不同的。  </p><h4 id="对角型和约旦标准型"><a href="#对角型和约旦标准型" class="headerlink" title="对角型和约旦标准型"></a>对角型和约旦标准型</h4><p>如果系统的传递函数以如下形式表达：  </p><script type="math/tex; mode=display">\frac{Y(z)}{U(z)}=∑\frac{c_i}{z-p_i}</script><p>那么传递函数的极点可以作为状态矩阵的特征值，有：  </p><script type="math/tex; mode=display">\begin{bmatrix}      x_1(k+1)\\x_2(k+1)\\...\\x_{n-1}(k+1)\\x_n(k+1)  \end{bmatrix}=\begin{bmatrix}      p_1 & 0 & ... & 0\\      0 & p_2 & ... & 0 \\      ⋮ & ⋮ & & ⋮ \\      0 & 0 & ... & p_n  \end{bmatrix}\begin{bmatrix}      x_1(k)\\x_2(k)\\...\\x_{n-1}(k)\\x_n(k)  \end{bmatrix}+\begin{bmatrix}      1 \\ 1 \\ ⋮ \\1  \end{bmatrix}u(k)</script><script type="math/tex; mode=display">y(k)=\begin{bmatrix}    c_1 & c_2 & ... & c_n\end{bmatrix}\begin{bmatrix}      x_1(k)\\x_2(k)\\...\\x_{n-1}(k)\\x_n(k)  \end{bmatrix}+b_0u(k)</script><p>如果存在重极点，那么此时的表达为约旦标准型，如果$p_1$为重极点，有：  </p><script type="math/tex; mode=display">\begin{bmatrix}      x_1(k+1)\\x_2(k+1)\\...\\x_{n-1}(k+1)\\x_n(k+1)  \end{bmatrix}=\begin{bmatrix}      p_1 & 0 & ... & 0\\      0 & p_1 & ... & 0 \\      ⋮ & ⋮ & & ⋮ \\      0 & 0 & ... & p_n  \end{bmatrix}\begin{bmatrix}      x_1(k)\\x_2(k)\\...\\x_{n-1}(k)\\x_n(k)  \end{bmatrix}+\begin{bmatrix}      0 \\ 0 \\ ⋮ \\1  \end{bmatrix}u(k)</script><script type="math/tex; mode=display">y(k)=\begin{bmatrix}    c_1 & c_2 & ... & c_n\end{bmatrix}\begin{bmatrix}      x_1(k)\\x_2(k)\\...\\x_{n-1}(k)\\x_n(k)  \end{bmatrix}+b_0u(k)</script><h3 id="状态空间表示与系统框图"><a href="#状态空间表示与系统框图" class="headerlink" title="状态空间表示与系统框图"></a>状态空间表示与系统框图</h3><p>简单来说，根据系统框图推出系统状态空间表示的方法是：<br>将系统每一个延迟单元的输出设为一个状态变量$x_i(k)$，则延迟单元前的状态为$x_i(k+1)$。系统的每一个延迟单元可以写出一个系统的状态方程。<br>根据系统的输出和各状态之间的关系，可以系统的状态方程。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220611212448.png width=70%>  </p><h4 id="系统框图与能控标准型"><a href="#系统框图与能控标准型" class="headerlink" title="系统框图与能控标准型"></a>系统框图与能控标准型</h4><p>系统框图的级联形式对应系统的能控标准型，简单来说：<br>对于$\frac{Y(z)}{U(z)}=\frac{b_0+b_1z^{-1}+…+b_nz^{-n}}{1+a_1z^{-1}+…+a_nz^{-n}}$，有：  </p><script type="math/tex; mode=display">\frac{Y(z)}{U(z)}=\frac{Y(z)}{H(z)}\frac{H(z)}{U(z)}</script><p>那么：$\frac{H(z)}{U(z)}=\frac{1}{1+a_1z^{-1}+…+a_nz^{-n}}$，$\frac{Y(z)}{H(z)}=b_0+b_1z^{-1}+…+b_nz^{-n}$。对$\frac{H(z)}{U(z)}$，有：  </p><script type="math/tex; mode=display">H(z)(1+a_1z^{-1}+...+a_nz^{-n})=U(z)</script><script type="math/tex; mode=display">H(z)=U(z)-(a_1z^{-1}+...+a_nz^{-n})H(z)</script><p>根据上述式子，$\frac{H(z)}{U(z)}$的信号框图可以作出，例如$H(z)=U(z)-(a_1z^{-1}+a_2z^{-2})H(z)$<br>的框图如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220618121826.png width=40%>  </p><p>对$\frac{Y(z)}{H(z)}$，有：  </p><script type="math/tex; mode=display">Y(z)=(b_0+b_1z^{-1}+...+b_nz^{-n})H(z)</script><p>根据上述式子，$\frac{Y(z)}{H(z)}$的信号框图可以作出，例如$Y(z)=(b_0+b_1z^{-1}+b_2z^{-2})H(z)$的系统框图为：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220618122929.png width=40%><br>将两部分合并，可以得到：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220618123059.png width=50%>  </p><p>对每一个延迟器前后设置一个状态变量$x_i(k+1)$：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220618123935.png width=50%>  </p><div class="note note-info">            <p>$x_1(k+1)$和$x_2(k+1)$的位置是可以调换的，因此能控标准型有两种写法。  </p>          </div><p>对$x_1(k+1)$，可以得到：  </p><script type="math/tex; mode=display">x_1(k+1)=-a_1x_1(k)-a_2x_2(k)+u(k)</script><p>对$x_2(k+1)$，可以得到： </p><script type="math/tex; mode=display">x_2(k+1)=x_1(k)</script><p>对输出$y(k)$可以得到：</p><script type="math/tex; mode=display">y(k)=(b_1-b_0a_1)x_1(k)+(b_2-b_0a_2)x_2(k)+b_0u(k)</script><p>根据上述三个式子可以写出系统的能控标准型：  </p><script type="math/tex; mode=display">\begin{bmatrix}x_1(k+1)\\x_2(k+1)\end{bmatrix}=\begin{bmatrix}-a_1&-a_2\\1&0\end{bmatrix}\begin{bmatrix}x_1(k)\\x_2(k)\end{bmatrix}+\begin{bmatrix}1\\0\end{bmatrix}u(k)</script><script type="math/tex; mode=display">y(k)=\begin{bmatrix}b_1-b_0a_1&b_2-b_0a_2\end{bmatrix}\begin{bmatrix}x_1(k)\\x_2(k)\end{bmatrix}+b_0u(k)</script><h4 id="能观标准性与系统框图"><a href="#能观标准性与系统框图" class="headerlink" title="能观标准性与系统框图"></a>能观标准性与系统框图</h4><p>对于$\frac{Y(z)}{U(z)}=\frac{b_0+b_1z^{-1}+…+b_nz^{-n}}{1+a_1z^{-1}+…+a_nz^{-n}}$，有：  </p><script type="math/tex; mode=display">Y(z)(1+a_1z^{-1}+...+a_nz^{-n})=U(z)(b_0+b_1z^{-1}+...+b_nz^{-n})</script><script type="math/tex; mode=display">Y(z)=U(z)(b_0+b_1z^{-1}+...+b_nz^{-n})-Y(z)(a_1z^{-1}+...+a_nz^{-n})</script><p>接下来，不断地提取$z^{-1}$项。比如对于$Y(z)=U(z)(b_0+b_1z^{-1}+b_2z^{-2})-Y(z)(a_1z^{-1}+a_2z^{-2})$，有：  </p><script type="math/tex; mode=display">\begin{aligned}     Y(z)=&U(z)b_0+z^{-1}[b_1U(z)+b_2z^{-1}U(z)-Y(z)a_1-Y(z)a_2z^{-1}]\\     =&U(z)b_0+z^{-1}[b_1U(z)-Y(z)a_1+z^{-1}(b_2U(z)-Y(z)a_2)]\end{aligned}</script><p>接下来，从最内部的$b_2U(z)-Y(z)a_2$开始构建系统，直到用框图搭建完整个系统为止，整个系统的框图如下方所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220618132242.png width=50%>  </p><p>对每一个延迟器前后设置一个状态变量$x_i(k+1)$：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220618133709.png width=50%>   </p><div class="note note-info">            <p>$x_1(k+1)$和$x_2(k+1)$的位置是可以调换的，因此能观标准型有两种写法。  </p>          </div><p>有：  </p><script type="math/tex; mode=display">x_1(k+1)=-a_1x_2(k)+(b_2-a_1b_0)u(k)</script><script type="math/tex; mode=display">x_2(k+1)=x_1(k)-a_2x_2(k)(b_1-a_2b_0)u(k)</script><script type="math/tex; mode=display">y(k)=x_2(k)+b_0u(k)</script><p>综合以上三式，有：  </p><script type="math/tex; mode=display">\begin{bmatrix}x_1(k+1)\\x_2(k+1)\end{bmatrix}=\begin{bmatrix}0&-a_1\\1&-a_2\end{bmatrix}\begin{bmatrix}x_1(k)\\x_2(k)\end{bmatrix}+\begin{bmatrix}b_2-a_1b_0\\b_1-a_2b_0\end{bmatrix}u(k)</script><script type="math/tex; mode=display">y(k)=\begin{bmatrix}0&1\end{bmatrix}\begin{bmatrix}x_1(k)\\x_2(k)\end{bmatrix}+b_0u(k)</script><h3 id="连续系统状态空间表示的离散化"><a href="#连续系统状态空间表示的离散化" class="headerlink" title="连续系统状态空间表示的离散化"></a>连续系统状态空间表示的离散化</h3><p>对于连续系统：$\begin{cases}\vec{\dot{x}}=A\vec{x}+Bu \\ y(t)=C\vec{x}+Du\end{cases}$，根据<br>映射律$z=e^{sT}$，有:  </p><script type="math/tex; mode=display">G=e^{AT}=\mathcal{L}^{-1}((sI-A)^{-1})</script><script type="math/tex; mode=display">H=(\int_0^Te^{Aλ}dλ)B=(G-I)A^{-1}B</script><p>即可得到离散化后的系统状态空间表示：  </p><script type="math/tex; mode=display">x(k+1)=Gx(k)+Hu(k)</script><script type="math/tex; mode=display">y(k)=Cx(k)+Du(k)</script><p>需要注意的是，$G$和$H$会随着采样周期$T$的变化而变化。  </p><h2 id="离散系统的能控性和能观性"><a href="#离散系统的能控性和能观性" class="headerlink" title="离散系统的能控性和能观性"></a>离散系统的能控性和能观性</h2><h3 id="能控性判定"><a href="#能控性判定" class="headerlink" title="能控性判定"></a>能控性判定</h3><p>根据系统能控性的定义，如果系统的控制信号与系统的状态变量独立，则系统是能控的。换言之，对于任意$n$，倘若$G^{n-1}$都与$H$独立，则系统是能控的。<br>定义离散系统的能控性矩阵：  </p><script type="math/tex; mode=display">[H|GH|…|G^{n-1}H]</script><p>即能控性矩阵满秩，即$|[H|GH|…|G^{n-1}H]|≠0$，则系统是能控的。  </p><h3 id="能观性判定"><a href="#能观性判定" class="headerlink" title="能观性判定"></a>能观性判定</h3><p>根据系统能观性的定义，如果系统任何状态转换都会影响每一个输出变量，那么系统是能观的。<br>定义离散系统的能观性矩阵：  </p><script type="math/tex; mode=display">\begin{bmatrix}    C\\ - \\ CG \\ - \\ ... \\ - \\ CG^{n-1}\end{bmatrix}</script><p>如果离散系统的能观性矩阵满秩，即$|\begin{bmatrix}<br>    C\\ - \\ CG \\ - \\ … \\ - \\ CG^{n-1}<br>\end{bmatrix}|≠0$，则系统是能观的。    </p><h2 id="反馈控制器"><a href="#反馈控制器" class="headerlink" title="反馈控制器"></a>反馈控制器</h2><h3 id="反馈控制系统的特征方程"><a href="#反馈控制系统的特征方程" class="headerlink" title="反馈控制系统的特征方程"></a>反馈控制系统的特征方程</h3><p>对于系统$\begin{cases} \vec{x}(k+1)=A\vec{x}(k)+Bu(k)\\ y(k)=C\vec{x}(k) \end{cases}$:<br>添加一个负反馈控制器$K$:<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220611213137.png width=80%>  </p><p>根据上图，有系统的状态方程：  </p><script type="math/tex; mode=display">x(k+1)=Ax(k)+Bu(k)</script><p>带入$u(k)=-kx(k)+v(k)$，有：  </p><script type="math/tex; mode=display">x(k+1)=(A-BK)x(k)+Bv(k)</script><p>其中，</p><script type="math/tex; mode=display">|zI-(A-BK)|=0</script><p>是系统的特征方程。  </p><h3 id="反馈控制器设计步骤"><a href="#反馈控制器设计步骤" class="headerlink" title="反馈控制器设计步骤"></a>反馈控制器设计步骤</h3><ul><li>检验系统原型的能控性矩阵。  </li><li>根据系统的设计要求，找到阻尼比$ζ$和固有频率$ω_n$，并构造出系统的特征多项式。  </li><li>设计系统的反馈控制器，并且根据$|zI-(A-BK)|$找到系统含有$k_i$的特征多项式。  </li><li>通过两种方法得出的特征多项式进行系数匹配，得到$K$。  </li></ul><h2 id="观测器设计"><a href="#观测器设计" class="headerlink" title="观测器设计"></a>观测器设计</h2><p>对于系统$\begin{cases} \vec{x}(k+1)=A\vec{x}(k)+Bu(k)\\ y(k)=C\vec{x}(k) \end{cases}$:<br>增加一个观测器：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220502180408.png width=50%><br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220611215158.png width=50%>  </p><h3 id="观测器的功能"><a href="#观测器的功能" class="headerlink" title="观测器的功能"></a>观测器的功能</h3><p>系统在下一个时刻的状态估计量为$\vec{\hat{x}}(k+1)$，它可以通过观测器得到：  </p><script type="math/tex; mode=display">\vec{\hat{x}}(k+1)=A\vec{\hat{x}}+Bu(k)+L[y(k)-C\vec{\hat{x}}(k)]</script><p>设系统的观测状态误差为观测器估计的系统下一时刻状态的观测值和系统下一时刻状态的实际值之差：  </p><script type="math/tex; mode=display">\vec{x_e}(k+1)=\vec{x}(k+1)-\vec{\hat{x}}(k+1)</script><p>结合$\vec{x}(k+1)=A\vec{x}(k)+Bu(k)$，有：  </p><script type="math/tex; mode=display">\vec{x_e}(k+1)=A\vec{x_e}(k)-L[y(k)-C\vec{\hat{x}}(k)]</script><p>根据$y(k)=C\vec{x}(k)$，有$\hat{y}(k)=C\vec{\hat{x}}(k)$，那么：  </p><script type="math/tex; mode=display">\vec{x_e}(k+1)=A\vec{x_e}(k)-L[y(k)-\hat{y}(k)]</script><p>可以发现，<strong>通过调整观测器系数$L$，可以使得下一次系统的状态误差随着本次系统的输出误差的减少而减少</strong>。<br>同时，带入$y(k)=C\vec{x}(k)$，可以发现系统状态误差的转移：</p><script type="math/tex; mode=display">\vec{x_e}(k+1)=A\vec{x_e}(k)-LC[\vec{x}(k)-\vec{\hat{x}}(k)]</script><p>即：  </p><script type="math/tex; mode=display">\vec{x_e}(k+1)=(A-LC)\vec{x_e}(k)</script><p>那么系统状态误差的状态转移矩阵为：  </p><script type="math/tex; mode=display">A-LC</script><p>系统的特征方程为：  </p><script type="math/tex; mode=display">|zI-(A-LC)|=0</script><h3 id="观测器设计步骤"><a href="#观测器设计步骤" class="headerlink" title="观测器设计步骤"></a>观测器设计步骤</h3><ul><li>检验系统原型的能观性矩阵。  </li><li>根据系统的设计要求，找到阻尼比$ζ$和固有频率$ω_n$，并构造出系统的特征多项式。  </li><li>设计系统的反馈控制器，并且根据$|zI-(A-LC)|$找到系统含有$l_i$的特征多项式。  </li><li>通过两种方法得出的特征多项式进行系数匹配，得到$K$。  </li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>控制系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2.金属线传输理论</title>
    <link href="/2022/04/24/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BC%A0%E8%BE%93%E7%BA%BF/%E9%87%91%E5%B1%9E%E4%BC%A0%E8%BE%93%E7%BA%BF%E7%90%86%E8%AE%BA/"/>
    <url>/2022/04/24/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BC%A0%E8%BE%93%E7%BA%BF/%E9%87%91%E5%B1%9E%E4%BC%A0%E8%BE%93%E7%BA%BF%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="金属线传输理论"><a href="#金属线传输理论" class="headerlink" title="金属线传输理论"></a>金属线传输理论</h1><p>传输线可以分为两大类：金属传输线和介质传输线（光纤），金属传输线中以电信号作为信息载体，本课将分析电信号在金属传输线中传输时的性质。  </p><h2 id="正弦行波的传输情况"><a href="#正弦行波的传输情况" class="headerlink" title="正弦行波的传输情况"></a>正弦行波的传输情况</h2><h3 id="无衰减的传输情况"><a href="#无衰减的传输情况" class="headerlink" title="无衰减的传输情况"></a>无衰减的传输情况</h3><p>金属传输线中通常采用若干相互叠加的正弦信号作为信息载体。<br>首先分析单个正弦波在理想金属线中的传播情况:在源点发出的一个正弦电信号可以用电压或者电流来表示：<br><div class="note note-info">            <p>理想金属线指：(1)无穷长的传输距离，意味着波无法到达接收端，即不会有反射波。 (2)传输线的各种物理性质是均匀的，各参考点之间没有区别。理想的平行双线中，两条线的间距始终保持不变。  </p>          </div></p><script type="math/tex; mode=display">v=Vsinωt</script><p>根据波理论和振动理论，源点所携带的电磁波的振动信息会向前传给传输线上的每一个“点”（类比质点，指传输线上距离非常小的一段），由于传播时延，振动信息虽然相同，但是传输线上每一个点的起振时间不同，从而相比于源点的振动，传输线上其他点的振动有相移，不难知道这个相移与传输线上该点的位置$z$有关。那么，传输线上某点的振动方程可以用电压表示为：  </p><script type="math/tex; mode=display">v=Vsin(ωt-βz)</script><p>其中$β$称为相移常数(phase change coefficient)，国际标准单位为rad/m.<br>通过对波形的观察可以发现，$z=nλ,n∈z^*$位置上的点其电压的变化总是与源点相同，其相移正好为$2π$，那么有：  </p><script type="math/tex; mode=display">βλ=2π</script><p>即，  </p><script type="math/tex; mode=display">β=\frac{2π}{λ}</script><p>从上式可以看出，$β$的物理意义是单位长度中存在完整波形的个数，因此$β$又称为波数(wave number)。  </p><h3 id="相速度和相速度"><a href="#相速度和相速度" class="headerlink" title="相速度和相速度"></a>相速度和相速度</h3><p>单一波形的振动信息沿着传输线传播的速度称为相速度(phase velocity)，记为$v_p$。根据定义，在波上取两个相位相同$(ωt_1-βz_1=ωt_2-βz_2)$的点，它们正好空间上间隔一个波长$λ$：  </p><script type="math/tex; mode=display">v_p=\frac{z_2-z_1}{t_2-t_1}=\frac{λ}{T}=\frac{ω}{β}(km/s)</script><p>相速度的物理意义是相位信息传播的速度。<br>根据带宽理论，传输波形是由若干个正弦波叠加形成的包络波形，这个包络波形的相速度称为群速度(group velocity)，记为$v_g$。<br>群速度表达式的推导如下：假设有两个波，其之间各种波的特性相差较小，假定其中一个波的角速度为$ω+dω$、波数为$β+dβ$，另一个波的角速度为$ω-dω$、波数为$β-dβ$，它们的幅值$A_m$相同:  </p><script type="math/tex; mode=display">Φ_1(t,z)=A_mcos[(ω+dω)t-(β+dβ)z]</script><script type="math/tex; mode=display">Φ_2(t,z)=A_mcos[(ω-dω)t-(β-dβ)z]</script><p>合成波为：  </p><script type="math/tex; mode=display">Φ=Φ_1(t,z)+Φ_2(t,z)=2A_mcos(tdω-zdβ)cos(ωt-βz)</script><p>根据群速度的定义，在合成波形上取相位相同的两点：  </p><script type="math/tex; mode=display">v_g=\frac{z_2-z_1}{t_2-t_1}=\frac{dz}{dt}=\frac{dω}{dβ}</script><p>群速度的倒数$|\frac{dβ}{dω}|$称为群时延(group delay)。  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220426142755.png width=50%></p><h3 id="有衰减的传输情况"><a href="#有衰减的传输情况" class="headerlink" title="有衰减的传输情况"></a>有衰减的传输情况</h3><p>在金属传输线中，传输的衰减关于传输线距离指数增长，记这个增长率为$α$，称为衰减参数(attenuation coefficient)，其国际标准单位为Np/m.那么有：  </p><script type="math/tex; mode=display">v=Ve^{-αz}sin(ωt-βz)</script><p>可以发现，<strong>$α$只会影响传播过程的幅度，而$β$只会影响传播过程的相位。</strong><br>根据复向量的定义，复数的虚部只会影响复数的相位角，实部影响复数的模长。那么将这个方程向量化，则有：  </p><script type="math/tex; mode=display">\mathbf{V_z}=\mathbf{V_0}e^{-αz}e^{-jβz}=\mathbf{V_0}e^{-(α+jβ)z}</script><p>定义$γ=α+jβ$，称其为传播常数(propergation constant)，整理得到：  </p><script type="math/tex; mode=display">\mathbf{V_z}=\mathbf{V_0}e^{-γz}</script><p>同理，传输线上任意一点的电流可以表示为：  </p><script type="math/tex; mode=display">\mathbf{I_z}=\mathbf{I_0}e^{-γz}</script><h2 id="平行双线传输线理论"><a href="#平行双线传输线理论" class="headerlink" title="平行双线传输线理论"></a>平行双线传输线理论</h2><p>在金属传输线中，最容易对其传输特性进行分析的是平行双线传输线(twin-wire transmission line)。  </p><h3 id="平行双线传输线效应"><a href="#平行双线传输线效应" class="headerlink" title="平行双线传输线效应"></a>平行双线传输线效应</h3><h4 id="集肤效应-趋肤效应"><a href="#集肤效应-趋肤效应" class="headerlink" title="集肤效应/趋肤效应"></a>集肤效应/趋肤效应</h4><p>传输线中，随着电信号频率的上升，导体内部的电荷更倾向于从导体中心向导体表面移动，因此导体表面的电荷量上升，内部的电荷量下降，导致导体的有效导电面积下降，导体的电阻随着电信号频率的上升而升高——这样的现象称为集肤效应/趋肤效应（skin effect）。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220425131011.png width=30%>  </p><p>因此，利用金属传输线传输高频信号时，传输距离主要受到趋肤效应带来的能量耗散限制。<br>在实际应用中，话音信号300Hz-3.4kHz的传输距离在5km以内。  </p><h4 id="分布参数效应"><a href="#分布参数效应" class="headerlink" title="分布参数效应"></a>分布参数效应</h4><p>信号通过传输线时，导线周围会产生高频磁场，因此沿线各点会串联分布电感$L$;又因为电导率有限的导线流过电流时会有集肤效应和热耗，表现为导线有串联分布的电阻$R$;两导线间加上电压时，线间会存在高频电场，于是线间会产生并联分布电容$C$;导线间介质非理想绝缘时存在泄漏电流，意味着导线之间有分布导纳$G$，这就是所谓的分布参数效应。于是在研究电信号在传输线中的传输性质时，一段平行双导线可以看作是若干个串联的电阻和电感、以及若干个并联的导纳和电容，利用电路分析理论方法来分析。<br><div class="note note-info">            <p>当传输线的几何长度$L$比其上所传输的电磁波的最小波长$λ_{min}$还长，即$L≥\frac{λ_{min}}{100}$时称传输线为长线，否则为短线。<br>当传输线可以视为短线时，可以将这一段传输线的参数分布看做是单位的电路器件连接。  </p>          </div></p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220425125750.png width=50%></p><div class="note note-info">            <p>传输线分析方法有两种：利用电路分析理论方法分析和利用电磁场理论方法分析。前者需要假定各种理想情况并且设置各种条件，但是容易计算，非常便捷有效，仅适用于高频电信号和微波的低频段；后者计算复杂，但是得出结论更为精确。  </p>          </div><h3 id="电报方程"><a href="#电报方程" class="headerlink" title="电报方程"></a>电报方程</h3><p>那么，在平行双线传输线上一段非常小的距离$dz$上的电压和电流情况如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220425131814.png width=50%> </p><p>定义传输线的源点连接了一个角频率为ω的正弦信号源，此时传输线上$t$时刻在位置$z$处的电压和电流的瞬时值为$v(z,t)=Re(\mathbf{V})=Re(V(z)e^{jωt})$，$i(z,t)=Re(\mathbf{I})=Re(I(z)e^{jωt})$，在位置$z+dz$处的输出电压和电流分别为$v(z+dz,t)$、$i(z+dz,t)$，通过基尔霍夫电压定律和基尔霍夫电流定律即可得到如下关系：   </p><script type="math/tex; mode=display">\begin{cases}    -\frac{∂v(z,t)}{∂z}=Ri(z,t)+L\frac{∂i(z,t)}{∂t}\\    -\frac{∂i(z,t)}{∂z}=Gv(z,t)+C\frac{∂v(z,t)}{∂z}\\\end{cases}</script><p>该式子称为均匀传输线方程/电报方程(telegraph equation)。<br>在某一确定的时刻下，该式子可以改写为：  </p><script type="math/tex; mode=display">\begin{cases}    \frac{d}{dz}\mathbf{V}=-(R+jωL)\mathbf{I_z}\\    \frac{d}{dz}\mathbf{I}=-(G+jωC)\mathbf{V_z}\\\end{cases}</script><div class="note note-info">            <p>具体的推理过程：<a href="https://l61012345.top/2021/04/22/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%A9%E7%BA%BF%E4%B8%8E%E9%80%9A%E4%BF%A1%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86/2.%20%E4%BC%A0%E8%BE%93%E7%BA%BF%E6%A8%A1%E5%9E%8B/">Lecture 2 传输模型</a>  </p>          </div>  <h4 id="特征阻抗"><a href="#特征阻抗" class="headerlink" title="特征阻抗"></a>特征阻抗</h4><p>由$\frac{d}{dz}\mathbf{V}=-γ\mathbf{V_z}$，有：  </p><script type="math/tex; mode=display">γ\mathbf{V_z}=(R+jωL)\mathbf{I_z}</script><script type="math/tex; mode=display">γ\mathbf{I_z}=-(G+jωC)\mathbf{V_z}</script><p>两式子相比，得到：  </p><script type="math/tex; mode=display">Z_0=\frac{\mathbf{V_z}}{\mathbf{I_z}}=\sqrt{\frac{R+jωL}{G+jωC}}</script><p>$Z_0$表示该均匀传输线上任意一点的阻抗，称为该传输线的特征阻抗(characteristic impedance)。  </p><h4 id="传播常数"><a href="#传播常数" class="headerlink" title="传播常数"></a>传播常数</h4><p>两式相乘，得到：  </p><script type="math/tex; mode=display">γ^2\mathbf{V_z}\mathbf{I_z}=(R+jωL)(G+jωC)</script><p>即：  </p><script type="math/tex; mode=display">γ=\sqrt{(R+jωL)(G+jωC)}</script><h4 id="理想金属线传播"><a href="#理想金属线传播" class="headerlink" title="理想金属线传播"></a>理想金属线传播</h4><p>在理想金属线中，能量在传输线上不会有热耗，$R=0,G=0$，此时传输线的特征阻抗为：  </p><script type="math/tex; mode=display">Z_0=\sqrt{\frac{L}{C}}</script><p>有两种情况也可以将传播情况视为理想情况：</p><ul><li>在高频传输中，$ωL&gt;&gt;R,ωC&gt;&gt;G$，此时也可以看做是低损耗的。  </li><li>当$\frac{R}{L}=\frac{G}{C}$时，也可以得到$Z_0=\sqrt{\frac{L}{C}}$，也可以看做是理想传输。  </li></ul><p>此时的传播常数为：  </p><script type="math/tex; mode=display">γ=jω\sqrt{LC}</script><h4 id="高频金属线传播"><a href="#高频金属线传播" class="headerlink" title="高频金属线传播"></a>高频金属线传播</h4><p>对于高频信号：$ωL&gt;&gt;R,ωC&gt;&gt;G$，有：  </p><script type="math/tex; mode=display">Z_0=\sqrt{\frac{L}{C}}</script><script type="math/tex; mode=display">γ=\frac{1}{2}(G\sqrt{\frac{L}{C}}+R\frac{C}{L})+jω\sqrt{LC}</script><h2 id="传输损耗现象"><a href="#传输损耗现象" class="headerlink" title="传输损耗现象"></a>传输损耗现象</h2><h3 id="色散"><a href="#色散" class="headerlink" title="色散"></a>色散</h3><p>理想条件下，一组正弦信号的群速度$v_g=\frac{dω}{dβ}$应当是频率无关的。如果群速度与信号频率相关，由不同频率正弦信号组成的矩形脉冲信号在传输过程中其初始相速度不同导致合成波形在传输过程中随着时间逐渐散开，称为色散(dispersion)。  </p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h4 id="双向脉冲信号的传播"><a href="#双向脉冲信号的传播" class="headerlink" title="双向脉冲信号的传播"></a>双向脉冲信号的传播</h4><p>在理想传输线中，两个矩形脉冲在传输线上相遇，如果两个矩形脉冲的幅度同向，则相遇时电压相加，电流相减；如果两个矩形脉冲的幅度反向，则相遇时电压相减，电流相加。  </p><figure><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220428194418.png width=45%>  <img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220429125438.png width=40%>  </figure><h4 id="脉冲的反射"><a href="#脉冲的反射" class="headerlink" title="脉冲的反射"></a>脉冲的反射</h4><p>上述理论也可以应用在正弦波信号中：假设双线收端短路，那么脉冲能量无法在传输线收端被吸收，此时脉冲电压变为零，电流流经短路区后流动方向与之前相反，将流经段短路区后的电流视为反射电流，这样的反射现象是反向反射(reflection with inversion)。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220429132256.png width=50%><br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220506105541.png width=50%>  </p><p>假设双线收端断路，那么脉冲能量也无法在传输线收端被吸收，并且在收端完全被反弹，此时脉冲电流变为零，反射的电压信号与入射的电压信号同向，这样的反射现象是非反向反射(reflection without inversion)。  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220429133142.png width=50%><br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220506105610.png width=50%>  </p><p><strong>当传输线的特征阻抗与末端阻抗相同时，末端阻抗可以完全吸收发射能量，此时不会出现反射波，这样的情况称为阻抗匹配(matched impedance)</strong>。<br>当传输线的特征阻抗与收端阻抗未能匹配时，信号会部分反射回发端。如果反射信号能够到达发端，那么该信号继续反射多次。  </p><h4 id="反射系数"><a href="#反射系数" class="headerlink" title="反射系数"></a>反射系数</h4><p>设反射电流、电压分别为$\mathbf{I_r}$和$\mathbf{V_r}$,入射（输入）电流、电压分别为$\mathbf{I_i}$、$\mathbf{V_i}$，它们内部通过正负性表达传输方向，整个传输线上的电流电压为：  </p><script type="math/tex; mode=display">\mathbf{V_L}=\mathbf{V_i}+\mathbf{V_r}</script><script type="math/tex; mode=display">\mathbf{I_L}=\mathbf{I_i}+\mathbf{I_r}</script><p>那么位于传输线末端的负载的阻抗为：  </p><script type="math/tex; mode=display">Z_L=\frac{\mathbf{V_i}+\mathbf{V_r}}{\mathbf{I_i}+\mathbf{I_r}}=\frac{1+Γ}{1-Γ}</script><p>传输线的特征阻抗为：  </p><script type="math/tex; mode=display">Z_0=\frac{\mathbf{V_r}}{\mathbf{I_r}}=\frac{\mathbf{V_i}}{\mathbf{I_i}}</script><p>定义反射系数(reflection coeffientient)为反射电压/电流与入射电压/电流之比：  </p><script type="math/tex; mode=display">Γ=\frac{\mathbf{V_r}}{\mathbf{V_i}}=\frac{\mathbf{I_r}}{\mathbf{I_i}}</script><p>有：  </p><script type="math/tex; mode=display">Γ=\frac{Z_L-Z_0}{Z_L+Z_0}</script><p>可以发现，如果负载大于传输线特征阻抗，$Γ&gt;0$，那么此时的反射是非反向反射；如果负载小于传输线特征阻抗，$Γ&lt;0$，那么此时的反射是反向反射。$Γ=0$时，阻抗匹配。  </p><h4 id="驻波"><a href="#驻波" class="headerlink" title="驻波"></a>驻波</h4><p>两列沿相反方向传播的振幅相同、频率相同的波叠加时形成的波叫驻波，驻波的形成会让能量无法向前传播因此更多地在传输线上被损耗。幅度相同的反射波与入射波会形成驻波。当反射波与入射波幅度不相同时，则会形成介于驻波和行波之间的行驻波（partial standing wave）。<br>根据驻波的特点，可以发现驻波中每隔半个波长（$\frac{λ}{2}$）就会出现幅度最小的断面，称为波节；每隔半个波长（$\frac{λ}{2}$）也会出现升降幅度最大的断面，称为波腹。相邻波节和波腹之间的距离为$\frac{λ}{4}$.<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220429142338.png width=50%>  </p><p>定义形成的行驻波中最大的电压幅度和最小的电压幅度之比（波腹和波节绝对值之比）为电压驻波比(voltage standing wave ratio, VSWR).  </p><script type="math/tex; mode=display">S=\frac{|\mathbf{V_i}|+|\mathbf{V_r}|}{|\mathbf{V_i}|-|\mathbf{V_r}|}=\frac{1+|Γ|}{1-|Γ|}</script><p>反推可以得到：  </p><script type="math/tex; mode=display">|Γ|=\frac{S-1}{S+1}</script><h4 id="工程应用"><a href="#工程应用" class="headerlink" title="工程应用"></a>工程应用</h4><p>在工程应用中，可以通过朝管线发射某个特定频率的波，测量接收到反射波时间来预估管线发生开路的位置。<br>实际上，完全避免反射波的生成是不可能的。但是如果线路上的损耗足够大，反射波将不会到达发端。工程上，常常使用衰减器在发端附近人为地增加衰减，使得反射波无法影响到发射信号。这样的方法称为填充（padding）。但是这种方法也会削减发射信号的能量。<br>另一种方法是使用高频工作的无源器件（比如缓冲器）来对反射波进行选择性衰减而不衰减发射信号。这种方法称为隔离（isolation）。    </p><h3 id="热噪声"><a href="#热噪声" class="headerlink" title="热噪声"></a>热噪声</h3><p>在传输过程中的噪声主要是热噪声(Johanson-Nyquist Noise/Thermal Noise)，它是由于热效应使导体内部电子热运动而造成的噪声，是一种不可消除的高斯白噪声。在任何阻抗匹配的传输系统中，热噪声功率可以表示为：  </p><script type="math/tex; mode=display">N=kTB\left[\frac{\frac{hf}{kT}}{e^{-(\frac{hf}{kT})}}\right]</script><p>其中$k$是玻尔兹曼常数，$T$是环境的开尔文温度，$B$是接收信号带宽，$h$是普朗克常数，$f$是接收信号的中间频率。<br>在室温下，如果信号频率小于$10^{12}Hz$，则$\left[\frac{\frac{hf}{kT}}{e^{-(\frac{hf}{kT})}}\right]=1$，有：  </p><script type="math/tex; mode=display">N=kTB</script><h2 id="金属传输线类型"><a href="#金属传输线类型" class="headerlink" title="金属传输线类型"></a>金属传输线类型</h2><h3 id="同轴线"><a href="#同轴线" class="headerlink" title="同轴线"></a>同轴线</h3><p>同轴线(Coaixal Line, COAX)是现在最常用的传输线之一。工程中，同轴线常用作馈线或者桌面端传输的线材。<br>同轴线可以在较短距离内传输高频信号。理论上，同轴线支持的带宽上限为∞。在低频段，相较于双绞线或者平行双线，同轴线的色散效应更为明显。在高频段，由于趋肤效应同轴电缆的电流会在外导体的内表面流动，此时电磁场传播收到外导体内表面性质的影响，其向外辐射的能量减弱，并且串扰更小。<br>同轴线内径和外径的相对半径决定了同轴线的特征阻抗，标准同轴线的特征阻抗有两种：75Ω或者50Ω.  </p><p>在实用中，外导体一般用作屏蔽，采取单端接地的措施避免接地点电位不同，引起接地电流干扰内导体中的信号电流。  </p><p><img src = https://pica.zhimg.com/80/v2-59dffda31fd97bebcfadd4e47145aa13_1440w.jpg width=50%></p><blockquote><p><a href="https://www.zhihu.com/question/354733777">“为什么同轴电缆的电流会在外导体的内表面流动？”-知乎 Patrick Zhang的回答</a></p></blockquote><h3 id="微带线"><a href="#微带线" class="headerlink" title="微带线"></a>微带线</h3><p>微带线(microstrip line)是另一种支持高频信号传输的金属传输线，其支持的传输距离比同轴线更短，一般用于电路中两个模块之间的高频信号传输。通常微带线被预制在电路板上。微带线的结构如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220506124534.png width=50%></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>电信传输理论与工程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>14. 数字PID控制器和补偿器及其设计</title>
    <link href="/2022/04/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/14.%20%E6%95%B0%E5%AD%97%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E8%AE%A1/"/>
    <url>/2022/04/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/14.%20%E6%95%B0%E5%AD%97%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="数字PID控制器和补偿器及其设计"><a href="#数字PID控制器和补偿器及其设计" class="headerlink" title="数字PID控制器和补偿器及其设计"></a>数字PID控制器和补偿器及其设计</h1><p>数字PID控制器的设计思路是首先根据设计要求设计出模拟的PID控制器，再使用一定的离散化(Discretisation)方法使其转变为数字PID控制器。<br>数字控制器在整个数字控制系统中的位置如下：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220609144002.png width=50%>  </p><p>尽管系统中存在大量的模拟环节和模拟信号，对于整个数字系统的分析和设计需要以数字控制器为准，即在数字控制器设计时，应当将整个系统放在Z域中考虑。  </p><h2 id="离散化方法"><a href="#离散化方法" class="headerlink" title="离散化方法"></a>离散化方法</h2><p>所谓离散化是指使用一定的数学映射方法将s域的表示映射到z域上。常见的离散化方法有：</p><ul><li>前向欧拉法(Euler’s forward method)</li><li>后向欧拉法(Euler’s backward method)</li><li>双线性法/塔斯汀法(Tustin’s method/bilinear transformation)  </li><li>零阶保持器的离散化公式</li></ul><h3 id="前向欧拉法"><a href="#前向欧拉法" class="headerlink" title="前向欧拉法"></a>前向欧拉法</h3><p>前项欧拉法中使用采样序列的第$k+1$项和第$k$项的差来近似响应的微分：   </p><script type="math/tex; mode=display">\frac{dy}{dt}≈\frac{dy}{dk}=\frac{1}{T}[y(k+1)-y(k)]</script><p>对上述表达式左侧做拉普拉斯变换，右侧做z变换，即可得到s域到z域的映射关系：  </p><script type="math/tex; mode=display">sY(s)→\frac{1}{T}[zY(z)-Y(z)]</script><script type="math/tex; mode=display">sY(s)→\frac{1}{T}[z-1]Y(z)</script><p>由于$Y(s)→Y(z)$，有映射律：</p><script type="math/tex; mode=display">s→\frac{1}{T}(z-1)</script><p>同理可以得到二阶响应的近似：  </p><script type="math/tex; mode=display">\frac{d\dot{y}}{dt}≈\frac{d\dot{y}}{dk}=\frac{1}{T}[\dot{y}(k+1)-\dot{y}(k)]</script><p>同理推出：  </p><script type="math/tex; mode=display">\ddot{y}(k)≈\frac{1}{T^2}[y(k+2)-2y(k+1)+y(k)]</script><h3 id="后向欧拉法"><a href="#后向欧拉法" class="headerlink" title="后向欧拉法"></a>后向欧拉法</h3><p>后项欧拉法中使用采样序列的第$k$项和第$k-1$项的差来近似响应的微分：   </p><script type="math/tex; mode=display">\frac{dy}{dt}≈\frac{dy}{dk}=\frac{1}{T}[y(k)-y(k-1)]</script><p>同理，经过拉普拉斯变换和z变换后，得到s到z的映射律为：  </p><script type="math/tex; mode=display">s→\frac{1}{T}\frac{z-1}{z}</script><p>其二阶响应映射为：  </p><script type="math/tex; mode=display">\ddot{y}(k)≈\frac{1}{T^2}[y(k+2)-2y(k+1)+y(k)]</script><h3 id="双线性法"><a href="#双线性法" class="headerlink" title="双线性法"></a>双线性法</h3><p>双线性变换由$z=e^{Ts}$使用泰勒公式对其展开：  </p><script type="math/tex; mode=display">z=\frac{e^{\frac{sT}{2}}}{e^{-\frac{sT}{2}}}≈\frac{1+\frac{sT}{2}}{1-\frac{sT}{2}}</script><p>得到映射律：  </p><script type="math/tex; mode=display">s→\frac{2}{T}\frac{z-1}{z+1}</script><h3 id="零阶保持器的离散化公式"><a href="#零阶保持器的离散化公式" class="headerlink" title="零阶保持器的离散化公式"></a>零阶保持器的离散化公式</h3><p>如果零阶保持器和被控对象看做一个整体，对其进行z变换（即将整个系统放在z域中查看），得到：  </p><script type="math/tex; mode=display">G_{ZA}(z)=\frac{z-1}{z}𝒵[\frac{G(s)}{s}]</script><p>$𝒵[⋅]$表示z变换。<br>上述公式称为零阶保持器的离散化公式。  </p><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>s域左半平面在上述三种映射律下的映射情况如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220420165039.png width=50%>  </p><p>可以发现，前向欧拉法将某些s域中的稳定系统映射到了z域中不稳定的部分。<br>后向欧拉法将s域中的稳定系统和部分不稳定系统都映射到了z域中稳定的部分。<br>使用双线性法，系统的稳定性在映射前后不变。  </p><h3 id="使用MATLAB-对连续系统离散化"><a href="#使用MATLAB-对连续系统离散化" class="headerlink" title="使用MATLAB 对连续系统离散化"></a>使用MATLAB 对连续系统离散化</h3><p>在MATLAB中，可以使用函数<code>c2d(sys,ts,&#39;method&#39;)</code>对一个连续系统<code>sys</code>离散化，<code>sys</code>是连续系统的传递函数，<code>ts</code>是离散化所指定的采样时间，<code>method</code>是所采用的离散化方法：<code>zoh</code>或<code>z</code>表示零阶保持器，<code>tustin</code>表示双线性变换。  </p><h2 id="数字化的PID控制器"><a href="#数字化的PID控制器" class="headerlink" title="数字化的PID控制器"></a>数字化的PID控制器</h2><blockquote><p>加州大学伯克利分校：数字PID控制器设计 <a href="https://msc.berkeley.edu/assets/files/PID/modernPID4-digitalPID.pdf">https://msc.berkeley.edu/assets/files/PID/modernPID4-digitalPID.pdf</a>  </p></blockquote><p>数字化的PID控制器的性质和模拟PID控制器的性质相同，但是其传递函数被离散化到了z域。数字化的PID控制器的传递函数如下表所示：  </p><div class="table-container"><table><thead><tr><th style="text-align:center">控制器类型</th><th style="text-align:left">传递函数</th></tr></thead><tbody><tr><td style="text-align:center">P控制器</td><td style="text-align:left">$G_D(z)=K_p$</td></tr><tr><td style="text-align:center">I控制器</td><td style="text-align:left">$G_D(z)=K_iT\frac{z}{z-1}$</td></tr><tr><td style="text-align:center">D控制器</td><td style="text-align:left">$G_D(z)=\frac{K_d}{T}\frac{z-1}{z}$</td></tr><tr><td style="text-align:center">PI控制器</td><td style="text-align:left">$G_D(z)=K_p+K_i\frac{z}{z-1}=\frac{(K_p+K_iT)(z-\frac{K_p}{K_p+K_iT})}{z-1}$</td></tr><tr><td style="text-align:center">PD控制器</td><td style="text-align:left">$G_D(z)=K_p+\frac{K_d}{T}\frac{z-1}{z}=\frac{(K_p+\frac{K_d}{T})(z-\frac{\frac{K_d}{T}}{K_p+\frac{K_d}{T}})}{z}$</td></tr><tr><td style="text-align:center">PID控制器</td><td style="text-align:left">$G_D(z)=\frac{K_2z^2+K_1z+K_0}{z(z-1)},K_p=-K_1-2K_0,K_i=\frac{K_0+K_1+K_2}{T},K_d=K_0T$</td></tr></tbody></table></div><h2 id="数字超前-滞后补偿器设计"><a href="#数字超前-滞后补偿器设计" class="headerlink" title="数字超前/滞后补偿器设计"></a>数字超前/滞后补偿器设计</h2><p>数字控制器设计的思路有两种，其一是先设计模拟控制器，然后根据离散化方法将其转化为数字控制器。因为这种方法简单，在实际设计中通常选择这种方法，但是需要选择合适的T（通常是$T=0.1t_s$）。在采样周期$T$规定的情况下，要想精确地设计数字控制器，则需要直接在z域中进行设计。  </p><h3 id="模拟控制器数字化"><a href="#模拟控制器数字化" class="headerlink" title="模拟控制器数字化"></a>模拟控制器数字化</h3><ul><li>根据设计要求，利用模拟PID控制器的设计方法（比如<a href="https://l61012345.top/2022/03/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/7.%20PID%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/#PID%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E8%B0%83%E8%8A%82%E6%96%B9%E6%B3%95">齐格勒－尼科尔斯方法</a>）设计出模拟控制器$D(s)$。  </li><li>使用离散化方法对设计出的模拟控制器$D(s)$进行离散化得到$D(z)$。  </li></ul><p>如果零阶保持器和系统原型的离散化写作$G_{ZA}(z)$，设计好的数字控制系统的闭环传递函数为：  </p><script type="math/tex; mode=display">TF_{cl}(z)=\frac{D(z)G_{ZA}(z)}{1+D(z)G_{ZA}(z)}</script><p>找到其特征多项式$1+D(z)G_{ZA}(z)$后可以使用朱利判据测试其稳定性。<br>如果系统稳定，可以通过$e_{ss}=1-\lim_{z→1}(z-1)Y(z)$找到其稳态误差。  </p><h3 id="根轨迹方法"><a href="#根轨迹方法" class="headerlink" title="根轨迹方法"></a>根轨迹方法</h3><p>根轨迹方法是一种在Z域中进行直接设计的方法。  </p><h4 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h4><ul><li>理论一<br>根据z变换中的定义：$s=σ+jω$，$z=e^{sT}=e^{T(σ+jω)}$，有z域上任意一极点$z$:  <script type="math/tex; mode=display">|z|=e^{-Tσ}=e^{-Tζω_n}</script><script type="math/tex; mode=display">∠z=Tω_d=\frac{2πω_d}{ω_s}</script>其中，采样次数为：  <script type="math/tex; mode=display">n_s=\frac{ω_s}{ω_d}</script>工程设计中通常需要满足$8&lt;n_s&lt;10$。  </li><li>理论二<br>对于数字系统的特征方程$L(z)+1=0$，有$L(z)=-1$，此时可以将$L(z)$分解为幅度和角度，那么有：  <script type="math/tex; mode=display">∠L(z)=∑∠zero-∑∠pole=±180°(2k+1),k=0,1,2,...</script><script type="math/tex; mode=display">|L(z)|=1</script>因此，<strong>数字系统中某一极点与其他所有零极点的连线与实轴正半轴夹角的角度和应当为±180°。</strong>  </li></ul><h4 id="设计流程"><a href="#设计流程" class="headerlink" title="设计流程"></a>设计流程</h4><p>对于超前/滞后补偿器$D(z)=K\frac{z+α}{z+β}$：  </p><ul><li>根据系统要求找到阻尼比$ζ$、固有频率$ω_n$、阻尼固有频率$ω_d$，并找到设计的极点$z$的模长$|z|$和角度$∠z$。  </li><li>利用$a=|z|cos∠z,b=|z|sin∠z$将极点表示为$z=a+bj$的形式，并在z域上标出位置点$P$。  </li><li>将系统原型数字化，并找到系统原型的零点和极点。  </li><li>选择$α$为系统原型的一个极点，实现零极点对消以简化计算。  </li><li>将系统原型剩余的零极点与P连线的夹角利用$arctan(\frac{y_1-y_2}{x_1-x_2})$算出每一条连线与实轴正半轴的夹角。  </li><li>利用$∠β=∑∠zero-∑∠pole+180°$找到需要增加的零点$β$的角度。  </li><li>利用$∠β=arctan(\frac{b}{a-β})$求得需要增加的零点的具体位置$β$。  </li><li>利用$|D(z)G_{ZA}(z)|_{z=a+bj}=1$解方程求得$K$。  </li></ul><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220610152116.png width=80%>  </p><p>对于PID控制器也可以使用同样的设计方法对其进行设计，只是其控制器结构发生变化，由于I和D控制器均存在确定的分子分母，在利用根轨迹方法设计时还需要考虑这些确定的分子分母对系统角度的贡献：  </p><ul><li>对于PI控制器，其在(1,0)处贡献了一个极点。  </li><li>对于PID控制器，其在(0,0)和(1,0)处分别贡献了一个极点。  </li></ul><p>如果零阶保持器和系统原型的离散化写作$G_{ZA}(z)$，设计好的数字控制系统的闭环传递函数为：  </p><script type="math/tex; mode=display">TF_{cl}(z)=\frac{D(z)G_{ZA}(z)}{1+D(z)G_{ZA}(z)}</script><p>找到其特征多项式$1+D(z)G_{ZA}(z)$后可以使用朱利判据测试其稳定性。<br>如果系统稳定，可以通过$e_{ss}=1-\lim_{z→1}(z-1)Y(z)$或者静态误差系数找到其稳态误差。 </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>控制系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>3.网络层技术：路由选择</title>
    <link href="/2022/04/17/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E7%BD%91/3.%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <url>/2022/04/17/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E7%BD%91/3.%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h1 id="网络层技术：路由选择"><a href="#网络层技术：路由选择" class="headerlink" title="网络层技术：路由选择"></a>网络层技术：路由选择</h1><h2 id="路由选择"><a href="#路由选择" class="headerlink" title="路由选择"></a>路由选择</h2><h3 id="选择标准"><a href="#选择标准" class="headerlink" title="选择标准"></a>选择标准</h3><p>路由选择是设计分组交换网中最关键最复杂的问题。路由选择是指在交换过程中选择一条经过网络的路径，称为路由（routing）。通常站点到站点之间会有多条可行路由，因此需要选择经过哪一条路由。通常路由选择的过程中需要考虑：   </p><ul><li>正确性（correctness）<br>正确地找到终点。  </li><li>简洁性（simplicity）<br>通常指可以找到最小花费的路由，花费中包括了钱、时间以及其他通信资源等。  </li><li>鲁棒性（robustness）<br>可以在网络遇到突发事件时做出正确响应。  </li><li>稳定性（reliability）<br>路由上的数据率等特性，以及一些功能能够稳定正常执行。  </li><li>公平性（fairness）<br>路由的选择需要考虑这样的选择对整个网络的资源利用率都高效。  </li><li>最优性（optimality）<br>选择的路由开销最小，表现最突出。  </li><li>高效性（efficient）  </li></ul><h3 id="选择要素"><a href="#选择要素" class="headerlink" title="选择要素"></a>选择要素</h3><p>在选择时需要考虑的要素如下表所示：  </p><div class="table-container"><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">标准</th></tr></thead><tbody><tr><td style="text-align:left">性能评估标准</td><td style="text-align:left">跳数、代价、时延、吞吐量</td></tr><tr><td style="text-align:left">判决时间（做出路由选择的时间点）</td><td style="text-align:left">每个分组发送时决定路由、会话建立/建立连接时决定路由</td></tr><tr><td style="text-align:left">判决地点（做出路由选择的位置）</td><td style="text-align:left">每个节点（分布式）、中心节点（集中式）、源节点（源点式）</td></tr><tr><td style="text-align:left">网络信息更新时间</td><td style="text-align:left">连续的、周期的</td></tr></tbody></table></div><h4 id="性能评估标准"><a href="#性能评估标准" class="headerlink" title="性能评估标准"></a>性能评估标准</h4><p>性能评估的两个基本标准是最小跳数标准和最小代价标准。<br>最简单标准是选择经过网络的最小跳数路由，即途经节点的数量最少（路由上中间结点数+1即为跳数），这种标注容易测量，且使消耗的的网络资源最少。<br>最小代价标准是最小跳数标准的延伸，在评估时除了要考虑跳数外，还要考虑数据率、时延等等。  </p><h4 id="判决时间"><a href="#判决时间" class="headerlink" title="判决时间"></a>判决时间</h4><p>判决时间是做出路由选择的时间点，基本上是由选择无连接的分组交换还是面向连接的分组交换确定的（基于分组的还是基于虚电路的）。在无连接的分组交换中，结点在发送每个分组时就需要为每一个分组单独决定路由。而面向连接的分组交换中，在建立连接的过程中路由需要被选择，通信过程中没有路由选择的过程。  </p><h4 id="判决地点和网络信息资源"><a href="#判决地点和网络信息资源" class="headerlink" title="判决地点和网络信息资源"></a>判决地点和网络信息资源</h4><p>判决地点是做出路由选择的位置，最常见的是分布式路由选择，即网络中的每一个结点负责为接收到的分组选择发送时的路由。但是路由选择要求公平性，这暗示了需要要求进行路由选择的结点需要具备知道网络中其他结点状态的能力。对于网络中的每个结点，要求其知道整个网络中其他结点的状态所需要的开销是巨大的，因此结点在选择时一般只会了解相邻结点的网络状态。因此，单个结点已知的信息有限，其做出的路由选择对于整个网络而言只能是局部最优的解决方案。<br>集中式路由选择则是将路由选择的功能交给了某些设定的节点执行，这样的结点一般具有知道整个网络中大部分结点状态的能力，因此对分组发送做出的路由选择方案能够更从全局的角度上考虑。但是这样的选择缺点是稳定性较低，如果这些结点失效，那么整个网络的路由选择将无法进行。  </p><h4 id="信息更新定时"><a href="#信息更新定时" class="headerlink" title="信息更新定时"></a>信息更新定时</h4><p>对于固定式路由，其不需要信息更新定时，虽然能够减少由于同步带来的网络负担，但是无法对拥塞和网络故障产生反应。<br>对于动态路由，如果没有可以利用的信息，也就不存在信息的更新。有用信息越多，更新频率越快，网络就更可能做出良好的路由选择，对网络资源的消耗更大。因此，相较于分布式路由选择，采用集中式路由选择往往要求更高的信息更新频率。<br>结点的信息更新包括结点自身的信息（本地信息）更新和网络中其他结点的信息更新。本地信息更新的本质是连续性的。对于相邻结点和所有结点的更新定时取决于路由选择策略。使用自适应策略，信息需要经常更新，使路由选择判决能够适应变化的条件。  </p><h2 id="路由策略"><a href="#路由策略" class="headerlink" title="路由策略"></a>路由策略</h2><h3 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h3><p>静态路由为网络中每一个源的终端选择一条永久固定的路由。路由通过最小代价算法生成，生成后的路由会通过一张或多张链表(称为路由表)表示节点之间的映射关系并存储在结点中，其中每一个结点的路由表只关心数据分组的上一个来源的编号和需要转发到的下一个结点的编号。<br>如下图所示。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220523124646.png width=50%>  </p><p>当数据分组到达某个结点时，结点根据路由表上记录的规则将某个来源的分组转发到对应的下一个结点上。<br>从某个指定的源点到某个指定的终端中的所有分组都会沿着相同的路由前进。只有在网络的拓扑结构发生改变时，静态路由表才会发生改变。<br>静态路由的优点是其简洁性，在具有稳定负荷的、可靠的网络中表现良好。其缺点是缺乏灵活性，无法对在网络拥塞和结点故障时进行调度。  </p><h3 id="洪泛"><a href="#洪泛" class="headerlink" title="洪泛"></a>洪泛</h3><p>洪泛(flooding)不需要任何网络信息。洪泛策略中，网络中的每个结点在接收到某个分组后会复制该分组，并且转发给每一个相邻接点。最终终端会收到多份相同的分组。由于每个源点发送的分组都有唯一的编号，因此终端可以根据编号将编号相同的分组丢弃。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220523131230.png width=50%>  </p><p>洪泛有三个重要属性：  </p><ul><li>源点和终端之间所有的可能路由都被尝试过，因此只要源点和终点间有一条路由能够正常工作，分组都会成功交付到源点。<br>这样的性质使得洪泛的鲁棒性非常的强，因此洪泛路由常用于广播，目的是：  <ul><li>使网络中的所有结点都能收到消息（尤其是应急通信场景）  </li><li>知晓网络中所有结点的网络状态  </li></ul></li><li>源点和终端之间所有的可能路由都被尝试过，因此可以找到最小跳数路由。  </li><li>所有直接或间接地与源点相连的节点都会被访问到。  </li></ul><p>洪泛式路由的优点是鲁棒性强，同时可以访问到尽可能多的结点，在使用洪泛式路由时不需要知道网络的状态，执行相对比较简单。<br>其缺点是洪泛的通信负荷量非常高，极容易产生拥塞。  </p><h3 id="随机路由"><a href="#随机路由" class="headerlink" title="随机路由"></a>随机路由</h3><p>随机路由保留了洪泛的的简洁性，同时降低了通信量，其具体策略是：<br>网络中的每一个结点根据链路的数据率、有概率地为选择一条路由。其中最经典的随机路由分配机制是轮盘赌，在轮盘赌法则中，即某条链路的数据率为$R_i$，这条链路被选择作为路由的概率为：  </p><script type="math/tex; mode=display">P_i=\frac{R_i}{∑_jR_j}</script><p>随机路由只需要获得节点自身的数据率信息，不需要获得整个网络中其他节点的状态。由于随机性的选择，选择到的路由极有可能不是最小代价路由或者最小跳数路由，因此通信负荷量并非最小。  </p><h3 id="自适应路由"><a href="#自适应路由" class="headerlink" title="自适应路由"></a>自适应路由</h3><p>顾名思义，在自适应路由中，路由的选择根据网络的状态的改变而改变。自适应路由需要通过一些机制知道整个网络的状态。此外，自适应路由的根据网络状态更改的响应时间选择非常重要：如果对网络状态的响应过快，资源利用率低，并且容易引起网络波动。如果对网络状态的响应过慢，收集到的网络状态信息时效性差，路由判决的有效性差。<br>因此相比于前几种路由策略，自适应路由的决策更加复杂。<br>但是自适应路由有非常好的表现，尤其是当网络出现拥塞时，自适应路由可以及时调整路由缓解拥塞。<br>基本上所有的分组交换网络都采用自适应路由。  </p><h3 id="不同交换方式采取的路由策略"><a href="#不同交换方式采取的路由策略" class="headerlink" title="不同交换方式采取的路由策略"></a>不同交换方式采取的路由策略</h3><h4 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h4><p>电路交换在会话的过程中建立静态路由：每个节点都做最小代价算法决定下一个节点，并建立映射关系。路由建立后通信资源会被分配给建立的连接。连接被建立后，各个节点上的传输是透传的。  </p><h4 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h4><ul><li><p>虚电路<br>虚电路和电路交换的路由是静态的，为会话确定。<br>虚电路，比如ATM（ATM结点收到信元后会根据头部中的类型决定是否读内容），建立连接时，网络中的结点需要读内容（解包并移交给上层）。一旦连接被确定，映射关系会被结点储存。相较于电路交换，在映射关系建立后，虚电路不会为通信分配固定带宽。<br>电路交换和虚电路的路由建立过程是基本上相同的。电路交换中，建立连接的信道和通信的信道是不同且固定的。虚电路中没有信令和消息信道之分，靠分组的首部确定。  </p></li><li><p>数据报<br>数据报的路由是动态的，为每个分组确定。<br>数据报中每一个分组都是独立的，每个节点都需要对每一个分组处理。数据报网络中的节点也不会关心分组的具体内容，只关心分组的首部。结点根据网络状态和头部信息利用最小代价算法决定下一个结点。每一个数据包的路由受到结点收到时刻时的网络状态的影响。  </p></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>通信和计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信工程</tag>
      
      <tag>通信网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.数据链路层技术</title>
    <link href="/2022/04/17/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E7%BD%91/2.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <url>/2022/04/17/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E7%BD%91/2.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h1 id="数据链路层技术"><a href="#数据链路层技术" class="headerlink" title="数据链路层技术"></a>数据链路层技术</h1><p>数据链路控制是为了更有效地进行数据通信、对传输过程起到控制作用而设立的。系统之间传输的媒体称为数据链路。数据链路层涉及到的通信任务是：  </p><ul><li>帧同步：传输时需要保证收发两方开始和结束发送一帧的时间点双方都已知。做到这一点的方法有两种：  <ul><li>每一帧的长度相同，但是这种方式在通信环境不理想的情况下可靠性不强。  </li><li>每一帧都有标志(flag)表示一帧的起点和终点。  </li></ul></li><li>流量控制：在数据发送时需要考虑接收端的容量，保证发送端发送数据的速度要小于等于接收端处理这些帧的速度。  </li><li>差错控制：差错控制包括两种：重传和纠错。具体采用哪一种取决于传输的时延和误码率。  </li><li>寻址：指明发送端和接收端的身份。  </li><li>控制信息和数据在同一链路上：改善通信资源利用效率。  </li><li>链路管理：管理数据交换的过程。  </li></ul><h2 id="流量控制技术"><a href="#流量控制技术" class="headerlink" title="流量控制技术"></a>流量控制技术</h2><p>流量控制是一种保证发送端发送的数据不会超过接收端接收数据能力的一种技术。接收端一般会配备缓存来对传输数据进行暂存，流量控制保证的方法是通过控制传输速度实现的。<br>在无丢帧和无码的前提下，传输速度受到两方面的影响：  </p><ul><li>传输时间（transmission time）：数据包从端到端通过的时间，取决于带宽、数据包的大小和传播时间。  </li><li>传播时间（propagation time）：一个比特从端到端通过的时间，取决于传输介质的性质。  </li></ul><p>基本的流量控制的方法有两种，停等协议和滑动窗口。  </p><h3 id="停等协议"><a href="#停等协议" class="headerlink" title="停等协议"></a>停等协议</h3><p>顾名思义，发送方在发送一帧之后，必须要等收到接收方的确认信息（称为ACK/acknowledgement）后，才能发送下一帧。接收方可以通过是否发送确认信息来控制数据传输的停止。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220331151203.png width=40%>  </p><p>从链路的利用率角度出发，期望的情况是链路上随时都能够占满数据、不会留出空闲，这样对链路的利用率就是100%。但是无论帧的长度是否大于数据链路的长度，停等协议都无法使得链路上能够随时占满数据，因此，停等协议对两点通信的链路的利用率非常低下。<br><div class="note note-info">            <p>在分组交换的多点通信中，停等协议在停等过程中的资源可以被网络中的其他终端所利用，但是停等过程中仍然在浪费终端的通信资源（比如计算力，时间等等），因此停等协议对通信终端的通信资源的利用率不高。  </p>          </div>  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220331152047.png width=50%>  </p><p>显然，停等协议保证了传输的可靠性，但是等待时延降低了传输效率。<strong>停等协议适用于总帧数小、单帧包含数据量大的传输情况。在总帧数大、单帧包含数据量小时，停等协议显得十分低效。</strong>  </p><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>滑动窗口的改进是一个批次一批次地发送多个帧，只需要在一个批次的帧传输完成后，接收方才需要发送确认信息。每一个批次的长度称为滑动窗口的长度。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220331154807.png width=50%>  </p><p>具体而言，数据被划分成帧之后被循环编码，编码的范围为$0∼2^k-1$。<br>起始时，发送机一次性发送编号为$0∼i$的帧，接收机处理这些帧，并返回一个包含接收机处理的下一个帧的帧序号$n$的ACK。发送机收到ACK后，通过将ACK中的序号与发送的最后一个序号进行比对，从而得知上一批已经被接收机处理的帧的个数$i-n+1$。发送机再发送后续的$i-n+1$个帧，并等待接收机的下一个ACK，如此直到所有帧被发送完毕。  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220331162107.png width=50%>  </p><p>如果在两个站点之间交换数据，那么每个站点都要维护两个窗口：一个用于发送，另一个用于接收，且双方都需要向对方发送数据和确认帧ACK。更有效的双方的交换数据的方式是捎带。  </p><p>相比于停等协议，通过对窗口大小的合理设置，可以使链路被数据占满，实现对链路的高利用率。<br>简单来说，如果窗口的大小为：  </p><script type="math/tex; mode=display">[\frac{t_{ACK}}{t_{transmission}}]</script><p>向上取整。其中$t_{ACK}$为ACK的传输时间，$t_{transmission}$为帧的传输时间。<br>那么可以使得整个链路被占满。  </p><h2 id="差错控制技术"><a href="#差错控制技术" class="headerlink" title="差错控制技术"></a>差错控制技术</h2><h3 id="自动请求重发"><a href="#自动请求重发" class="headerlink" title="自动请求重发"></a>自动请求重发</h3><p>帧传输的差错包括两种：帧丢失和帧损伤。保证帧传输可靠性的机制是自动请求重发（automatic repeat request, ARQ）。<br>ARQ所起的作用是将不可靠的数据通过重发变得可靠。有三种形成ARQ的标准。  </p><h4 id="停等ARQ"><a href="#停等ARQ" class="headerlink" title="停等ARQ"></a>停等ARQ</h4><p>利用停等协议进行设计的ARQ机制。停等ARQ针对两个类型的差错有如下处理：  </p><ul><li>到达终点的帧可能已经被损伤<br>针对这样的差错，接收端使用差错检测技术检测出差错的存在，并直接丢弃这个帧。在发送端存在一个计时器，发送端发送一个帧之后，计时器开始计时，并等待接收端的ACK。如果等待时间超过阈值，那么发送端将再次发送同一个帧。  </li><li>ACK损伤/确认损伤<br>当ACK在传输中被损伤，使得发送端无法辨认时，发送端的计时器也会超时，并且重传一个帧。此时接收端会受到两个完全相同的帧。为了使接收端能够识别这个帧是重复帧，而并非携带有效信息的帧，在传输时将发送的帧交替编码为0,1，并且ACK也交替编码为0,1.<br>ACK0确认的是为编号1的帧，ACK0确认的是编号为0的帧。  </li></ul><p>简单来说，停等ARQ对这两种损伤的应对机制都是使发送端的计时器超时，然后重传。  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220331165339.png width=40%>  </p><p>停等ARQ的优点是简单易行，主要缺点是由于停等ARQ基于低效率的停等协议，效率也十分低下。  </p><h4 id="返回N-ARQ"><a href="#返回N-ARQ" class="headerlink" title="返回N ARQ"></a>返回N ARQ</h4><p>返回N ARQ基于滑动窗口协议。如果终端在某个帧中检测到差错，那么终端会为这个帧发送一个否认确认(REJ)，终端将丢弃这个帧和接收到的这个帧之后的所有帧。没有差错的情况下，终端会发送一个肯定确认（RR）。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220331172834.png width=30%>  </p><p>返回N ARQ针有如下两种机制来对无效帧进行重发：<br>如果接收到的帧是无效帧，接收端则丢弃该帧。  </p><ul><li>如果接收端接收到帧，发现帧$i+1$有错且此时发送端仍然还在发送其后的帧，于是接收端发送$REJi$，则发送端必须重传帧$i$即以后的后继帧。  </li><li><p>如果接收端没接收到帧，且此时发送端不发送之后的帧，发送端超时，此时发送端会发送一个包含询问信息的RR，询问接收端想要开始重传的帧序号，接收端发送这个帧序号$i$后发送端必须重传帧$i$即以后的后继帧。  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220404162717.png width=50%></p></li></ul><h4 id="选择拒绝ARQ"><a href="#选择拒绝ARQ" class="headerlink" title="选择拒绝ARQ"></a>选择拒绝ARQ</h4><p>在选择拒绝ARQ中，被重传的只有那些接收到否认或者超时的帧。选择拒绝ARQ的优点是被重传帧的数量被降低到了最小，增大了传输过程中的资源利用率。但是由于重传帧需要重新以原序插入到原来的帧序列中，这样的的机制对发送端和接收端的逻辑和缓存大小有非常高的要求，因此选择拒绝ARQ的应用范围比返回N ARQ更窄。<br>因此，选择拒绝ARQ适用于重传成本很高的通信链路，比如卫星通信链路。  </p><h2 id="高速数据链路控制协议"><a href="#高速数据链路控制协议" class="headerlink" title="高速数据链路控制协议"></a>高速数据链路控制协议</h2><p>高速数据链路控制协议(HDLC)是一个具体的数据链路控制协议。HDLC使用同步传输，其帧结构如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220408141525.png width=50%>  </p><ul><li>标志字段<br>HDLC中使用唯一的“01111110”字段在帧的两头作为分界。一个帧的标志即是前一个帧的结束，也是后一个帧的开始。为了保证信息内容中不会出现“01111110”与标志混淆、破坏同步的情况，需要使用比特填充的技术。具体是在帧的标志之间，当内容连续出现五个“1”时，发送器会插入一个附加的0。  </li></ul><h2 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h2><h3 id="交换式通信网"><a href="#交换式通信网" class="headerlink" title="交换式通信网"></a>交换式通信网</h3><p>在交换式通信网中，超出局部范围的数据传输需要经过一个中间交换结点构成的网络传输到目的地。节点承担的功能是数据的交换：这些结点接收网络中来自其他结点或者终端的数据，同时将数据发送给其他结点或者终端。<br><div class="note note-info">            <p>在计算机网络中，节点的功能不只是交换，还可以是存储和计算。随着通信网不断地和计算机网络融合，新型通信网中的某些节点也具有这些功能。  </p>          </div><br>节点之间通过一定的拓扑结构连接在一起，与终端（或者称之为站点(station)）一起构成交换式通信网。<br>如何制定节点之间的数据交换规则，使得在特定应用场景下的可靠性或者有效性或者节约程度突出是交换式通信网中需要讨论的问题。<br>常见的交换技术有四种：电路交换、分组交换、帧中继和ATM。<br>这些交换技术可分为两类：电路交换和分组交换。这两种交换可以采用不同的业务类型，业务类型分为面向连接的和无连接的。  </p><ul><li><p>面向连接的（connecting-oriented）<br>在双方通信之前需要通过通讯会话建立连接，直到通信结束后才能释放这个链接。需要注意的是，对于电路交换，在建立连接后，无论双方是否通信，连接都会持续占用整个网络的通信资源，因此面向连接的服务通常是以连接时间计费。<br>面向连接的通信包括三个阶段：  </p><ul><li>双方建立连接</li><li>通过连接双方进行通信</li><li>释放连接  </li></ul><p>相比于无连接的交换，面向连接的交换会消耗更多的资源和时间，但是通常可靠性会比无连接的交换更好。  </p></li><li><p>无连接的（connectionless）<br>通信的双方不需要在通信前建立连接。通信的发送方不关心接收方是否可以收到，也不保证连接的可靠性。<br>如果传输系统本身就具有高可靠性的特点，那么通信环境也可以保证无连接的可靠性。  </p></li></ul><p>面向连接 和 无连接的 是不同的<strong>业务属性</strong>，而电路交换和分组交换是不同的<strong>业务类型</strong>。<br><div class="note note-info">            <p>协议架构中每一层采用的交换方式是独立的、可以是不同的。但是，如果下层资源没有被固定分配，上层无法使用固定资源分配的协议，因此不存在下层使用分组交换，上层使用电路交换的情况。  </p>          </div>   </p><p><strong>面向连接的交换适用于长期的、稳定的、传输数据量大的通信。而无连接的交换适用于临时的、传输数据量小的通信，这种通信不需要为可靠性负责。</strong></p><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p>电路交换（circuit switching）是面向连接的交换，通信的双方在通信前建立双方独占、专用的物理通道，是一种物理连接。在建立连接后，相应的物理资源会被分配到这条连接上，在传输的过程中，这些物理资源被通信双方所专有，但是使用的资源量无法根据需求进行动态调整。<br>如果双方的通信需要经过中间结点，在电路交换中，中间结点不关心数据内容，直接转发，此时中间结点的转发时间相对于传输时间是可以忽略不计的，因此这样的传输可以保证传输数据率始终恒定。传输过程中看起来传输的两端仿佛存在一条直接连接，因此这样的传输称为<strong>透明传输/透传</strong>（Transparent Transmission）。<br>同时双方与中间结点的连接使用的信道/电路是不同的，且一定专用。  </p><div class="note note-info">            <p>物理连接：利用物体的物理特性对相关物体进行连接，连接过程占用的资源是物理的（比如时间和频率）。  </p>          </div>  <p>典型的电路交换应用例子是物理层的光网络传输。<br>单个电路交换节点中采用的交换技术有如下两个：  </p><ul><li><p>空分交换<br>信号通路之间从物理空间上被分开。每一次连接都需要经过空分交换机分配的一条专用的物理通路，数据在节点上从一条物理线路上切换到另一条物理线路上。<br>通常为了增加空分交换中每个交换节点的利用率，常常采用分级的空间交换矩阵。  </p><center class="half"><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220417150203.png width=30%><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220417150409.png width=35%></center></li><li><p>时分交换<br>如果链路中使用了时分复用技术，那么对中间结点而言，其会接收某个时隙上的数据，然后转发时将数据置于另一个时隙上。  </p></li></ul><p>电路交换的例子是电话线网络。<br>电路交换的优点是：由于其透明性，电路交换往往可以稳定地实现恒定高数据率的传输。且当连接被建立后，基本上不需要额外的比特开销。<br>其缺点是：</p><ul><li>其对通信资源的分配是固定的，且双方在通信过程中很难获取到额外的资源。</li><li>由于通信资源的专有性，连接被建立后，线路在空闲时的通信资源无法被网络上的其他结点使用，通信资源利用率低。  </li><li>由于电路交换的数据率恒定，因此在不同类型的设备上传输时，两个设备必须以相同的数据率传输和接收，网络的利用率受到限制。</li></ul><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>在分组交换中，传输数据分为多个数据包（称为分组）进行发送。每个数据包的格式是标准化的，每个数据包中有首部的控制信息（包含路由信息）和其后的用户数据，大小可以不同。到达中间结点的数据包会首先在缓存中存储，等到相应的输出电路空闲时再转发数据包。分组交换所使用的资源和连接都是逻辑的，被整个网络的所有节点共用。双方如果不通信，资源则由网络中的其他用户共享，因此分组交换服务是以数据大小进行计费的。分组交换可以是面向连接的，也可以是无连接的。<br>分组交换的例子是计算机之间的通信。  </p><h4 id="虚电路"><a href="#虚电路" class="headerlink" title="虚电路"></a>虚电路</h4><p>虚电路（vitual circuit）是一种面向连接的分组交换，在通信前双方需要从共享的通信资源中建立一条预订的路由（但是这条路由仍然和其他虚电路共享），并且相应的路由信息会被添加到分组中。因此，在转发每个分组时，节点不需要为每个分组选择路由。对于使用同一条虚电路的所有分组节点只需要做一次路由选择。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220417153729.png width=50%>  </p><h4 id="数据报"><a href="#数据报" class="headerlink" title="数据报"></a>数据报</h4><p>在数据报(datagram)中，每个分组被视为独立的，因此一些分组虽然有相同的目的地址，但是并不是沿着相同的路由到达目的地，并且可能会失序地到达目的地。数据报可以是面向连接的数据报，比如TCP数据报，也可以是无连接的数据报，比如用户数据报和IP数据报。<br>用户数据报网络（user datagram post，UDP）是一种无连接的分组交换。用户数据报数据报省略了呼叫建立过程，同时由于其更加原始，因此可以更加灵活地处理数据。<br>对于TCP，即为面向连接的数据报，TCP中的链路层关心可靠性，有响应的流量控制和差错控制。TCP为了可靠性做出了代价，包括：三次握手时消耗的通信资源，首部占比更大等等。对于UDP和IP数据报，链路层不关心可靠性，但是可以在上层设置可靠性功能。  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220417153947.png width=50%>  </p><div class="note note-info">            <p>电路交换和分组交换也可以组合使用，比如在语音通话中，双方拨号建立连接的过程会发送一些用于建立连接的信息，这些信息的传输方式是分组交换。连接建立后，用于连接的通信资源会归还会网络中供其他用户进行建立连接的信息传输。但是连接一旦被建立，双方的通信则是电路交换（或者说语音通话本身仍然是电路交换的）。  </p>          </div>  <p>分组交换的优点是：  </p><ul><li>链路在一段时间可以被许多分组动态地共享，通信资源的利用率较高。  </li><li>分组交换网络可以完成不同传输设备之间的数据率转换。  </li><li>网络发生拥塞时，分组仍然可以被中间结点接收并存储在缓存中，并不会像电路交换那样双方因为无法分配到资源而无法通信。  </li><li>可以对不同的分组定义不同的优先级。  </li></ul><p>分组交换的缺点是：</p><ul><li>无法保证每一次通信都可以获得足够的资源，且不能保证重要的资源被合理分配。</li><li>在传输过程中数据包的顺序还可能发生移位或者丢失。  </li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">电路交换</th><th style="text-align:left">分组交换<br>数据报</th><th style="text-align:left">分组交换<br>虚电路</th></tr></thead><tbody><tr><td style="text-align:left">面向连接的<br>有专用通路</td><td style="text-align:left">面向连接的/无连接的<br>无专用通路</td><td style="text-align:left">面向连接的<br>无专用通路</td></tr><tr><td style="text-align:left">在整个会话过程建立通路</td><td style="text-align:left">为每个分组建立路由</td><td style="text-align:left">为整个会话过程建立通路</td></tr><tr><td style="text-align:left">呼叫建立时延，传输时延可以忽略</td><td style="text-align:left">分组传输时延</td><td style="text-align:left">呼叫建立时延，分组传输时延</td></tr><tr><td style="text-align:left">用户负责报文丢失</td><td style="text-align:left">网络可能对单个丢失分组负责</td><td style="text-align:left">网络可能为分组序列丢失负责</td></tr><tr><td style="text-align:left">固定带宽传输</td><td style="text-align:left">动态使用带宽</td><td style="text-align:left">动态使用带宽</td></tr><tr><td style="text-align:left">呼叫建立后没有额外开销比特</td><td style="text-align:left">每个分组中有额外开销比特</td><td style="text-align:left">每个分组中有额外开销比特</td></tr></tbody></table></div><h3 id="帧中继（frame-relay）"><a href="#帧中继（frame-relay）" class="headerlink" title="帧中继（frame relay）"></a>帧中继（frame relay）</h3><p>由于通信环境的高数据率和误码率，传统分组交换网中物理层的差错控制功能显得冗余和高成本。帧中继中纠错功能被直接交由上层——网络层进行处理，从而减小系统在物理层的开销。在通信中用户信息以帧（frame）为单位进行传送，帧是一种数据包，其特点是长度可变。网络在传送过程中对帧结构、传送差错等情况进行检查，对出错的帧直接予以丢弃。  </p><h3 id="软交换技术"><a href="#软交换技术" class="headerlink" title="软交换技术"></a>软交换技术</h3><p>交换式通信网中的基本硬件设施是交换机(exchange/switch)。世界范围内交换机经历了”人工交换(manual exchange)-机电交换机(electromechanic exchange)-程控交换机(stored program control exchange)-软交换(soft switch)”四次大的技术革新。<br>程控交换机中的功能可以大致分为如下几个部分：用于连接站点的用户电路(user circuit)、用于连接其他交换机的中继电路(truck circuit)、用于控制通话的信令收发模块(signaling circuit)、控制和处理数据的中央处理器(CPU)、以及交换机内部负责各个模块的之间通信的交换结构。<br>传统程控交换机的缺点是：由于各功能模块被集成，因此如果要升级或改进其中某一模块，整个通信网中所有的交换机都需要更换。此外，对不同用户设备和信号，可能会使用到不同的程控交换机以适配接口。<br>软交换(soft switch)的基本思路是从物理上将硬件交换功能与其他功能分离。物理交换功能由媒体网关(media gateway)执行，并且可以兼容各种用户设备和信号；其他功能模块位于媒体网关控制器中，媒体网关控制器可以被虚拟化成为网络中的一些结点并且可以被整个网络中的节点共享。  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220417163755.png width=60%>  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220417163755.png width=60%>  </p><h3 id="异步传递方式-ATM-asynchronous-transmission-method"><a href="#异步传递方式-ATM-asynchronous-transmission-method" class="headerlink" title="异步传递方式/ATM(asynchronous transmission method)"></a>异步传递方式/ATM(asynchronous transmission method)</h3><h4 id="分组的大小"><a href="#分组的大小" class="headerlink" title="分组的大小"></a>分组的大小</h4><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220417165838.png width=50%>  </p><p>分组交换中，固定长度的一段报文被分成多少个分组取决于不同的应用场景。粒度高的分组方式(如上图中a)其额外开销比特（payload，即头部的控制信息）与用户数据占比更小，传输效率更高。粒度低(如上图中d)的分组方式，其额外开销比特与用户占比更大，但是更多的分组在交换时可以更加灵活处理，交换效率更高。    </p><h4 id="ATM-体系结构"><a href="#ATM-体系结构" class="headerlink" title="ATM 体系结构"></a>ATM 体系结构</h4><p>本质上，ATM是一种面向连接的分组交换，但是与虚电路不同的是，ATM中建立的连接信道的数据率是可以被动态定义的，因此解决了虚电路在通信时难以获取额外资源的缺点。ATM使用固定长度且非常小的数据包，称为信元（cell）。每一个信元由于体积小而易于处理，使得传输高效。同帧中继一样，ATM在传输过程中也在物理层几乎不为差错控制有额外的开销，而将这部分功能转交给上层。<br>但是在2G时代由于使用ATM需要更换终端设备，成本开销巨大，因此在2G时代这一技术并未流行。直到3G时代，ATM协议作为接入网的第二层才得到广泛应用。<br>ATM协议中有两层与ATM的功能相关：ATM层提供分组传输能力，而ATM适配层(AAL)提供了将高层信息映射到ATM信源的方式，使其能够以ATM方式传输。AAL对五种业务进行了适配。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220420170848.png width=30%>  </p><h4 id="ATM-逻辑连接"><a href="#ATM-逻辑连接" class="headerlink" title="ATM 逻辑连接"></a>ATM 逻辑连接</h4><p>ATM中的逻辑连接称为虚通路连接。端用户之间的物理传输通道被划分成多个虚通道，同时虚通道(VC, virtual channel)可以被划分为多个虚通路(VP,virtual path)。每一个虚通路都是速率可变的、全双工的、长途固定的信元流。且每一个虚通路都有唯一的识别标志虚通路标识符（VPI)，每一个虚通道也有唯一的识别标志虚通道标识符（VCI）。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220421135621.png width=50%>  </p><p>为了避免从不同虚通道上来的具有相同VPI的信元流在结点转发过程中出现错误，中间结点会将来自某个虚通路或者虚通道上接收的信元根据特定的映射，交换到另一个虚通路或者虚通道上。这样的交换可以是低粒度(low granularity)的（只是将信元转发到另一个虚通路）也可以是高粒度(high granularity)的（将信元转发到另一个虚通道的另一个虚通路上）。  </p><p>ATM建立连接通信的本质是<strong>在建立连接的过程中，链路上的每一个中间结点都会建立一个对应的转发映射，其中规定了来自某条虚通道的虚通路上的信元一定会被转发到另一特定的虚通道的虚通路上。</strong><br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220421142819.png width=60%>  </p><h4 id="ATM的链路管理"><a href="#ATM的链路管理" class="headerlink" title="ATM的链路管理"></a>ATM的链路管理</h4><p>由ATM协议构建的网络中有两种接口：  </p><ul><li>用户-网络接口（UNI）<br>用于用户站点和ATM网络之间的交换。UNI信令用于定义协议。  </li><li>网络-网络接口（NNI）<br>用于网络和网络之间的交换。NNI信令用于路由和网络管理。   </li></ul><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220421152949.png width=50%>  </p><ul><li>流量控制<br>ATM中只控制站点收发信元的速率而不控制传输速率。因而UNI信元格式中要求有流量控制的域，而NNI信元格式没有流量控制域。  </li><li>差错检测<br>ATM中ATM层结点只检查头部信息是否出错，而内容的差错检测和控制交由更高层处理。  </li></ul><h4 id="ATM信元"><a href="#ATM信元" class="headerlink" title="ATM信元"></a>ATM信元</h4><p>按照通信类型（即用户-网络/网络-网络）的不同，ATM有UNI信元和NNI信元两种信元格式。<br>ATM的信元长度为53个八位组/字节，其中信元头部的长度为8个八位组，其中有流量控制（只有UNI信元有）、虚通道标识符、虚通路标识符、有效载荷类型和信元丢失优先级、首部差错控制字段。<br>流量控制（只有UNI信元有）、虚通道和虚通路标识符在上文中已经介绍过，故不在赘述。<br>有效载荷类型字段指出了信元中信息字段的信息类型，其长度为3bit，其表示该信息是用户信息还是控制信息，服务数据单元的类型，以及是否经历过拥塞。<br>信元丢失优先级（CLP）用于在发生拥塞时提供指导，其长度为1bit，CLP=0表示该信元的优先级较高，只有在没有其他选择的情况下才能丢弃这个信元。CLP=1表示该信元在需要时就可以被网络丢弃。<br>当信元中的拥塞标识为1时，结点会根据CLP决定是否丢弃一些信元。  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220421161600.png width=50%>  </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>通信和计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信工程</tag>
      
      <tag>通信网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.物理层技术</title>
    <link href="/2022/04/17/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E7%BD%91/1.%E7%89%A9%E7%90%86%E5%B1%82%E6%8A%80%E6%9C%AF/"/>
    <url>/2022/04/17/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E7%BD%91/1.%E7%89%A9%E7%90%86%E5%B1%82%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="物理层技术"><a href="#物理层技术" class="headerlink" title="物理层技术"></a>物理层技术</h1><h2 id="数字通信传输技术"><a href="#数字通信传输技术" class="headerlink" title="数字通信传输技术"></a>数字通信传输技术</h2><h3 id="同步传输和异步传输"><a href="#同步传输和异步传输" class="headerlink" title="同步传输和异步传输"></a>同步传输和异步传输</h3><p>同步传输和异步传输是依据终端是否在同一时间可以接收一批数据来进行分类的。注意同步和异步概念的相对性取决于“一批数据的定义”，本小节内的一批数据指的是多个字符（一个字符包含多个比特）。  </p><h4 id="异步传输"><a href="#异步传输" class="headerlink" title="异步传输"></a>异步传输</h4><p>拒绝传输无中断的长比特流，从而避免时序上的问题。异步传输一次只能接收一个字符。传输过程中接收机可以通过每个字符前后表示分隔的标志（称为先导码和停止位）来保证字符同步。<br>异步传输的优点是传输系统简单且便宜，但是由于先导码的存在，每个字符内需要2-3个比特的额外开销。虽然每个字符的长度适度增大可以减小额外开销的占比，但是字符越长，累计时序误差越大。<br>累计时序误差是：实际上抽样器对每一个比特的抽样时间存在一定误差，误差在时间尺度上累计就可能出现抽样出错的情况，称为“滑码”。  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220329142655.png width=50%>  </p><p>为了避免滑码，异步传输适合于字符传输间隔时间长的情况（比如键盘）。  </p><h4 id="同步传输"><a href="#同步传输" class="headerlink" title="同步传输"></a>同步传输</h4><p>同步传输时，数据包以稳定比特流的形式传输，没有起始位和停止位。同步传输时，发送机和接收机之间除了数据传输线路外，还应当有一条独立的线路用于提供时钟信号，为发送机和接收机进行同步。时钟专线消耗资源较大，也可以采用将时钟信号嵌入码型的方法（比如曼彻斯特码）。<br>此外，还需要保证发送机和接收机能够同时判断数据块的开始和结束，因此每个数据包会设置同步标志（称为同步码），此外还会含有一些控制信息，传输的数据加上前后两个同步标志（称为前同步码和后同步码）和控制信息构成了一个同步帧。  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220329143803.png width=50%>   </p><h2 id="差错检测和纠错技术"><a href="#差错检测和纠错技术" class="headerlink" title="差错检测和纠错技术"></a>差错检测和纠错技术</h2><h3 id="差错类型"><a href="#差错类型" class="headerlink" title="差错类型"></a>差错类型</h3><p>数字通信系统中的差错可以分为两种类型：  </p><ul><li>单比特差错：只改变一个比特。造成单比特差错的原因通常是热噪声。  </li><li>差错突发（error burst）：一串比特/比特簇中有很多差错出现。造成差错突发的原因通常是冲击噪声和信号衰落。  </li></ul><h3 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测*"></a>差错检测*</h3><p>常见的差错检测的措施是奇偶校验和循环冗余校验。<br>由于本课对这部分没有要求，在此略过。  </p><h3 id="差错纠正"><a href="#差错纠正" class="headerlink" title="差错纠正"></a>差错纠正</h3><p>差错纠正的方法可以分为两种：</p><ul><li>数据重传<br>重传的高效性取决于传输耗时和误码率率。在短距离有线传输中，重传是高效的。但是对于卫星传输，传输耗时长；同时无线传输中无限链路的误码率高，重传低效。  </li><li>通过编码器和解码器进行纠错，比如前向纠错（FEC）。  </li></ul><h2 id="链路设置"><a href="#链路设置" class="headerlink" title="链路设置"></a>链路设置</h2><h3 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h3><p>拓扑结构是节点之间的物理连接结构。拓扑结构可以分为点对点和多点两种拓扑结构类型。<br>如果同一条链路上只有两个站点，那么拓扑结构类型是点对点的。如果同一链路上有多站点，那么拓扑结构类型是多点的。<br>本地局域网的拓扑结构通常是多点拓扑结构。<br>最基本的两种拓扑结构是：网状（mesh）和星形（star）。  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220329151057.png width=50%></p><h3 id="数据交换工作类型"><a href="#数据交换工作类型" class="headerlink" title="数据交换工作类型"></a>数据交换工作类型</h3><p>数据交换类型可以分为单工、半双工和双工。  </p><ul><li>单工传输<br>两个节点之间数据传输只能从节点A发送到节点B，换言之，数据流是单向的。比如电视网。  </li><li>半双工<br>节点A向B传输的同时，B不能向A传输数据，换言之，数据流是双向非同时的。比如对讲机网络。  </li><li>双工<br>节点A向B传输的同时，B也可以向A传输数据，换言之，数据流是双向同时的。比如话务网络。  </li></ul><h2 id="复用技术"><a href="#复用技术" class="headerlink" title="复用技术"></a>复用技术</h2><p>复用是一种多个输入使用多个相互独立的信道在一条物理链路上进行传输的技术。常见的复用技术是频分复用（FDM）、同步时分复用（synchronize TDM）和统计时分复用（stastical TDM）。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220408142401.png width=50%>  </p><h3 id="频分复用"><a href="#频分复用" class="headerlink" title="频分复用"></a>频分复用</h3><p>不同的信号调制到不同的载波频率上，使得多个信号可以被同时运载的技术。不同的载波频率之间存在足够大的间隔，以保证信号带宽不会重叠，这个间隔称为保护频带。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220408144332.png width=50%>  </p><p>频分复用通信的结构如下：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220408143337.png width=50%>  </p><p>频分复用中主要的两个问题是串扰和交调噪声。  </p><ul><li>应用<br>早期的传输音频信号的长途载波系统利用频分复用来扩大容量。对话音信号（300Hz-3400Hz），通常采用4kHz的带宽。  </li></ul><h4 id="波分复用"><a href="#波分复用" class="headerlink" title="波分复用"></a>波分复用</h4><p>由于用于通信的光的频率过高，通常采用波长而不是频率来表示光的特性。在光纤通信中，使用波分复用（WDM）来对光信号进行复用，其本质是光的频分复用。波分复用时，每一种波长的光都携带一个独立的数据通道。大多数波分复用系统的工作范围为1550nm。<br>密集波分复用（DWDM）是一种信道与信道之间间距更加紧凑的波分复用。密集波分复用没有严格的定义标准。  </p><h3 id="同步时分复用"><a href="#同步时分复用" class="headerlink" title="同步时分复用"></a>同步时分复用</h3><p>在不同时间交错地传输每一个信号当中的一部分的复用方法，每一个单位时间称为一个时隙。  </p><h4 id="同步时分复用的链路控制"><a href="#同步时分复用的链路控制" class="headerlink" title="同步时分复用的链路控制"></a>同步时分复用的链路控制</h4><ul><li><p>流量控制<br>采用同步时分复用的链路数据流中不存在首部和尾部（即不存在格式，因此同步时分复用的流量控制本质上是信号控制），也不需要由数据链路协议提供的控制机制。原因是同步时分复用链路中的链路数据率是恒定不变的，接收机和发送机利用这个固定的数据率进行同步。为了保持同步，在使用某一条时隙的设备不进行通信时，仍然会对这个时隙填充一些比特来保证恒定不变的数据率和同步。换言之，即使这个时隙上的设备不工作，这个时隙也不会分配给其他的设备使用。因此同步时分复用技术对信道的利用率较低。   </p></li><li><p>差错控制<br>由于信道（时隙）之间是相互独立的，因此不同信道之间采用的差错控制方法是可以不同的。  </p></li></ul><h4 id="组帧技术"><a href="#组帧技术" class="headerlink" title="组帧技术"></a>组帧技术</h4><p>在同步时分复用中，全部时隙上的一组单位数据（比如PCM-32系统中就是32个时隙的一组8比特数据）称为一帧。每一个TDM帧会附加一个控制比特，比如PCM-32系统中的0时隙和15时隙就是用于控制信息的时隙。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220408153657.png width=50%>  </p><h3 id="统计时分复用"><a href="#统计时分复用" class="headerlink" title="统计时分复用"></a>统计时分复用</h3><p>同步时分复用的主要问题是对时隙的利用率太低。统计时分复用中，时隙不再被某个发送机专有，复用器从所有的发送机中收集数据，直到填满所有时隙构成一个帧，然后将这个帧发送。这样的好处是即使某个发送机没有工作，某个时隙也能够被其他发送机用于发送其他信息。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220408173414.png width=50%>  </p><p>同时，统计时分复用利用了所有连接设备在任何时间不会都在传输的事实，因此<strong>复用线路上的数据率小于连接设备数据率的总和</strong>。在同样数据率的链路下，统计时分复用比同步时分复用支持更多的设备连接。  </p><p>但是，由于一帧当中不同时隙含有的数据接收方不再是固定的，每个时隙的开销相比于同步时分复用会更大，因为各个时隙中的数据还应该包含地址。<br>并且，某个接收方需要等待自己的所有比特组都全部收到之后，才能开始处理信息。因此，统计时分复用对接收方还应该要求具有更大的缓存。  </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>通信和计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信工程</tag>
      
      <tag>通信网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>13. 根轨迹图·采样周期的影响</title>
    <link href="/2022/04/16/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/13.%20%E6%A0%B9%E8%BD%A8%E8%BF%B9%E5%9B%BE/"/>
    <url>/2022/04/16/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/13.%20%E6%A0%B9%E8%BD%A8%E8%BF%B9%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="根轨迹图·采样周期的影响"><a href="#根轨迹图·采样周期的影响" class="headerlink" title="根轨迹图·采样周期的影响"></a>根轨迹图·采样周期的影响</h1><p>为了更好的研究开环传递函数$G(s)H(s)$或$G(z)H(z)$对反馈系统的影响，用根轨迹图（Root locus diagram）来表现对系统使用增益控制器时，根据系统闭环传递函数的极点在s域/z域中随着比例控制器的增益的变化情况来得到系统稳定性和受阻尼情况的改变情况。<br>简单来说，  </p><ul><li>根据根轨迹图可以发现系统在不稳定/稳定/临界稳定条件下时，所对应的比例控制器增益（范围），从而设置合适的增益，使得系统稳定/不稳定/临界稳定。  </li><li>根据根轨迹图可以发现随着增益的变化系统受到阻尼的变化情况，从而可以根据设计要求的系统阻尼情况(过阻尼/临界阻尼/欠阻尼/无阻尼)来选择合适的增益。  </li></ul><h2 id="根轨迹图的绘制方法"><a href="#根轨迹图的绘制方法" class="headerlink" title="根轨迹图的绘制方法"></a>根轨迹图的绘制方法</h2><h3 id="通过闭环传递函数绘制"><a href="#通过闭环传递函数绘制" class="headerlink" title="通过闭环传递函数绘制"></a>通过闭环传递函数绘制</h3><p>通过闭环传递函数得到根轨迹图的步骤：  </p><ol><li>在系统前馈中增加一个增益为$K$的比例控制器，通过闭环传递函数的特征方程解出s与$K$之间的关系。<br>如果原来的闭环传递函数为：$TF_{cl}(s)=\frac{G(s)}{1+G(s)H(s)}$，那么增加了比例控制器的闭环传递函数为：$TF_{cl}(s)=\frac{KG(s)}{1+KG(s)H(s)}$  </li><li>找到系统的特征方程$1+KG(s)H(s)=0$，并解出零点，在s域中标出零点。  </li><li>在s域中标出极点，即$K=0$的位置。  </li><li>增加K的值，在S域中标出一系列的s的位置，并以（$K=x$）在每个点上方进行标注。  </li><li>判断$k→∞$时，s的移动方向，并用箭头标注。  </li></ol><h3 id="通过开环传递函数绘制"><a href="#通过开环传递函数绘制" class="headerlink" title="通过开环传递函数绘制"></a>通过开环传递函数绘制</h3><p>通过开环传递函数$G(s)H(s)$直接绘制根轨迹遵循如下规则：  </p><ul><li>根轨迹的分支数<br>根轨迹的分支数量是开环极点数$n$和开环零点数$m$中的最大值$max(m,n)$。  </li><li><p>根轨迹的起点和终点<br>根轨迹的起点只能是极点，而终点要么是零点要么是无穷远处。<br>如果开环零点数等于开环极点数，根轨迹始于开环极点，终于其左边相邻的开环零点。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220416165207.png width=20%>  </p><p>如果开环零点数小于开环极点数，那么有$n-m$调根轨迹终止于无穷远处。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220416165355.png width=20%>  </p></li><li><p>实轴上的根轨迹<br>实轴上的某一区域，若其右边开环实数零极点个数之和为奇数，则该轨迹是根轨迹。或者描述为：将零极点从大到小编号为(1,2,3…)，实轴上第奇数个零极点左边的部分是根轨迹。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220416165244.png width=20%>  </p><p>进入实轴的点(称为进入点(break-in point))是函数$-\frac{A(z)}{B(z)},G(z)H(z)=\frac{KB(z)}{A(z)}$的正极大值点，离开实轴的点（称为离开点(breakaway point)）是函数$-\frac{A(z)}{B(z)},G(z)H(z)=\frac{KB(z)}{A(z)}$的正极小值点。  </p><p>两个根轨迹在实轴上相遇后立即分离的点称为和分离点，在和分离点后，两根根轨迹会向对向偏转90°。其中，起点值较大的根轨迹向上偏转，起点值较小的根轨迹向下偏转。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220416165314.png width=20%></p></li></ul><ul><li>复根<br>如果有复根出现，则一定是共轭成对出现的。  </li><li>不重叠<br>在任何时候，同一支根轨迹分支不会与自身重叠。  </li></ul><h2 id="根轨迹图与数字系统特性"><a href="#根轨迹图与数字系统特性" class="headerlink" title="根轨迹图与数字系统特性"></a>根轨迹图与数字系统特性</h2><p>对于数字系统$\frac{G(z)}{1+G(z)H(z)}$，再加入比例控制器后，其闭环传递函数写作$\frac{KG(z)}{1+KG(z)H(z)}$，此时的特征方程为：  </p><script type="math/tex; mode=display">1+KG(z)H(z)=0</script><h3 id="稳定最大增益"><a href="#稳定最大增益" class="headerlink" title="稳定最大增益"></a>稳定最大增益</h3><p>根轨迹上的稳定最大增益出现在有重根的位置。对于二阶数字系统，对应特征方程的$Δ=0$时对应的增益$K$最大。  </p><h3 id="临界稳定"><a href="#临界稳定" class="headerlink" title="临界稳定"></a>临界稳定</h3><p>对数字系统，根轨迹上与单位圆的交点对应系统处于临界稳定状态。  </p><ul><li>当根轨迹从实轴离开单位圆时，此时对应的极点应当为$z=-1$。  </li><li>当根轨迹从z域上其他地方离开单位圆时，有如下求此时系统极点的方法：<br>对于二阶数字系统，其特征方程可以写作：  <script type="math/tex; mode=display">az^2+bz+c=0</script>根据求根公式，有$z=\frac{-b±\sqrt{b^2-4ac}}{2a}=\frac{-b±\sqrt{(-1)^2×(b^2-4ac)}}{2a}$，有：  <script type="math/tex; mode=display">z=-\frac{b}{2a}±i\frac{\sqrt{4ac-b^2}}{2a}</script><script type="math/tex; mode=display">|z|=\frac{c}{a}</script>当系统处于临界稳定条件下时，$z$的模长应当为单位圆半径1，有:  <script type="math/tex; mode=display">|z|=\frac{c}{a}=1</script></li></ul><p>将临界稳定时系统的极点$z$带入含有比例增益$K$的特征方程中，即可求得临界稳定时的比例增益$K_{crs}$。  </p><h3 id="临界阻尼"><a href="#临界阻尼" class="headerlink" title="临界阻尼"></a>临界阻尼</h3><p>根轨迹和系统的受阻尼状态有如下关系：  </p><ul><li>当根轨迹位于实轴时，特征方程的$Δ&gt;0$，对应$ζ&gt;1$，系统过阻尼。  </li><li>当根轨迹离开实轴时，特征方程的$Δ&gt;=00$，对应$ζ=1$，系统处于临界阻尼状态。  </li><li>当根轨迹不在虚轴时，特征方程的$Δ&lt;0$，对应$0&lt;ζ&lt;1$，系统欠阻尼。  </li></ul><p>当数字系统的根轨迹离开实轴或者进入实轴时，系统处于临界阻尼状态。要系统的临界阻尼状态对应的极点即是离开点和进入点，其求法是化简特征方程，得到比例增益关于z的函数$K(z)$，对其求导且令其为0：</p><script type="math/tex; mode=display">\frac{dK}{dz}=0</script><p>其中微分方程的解中较大的值是根轨迹的离开点，较小的值是根轨迹的进入点。<br>将临界阻尼时系统的极点$z$带入含有比例增益$K$的特征方程中，即可求得临界稳定时的比例增益$K_{crd}$。  </p><h2 id="采样周期对系统性质的影响"><a href="#采样周期对系统性质的影响" class="headerlink" title="采样周期对系统性质的影响"></a>采样周期对系统性质的影响</h2><h3 id="采样周期对稳定性的影响"><a href="#采样周期对稳定性的影响" class="headerlink" title="采样周期对稳定性的影响"></a>采样周期对稳定性的影响</h3><p>零阶保持器可以将数字信号在每个抽样时刻保持这个抽样值并持续抽样周期$T$时长来实现数字信号到模拟信号的转换。零阶保持器的$z$域传递函数表示为：  </p><script type="math/tex; mode=display">G(z)=\frac{z-1}{z}Z[\frac{G(s)}{s}]</script><p>其中$Z[\frac{G(s)}{s}]$中含有抽样周期$T$.<br>此时改变$T$的值，并研究不同$T$下的根轨迹方程，以及$K_{crs}$.可以得到结论。<br><strong>采样周期可以影响数字系统的稳定性：随着采样周期的增大，临界稳定时的比例增益$K_{crs}$越小，表明系统越不稳定。</strong><br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220419141512.png width=60%>  </p><h4 id="采样周期对稳态误差的影响"><a href="#采样周期对稳态误差的影响" class="headerlink" title="采样周期对稳态误差的影响"></a>采样周期对稳态误差的影响</h4><p>稳态误差可以通过先求静态速度误差常数，再使用$e_{ss}=\frac{1}{K_v}$得到。<br>可以发现，随着采样周期的增加，稳态误差也相应的增加。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220419143755.png width=50%>  </p><h3 id="采样周期对受阻尼情况的影响"><a href="#采样周期对受阻尼情况的影响" class="headerlink" title="采样周期对受阻尼情况的影响"></a>采样周期对受阻尼情况的影响</h3><p>同样地，改变$T$的值，并研究不同$T$下的根轨迹方程，以及阶跃响应.可以得到结论。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220419142232.png width=50%>  </p><p>如果采样频率不够高，那么阶跃响应的过冲率会高于通过$ζ$预测的过冲率。  </p><h3 id="采样周期的设置"><a href="#采样周期的设置" class="headerlink" title="采样周期的设置"></a>采样周期的设置</h3><p>可以发现，采样周期的设置会对系统的稳定性、稳态误差以及瞬态响应的表现都有影响。  </p><p>采样周期设置一般需要遵循：  </p><ul><li>奈奎斯特采样定律，即$\frac{1}{T}&lt;2f_H$   </li><li><strong>对于过阻尼系统，满足在峰值时间$t_p$内需要8到10次采样。</strong>  </li><li><strong>对于欠阻尼系统，满足在一振荡周期内$T$内需要8到10次采样。</strong><br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220419145239.png width=50%>    </li><li>采样器的硬件实施能力。  </li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>控制系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>12. 数字控制稳定性</title>
    <link href="/2022/04/14/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/12.%20%E7%A8%B3%E5%AE%9A%E6%80%A7%E6%8E%A7%E5%88%B6/"/>
    <url>/2022/04/14/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/12.%20%E7%A8%B3%E5%AE%9A%E6%80%A7%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="数字控制系统稳定性"><a href="#数字控制系统稳定性" class="headerlink" title="数字控制系统稳定性"></a>数字控制系统稳定性</h1><h2 id="模拟系统的稳定性"><a href="#模拟系统的稳定性" class="headerlink" title="模拟系统的稳定性"></a>模拟系统的稳定性</h2><p>在模拟系统中，通过测试可以发现一阶系统极点在s域的位置与其系统特性存在如下关系：  </p><ul><li>极点在实轴、左半轴的系统：<br>系统响应以指数形式下降，且极点越远离虚轴下降速度越快。  </li><li>极点在实轴、右半轴的系统：<br>系统响应以指数形式上升，且极点越远离虚轴上升速度越快。  </li><li>极点在原点的系统：<br>系统响应是单位阶跃响应。  </li><li>极点在虚轴的系统：<br>产生稳定的正弦振荡。  </li></ul><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220416153559.png width=50%>  </p><p>具有共轭复根极点的系统，其实部会影响系统响应的指数变化，而虚部则会影响其振荡频率。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220414195352.png width=50%>  </p><p>可以得出结论：<br><strong>在模拟系统中，如果系统极点全部位于$s$域左半平面，那么系统稳定。</strong><br>要想知道如何判定一个数字系统是否稳定，那么需要知道模拟系统$s$域和数字系统$z$域之间的映射关系。  </p><h2 id="s域到z域的映射"><a href="#s域到z域的映射" class="headerlink" title="s域到z域的映射"></a>s域到z域的映射</h2><p>根据$z$变换的定义和拉普拉斯变换的定义：  </p><script type="math/tex; mode=display">z=e^{Ts}</script><script type="math/tex; mode=display">s=σ+jω</script><p>有：  </p><script type="math/tex; mode=display">z=e^{σT}e^{jωT}</script><p>令$r=e^{σT}$,$θ=ωT$，将其极坐标化：  </p><script type="math/tex; mode=display">z=re^{jωT}=re^{j∠θ}</script><p>那么有如图所示的对应关系：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220414193542.png width=90%>  </p><div class="table-container"><table><thead><tr><th style="text-align:center">s域</th><th style="text-align:center">z域</th></tr></thead><tbody><tr><td style="text-align:center">(0,0)</td><td style="text-align:center">(1,0)</td></tr><tr><td style="text-align:center">虚轴正半轴</td><td style="text-align:center">单位圆上半部分</td></tr><tr><td style="text-align:center">虚轴负半轴</td><td style="text-align:center">单位圆下半部分</td></tr><tr><td style="text-align:center">左半平面</td><td style="text-align:center">单位圆内的部分</td></tr><tr><td style="text-align:center">右半平面</td><td style="text-align:center">单位圆外的部分</td></tr></tbody></table></div><h2 id="数字系统的稳定性"><a href="#数字系统的稳定性" class="headerlink" title="数字系统的稳定性"></a>数字系统的稳定性</h2><p>已知s域中如果系统的极点全部位于s域左半平面时，系统稳定。根据s域到z域的映射，不难得出结论：<br><strong>对于数字系统，如果其所有极点全部位于z域单位圆内，则系统是稳定的</strong>。<br>且极点位于z域内其他位置时的系统响应形状可以通过寻找对应在s域的位置，对极点在这个位置上的系统响应进行采样和量化即可得到对应在z域的系统响应形状。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220415150508.png width=50%>  </p><h3 id="数字系统的稳定性测试"><a href="#数字系统的稳定性测试" class="headerlink" title="数字系统的稳定性测试"></a>数字系统的稳定性测试</h3><p>虽然已知数字系统稳定性的条件，但是对于某些高阶复杂的特征方程，无法直接使用求根公式或者因式分解来找到具体的极点位置，因此需要其他的数学方法帮助判断在已知特征方程的情况下，系统是否稳定。  </p><h4 id="劳斯判据"><a href="#劳斯判据" class="headerlink" title="劳斯判据"></a>劳斯判据</h4><p>劳斯判据不能直接应用在z域数字系统上，因此需要通过某种方法将z域变换到连续域上，这种方法是双线性变换(bilinear transofrmation)。<br>在双线性变换中，定义：   </p><script type="math/tex; mode=display">w=σ+jω</script><script type="math/tex; mode=display">z=\frac{w+1}{w-1}</script><p>根据z的模$|z|$与1之间的关系也可以类似地得到一个z域和w域之间的区域映射关系。简单来说，z域单位圆内的部分被映射在了w域虚轴左半轴。  </p><div class="note note-info">            <p>虽然这样的映射关系非常类似z域与s域之间的区域映射关系，但是w域和s域之间由于线性映射$z=\frac{w+1}{w-1}$和非线性映射$z=ln(s)$的区别，因此w域和s域仍然是不同的。  </p>          </div>  <p>经过双线性变换之后的特征方程就可以使用劳斯判据对其进行稳定性测试。  </p><h4 id="朱利判据"><a href="#朱利判据" class="headerlink" title="朱利判据"></a>朱利判据</h4><p>朱利判据是一种对数字系统的稳定性判据，相比于需要先连续化特征方程的劳斯判据，朱利判据可以直接判定数字系统是否稳定。<br>具体而言，对于一个$n$阶数字系统的特征多项式：  </p><script type="math/tex; mode=display">F(z)=∑_{k=0}^na_{n-k}z^{n-k}</script><p>其稳定的必要条件是：  </p><script type="math/tex; mode=display">F(1)>0</script><script type="math/tex; mode=display">(-1)^nF(-1)>0</script><p>系统稳定的充分条件为：<br>将特征多项式系数按照如下的朱利表进行排列：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220416152153.png width=30%><br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220609150157.png width=30%>  </p><p>排列后的系数满足：  </p><script type="math/tex; mode=display">\begin{cases}  |a_0|<a_n\\  |b_0|>|b_{n-1}|\\  |c_0|>|c_{n-2}|\\  ⋮\end{cases}</script><p>一共$n-1$个条件。  </p><p>对于数字系统，其特征多项式需要同时满足朱利判据中的充分条件和必要条件，该数字系统是稳定的。  </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>控制系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>11. 数字控制系统概述</title>
    <link href="/2022/04/12/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/11.%20%E6%95%B0%E5%AD%97%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/04/12/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/11.%20%E6%95%B0%E5%AD%97%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="数字控制系统概述"><a href="#数字控制系统概述" class="headerlink" title="数字控制系统概述"></a>数字控制系统概述</h1><h2 id="数字控制系统的特点"><a href="#数字控制系统的特点" class="headerlink" title="数字控制系统的特点"></a>数字控制系统的特点</h2><p>数字控制系统的核心是控制器的数字化，起到系统控制作用的控制器通常是微处理器、微控制器或者是电脑。数字控制系统中，数字控制器的输入和输出信号都是数字信号。<br>相比于模拟控制系统，采用数字信号对系统进行控制的优点是：  </p><ul><li>对噪声的鲁棒性好<br>通过与设立的判决门限阈值比较可以直接还原数字信号。<br>电子系统中的电容和电阻等器件的实际值往往会有公差，这些公差对数字信号不会起到很大的影响。  </li><li>灵活性高<br>模拟控制器被硬件实现后很难再改动和重设计。但是数字控制器可以通过软件实现，并且往往不用将整个控制器全部重做就可以进行改动。  </li><li>处理速度快<br>得益于计算机处理速度的发展，相比于模拟控制器，数字控制器的处理速度更快。采样间隔可以达到非常小的程度。  </li><li>成本<br>由于大规模集成电路的发展，数字控制器的价格更低，占用空间也更小。  </li></ul><h2 id="数字控制系统的基本结构"><a href="#数字控制系统的基本结构" class="headerlink" title="数字控制系统的基本结构"></a>数字控制系统的基本结构</h2><p>在结构上，由于数字控制器只能输入和输出数字信号，因此在数字控制器的输入输出两端应该设置模数转换器（ADC）和数模转换器（DAC）。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220412133957.png width=50%><br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220412134119.png width=50%>  </p><h3 id="模数转换器"><a href="#模数转换器" class="headerlink" title="模数转换器"></a>模数转换器</h3><p>模数转换器是一种将模拟信号转变为数字信号的转置，它为数字控制器提供了数字信号和模拟信号的接口。<br>模拟信号转化为数字信号的过程可以概括为：“采样-量化-编码”。在采样阶段，幅值和时间连续的模拟信号经过采样，转变为离散时间，幅值连续的采样信号，采样信号通过量化后规整幅值，得到幅值和时间都离散的数字信号。数字信号通过编码器编码可以被解读为各种信息。  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220412134843.png width=50%>  </p><h4 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h4><p>采样过程需要遵守奈奎斯特采样准则，即采样频率需要大于或等于基带信号最高频率的两倍，这样才能保证模拟信号被准确的采样：  </p><script type="math/tex; mode=display">f_s≥2f_H</script><p>采样的方式有两种：  </p><ul><li>周期采样<br>对模拟信号进行等时间间距的采样。  </li><li><p>多采样率采样<br>对于不同的反馈信号环路采样精度的不同，使用不同的采样率进行采样。  </p></li><li><p>混叠<br>当采样频率设置不合理时，即采样频率低于2倍的信号频率时，会导致原本的高频信号被采样成低频信号，这样的问题称为混叠(Aliasing)。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220412165637.png width=50%><br>混叠的解决方法有两种：  </p><ul><li>设置采样频率大于$2f_H$</li><li>使用低通滤波器称为抗混叠滤波器(anti-aliasing filter)添加在模数转换器之前。  </li></ul><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220412165908.png width=50%>  </p></li></ul><h4 id="量化"><a href="#量化" class="headerlink" title="量化"></a>量化</h4><p>量化是用一段特定数值对采样结果进行近似的过程。<br>对于均匀量化，对于如果使用$n$个0/1比特对结果进行量化，那么量化级的大小为：  </p><script type="math/tex; mode=display">\frac{FSR}{2^n}</script><p>$FSR$表示采样值范围的最大值。  </p><h4 id="逐次逼近式ADC"><a href="#逐次逼近式ADC" class="headerlink" title="逐次逼近式ADC"></a>逐次逼近式ADC</h4><p>下图中8bit Register的值的从MSB开始进行比特反转0-&gt;1，每一个比特位0-&gt;1的变化都会由DAC转换为电压与输入电压进行对比，比较器将两个电压进行对比，判断DAC的电压是否高于输入电压：如果输入电压高于DAC的电压，那么Register中这一比特位的值为1，如果低于DAC的电压，那么Register中这一位比特位的值恢复为0。<br>调整8bit Register的每一个比特位，直到LSB调整完毕，ADC的转换结束。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220412165306.png width=50%>  </p><h3 id="数模转换器"><a href="#数模转换器" class="headerlink" title="数模转换器"></a>数模转换器</h3><p>数模转换器是一种将数字信号转换为模拟信号的转置。数模转换的过程可以分为“解码-零阶保持（zero-order hold）”两个步骤。<br>数字信息通过解码转换为数字信号，离散的数字信号通过零阶保持器将每个时间点的电平值保持一段时间，进而形成时间和幅值连续的数字信号。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220412162854.png width=50%>  </p><h4 id="数模转换器电路"><a href="#数模转换器电路" class="headerlink" title="数模转换器电路"></a>数模转换器电路</h4><p>数模转换器电路有两种实现方法：  </p><ul><li><p>T型电阻DAC(R-2R ladder network DAC)<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220412163205.png width=50%>  </p><p>对于使用$n$个比特的量化，电路中存在$n-1$个“$R-2R$”的电阻电路。$b_0$为最低位，$b_{n-1}$为最高位。当$b_i=0$时，对应“$R-2R$”电路接地，当$b_i=0$时，对应“$R-2R$”电路与$-V_{ref}$连接。$V_{ref}$是采样电平的最大值，即$FSR$。<br>通过对电路的分析，有：  </p><script type="math/tex; mode=display">V_o=\frac{I_{bin}}{2^n}V_{ref}</script><p>其中$I_{bin}=[b_{n-1}b_{n-2}…b_1b_0]$   </p></li><li><p>权电阻型DAC(weighted resistors DAC)<br>权电阻型数模转换器要使用权电阻网络，其中电阻值为2的0次幂、1次幂、2次幂、3次幂等。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220412164317.png width=50%>  </p><p>权电阻型DAC在实现过程上很简单，但是由于使用了更多和更大的电阻值，难以获得足够精度的$2^n$电阻值，所以权电阻网络实际中比较难以使用。<br>T型电阻DAC在实现过程中更为复杂，但是由于只需要$R$和$2R$两种电阻值，可以保证其精度。  </p></li></ul><h4 id="零阶保持器"><a href="#零阶保持器" class="headerlink" title="零阶保持器"></a>零阶保持器</h4><p>零阶保持器可以将给定信号保持一段时间，零阶保持器的时域表达式为：  </p><script type="math/tex; mode=display">u(t)-u(t-T)</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220412171533.png width=50%>  </p><p>对其进行拉普拉斯变换：  </p><script type="math/tex; mode=display">ZOH(s)=\frac{1-e^{-Ts}}{s}</script><p>在数字控制系统中，零阶保持器可以将数字信号在每个抽样时刻保持这个抽样值并持续抽样周期$T$时长来实现数字信号到模拟信号的转换。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220419141742.png width=50%>   </p><p>则整个系统的传输方程：  </p><script type="math/tex; mode=display">G_{ZA}(s)=ZOH(s)G(s)</script><p>如果零阶保持器和被控对象看做一个整体，对其进行z变换（即将整个系统放在z域中查看），得到：  </p><script type="math/tex; mode=display">G_{ZA}(z)=\frac{z-1}{z}𝒵[\frac{G(s)}{s}]</script><p>$𝒵[⋅]$表示z变换。<br>上述公式称为零阶保持器的离散化公式。  </p><h3 id="级联系统分析"><a href="#级联系统分析" class="headerlink" title="级联系统分析"></a>级联系统分析</h3><p>如果每个子系统分别采样(模数转换)后级联，那么系统的传递函数可以表示为：  </p><script type="math/tex; mode=display">G(z)=𝒵[G_1(s)]𝒵[G_2(s)]=G_1(z)G_2(z)</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220420155645.png width=50%></p><p>如果每个子系统先级联，最后整个做采样（模数转换），那么系统的传递函数可以表示为：  </p><script type="math/tex; mode=display">G(z)=𝒵[G_1(s)G_2(s)]</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220420155847.png width=50%>  </p><h2 id="数字控制系统的分析"><a href="#数字控制系统的分析" class="headerlink" title="数字控制系统的分析"></a>数字控制系统的分析</h2><h3 id="差分方程"><a href="#差分方程" class="headerlink" title="差分方程"></a>差分方程</h3><p>数字控制系统中可以使用差分方程描述系统的特性：  </p><script type="math/tex; mode=display">∑b_ky(n+k)=∑a_kx(n+k)</script><div class="note note-warning">            <p>需要注意系统的初始条件，如果规定了系统的初始条件：$y(0)≠0$、$y(1)≠0$，则应当利用z变换的时移性质：  </p><script type="math/tex; mode=display">Z[f(k+1)]=zF(z)-zf(0)</script><script type="math/tex; mode=display">Z[f(k+n)]=zF(z)-z^nf(0)-∑_{k=1}z^{n-k}f(k)</script>          </div><p>对差分方程两边做z变换，整理可以得到系统的闭环传递函数：  </p><script type="math/tex; mode=display">TF_{cl}(z)=\frac{Y(z)}{X(z)}</script><h3 id="系统类型"><a href="#系统类型" class="headerlink" title="系统类型"></a>系统类型</h3><p>对于数字控制系统，其开环传递函数可以表示为：  </p><script type="math/tex; mode=display">\frac{1}{(z-1)^N}\frac{B(z)}{A(z)}</script><p>以$(z-1)^N$中$N$对其进行分类：$N=0、1、2$时，称系统分别为0/1/2型系统。<br>不同类型的系统在不同输入时，其瞬态响应的表现是不同的。  </p><h3 id="系统的瞬态分析"><a href="#系统的瞬态分析" class="headerlink" title="系统的瞬态分析"></a>系统的瞬态分析</h3><p>数字控制系统的瞬态中同样有设置时间、峰值时间、上升时间、滞后时间、过冲率等指标，其定义与模拟控制系统的瞬态分析相同。</p><h3 id="稳态误差"><a href="#稳态误差" class="headerlink" title="稳态误差"></a>稳态误差</h3><p>和模拟控制系统一样，定义数字系统的稳态误差为：  </p><script type="math/tex; mode=display">e_{ss}=1-\lim_{z→1}(z-1)Y(z)=1-\lim_{z→1}(z-1)TF_{cl}(z)U(z)</script><p>$TF_{cl}(z)$是系统的闭环传递函数。  </p><p>同样地，可以根据系统输入为阶跃序列、斜坡序列、圆锥序列时，其稳态误差是：  </p><div class="table-container"><table><thead><tr><th style="text-align:center">系统类型</th><th style="text-align:center">位置误差 <br> $r(n)=1$ <br></th><th style="text-align:center">速度误差 <br> $r(n)=n$ <br></th><th style="text-align:center">加速度误差 <br> $r(n)=\frac{1}{2}n^2$</th></tr></thead><tbody><tr><td style="text-align:center">0型</td><td style="text-align:center">$\frac{1}{1+K_p}$</td><td style="text-align:center">$∞$</td><td style="text-align:center">$∞$</td></tr><tr><td style="text-align:center">I型</td><td style="text-align:center">$0$</td><td style="text-align:center">$\frac{1}{K_v}$</td><td style="text-align:center">$∞$</td></tr><tr><td style="text-align:center">II型</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$\frac{1}{K_a}$</td></tr></tbody></table></div><p>其中的静态位置误差常数$K_p$：</p><script type="math/tex; mode=display">K_p=\lim_{z→1}G(z)H(z)</script><p>静态速度误差常数：  </p><script type="math/tex; mode=display">K_v=\lim_{z→1}\frac{(1-z^{-1})G(z)H(z)}{T}</script><p>静态加速度误差常数：  </p><script type="math/tex; mode=display">K_a=\lim_{z→1}\frac{(1-z^{-1})^2G(z)H(z)}{T^2}</script>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>控制系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1.移动通信概述</title>
    <link href="/2022/04/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/1.%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/"/>
    <url>/2022/04/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/1.%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="1e00748041323a920000cb0d145c4b4c3569f26dc5726a037c5afa507c247b43">d23a4056e39b7e810998c80d99c7e17f86f9f2d02bab1f8b5f4197996369e4efa5117704ae69046b9160541c97ed22240d690618075d82cfb9a5255a8d2cd2010df53794364f472049f6bbb43116dd8b24df1fd53f77b0a64ca4bcf968339ab994aa43c5e393ae24029e499b72775ec55a9237363d54f95f8807b483f6c594de2c41db6b54117649735dcbace52109921b6b221a8afe41cad4a3b1f9cd3e263e2cb62b95c23efa482a51c34098d7eb73c21a068d2414d50e34042b6021de49bdb07fb2671ffb9235c6168d605132faca833a5082bb2581fe2cd8ab599ba53aecfd9934213a0cfc485854c563a32b107ab024cdb29f8c06318bfbceec3c91a59a66d1befcb1ed2d305b494f3fb0cf4aa48d00fde33fd520b197e3e943865aea950b8e0408daba40b8dde5269320df4c8c3ab1e5abb1d75a216a00eb3a83452a808e5492aab714a0ceb23f2e2948e6e6ce4066c15387a10295bf3b2f35eb27fb311bae477aaf8a4ea3dc0f22314a7c17012a8324e31154b767b418e7fadf2c38e9a51727ddf8045a6ef897e2d2b6a6d4d5999ff197c3e5d0a8c21155be6899fb184fc27c96ec1258197b1cdb7e80efe545e68810c0b6316ef5797d3b2ce6f49827e48b3546ac61774394031024603753cfb4d8cd5200ea92ac4db34df5d6519388021ba5eaab0b90c8d15ff6936b7e632f432eebea227e61a31fe96b2e150d925db5f47f1cc059f1264f2cdc5318e64b65a498f8461eb88e013e035189bc9900fcef22cea269f3318c0469c8fff041b54c09f1b1a374147845dd23cd0dae292718efd9b1421fdaf946ad152c848b7380916b146f2a3752c44a37475c87c09ab1d8a7ce0b6920791d3298d51a75368ba207497ec8470656f0ef24d93f0a11030148ec4402f44eeaf055cf3af97ab1e504be474f88c80d36ea19e38ed4ba575b37dadb4a2a23525459a72902352a014efcc7cb91478ef8006d79d7460ac958ac56f8601e4797a39010cb6ad286476b36bb28ed708db73f6450a170a8447190eb4ce4187156fe3a8522bc9a6e3a9b7559aa5f96544fbda5ed5c8835aa7762d08d30a761b2b8dce93e8177ecc6a9d1003fee76ceff5b13ed051b94b67ed5fabd878a086d66cb9a89d20d4bf88bf1bae8e76ffcde42c21707ff7f2728dfc42ce35d51d08685990a4b64a493ca3445a87b716adf85de0ff53b8791204097c16043cc9160625b03108e9baf5b809b1e07e46536b38e8e0716e81c794214c4a0174afd3e9cb18f7efc54e59b1eb9495d72e4587738f12e73f75030324bafadb8e0433a537ea54703ab9c505da6ec4026e3682460f9f17370e039c752581970ad4f2c1122baa3ba7ea2e2c2573ec437fde3e51da272d0926eaebef04ceb6dcb2651981a82ed89048e1bf366e7aa43e5383b2bed5857bed6cad84b0464b1d3157041c4f8c73c937919665b2aa591afbda01eb793e00d4f44354aee3a0b895532519fa5f1657e495a3e1265f6d10c9fdd2ac819145c64bfa172190a9130af203268ef2a4041f5e572de0757c221993db54c0dc0220878b634cb1ae1e62d6774f8c23b6119e99f88a71639b4173806ae66086aa5fbb75a14b8b73f14ed12b2efd488348a3f04cdab466e915a12f8db4615ab2749c45a0027aae1762d0d51c95511a9937e8e333eed68582ed9776c12baaaab63593165223fa895731bbf908d43201e733752905f14f146e22081244fed5f9418fb2a7e47ee5511d99f541084a4692bdd165b5f4b7c123c1d16c13018eb3a0fdc5fa27430cb5eed2e7043b5db76cbb702e5cd5e5c90667db76d3fa4925e6ee157da0c11e670151b0cb5aa9bddeccc32acefdabb1df39ddc33cf8186617dce19f71c5656d67f07e378bb7e3844e853f9f6edfc29bf0099f9153460f1e8e15fe719a0b82af4fedb727d87ea6026be7acdb92d80a7c3087005854e3d5a6e973edab8246fdccae8371941f4ecec656120b48f34ebe81b3bccf2d7b17b31d8de31360672be0f6bf9294036460825c66414c4201bbb84ce4ee2ad1ee3d29c276237eef296eee742b4273a141e7f4abc73bae91e650d94b82dfe4970ee358b795925f01745401dec248f1b3576fc9dbfcb12a16794df9283de1d44dfb9d834aaaaf29a7de5104ee8a4190b00feef3156ad402f241ef0bd17da833a7ca9eabb595e44595c6a172fba25855bcc324cf51a87211d43c03e361acd7e7d63a32b878018ee84c1268df7897057bed91eb48d90e8547ef83375221a83952b284de6ba91075e315194f3399832b3d2a24629e1192c35126be2b113ba2f571f97c03bdca786178ef80e51354852a62270573bb5dc0adfc8dd1404ae3f90ba5ac37baab14d52ccaa90b6fa8b2881599f8f50d7d983765848d4a9d146937bbba89dd4107a76594998f49bf3ff26001f5ed633e23a7815c760fee08dce633386f07cb79e1073b486d1f6e49d14a38c13b1a5cb6b9b2ec5f852baaa0d9281e974f0219f6fd6522a3059e9df32384763892e9e349488ff7a612e50e2d1a6d3722a1384a8b32a41b838c6f0921aca08751faffae888edbdc993523f5774b8db862814ba08760a7d51d3696ead2687597687745335103c82309a8b6a76e3ce5e4c2709a176d17926c6608ec169717a298c45d3d97308521ff6b9d3accff3308c2df0c25f6c6a989fcc5f1c0b856bf0794a1456a672b172089fba784405415c6f53fdbd9e219a1012a49e2531f531029a06bb2175a1778492c9eafe4eb16784b9e18a9e7b855131354598ed05fd85097ae27f0a5828d722c8c92956f4119050a3f68d79cfffa495b5e782c9cb611058b06c3dcd48eba275409ed4c7b1863f2e72c51ee53204b8e0af21f90ed3834aadf46c8e67cb9e4e8bc3577b1ebb2859cb303f9fff5b18b45f17ae5d81e592baded612440749420c003847c5ec853e0327bfca853b346d4c271209b21098fdb94037182a350877024aa858ff11167a85b5e4d01de2db1cc83b4a0df1809c76612493c3ac83cf906ecf24bd0397d098a27dd9b658a67b4a19987afbad89d6b505d17bb381389b6ca9b7f8449b897952f5058d7f74fc47ddc0162ba90ee992be63274496e1bf7e43aa23bb5e10350fbe5d9aae9b29d17bd5715a12fafdd4da576f519ce94c0e5ce2768c9e7f9db15ed48e9848e01624fc295e82c4b9c1d98863c3df1840c588cf43355193a7c1c7ee9d0b154f8e9bafc8e3ae9f9310c2075d94878ed325fc979220804e923c5bdc9dc6392e3b27ee0164bfcd398f294361e43a87aca391dbb12b61d8233f4ca523cf52ce69e950475843fa05371af4edfd0ae232e21a1a709133cfbba1d3a257944c19932a95eff3e2d127236b27f254167fcac44bfadac0f719011f9d3b05e9f8a525602da3606831a30acec60b06e9c2abc8dceca7937e651a1ac190eba9d7b0c9a91098a9f7cd4fb5326b4bd3d7000b51c4124532fc8122fd8557d3c90e9ef154de50da5a3fa84ec261cf49868e0f5a844fc3ab4e8dd38df0dd1e9cd7e26211ba907bf9aa3e1db03ed536b7a9d1af777bb56202e273d9229e9672e2233b62643df3265b8a05744dce35025fd1fae2036eefe773b969de8ca33fd84e7020bc897cd54f5583511ba3dc797b9906bcdccba788b75f4041c2437dd81687258ad6160fd46989f309e7b9d678f424601c23edb8704663280b552ad602cfaf3e02704fc95d6ab33416ce9c9d8b3ae7555452d40a255a631ba7316b941a3b59bf7538975c04d62d1ace6b0c202c456c8857664c0c63988ede589cbd2676be29f91fa7bee9001a58ab8a8c4cd0b12c78cdb2809203c36dd36fc324372eeda3b7d8838305c40e0abb802efa2de84343904d6781f92f33b30afd28b0cfe017f5152bfe20ad08b398a1144615024fc1165e64b1ce0d5aa40739f99d02db8bc8ee9ae7c53ee03c3a0abe57ed1711a1d7a7a17ce933c6d79dcb53b03eeb9e2dfbcd336c22b0eb7077c8f664f76d22766f3440fedb1622482635c34a378f0ec6f79c81534dd5a80202c1953ef37e07adf83d547bfcb76fe408d82fdee5662d63544c2fa972e1ffda74d3d46a570fee0c9c147ab5c37cf339d186d6b0987915f87043ee1fa2cb07a4a31b128aa9db5f346e823d603bb42fc75711c92cf1629894a524006fe9dfa852158c112aa0bc87e8165e5bf74bd2826fd06537385a7635fe58aba382200cf69aec3e7d4c8880181cc0986a282b046079d6fede31044eafb0194757c5449868bb46e48b2048f808a743e8336287885e2c8d249fd7d965e33db025cd0cba7c47bb9463cda8f3ec1478858b84fab114dd56fab65c6b50c7240670d5947326757534cee28b7c2433104dc64fa56bf5c029262b160d45c1cb46a4b1a2892900d27a08ea8c79c74f16d57fcd14d939110c96fbadfd3436076032374991b503efa84f178cfbfb796c8e78b7281ef5268b079885812a94b7e2c0cb4b83f59ef9cf2be0c5555507cb3d96ef54bad4eaa6bf3777eb0573cadd95467925171160c388444ed7500ffe2ac2ac77f18fc77ed73a9bbee8df6e2790f98c2ac7ed291995dfa2e00d254e791068221fb8366d6583d403cfe9ea082fca152b2a2a04d850367cdc2b3f586bc009178fba9610a8fab23109ebf8a03179f4e44d597b81796e38ea72158ee9ce2bf81a58fc0fd2af75fa34848b2b1c6ed82854decbf71a7421929b417bd576fb3075fd92fbc74770bd182048af329a0c75fcca05d0b6de9d407a56e572a82971d9a8dc8b087e273e4d35912df04f9fe11789ee7604a1a939dbba74339706bedd0885aa841059a4a7d872e19c67e9f991310e253498d55f186e6572cdc4d225dd175b578a4d0585b8299e9025829107fa418dcfbc049f2bb7c8c598d2575f5136e4179ed69f1dce571babbd977d9c52c9abb5e73f4380c50d4af9df5d1ec8abab026a242c28b54fcf6d1daa70908d0e752eb2c393bdd611e7c176b996ecf7437a6b8462d842d539c65f41ce925b2f03490fff9ef60d30b88baf72e0e1bda0d980cc816b4c73bd2f7d1a9f5ea02d4931728f85abb4a85edecfc984d0c382de2b15b2da15e7c375ad14033fc629b379880368c9268b5b502c6e072dd3f81762ba443640f8da846a90b2f309e1260afb31b0741962811412eb31444a1cccb75bf7eece6cc46b79fe0ba4042a600ea3ace04dd2d2481133077133b99cdb0c07cf6f752fda70cace0a45276b0708ba2321ba7f454d61379ebc752a27f3d190bb7b0b897d205d241566401ee5cea0458fa763764c24c5ea86578ce4a25700f24d577eba8ae4edf9cfa1f63c2246ce239c58e2a04cccb166fb3d3ebc3b987cd670e5a73a68ddcafe198c89e23fb5514816b3636a020dbc4f423463d7becc0ba50bb4140b555d5e9c63d6771e04cd755644da7b4d55cde87d421c40f25cbb44b9937230e8553492bf0c3375a509074a3d1cc481b6aab29b9e6c3d5ef0b93df2fb22aca4500dff47c890f4ac1ae57ba5936382b2831c953ae5d976bbb49ed7fcc60b2146d7be9f65a90851047d0fbc36d40d59f4cee956d2e957c53b82808f1af2fe29ba7c198540f36d53771874095de8fef68fbe246a160fc6cc50f7a8b37f29fc0c9000220f0627157e568facf81213e6ad4aef5b2916658a6b391231a86b91b0a2db7eb017150ce1eb60714ab3a9024bf80de1871ee26196d24895db2a2354c174582d9cecf142a71997ec801a42a46819c603e0c5620d86a5e07dfae2f66ecb179ed4211361c8c96859ddef11d1b4be6f9a79180d390a5d5b519ea305f445fffc675b1409a16dc79858c651f792c505822cfd94d9392a912ed0bd4a6bf25ad3c7f0c5d35eb7fe0173ea1ffb1d24c0449dd909bdbd0d2df8f2d7f6d884ced5837a69cac6366364468c0ac3ec598bbaad77b9dd505c220d21a7d8c163735fd6c4245dd44bcee76d78176fb5b04097acc2f35ae15146314ea7624fd868e0068a05914cf3c2b8cbbe04ae2d36e410ae26a867206db6b25196068f855159e77577be430ae965601fa1559c1af0e9c754a423078ff60c80540c46ca95dd18fc429f88fb86f8d9ae01d78d15e887adfe87ed752a9cf3a51be13e6fb50f18610e32157bdafbe06051afe32aa0334106d6fbcb086ed216dc4224a9271bf82ed516dbf2ced47edc7f302d7bc2eb9cacc087dce9094269d060808c535c9a53183170030913bb1f45104fd69d097cec14c62de1106d6a738a0676d990d2c1c02a923c12f4e39998b5c8dc3ac45d3c4a82b12add6782375eff39a87faa0b30318fccb6b8e52ddb472f6cc6212f9eed970f2e6d72b1dc6ce80a620c6e02a0f6315ed9f03fa18529c89bdc0a2113472ee6b3319082e4e7b60eb5cae554ba4340cfd5b5dd0a787dd723c53d701de5844c2eee1b62c16511c6d063adb6cb77d78dbf36790add60804b0025c503ac36ebc6c9b6c920602d81a7d7afe9e8e5866bc4721e0f54e36cd9ba2c1b037ff3a5839c0b087ee56cbfad79fc84fee5b144d673402a304764e35beadbd394ce461e3a478a897c53e8436bf5abba95051e61c4bffe5091a396d447781ebedda8a9f4327276c187efda64d1618d1e25609aa024e640bf9bc863d79320105947ca1fd8577aea0532941b1242953d757a33646a2bdd1e3fa71aedf077587724f22aaf01714504ddb7ed68f66bc5f46190f7757ca246806ab835bcba4d1ef1d47e2e6ea653a53bb3b81b3800b14bc3f1626f65a04e24eb343cc623e3195044f19ae0cea196ca8c0dec25c9c0e103b1facc4b9763e14281526dc81e55ecd5abf0b31b159b1f4f11bc2f4f5e91c15266523d75a19e17154005eae877275455d2c33721d730dd5903732d93dfcf860625ca91c9880c65746d72e4fa5112d0aa9d60130b2b8c80ab79eaa2dbb81bb24839c8cd4a36b79953c3d68b03ade65a331b960a3e7244f729997587d47dd8cb6fd3f73072a2411731fb47c7dda5ede07ea6a8a82470767f14843d60e20ed1d4723a63c24fb49f0618db1a69d08d5744c73b90c3a7825294a5f073125e39a549e479f1a28bfc89a48c3c6418056a1269e9e2c9a4786c6eae07802542fcecfb917620015d558788ca1c94efc7828d5151e0805f9e6043726121f5b88817308d8bb4cdb73751f3e3edf755a41fa7128b9e516cf552d24edb664274e68feb8d01c18160b557ffacee07a6b4e1e5e2ad307302fcf748bc5c2595a100b02ed77842b8ff3763437108f701dc4f3c782bb46df67b365fa7da7c2a14f8bfa84d47dca0adbdbf854f4bce227d9850af0164a2cc2c9d1e4a18deb78fade9eb0bda807f293051b0a132aec81ef9c320610f8b9985823fa87261aabcfa7e05b9de7fda2a4cc48a41cb182811a2d85ddaea250f4728229af9670fd2e329547eea35532eda56152f6bfe7b0837fc6ea7144b2de3f9868eb8b7b08dc4e9d5c29e24d82a1f88f6074cfb3e9628364d2aa2034354c5587e9601d3153a30b783fe3e1f08584d4ac73315d003c439746e8f10829d4a59d9226da9f5d8f7231315acd096d2396dfe20f7ce5a1ca9194494b83ae3cf684842ce9aac9424eee85bc8324927e7d4c10d96fd0a2ee8eb5f9d52a5a2b06835bc2be60a56fe24a46dc4915168e5e753ecff6414219f341e7675c8e84c0c1b34973e9f2dc07291b845b432b19c608e5e42b9aa85cea27808157887a317d80816a363e4cbf3a5e3f17bad42769e295b67434bcf9e61f3ac61fa8d16df8d6af293b1d62e13c13e01da4389e43ee3f49c55ab0658b1fc86842ee30cd3c0dcae48d2a6849a6a0b697b5855a336c7f65312753db04dfa65b6c20d948774f2319e242cc34184f3151d6ad1251c8aeae62d7bfddd5047f880ceeba73fffc12f35c50d98c2ef0a12f1947481123da63d9ddf97849901b1f90883428950e2e8eb6f566469fc5e890ff2a5d1c8db7f83e030827a849797674736b9e03c8b2144e2c3e21d22d1181db97685ebcb00008031b8ee6a5d4172c902e84e19fbf27ca5989cd47ee63491dcce08c5511be45990f725b43d2059aaf95247855465ef82555e8102c4c653cd502a9f8fa3c99cd45a559519292591c1335e9d22eccf60913d6ce1e75b8c1359d9e92057b387fd3206491d536cdc77603f99f29f204389b4a8f45192fc07d61c37cccee63409f93e0d9c2bfc2636caf1632dae9e7a0885f13c0fdfccec6a08b78e680b4a117539ea23f29131589e609a77dff3de76f9680821473334da37d0747fe2d921cc55f666a45d552f6aa14b8c6dce95ec38b5c8271b425005ff12bb5c0e0d969133260654e986dc5038021406444e042a6a968c47a4e0a33325a2ad4747280d42d26d98240bc824dcd61f1f8e6a790f0361fbb6260bb90bf1567667a66125a701905ac4280a53723df34f507bff0b3eae3fd697fcdc5c6d80c799af2de430aed209fee557368b6b615d0fdbd34ff9f4286f94f8e464a9e1821e4a9565c5abee0e34dfaf13da462b339c6df0028b02671353c547891c2bc33a0b6234a4ba300b6a081d9ccb6ddfc6a4c70fa777fd025d6b5853465f83a9d80e896ee17bd21b1e75b42c39e09ddd2ab56f5dffac05c316840fdbd1bdf8157aa3e02dffef33b057b5d7a1cfb722366000d22d4e724d0cca5f8e4db592f10dd469ecba1e2184c0f15d5d6c91ff5b786384c88e18a1ebe4b1fbcdd59c9955e5ce2af3645c39d619594b09ac9a1be1bc0fdb929592162db0578d1ba34e53967571a1e8fe0257ed77e4559d47bcb3aaa50ec38ce1a6c92879315c7d501b68365ff29f5fa9d78c88434713b403a95c36ae687e096b0c28e574ca454b2d19d601c330472a2ca9cf4cc59350ac93ecf3194650a3b6f656ebedd7aa9dfd2f58c340bbded6afeac7b777f44c373daa4b28c33717b19125e233ff69cdb4823c8863e8753ed2d1cb87347a37393fc28ad4105c7fd668a4c6f7e0bc22125bf3e3c18ba6360d77c4180fc451638c2827bcf2ae2c20b412d2741cc9239374f715dbf8468e18772b882868d8c9d6350ce98e6b9740f4445812e983deabb0ffc28e3dfaf7bc4db0d827af1e445012276d3197f554fd4ad0afc7b0a1782104b783448677504f66a3ecf9a4495ba7b82fb18034b5c7f7be47f4709005233c2c6ac277fb64f0d02c775cf9f1ef2ee1f757a674a9876efd66cdabcdda92c73b6658ae6f410b0fe93c87d0a40342a660cc0ede74a7d91d5cb8b0805aacb183dddadf79b4f830ba6697fab2929da7b8da0572fcdd215c3d2cae60f924378e433769015ad60a4f705aba538bb0469e10911d8abae2487cd1fb73643d69e5f906a89922390f5b2819f2b9042c37e6c26857be3226df9fdbd77071f0200d2e9afc5932c79c5649ba78df1db6dd4441e8afd8650733d5e12b912624f5b180d7065ce48c43176524b07eeced72f99ac1429a0b5d36d2c6d60e427574adbd7cda914b325cac4761c57b3915a01dd15db312a188ea67eb8e514e33219e0f25c7850358845fb52152b0cb768b531c0880389e2258ffe7e5c33438f1e6e965f08aad84f8d523a452e979cdac33579b39548b6f2c72d86e7c6a21a96ca1cf0a8ebeb05a6d36426e1647690b17026a6b5d0316523c3429d24c8342c2fb58a45b6aca1d46b9358e51726c3a00636755ba10010938023cd2f401ccc827260c0f192208b5ed307bdd499fe0cdaf0e77270962735b39f07321c4877d793479ca5127946fae833f5489d416a1bb8b2ef5d4014b70defd026668cc4c0057c3d253034b79e6595cb3e4b4a5eb212010b338721a9a6d3b8dc525cd99322371d906124cdbe63b58a9fe181f3ebcdf6c6855d9187415100a9de7c739670816ba667079f5f0ac85d59161c1ad0caf0a0265f882aea44042d9e94dbc53c66ff1ea3ca5d6ed1c5625b51a6f692370ca22460ee7e41018aa8b5595be85c939e2cfd60da5f87c2b6458b5f27c665736304df66063fb9d7f441944475c615ad05b112597b1b2f0d7532d36db7c09dbef603c5e57267c133b13d6932709fa6574802422657aaf2a0bc24814ae475a1fbd9344974e46ff652dbb73cd8294a3831479c14a5521b6c17203a23174e9b00d19e174491fe67426600602920662c909263802e9ab5753952be698b00331be22aa002c393341f481baa71c4278c9127d744c6a55d6d69ece7e7641781e6d1499e321c9288bba3102ab93843e252ee7019f7616e71794858194e0b82da98abee6e7933ff3cb3df72058b2dea2d2a88e94818bbb283641fba50e4271028835d149bc392ad406c6fdc071f9dcc6db63604ce85aceda73fb7303fb4caa1ee42a3d1bf7c3ec97eb100ecbed42af11303f8da9952728ca4b2fcd62e6856bffdc33d09bdeaade4a4b61dda7b4eda26f8b5bfd2b4c48507661149321805ce6bc567f412c3718a99ae532ab103c8e4f4b038d64e1a8e163418b5394c959b09ee358bf0c43e08899ddae4875b2e8d1f9bba0d30f743f1bbf9ed03c73ce55ae3bfd7cda8153f8a4a0ad2aa2cbf5d363fffd94dd0a2155f082a536b12646bcd8dc80922c7ca2d43890e23d5f1c2e1c696c079c8f53ccad4ab1c89639ae3981438bd089997b49828778a918de3d19019527625f440949c05a152fd2690c151600123df9d5e3437b52a21b443e0ae3983b09752d3bd563746a68ce7d946c07a76b69dccad8a8a0422cdc418d266da4c5fbfaeb2a8e86435beeccd6921c5522efb064d169b91085d95da42ba886c1745b53366b74d862f2e648a1d17644b9594ffe33358ce7ee9d4a01a27d2fb2e9d3608676714c09cecc52e336c2cf1357c6e690cf76f455026ff10abfbcf2130c3d34da5277cf428e354dc12d8335cdb13e324c60a3396ab3ecea0ef8cb7d87fa5505b4908d8567fc6a5f7d537234825042b282db02160a999ac6dc018899d0b6c651dbfec76f59ed1f16b7e8146ff4ee0fe3e3b8b29ded955328fb2e65e33096f846962bf3dcab7818aaba6ed5270eda2d790b8e3081af15dd5cb0734459a619bd1f0178e88ec1372fe679edddcbae601fe6ab829a83c28c44f2cc32bcec273ae010904ff73c8c1061d62d8c37a3eac941667ce5252b25d19e7db534b2fffee085f59cc3aa07be470273d3d86b283f732b6151d300f3748e7aa5ac4f67010c64a880f74bf613ca4ed3e0ba9a37bc30c57af40fd9c9a5e4a276a33402219716d9243e1a76ea04e840f145ea04a0236ea5f08062c9fea09fadea2a57caa0694da37ce1a9432ea091eb06e90be93c650ca3b134f2e01e3f053e2ca319d0f767270f41dd8fdc210271c4d957254353497c83f5c05e9a5dcc488acc86fddaa33b130b45499b4ee41d72df2af0395600523d86211ba663953aca69274f5f106f4d7501c9651897bedf8e832b887c85e26375bd08611c4d50d476225732045eaff3edd655beefef9a1411ca80f633887f1f7d230d1db6833e4f5a6119992be47119009fe8911206467202c64bbf91457cf2ef3ad7fb9ad58d95118236f4890ad2bb37cd41d7c9a90142026e24889f9335a292ce3046048abe58e4a8d206699f71edd21b643c5a462ac2b568978ce4dddfa4144d72785fe06b69bf45854bffb4423cced276e8b7366b1fa80b9381a6ceb0892e12804adfbadcd433b302757402620ae98f3202f15c6b4bc84463fa88a64b38ef946b636e2731cf2538e74c5d8fb434390ad4704a4ac9fb235f17011806098d5194af07bc4718277563769c3d2e11f17941320fe879193a3396d354e018308da346e1476e6f5f30804ebfb37185ed9db68e9052aead863f80494537ab8bfad2f512e68e387e589619a6768677e437146abf2ba172247f533435fbc9b753cb86f09aa660964bc7dbefd936d394ab4f79412aafe0c5a923af2981dd2a7d5209da0614fdbf1348b1f5d27c926a0e6dfb8de524fefc224d3795746ed7d8c77f039bb9958028afd1ddd23a242d811ab0acef527e7e68aff0d72a93ad3e146c341800ab00bcd2f53470fe1c05becba60f50ddb3f6b1b53cb9c15381585ad42c2fcfac4d219e074796f78dc495f4bb64afc889017a0d2ea495fae2d026a87f8cdbe07cd7437bc95585dc31caf32621fa8589142e35cf003cd109f79383c246fc6cd8af624c4ef4a96509a8ec091c0daabba1faff61fe11253147a2d1402110557f82f0481d4d023128900edf3861da4682527a7eda7a2aac679837c667a52d3758a670e1fa32ba2ef25c6537ba3a0bad2cda49acdfafd3e1df56f5035cff9a8c0879a001304e867ec80a092ab908e99393a982e3295da65ba69160585e3237916d022a4e7d8d552c043872a067794da703620bbd9e55f467a91b73af90cea24408de7efbeb557c9ff73161cc0d98252dd736132d3678c49e83a2ce94e2346e33687daf2a9b27621fc53e7a3721c204338929d4de363b632059ad66ebdfbac4f8087ed4cdb0c101655b7069b7550eb9353f25f54b034cc84f369bbc26600b3281f8c4f1212d4b109f0dc1e3141e37316256554781f24051899a4829b607a87aadbe615ff0dbde63ab1b4def0a0ca04b9694387cf76c043104c2e3c10802f635507bc53d7aa226384dced909b29a945479c4fca700ae2ae92ef2cf264b2e2162bd5b4862dd544ea44882a08c2c5e0ea32c676b4e1ff548f056f423604c1f92f288b1685e2f620d6b61e605f3c2b180139eb6ebc78f56b85cb7e4b7d5a78b309a6ee89cff38bbe2a8e0f56300313499cac3e2f7c21e2aa2f14b583dd3fa2958b1cdc4f55695e39576954bc41e58bc2fa9ba08d30bcbdadcc37bb1c2d62ce5dbe2b5ed76facd87c84d178763ca1c32c701568876156fce928815e6843273d1fb28dd40e732a861f4c8e8e6611bba663161ae597692fa126a3c5e399a5a96460f16c2843847c4b8d5259688757e1ed9dc5181e2be4ae5fd86289ed1a3745387d7dc14b1e344032b58f3585e07c231079d0fb45439da1ca5573e915835201ad0ac602d5a68028a8ccd67ddbcd119a4211e20ec7dbd9db96e83a54f36792f10d731ba42c85f12958cca671a1143bb4b1135b66e98c6f3e5fa2134199d72d4a13e7084ad23e31671f754a532d662f1b5e085d137952a0d27d7ade750f75a9c31f3820626fd883dde726f1f5bbe0f26d36f87ff1e7c3cee4c45a4209250090934a3394d0c27f24787318a7ed081ab26ed8d4ca897bb85660f54651fe9f1dd9a405290314aec0d0143ff4d3da88f21dea080a16937feee8be91b7b8c3b3e2a3019087a47b62ef8c01af5569dd03a3b2ac90e7e9be07212751a74913411b08c6ab4ef13302a6608f678c1191f3020b4afc63d1a54b01f97c3dc0a67c2bf49918f1823c450fcf4abcae1feaad2425c1179c20585ce4de2b15f383241a45dac2e12e0b3e39f1acfd430b25b3b384f94c1f9a375510c3e6b8ab046ff5f62e6ca585023f35a9b50ad273208102518ff17dda52d61bf284b7572a2d0fe0148153e96d2ab07c25c3e6662f0c084364c1ba0c54d6d027fb3cfb05dc80e1a009edc191db52e3ddd31416090780dda451b75eb5ff61ab5f15b4e19aa04930d24ea761e1dd30632ab44431b382ed6498fffe8f9c70527757fa6907c4f12e0de9e2a8d55bf8f8a5b9db22903ac459047320f690a0549263419fa5a436b8cc7c73728a8f2b94b8fbe29ebf540db9750105d523eca017019b585c1edc9b974be9a1fe4a3bb0263432ee550720bdab2a2be04802cafe16d49f8eb574ebacf2e04952dc4ec4f500c8c4dd131098d6ba339e0ec7383b47d6fdcc28bd14ec516197b0496a5a8560faa6c98783fdfc25664319a9652c26e508bed19c15dd19cd65ca2711c9e0f7d75fbd3d51ca4e7dc91fbd0e608a1211887ad6ad536b95560fd76a80efd1d2d61cdbbd07952ed0cb72c55b1ac0f0fd6686865efb3fc4b7ba2dd8b43f6ebb733fb492b89295b6bcdbf39fc949bf778b2ca39b77a61a818b249ece21eb4abc26b623c9a70a94b5865aba7dd18c63865617518eb97efdff1587e89d8a521382a06df7eae59eed3704eddc584e6671e5a10c4ac931ae716fef2ae87bd5c77c9b632f8513277eef544f0a08ba97418879dc58123e3a855c4a3d80e0ddd486724f6860669df2f36a9cd55b7d79730db68bb6a1ee42746574ee253e5af7798a8880b0e3c5596b289b90108860efc2898a81a842e896fc9872f040cedc805fcc11ff920b1337660ed3b0957e7c2892eb59a96aadf00a425c962d13ec641424d753b3bea5665a296dd5e80eb0928d36e6f584c1a703f0e930969d31609b8379a6727f3bd504f64675f5c9b950b607475fa2381ed360fa09bc01f86cae32deae2d637f7e2550afd834f9cc497806d00391683b7fd1519da798ccdf15a59556396aa324c234d6acbc4ba8bc521032948f8a67e42b46b2ccfe39d80e368538ada98c98f07ec303b871779aba392ebd5150535b46829d44f31065d1d4ed80641473fddafc10556680fe2fffa31668822fc1c1310a94a33010a485ee1ff264ca98b0e8927fb6e31b9205464a4673cd825239e1f265c1787740faf1e6767559eb6293bf60f37a320ad33526b63ff0d389b82dfd444fef596a5436582e657dbb162bf7132343580d81adabec2393e65b9ef1886993d6233be6fcf27b3032bd1343eaad67ee44ef74368a2b4feaa1c4d1ee11a17b0abbe0e90284039a23323d7efff4619dc00045cc6b94180a1041df5b6d5fa76bb84bec13116249ea4b131cdd19c8516b1859c3b56b409048eeacf965b69995cb395a10235e11a0401975497fa851a72b64c1b03a2acbfa0f2a7c0a4a3556867eb7e91e4fd49668c565bcb8bf07969cd71d05c44648a537978d3cb25b0c276035339a78eee4291fdabb38c2c7d78a7fd3c1cecd9add7fe3fb791218daed36627d1bd3bc2aa1e454b1860f112e0e219a871b26fd1abcf2e7e23b8f18304b970a50be19f1297ba9af4e714e8d4b28589752ee6766d1255c080528abfd7d6c4588d2e9587b0345f9feab4adc82df93d33811a9af7230a94f2d0196e2f54b998e5e6aaaaaf32bd4600762c9be4a8f739a49afccdedc5b62b9de93cccb1a26dc0dcbae936e0058a5beaae8d5996fe339e9d29116fb833e42e50002723e58d8902aa4b76429fb0234868cfb57b3f78e84b79f2273cc40d3e8b1fb22840291e5504cab1fe31b7ca305c3546c8188d3c89e1f007d8b38b76d1e8d84f9c9333add6dbd18e9f20ede0d3f6621a762f5cc543d14a0dbf406620807a5331b90fb68802cb1cef435281a434e0d9b6f02b89ae435ea0601c371cee2417228d135e7a06c468b22bd9ea3de2acbde79b6328a450c5ac614aac31610784590a3107112559c63d0d5b524446ad54ee7aac65a54cec788ac794eaad5aaa472fb35175fe593445eaa14aa4af050be1206c9ed524ff37dbb73c55b0b07bb99706eec42ba9ade50f68722ee847ed44d8fda417ab982889d77e91024983dbeb128152d135454b3341c76ee66daa6145858226e572e921161a949ce793ef8ed5b0885eb7e0d2fc393d1f1dfc5d7225b3adc6c174973c0fae23ed6af9cef752382fc563af911019f6521ce11ec57b49e7f11a0a26350ca83ad4d6f1f9ccfd5ed649e00f97bb4348f160ca339418edf465738eea681a506389f66d7eea57359ae9af6cec8fc41e89fbf0e38034d5cf5d306abab139b648ba49d3b8fed631a9aee7e4053bac313b188b74063daa8263a87c7ca49ad7e2195d1125639939e41bc81d58096e823a560d78aeacb5df97a09cb4494f7fc0b0f668534e206c3d36f76bc5cbda6cb17dc1e764fa5cceb5ded179ae97d9cc810016d8b8853070209e70b950996671d73d783da2b2d953bf6ed6c2cbd1d2959bf0b7045606c549aca086edf912b5c1b61504c19595b345dbad0fe9af86a5b9a8f563bca2646a46d1211da053e31c750a96cb280e8476b4fd75535f241bf63042afb4455d58c5689a69237b804a4dcd7694ca5928dc9ddc770a3c9a4a97d4d226e291ea96d90c69c3d5cdc8985be54b5355d19948e604e752f740dec14167da368176896b9d3887efd92b8e0604f261b0fa41ac01552fa838134b83a114a45288cfc23a9932606091138a77dc9f0986682c1a0f73e6ea8755308ef9a372f977ef047baafcde75214898707941cd5d6a12a3335a775aefa4565d2d5a43675e45eb3754746c31a125745edbd8d69fb4c79e7210080e217fa3fbbf8a5f4e3726f81f736c6c991defa7e3623f8558ab158138688579be384c2876e0976ba3873d46b3bed10054004e4f5d75b620b316356d9cc62665d8c54d417810b650d5e59713dae3aae4dd9e73cbc3bc2317d7ba952e4eec00cc4517808b5d887c3d65f474d3a74208329429935f3d85a4243825d13ad60fcc80d57ddf76184eb0fb9c506f974672543dbd82e3997c6ae1e5376090ce70390e93b4fa509e717a021bbd248eb650382e261c4ee9c6e9232d7a83425bca5e3892ba591a1e4f4d71b351010b5552dfecb49a87ff74a2dd090e525aede6f4df18078f19ba2abacd18a0b1eb5ee4fea4c43df66463ae5724a74853a02183db419c902e63f873bca93affa90304df4e162289e04bf023a60250bc27363352823de908156cb40a0fa10393be72c54ef019d0e3c34e7c60a7c23873c972567295a8de9564c3f1798c52d23a2d60ea637d7c0a65c9de3ea592c1d91e934fc24642a63136c245e470f4ca9d505463ec7251760b8aac73a957354545f5eba9f0b375a94e6ed1bec04e2d79edae608b528bd3bba87c37ca4b61a49fcf10aba8137c1e85be61a547f45b8fcb639c1c5274cc6dadafb5927d98be0354299c6b2284b9950cb1b7ea1009f58029d731982cfd06f5f1d5f9f9e103165522b4cddece38a519487db8b61c05f4d6ec6fefbb97a919b5948ac8eecb89084f573aab18c8bcd28adefac82ff5920890bceb42c05c463d7387e55077c27cf3a62bd8166540f10f529801b6011d07cd91e4700cc2c33f6f3595d54296756c33dec3ac5841f053f2ddcedcaad713423c31b3386d13d3b0fa79e59a9e9f40930692d06e49a1ecc51cb7a5737b3563559522fc224380d8b9d34f14586e6e517e83f9ca68f8f79c778d8a00623b6bfb5869aaa087df6253ac70096d585e6b6b7eb1ab69dcd8972a0e4d79c6ecfee88f2ecc6ebb3011e6aab8f364fccb817bccb006d1085853ef5b33d79b07bf489f7d7e02e006218e67eaf71a162cf380870aa229f6d7246432270413468d381c9446507ab1a56a910755f61d9d2363d7f6711cc1c775c752f1fced121a7d189b0dfce780e7cf259f9937bb15a4d3b1953253b610915271882d43e7cf8ef3dd56c0b8fc83045a430626f521ef5d9b49ead425a1e659f5c71f2179e172a12573b1c87829aa3c4677e07d006fb2695f207ef1d75ad56e58afcc10502823af130c09addb7617c219418dfd7189e3be72dc4f980c646339194c958ab23a441b7e72f04db151d4098102165ab60c2a754fddf42df672922bc0e17c420120d196efaa2d7ca93d7b3d318fec8179043efd0b3f9d9a6d9adfbaaa46764c489330fd99bb8dbd2689cff4e8feda99f4ae4fe39c8c58b3af6f0bf2a1b59d8d5579d7b4368670b3ed4e174da59bdc5d6aafbd6b4657672b2bc11c4872f005d1eccfda1dfe4a390cd8d84ab7d7b67e9de48ddae3ec082e2a94fc1a97a16607557ac149eb6986732ac09b841c89a4d8427cc5b5d0940c8ebea88007421af4e5a16a9fdfcd2f5302fbc057906f7932ca1f35aec73a94e925e8c7ad4f73bd70ce31019380e4f0b18a8654ddc5cbb6f07730345e35f5c675d88c4979d4e9ae9b0227d7c19e967528fa38a78b8863048eb6fbb4afdaabb9b83f5b5b4ab888737bc21bb3e5cd63eaa922e0896903d630d2e0c69d2ac8a345746545893f5eaf163320e3817482ba8b31b2d7a31f73ea16afe3139b3d988b5c2ba3cc7b164deee537a6c41c57cb696b20dad9134aa84084b72a18b74b6f5be66da90c78bbfffdda25d8d44c5a5b3b503877c8990d68262f68996b4b830955ff1ad6ed47c3bb1041e488f056d1eebe45db9fc82e974e54fa4b6524d8525bc611040ef5168a6d1fd86c24e4f08e4bed8ba38e2ae76728afed2556e915dded21b0c2e5c39abf7b14f29569bad0b14554f9ba434cb660c26914b94d2269a599082d44a4ab50c8b4c48abe1d28e7d082829068b880ee0eb22f030a6842131b59abd2d9c6ca5fe40862e8fd9db4ff2fcc8251e880971ec118bb145ae6dc862bd3db11c51a64e59bdf9aa36cf2745dc91f5f9733e5aee4143953fd7db4c23f203ad8d937443e75c2069d3daff7a01fe2ba71db19314317b0361c9216513b4fa91225cfc9ce6a856ffcdc1694ee78ace0dd001833e570ba422ea872d1e1e6755fd8df7a5d8963c523cdc2ab01323b23ce9ffdeca2095df56143f18024ccb1d179758c65f5a0b7183a1263b09112c463b75f3e1be7b80be98086e04f1b2ff1f96f482587ab6106a48566b8afbc3e18c5cfa577818ba080d261dbe2691f9ed86cc6badb76bae59feaa5c80f9a9bd5f1029d642b650cd8a1903663f706cd3cb483246c4153ed3d01c8a919a3e9871fa4acfeae21c34119a9a4ba2b16f03befc4815dee3d83ebf597f6cf9f5bf7e25a6265be8142cd7e9b40ce2f1a9469b08a13c4b092d936981cdc25bf185a4761ee3ecf8aa09b937a6f03788f19882d98b536e3c450ec84981fbda7f68dbef8c6b007cfeed93f4465b8cc5d84c48bd7a0666ce0ca59f1761e59e58235d1eb5a8af0add8b7e851395e62f22dc9e16d278da86d45cafa5780ff9bf83dd4ab13e12255551d1c2fef069b9d7d68a1d085736a17be88295c8b04cb7eb4259f67e1c7b6e673a581b81b66b4f72b60adadc9895ab55b14b8dc472c77d96a69f7d804a09910a10458fa94a78e19081e5dda78340db30bbf90263a3640768a0140b53f945f305b45070a9253a9b79e48c9650d057226d2f6782930ddc9071d639f127d3b593207ef46b96221c83623ecf6a9db60d91c5cd60f2926692b64b697f8264617b2716ab234df1fe9eaa02bf899509563105d7652afd173e65788dca44b7f98af6f51983f48374db4c60f6d01a8dd9538681b1c592d66c17f4bfc3f6e6fc0310b584e5c13af8c254d3d4e98c37cccfcfbba0a61c019d73fa848d369719c1093cbe8193acd779db9dcf6b95aa86f0f331bb81b6beaa67beb9e5982b2353d6fe22f5f330743e49a865e76729a2f12832dc8fc413d09b117ea01343375450f6b8411a3ede08cb0dd5c21cc88fab6904b84453791fead380283b3e5b477ad55dbe81a52405d171d99891640455bfc6f82f496765598a6f4a5443ebffd42ed6ae6612fc1da4332883be66f84c06fcc04d0bd706e5d794b5992b6b56af49b5fbc0d5a5da84f30e75ac9604ab25b660b6531a9c13b6279256ff3ce0363981ccefa3ecdc659de9265b66a0a47f992c683e8a267ffe2d87959f38ceba1668cf6227beb55ae362526226af446cdf406dabda009351aa4944dd930608f7acb79c119144687ca76e7b0b7d30cc71ac54ee0ec62ec1e4919ea639923473d4fa849cf9c38bf68d2eac96d6f8eca27a89b4c504c68726072a33c08196c06170bc811bee5cace2fea1c4c9d93421cf64c9353fdc3bcbad8db05bd9b14a3c343fa1cc7f0065b08705788b778fec0874261ae2e49db29c0f7c17b1486e81a78bc79d70eac8d29f9715d8ca9e91186e24ba208d124117e69870a594ded202d471a67ae982fbaa27495b9d8b1d1b5398b4299b417888be215b9e8ea6c9e441b7fb39bb230185ccd7830d59cd6eb6f2df07c472148af09f601e06abeeee4349fa9b06eb73805a8b02e3a9607547802cdd99174de4a9a1aa1ce4e5067dcbacd6d470dfd644d00209cf657f7f33695ab16d2e14ef4560008c386c81abe2a24dc07492c56944795951e4aa4f82e3f82d8c9870756b6ac09215fbd500fdbd9ce4e7e2447ff3d09136b2b90725599ed09a823838fbff633ade4f6bedc83c42cd755f6f66534aa9ce64b31287901730992ea870471f3eccfd2fc317c9b9be433c434e57b65a184e40710c53798a4d36c0c862ad81f4c6648fb6aa0977fac2204f005af1e9c89443fedd19a4a7e04436afaadb127dd69cdca043bf4bc8eed82531a79da5f40ec1d9a13251b96b80d195ab0171d40a6a76faecda5937766862f3810ff9b68c013e26b27eaf96c3628568262155ac971ff4aef6b6cb49b7dabc9c6921aaed4e78528838e583cdc40f9bc58450701d208cbc3503937db9a24b210c59d7c706ea90d3310b4e606041f56ba487b76f8473c53dfb5c146bae9fddcbd08edf257de39010320550f5db65cf71fe7763b7a144b719e2febec65e77cf4975ead3d2e53d6f36cc612452e014ecc53e32ae31e2798505e85bdb2a43f0cf3c1d63d0571de8c769b324c00c887059edf62afc845595c8ef8f21626943f5cc85c88915e1ce6b6693e406ba4785ead7cf26ce2ed6f6c3d8f7292ab9e13a73d36cfe5187d93ddc2dc32b52c155b4c7a44e8947156d05a3cc7c99f051166edeb2a5fc15e1a6d4a24ddd0cfdf77902d4c1baba79e396f3c7c566d10bad497bb3884af722f8a6f44b42db1e17ac3189e4e6f03fb1991fcf9ae5c8b7975d58c19a9a7f369fcad74e59f3d1f973d3703792612ecfdf37faa9963720ea3890770205a56df86189c1e700608866a8b762db9907671579f71a4de066abe8779448d708d22be5442348e1b969305850f3b42295275542f554fe9f46de41305dbe7214a9cded44c9120c5f37e25741ad20f6d6f937b26413d22a453e348b254374c78dd919e24e911e5f74523a00f39dbfda5c5a379e83d7bc4819bc958aa25a6ab44461c738d53241bd9181641749cc815796367acdad8ad6b4f8f83598461d370f1ee3375f1490107ecb0e090f89cf20651e810447ed69458cb04151f1d8a3c626a5186b3ea0c0bd89fb5eaada665865e957d691c6a813f13395a878d9486f01b37dd28bedfa893bedb5392e49b61988573440573c74c052c7b82d5113900038fc4a760a6a46fcb16a7b21997e3ad8bc8139cd38dc830de91f13e2142771f9b7524132cd26a8ff97aaca9cccc2d14e6f0ddc8a34b8b0fa9ec68ef09bfb33853319e71d8a4cc5565808eb562582cd416393ba2d406f8a7ae3614ac1eb8ad72d061f7ecbe8b2c492550ac58291eac308dda36932ffe67a69263d69c7f62e2d8a22fa80aa2ea01113f1d50b00c17647ae439f9a94fd843c4554983c69f18d62a82c52a0b778fdb5a37d432f2ecb0eaaed8229b5c7f268f24dfbef626052f486fffa7f17962393b74bab21c5e98e781571105fdb04f7de5a0b4443f736680ade79d927f64eb8e7f1bef6ae902c3a446765de23df57211a4159dd12fb6ec4acb89eab6cda3f6b6a0f8d02e47c4a6d5407f58570b31948340d5ef77da0dcdefa55e1eabe738afde3e35c00450483b4a8e121cf16bda6203603d960c1b480bcf86531c44a88d17035820c5432f30ef073cb5dbd26676e59baf9b0d632ba7cbcbb011af63b9b71edeee4347c97a159d11279a358b46375073dd5ea9401be8387d3edb4a18625cb8506d760cf4ce53e185d88c63a6118772e60380fadac35f96d72944efa11f314496da163b8a76b3d2ce62fc3bd8d8bc596ff89405d5cb93a0ee0f90f30cca0f718d632df7c6e89467f1ec8748b48aa729c0fc83052525b32b54ede3f30dfea96fec9fae14dca78a99ecafe9795d80754d5ca841a639dee345cf42627587da227177ee0eb343eca737560c0c774de95e20fbed76abe816d9e60649fc928864d746f95bcf3533c145f44a4c8a49c2a47a11df52b1735b5b474dcc3211bf05f887ae7e4be7d62a1247d71eebe2aa9c743556a19825cc233fe531ebe1f2857bdca40e62ecdbb8cff7d970fd23ca0b624d0f2cddb081c57bb637f1f7243c498132c10747915b5e0230b2b22697ce99952f5b01fa0c64aed753935958ed875365c38ea9ba7b3431120bcabf82166d6cc590de0c7c84d38e804107bcbf1164aa95d3fa7205cbb06b7c0e753636081bb1ed6b12a8995351c082e98b776ecfa86fb78b2741baa81c6f1c0e902b07e34822dbad408d2f7391c59e4009e916b0ee56320aa086ca894539b7806d5eeebfa9dc99e037f7ba325b12e6187491cd7ae0347be334848a015519aff51a3dbb283b653310ab1c6e196ed46f713b909815551b1a803209a523e287e3a62bb63f2184b11f6b8d0922cfbbe2fb409c5aef534084f51a8c0e66ae4b62ccd09383daf8ca1448fb854d1d772189d4c4662e4a34797599edba3e8eb3c2a455bb62491094b636aaa8fee7c6b172720f2ef84e24f54edae436760aee48ee06ecbee5ba731213aa1a5239030f9bd13404a9f7450aa607ff01dbc025b7c614794f91b17d732f84c807b319dc9bce92398bb3f5f9cb6be5f1ad93f3599dab7443661de744686b3452fe60fdda34e1dac59669022992b479caa8d720bbf75b5c785ef391977eedd26ef901139badb9499f57f8cb9472dbf5b8ae3489cc4c31e7ab7bb6ea2f566f2246bd16b2808f25e458e25b4b66e53a6a7acb0694ea39af9aa1e98b32c91198dd4322ac3396653baf1e6bb24040c276b5f1fbc125e3436ebad859ef97f4ab0db968d31e3e892ff54bb6ca21ac814f1b97e0545ae0e04ac9e1141999158921d4df01858410457f5f75fc935ff21be8cb48f79bd600bdf0b8c8ad3a5d64b93aca3c801e8594ad1a5d20e9d84f58a6fc36466cbc26d9bb7cd8220fd6431bd99e3fbefb9196f0be37b977ceb11b5076208419c251db76b5365757a2b1ef9e3a787a30a1842a4aec89e5928b0c2b192093c507ab16f3ce895b772a556e030f38fed9517b4b26a179af21dac1f456f2f5772077664f6c8c3416576e8ba09ede2951755b3a7dfc05f2f5f1fabd913696df56a2a149c9cd080224e009e82df9cd8ed7079fffd4dd8b6085b9aafbe9fd994a94abeea7f8494e52ba1375e2d7632b276b4cb7439e60efc88f4736f6f1f69c54d4df715ec7e69f2a36d577d1a3c5e66e3ec43e366fb53365b6d90e1340fa69f4f9ce2a5ba13ef6484c05de6318a41e1b7df7fdd2d7d442cb3f7b58388ed22e27b6c6635c477e7d6b3ec8711384d0a5aaa208891b099a32fedcb6a28e78eef24f325a589a2d341c74e0c40de23eedfd2f1a009457988de6c874b13eb39aefa29aad9ae578365acda789cc2eade70fff8db4ff0555421d238192c9b5e97ee392c882e1d70f4a72def271eb1e4f9758bcb1aebc6723d7475458e61766868acf5d517a00cb916f4761811af147c9a3fc3de459033775eafee4ce8fa3c8989f488f483542a9491d932f653e44e4ccfce4f126b5d864cc6aef7704a744161e04deac6a2e48777ebbc9e4709d33476213dc77c9a997a8ee395c7691792cf02be3e996bcf8ba9767dadc16ab0fe59403da889d438b6e51d5444273262dacff0c1f22ac18e6a74472bc0d53ac924c1013306ac0972ea2b73b2be8acd383303ccd72bd8abe948faba7c1fafb1fbad82c16c17b32e6d673f851ec86edf9cc91d06c2f59f4e84d46654a34a8d20fa1682e29a67b6e4b1f43b703a7feb5bcbc3fe0801fa11ed0f6c8d34489e75a06a016754e8315aac7bb4d027c764cb8fbd15bb62e803dd3829c9d7c7c320cca47777c70bb68c6f7976f8188594bd33ef47df1ecb3fbbe1f5938a26f1f8a2855002506402985319225079b9121450e465ab9f1d69c8c9b2416cad940cd2240dc629b78bd6c1febd1d9a55f2403258a18eed36d76ec6ed60943921cca91a725433dc6f8a3c4c6e89ddf447e73a3a7c0be0e66c27d0235215a1363796675989d4dc78f686111eb9b79f016d05ba113679a8a09033fc23d10bb67c14f91f99c5296375ee7e26d8b1d230e370b21d0bf7e482045e27a5e7fac2243b70c143db47b852bb9263b49bbd46563a1b5cd26675e9a68229622010ef183b53bb2cf71503c47f527a6ae9c503107c1ae4a81ec013b8a0527612ac8b27153a829b8ef5f8ba9ed0ce5803c1847b19b9c40a28ce603bb8ac53835e63da2600f0e410e063943e6b228f6d302d84bc01fc6885d60d2de4b3280abbd9f76a381eeae7e26c53022d4aca7f30dd919ad6838cac4c415c95f9b60597011023ef47951e9604dfb151605113e41362242e01502c21ecc5b855a0055bbbc94b86ca82fef9f8c6b3f59f51829767d0354e9f2180f129be42fea95dbc9fc94a22e7525069fe348eea5b048165551a490436a842da4e1220a9ab104bb95a3b0ff464f62da781c23ac7f0f15da05284143136e118a6679cb3b4766b1b7e45f0934d618252efa88b6037d0ba75689668680bc21997654223ca2800d1bacfca9bba76ea869e307b8474b37d23ddbe6c4a2d386f8fcef2cf258dd27ae279abecdf2bc18db033796865e0c144d292d221e8bd5d8a86a29fb1e74b302e5ad145d4394f04af0d4505959e7ac1121960c083a213558b7bc83339a3cb9f4a3b09bcec317049a3398bb452c7f42f65964e78d7e7182b68ad63bb7e4e31b6b1eed73047223306f10ff8f503d5f83e3e0baa50c17934be76163b5d5dd7f1491065b251e7075b90f5636ed7b54d6ffd62258672ac41b5e1d35b703372dce78981fec8ffc1b00303c8da45d12d318b1f658a239e35bd375162aa1c5be19d5225f1357f2302a63d79630efe20f317184875f6bfed61cd2bbdf1929af0c8b4586c73d227bc1fb9445e9849021af92c6498b8097994fc7684d6136ddeff6bffe1fced4ccbdf19398f79d42d0dd76ed75f0ab0875cf0514c7b613d08c8faf3a0b46059e50e741f54490f60a2bb94d4de36adc34c04838dd83cab586a7df97d27ffaf46b6d4908528949d0fad3928dbcd09ba88f9460397681823d942a05c2c6a5f3143d98ebdae461bf6af167d7af7b29f875b2fd83132ad97316def05ab895e75774cc7bdb34ff5ba1721648d96ea78957566e917c7fa38f9f69912cad80a174e49c20018340c5be87e662fba5b8e86d61b4bf81f8f609b80645de59ff1dbbd49e949926f51e443bc0d02a5873f1a3e4115242fd7be21d203a03ad7777704e1da4016f10232b3b124a1e5f846352949e2b4d690a6dae6530ee150ae6867da1d1b0b62e3f8fef96c11ab4460a9a7cae964941ab6fbe1b0a74ae4c0603f2a79a7cd237d94dbe9e1794eb3aeaad861e35281801a0b774ad89e2eb60389b1f0a8578d1954c540355799cf209748e96360d785364710f605fd77bb6cf5ef6f02ba04dd29c94492896ce46d131418f35c8565ab718ddb865b680230bbd242138af9ca0627f006f9252ab83bf0abcfc1195bbbf5f787ddb4260fdd73b55051c709a275270feb2178393c5b5c7820565406a3b2ee26cd7fa6c1d82e342f5ccd087f19966fcedc587d3b8a37c646e98997e5c729bad9792d8908981519de321c28fc2b6f6a47d45ce6effeda23e7d30a3641bc16be6409a4b21059611b03ae9ea2d65bcdf5ad88e50f40b5098953455112d0caca231cf196fdfb2686f129961e1d5c24ee5915f5be38a250966ad7485176171053a42dc40382aaccbe696d1b694f998acfe49f47c37b16e82dca7953541ff7be27eb5ecfb0cac627e6ea9adb377b4cef61db093b76feccb9bf8ea8ade354d59a0375b63cf368bc338262f86f39743813f739592bf2a94fe99acc54f4c297dbb276fc2be41eb5ce565ea4368282c27c2ee715365a4eff08dc51b8a1ed09201c03357b1ff339ab9f2316e3cbfb385efa699150934c0089ee1760ff82fd8509a53bdb38ab461132ccc7d36b338fc2a6df071769f85586e5c731de1134a2b18e5157c68ad457254b137ca647daa96a63b1356e7682fc4a114f938bbf23a40569ce682a3a50066edaa1c0ba4b0959aa5c50dae5c97fe851bca6fa1a16df6fdb7d142356b70da8a6270138b3ee2f6b205f71a98471e010e254f764d3318992d0f04c96466a034fd95ff19c44de7d821b4385a80ae57ec8d42ce151417b973811c8377874cdff801c9c1bc1cadd1cb2a9b1b7cbe3125bcb4fc5e16da25567e3abe5fe8d7e6d76b15ac6f15ef9b1dab6351c253f96cea9e87a1f97be93c2682cdedceaca2a9fa3ef39abbe428a096d72a98e80de2b61289415b0d34bb3d5ca3633c8938ffa05f721e4194587efb5502584735ac7b76bc0b29817bcc6a7704494b895e9130a7caed0d38d3bfed0bcaa546fe2a7e6103938ea9847acf116fb8b0c8a85a70915fd0a49b0bf530495c23503c6104a446a674f4d84eb71b057679871369312a8430283b3bee77771162ff5b74996b4df0623bcfc0e0dd2944d618cf09ec401fcdd495c58dae205e125579fe444ada71dbcdb6181a61ee549d9beeba6df5328f374e34d771febd8308aed25a9cd8fd7c9025bf636188756fdb20b5a7e911190ba1646af29ad770f326f253272f1a62843e54a86cfdcf1205b41cfb0c2724a94abe4250562c440244c22a0636a7991bec1b0da31a5b6dde7e2410675d5c24f8568b1d76ff227d4882990fb11309b0b4016b450d94c292471f9b57e554b78ba9a8b85dcf89193b241e3f97a9179b9a88734be739eba1da6aa11bc379cd51b7da204549b06d5b90ca4a017b21429230170b184b53a6d259652aed168102b5d94c9f8e71d05ee507801d4eb360a47843fdc02c4f1ee4f7b590b7a80620642d42a38d40f2ceeeb6c2388a20ffa44b0a4470a63267b0507df765d305e6615315418567bec59a3e0901d1639625e8ff05649ec3e5d6fbe87250e3fc5bc20f7d5df5222bae38a740fce360282684e55de9d676cc4d21c10169fb39002b62b39d0ac1e287f485ffe6b64dad170e463470444eaa33349546f83ccc8e1b4b0c0b8cbaa725fc07956ad4fa9477a28a635e3ad7ff3c1d785fe47c7f2b899f9c8985381a83c709844c7a398bbd18ab733cec791e5f769f9f99f5aed1dd917037138bd4d8ad6ce2072bfa5c35b6bf31d9bddb42b94c5dfee2eb1a95d8792130200f3277803ef14b7e83498adb18810be81cffb4c4eb27921eb7df2a921a74d44bf8e0df7bfb4fc5fb0adaf6f3be9bacb059f6985222465e56860e02a7686c3f3d601f11c77aaa4d55900628cc1ef6b12527406c1d5159dcab6e9661a6a231be120b3507a2dfd07694bcb6049fe12df679557f916e6516b79b8d4170b7966311c403e19d5156ce97dc459073ef1fc98ff37987cb5a357edc79b7651e8bf5f03fe35bb79bdc21ae138e5f6890ca4a3bbbd3f74eb96f7cc620cde661cfaa1d10d9ff050279d1eba681d578a2abc632372ebabc21519b3258ac1bc2129b010e15e8b99e7f2d0f2bf9a73e4bce49259f9bffb550841f177bd768889854750f39fcd99d51c8fdfa5f9052a7f5c316aa4c26219d9895a38a38eecf5546d23529e5fd0ed960a184558af448ed844db39995bbd423bee30d3d17a4bd65ba186cb82e74d8f3f2cadfc96963bd2654686f54fe82cc201e047d45abd9846f63fedaa2e8ffba5713483d9da4b1dc3816c2e4da8a473df5f70b59e278259c10e387ecde6e8cea10945ce8b410d97b1f8150185952acf2d8110bd658533887b91b056653997ebe45ce252c30660b5f910fefcd5928d86d8ef02e157cecaa375859f6219d5514adffd2d6470b8c598fbaec798b94d9c12a102f4a6f72858e3ec5bb29052aed5d76d25e457ea3b94916b101908dff293f62519731305ff332bf931a130f4a256619a5d3d6561ea0fd158c6db86899f475714a9c4c7bf63612a53eee2c8e8788b207c90fb15e4d188006ba0ecb7363ddfd9909b0471a0310ab72e40a4f4912121585a0874279937bbb31f63c837cb11ba1567a355a9dc7d79b54dff30a46cbec627309cfc6ba0dd280dd90f0f7ff1b723785500d4262757f717ecc07a4509c997d6c6bcdfed025e657bc5d6b42f23002b59024a68d8fb1bbcd9154fac37475ffe54b09c860da61f30ccbaf8fe118f646196ab8efd2ad7ee7ea28aba519c06f61b79f79837e3c100b4b48c6b9aa3edf2b0c9b6381cacb046aa92cddaa8aee48aa28bec705046e2440210cf410adcf96e9950fa6eb6ddc27c225d4afd2ced37e6f2f3576afe0d6944b63307fa3e0314bc657b9562957796cace2ff3fe585b7c71bf7fdcbf818f5ac2f26e24bc6703d6ff5e91ee8f04e74d3d90728ab9a1ee9ef9cb97faa17eefb4dae39ac40d30d748b3e763e3957e882ac45e52c421d464ac5ade169f4df4570634e905f3b0766c097acc744bd2400f50efd0d48246a993060b9bffab16d38896edad8db06f5079cf56db15ebb38f3b0e16c2f3b6f13659ac95aeaf85f91bd7dafabee3e99d495a775d2c86bb60f689cf59cd8d97fd3268b7911c0669a120c424a4951cbc198d10fd272bc7e7d0746231c38e873572bbb619ea2bb029fd8095c23785be375dd7c1f132c996c6b047c3d5b1854cc5afb79c64bcbd2be8706415171085454e9354c8b215bdf22078d72effb9ca0a6d08b4a0e07651f0ab488cdc8af7938b4bc72578ce7a768e0cfa5bf01afc81645f3677762d7542f9bbdd5c85192e31c81cc96280fad60a044747123311c9e68a2a11b9a7cf20956b6811e9aef2b850f62c2cb7c7726a03c3293c1d097191c4b631ecae41a034b27290cd42ad88a8519e4ab4e0ac5f28f9cc3e7412ce2b33d81d52ee9f5489b283d005ccedf527f8974d147433d1d048cc14a78448e2043087a0e7396437a6b934272c828a2eb3f803668b78ae35a64d90da277b585192431a3f4e6af59e2eebd43d24287483d0ff12240d6d2027b2734bb441e2e2ad6285efb1b9860b1b7a555c3c4794b246c652965248bd960942d156bc349ddacff9161a10565f40e508e79d859d599c929f4f190bb4208ec7551f5397729e5bd3c564f038412835fc1d2c0775dc5e8f470ca5b8a96166da2f690d2e7a69b754eb1e5c9b70052709e875556aa2333a123ffcc1518f6d4344579303e5c028043b5e4bbfaed5d4887f451cc0abb8b5de82276a085d412a672d13483efe51c0fac2f97b14905ace5239ef1afb595b2f0022ccd57f32e86e00d00e516ae5d0bff8dd18f393f8301aa2749f3ca381a7846df8fa04c8a5057848f025d6790eceb9950bea8fc117c6597b792c4bc5d292c63f0efb142ba3323b885eca943244a06aa4a0a716bbb7ec05ee3ac62f1309868eee26a7b709e5a3b9482060d25dfef74c3255fc4b473901546ac80e8c0bd39ccc510396c935924ead3f171d7047abe7ad237b9d10cb1e5ece3d550a34b14fbd8c47ba611e11ea00d8d7f788f138a011f76c01faa229feb65fdd7cdbb03d0a12e2ceb250c113d5beab300798293603dec3d9459af1b42f66bafe834cf61934a1df6967256ce602b87fa149596889369a9877cfcf7630d99bae4bce42573fd963a929502fd548ebef53e6c24dd899bec7cf756c62b29b12f16979d6c557b171c6b3e8d0b4f67694e0f60f07edaa218ccdd8e71ef199be4075a59a280fd6ded9fdfe0611ea83cf9d6d74df6662db40d93b701cc7cfb37a58d72c65ea76507453706d964f6cc094fa2ddad104a4105573d3abb645f30e70fc435c614f80e3f10380ff2672ae90d816c3bddbf35330516fcfb9c2c758a2f0dfebcb9a0110a1b3c333ef462e01d87c93c6fa8e5a087b5d01e8865c860e3ade87a03860916b111d5798fcfafeb6d65326b6503a2ae2e5913b06dbbe0f29646bdb41f8fbe37ab3e54337cbe95ef4838841f9a9e6653d74c99033185f0646a8b5cb75d302b2a574d965245401944cbb4c6a1c2d4793b73f045a22a894d285aa86b0674f1800b0565d1352fae070d5cf44cce017c0d4706f86aa88425400a395e90bb3c83f750a62f936210c6e398fb9b453ea85836fc93a7976cd4f4</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">诚信考试,不要作弊</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>移动通信</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>浅谈《原神》文化输出的策略和优缺点</title>
    <link href="/2022/04/02/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/%E5%8E%9F%E7%A5%9E%E4%B8%8E%E6%96%87%E5%8C%96%E8%BE%93%E5%87%BA/"/>
    <url>/2022/04/02/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/%E5%8E%9F%E7%A5%9E%E4%B8%8E%E6%96%87%E5%8C%96%E8%BE%93%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="浅谈《原神》文化输出的策略和优缺点"><a href="#浅谈《原神》文化输出的策略和优缺点" class="headerlink" title="浅谈《原神》文化输出的策略和优缺点"></a>浅谈《原神》文化输出的策略和优缺点</h1><blockquote><p>国产游戏的文化创新模式探索 ——以《原神》为例, 黄项楚，大连海事大学<br>详细讨论与分析原神的文化输出，<a href="https://www.bilibili.com/read/cv12071726">详细讨论与分析原神的文化输出 - 哔哩哔哩 (bilibili.com)</a><br>原神是怎么做到用游戏来进行文化输出？-知乎，<a href="https://www.zhihu.com/question/476701870"> 原神是怎么做到用游戏来进行文化输出？ - 知乎 (zhihu.com)</a>  </p></blockquote><h2 id="什么是文化输出"><a href="#什么是文化输出" class="headerlink" title="什么是文化输出"></a>什么是文化输出</h2><p>文化输出并不是输出文化，输出的是一种对事件的看法，一种对世界的解释权。无论里面包含了什么文化要素，它是由我们说出来的，里面包含了我们的定义，我们的理解，让世界接收这种定义，这就是文化输出。价值观具有稳定性和持久性、历史性与选择性、主观性，对动机有导向作用。换言之，输出的是真正输出的是价值观。价值观对一个人的影响深远，会主导一个人的为人处世方式。  </p><p>就像我们所熟知的美国梦工场动画的《功夫熊猫》系列，虽然它以中国古代为背景，其景观、布景、服装以至食物均充满中国元素，但影片却充斥着西方国家的那一套个人英雄主义色彩。再看看《流浪地球》，虽然主视角是中国人，但是讲的故事是整个地球的人的故事，他们是一个整体，地球上所有国家的人们都懂得团结合作共存亡的道理，只有中国人才能拍出这样的影片。同样的，原神的蒙德、璃月、稻妻地区的主线故事当中都体现出的是集体主义和集体智慧的力量。比如以中国为原型的璃月地区主线讲述的就是璃月七星和仙人们为了璃月，抛下矛盾，共同度过危机的故事。  </p><p>很多外国玩家游玩后都感觉到璃月主线故事当中的“新奇与冲击感”，这能称得上是对他们既有的价值观的冲击，因为他们的文化中，没有这些内核，只是强调着“个人的价值”。而中国文化中，我们更多地强调集体智慧和集体力量。这些外国玩家在不知不觉之间收到了我们的价值观的渲染和影响，加强了文化认同，这就已经是文化输出了。  </p><h2 id="《原神》中采用的文化输出策略与优点"><a href="#《原神》中采用的文化输出策略与优点" class="headerlink" title="《原神》中采用的文化输出策略与优点"></a>《原神》中采用的文化输出策略与优点</h2><h3 id="对中国文化的守正与创新"><a href="#对中国文化的守正与创新" class="headerlink" title="对中国文化的守正与创新"></a>对中国文化的守正与创新</h3><p>游戏与传统文化结合的方式之一是 对中国元素复制和还原，也就是将中国传统文化元素融入到游戏中的人物、场景、建筑、音乐、台词中， 以视觉符号和听觉符号来具体呈现。这种方式更多地体现为游戏的外显性特征，是游戏与传统文化相结合的最直接、最准确的一种方式，玩家可以直接观察和感受到传统的艺术形式，获得身临其境的感觉。《原神》中对桂林、张家界、黄龙等地风景保留原有风貌，对传统建筑在空间进行魔幻风格创作，让中国元素更具魅力，向国外玩家传递中式美学观。此外，《原神》角色的外观设计和内在形象在体现传统的中式文化和中国价值观的同时，融入了现代设计的元素。以游戏角色“云堇”为例，游戏设计者在角色语音中加入了大量的戏曲唱词，同时创新性地在角色打斗动作设计上融入了京剧表演的“亮相”等多个手法和动作。人物上线之后，在国内戏团纷纷将唱词改为川剧、豫剧版的同时，京剧和唱词配音演员的戏曲选段视频在海外播放量突破了百万。有中国优秀传统文化做基底，但不能一味地去移植，在 保证中国优秀传统文化内核的同时挖掘新时代下的正能量，例如改革创新精神等作为游戏故事剧情的核心理念和游戏所展现价值观。《原神》让国外玩家在游戏中感受中华传统文化魅力，引导玩家去理解、去认识中国文化的精神内核。  </p><h3 id="利用文化接近性降低文化折扣"><a href="#利用文化接近性降低文化折扣" class="headerlink" title="利用文化接近性降低文化折扣"></a>利用文化接近性降低文化折扣</h3><p>文化折扣指的是文化产品传播到其他地区时，其他地方的观众从他们自己的常识和生活方式出发，很难认同这种风格、价值观念、以及行为模式等，因此会引起相应的价值折损。  </p><p>减少文化折扣最重要的方式是提升文化作品的译制水平。《原神》提供中、日、韩、英 4 国语言配音，包含中文、日文、英文等在内的 11 国语言切换， 有助于外国玩家理解故事脉络与情感氛围。其次，需要跨越价值观，贯穿璃月的核心主题“契约”在西方同样受到重视与推崇，易于外国玩家对游戏内容与内涵的理解。国产游戏制作时需要充分了解中华文化中普世的部分，选取服饰、饮食、建筑等文化元素中适合的部分，传达国内外玩家都认可的价值观念，降低文化折扣，在“走出去”的同时“走进去”。  </p><h2 id="《原神》文化输出的缺点"><a href="#《原神》文化输出的缺点" class="headerlink" title="《原神》文化输出的缺点"></a>《原神》文化输出的缺点</h2><p>毫无疑问，《原神》这样，以游戏作为传播媒介的文化输出方式是能够让接受者更加容易接受的。但是以游戏作为传播媒介的弊端在于，相比于传统的“孔子学院”式的文化输出，以游戏为媒介的输出无法保证输出的有效性。其根本原因在于游戏无法像“孔子学院”那样，通过设置固定的时空、设置“老师”和“学生”两种具有等级之分的身份构造出严肃的语境。在严肃的语境之下，接受者更容易将接收的信息进行升华和理解。而同电视一样，游戏本质上也是一个可由受体意识自主决定进入和退出的语境，因此无法将传递内容深化和“神圣化”。因此，虽然《原神》这样的游戏媒介在传播的广度和接受者的接受程度上有着出色的表现指标，但是纯粹地依赖于《原神》这样的、通过游戏等娱乐媒介来传播中国文化、输出价值观仍然是幼稚的想法。  </p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>当今时代下的中国文化输出，更应该二者兼具，以越来越多地娱乐媒介作为扩展文化输出广度的工具，并将人们引导到严肃语境构建的传输媒介中，升华大众对于中国价值观的理解和认同。这样的文化输出，才是既有深度，又有广度的。  </p>]]></content>
    
    
    <categories>
      
      <category>技术杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原神</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.传输理论概述</title>
    <link href="/2022/04/01/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BC%A0%E8%BE%93%E7%BA%BF/%E4%BC%A0%E8%BE%93%E7%90%86%E8%AE%BA/"/>
    <url>/2022/04/01/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BC%A0%E8%BE%93%E7%BA%BF/%E4%BC%A0%E8%BE%93%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="传输理论概述"><a href="#传输理论概述" class="headerlink" title="传输理论概述"></a>传输理论概述</h1><h2 id="电平"><a href="#电平" class="headerlink" title="电平"></a>电平</h2><h3 id="分贝值"><a href="#分贝值" class="headerlink" title="分贝值"></a>分贝值</h3><p>由于功率与电压、电流、电阻之间的关系是：$P=EI=\frac{E^2}{R}=I^2R$.功率对数化的结果为：</p><script type="math/tex; mode=display">P|_{dB}=10lg(EI),P=EI</script><script type="math/tex; mode=display">P|_{dB}=20lg(E),P=\frac{E^2}{R},R=1</script><script type="math/tex; mode=display">P|_{dB}=20lg(I),P=I^2R,R=1</script><p>定义相对电平为实际功率与参考功率$P_r$之比对数化后得到的结果：  </p><script type="math/tex; mode=display">P|_{dB}=10lg(\frac{P}{P_r})</script><script type="math/tex; mode=display">P|_{dB}=20lg(\frac{E}{E_r})=20lg(\frac{I}{I_r})</script><p>$P|_{dB}&gt;0$时，称为增益（Gain）；$P|_{dB}&lt;0$时，称为损失（Loss）。<br><strong>可以发现，当$P=2P_r$时，对应的参考电平增加3dB。</strong><br>当$P_r$为一个公制的单位数值时，此时相对电平转换为绝对电平，通常的绝对电平单位有$dBW$和$dBm$两种。<br>当$P_r=1W$时，得到的功率的单位是$dBW$，有时写作$dB$.<br>当$P_r=1mW$时，得到的功率的单位是$dBm$.  </p><script type="math/tex; mode=display">1W=0dBW=30dBm</script><h3 id="奈培值"><a href="#奈培值" class="headerlink" title="奈培值"></a>奈培值</h3><p>对功率进行以$e$为底的指数化后的结果称为电平（奈培值），以Np记，同样也有相对电平和绝对电平两种：  </p><script type="math/tex; mode=display">P|_{Np}=\frac{1}{2}ln(\frac{P}{P_r})</script><p>奈培和分贝的换算如下：  </p><script type="math/tex; mode=display">1Np=8.686dB</script><h3 id="系统的绝对电平和"><a href="#系统的绝对电平和" class="headerlink" title="系统的绝对电平和"></a>系统的绝对电平和</h3><p>如果是级联系统，每一级的增益或者损耗可以直接相加：  </p><script type="math/tex; mode=display">P|_{dB}=∑[P_i|_{dB}]</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220401143527.png width=50%>   </p><p>如果是并联系统，则应该去对数化后相加的结果再进行对数化：  </p><script type="math/tex; mode=display">P|_{dB}=[∑P_i]|_{dB}</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220401143850.png width=40%>  </p><h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><h3 id="传输系统"><a href="#传输系统" class="headerlink" title="传输系统"></a>传输系统</h3><p>通信模型包括如下几个要素：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220327161658.png width=50%>  </p><ul><li>源点(source)：生成所需要传输的数据</li><li>发送器（transmitter）：将信息转化和编码为传输系统中接受的电磁信号</li><li>传输介质（transmission medium）：传输电磁信号，可以是传输线或者复杂的网络系统</li><li>接收器（receiver）：接收传输系统的信号，转化为可以被终点接收的数据信息</li><li>终端（destination）：接收来自接收器的数据信息  </li></ul><p>但是，传输系统的概念是相对的，在通信传输中，传输系统的概念：  </p><ul><li>可以是微观的，也可以是宏观的  </li><li>可以是复杂的，也可以是简单的  </li></ul><p>传输系统的概念可以简单到任何能够独立实现传输功能的都是传输系统。可以直接在节点图上表示为两个节点之间的一条线。  </p><h2 id="传输术语"><a href="#传输术语" class="headerlink" title="传输术语"></a>传输术语</h2><h3 id="直连链路"><a href="#直连链路" class="headerlink" title="直连链路"></a>直连链路</h3><p>两个设备之间，除了一些用于增加信号强度的放大器(amplifier)和转发器(repeater/regenerator)外，再也没有其他设备的存在的链路称为直连链路。<br><div class="note note-info">            <p>放大器和转发器的作用都是在传输过程中增强信号，减少信号在传输过程中的衰落。<br>放大器的优点是便宜，但是在放大信号的同时也会放大噪声。<br>转发器的作用可以总结为“再放大、再整形、再定时”，其工作流程是“接收-解读和除噪-复现和转发”。转发器可以保证可靠性，但是转发过程相较于放大器耗时更多，且设备更加昂贵。  </p>          </div>  </p><h3 id="导向的和非导向的"><a href="#导向的和非导向的" class="headerlink" title="导向的和非导向的"></a>导向的和非导向的</h3><p>传输媒体可以分为两类，导向的和非导向的。  </p><ul><li>导向媒体：电磁波在导线引导下沿着某一物理路径前进。<br>直连链路的媒体是导向媒体，且它仅被两个设备共享，那么这个导向传输媒体是点对点的(point-to-point)。有两个以上的设备共享同一个传输媒体的导向传输媒体是多点的(multi-point)。  </li><li>非导向媒体：无线传播，媒体不引导电磁波的传输方向。  </li></ul><h3 id="信号和带宽、数据率"><a href="#信号和带宽、数据率" class="headerlink" title="信号和带宽、数据率"></a>信号和带宽、数据率</h3><p>信号的频谱上，信号延伸的整个频谱范围称为绝对带宽。而绝大部分信号能量集中的区域（主瓣）的频谱范围称为相对带宽，或者直接写作带宽。<br>通常，一个给定波形包含的频率范围可能非常宽，然而任何传输系统都只能容纳有限的频率范围，这是限制传输系统数据率的主要原因。<br>在数字通信中，用于表示信息的波形通常是方波。一个方波波形可以通过若干个基数倍某一频率$f$的正弦波叠加拟合：  </p><script type="math/tex; mode=display">s(t)=\frac{4A}{π}∑_{k=1,3,5..}^∞\frac{sin(2πkft)}{k},k为奇数</script><p>$f$称为基础频率。<br>可以发现，任何一个方波波形具有无限个频率成分，且为无限带宽。但是可以发现如果将带宽限制在最前面几个频率成分时，其对方波的拟合效果已经非常好了。<br>通过实验可以发现，增大频率成分，方波的带宽增加，其数据率增大。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220608105104.png width=50%>    </p><p>奈奎斯特提出了奈奎斯特带宽，表示了带宽与容量（理论最大数据率）之间的关系：  </p><script type="math/tex; mode=display">C=2Blog_2M</script><p>其中$B$表示带宽，$M$表示所使用的电平的个数（即数字信号的进制）。<br>在此基础上，香农提出了香农公式，其中考虑了噪声对传输系统的影响：  </p><script type="math/tex; mode=display">C=Blog_2(1+SNR)</script><p>$SNR$为信道的信噪比，单位为“1”。  </p><p>可以总结：<br>信号的数据率越高，其有效带宽越宽。换言之，<strong>传输系统的带宽越宽，则能够在这个系统上传输的数据率就越高</strong>。  </p><h3 id="模拟和数字传输"><a href="#模拟和数字传输" class="headerlink" title="模拟和数字传输"></a>模拟和数字传输</h3><p>模拟数据是在一段时间内值连续的数据，而数字数据是值离散的数据。<br>通信中，模拟信号是连续变化的电磁波，模拟信号可以在导向媒体和无导向媒体上传播。数字信号是电压脉冲序列，只能在导向媒体上传输。数字信号的优点是传输成本比模拟信号更加便宜，且不易受到噪声干扰。其主要缺点是数字信号传输比模拟信号传输更容易受到衰减的影响。  </p><h4 id="模拟传输"><a href="#模拟传输" class="headerlink" title="模拟传输"></a>模拟传输</h4><p>模拟传输系统传输模拟信号，在传输过程中不考虑信号的承载的数据是模拟的还是数字的。模拟信号在传输一段距离后会产生衰减，因此模拟传输系统中通过放大器来增强信号、减少衰减，但是放大器同时也会增强噪音成分。  </p><h4 id="数字传输"><a href="#数字传输" class="headerlink" title="数字传输"></a>数字传输</h4><p>数字传输假定信号表示二进制的值，由于数字信号是通常高频信号，对衰减比模拟传输更为敏感：主要原因是传输线中的阻抗会随着传输信号频率和传输距离的增加而增加。因此在噪声、衰减对数据的辨识度产生影响之前就要结束传输，换言之，数字传输只能进行短距离的传输。要想让数字传输支持长距离传输，则需要使用转发器。  </p><h3 id="服务质量-QoS"><a href="#服务质量-QoS" class="headerlink" title="服务质量/QoS"></a>服务质量/QoS</h3><p>QoS（Quality of Service）是服务质量的简称，表征了用户(subscriber)对服务提供商(provider/operator)所提供的服务的满意程度。<br>在通信网中，最早用户对于业务的种类需求并不多，只关心通话质量，因此早期的QoS可以通过声音的响度和清晰度进行反映。其后，随着用户数量的增多，QoS考虑了传输时延（通常以50ms作为快慢的区分）如今随着业务种类的增多，QoS的反应指标也相应的越来越多。<br>通常QoS的关键指标有：可用性、吞吐量、时延、丢包率等。  </p><h2 id="传输损伤"><a href="#传输损伤" class="headerlink" title="传输损伤"></a>传输损伤</h2><p>在传输系统中由于各种传输损伤的存在使得接收信号和传输信号并完全相同，常见的传输损伤(transmission impairments)为：衰减和失真、时延失真和噪声。  </p><h3 id="衰减和失真"><a href="#衰减和失真" class="headerlink" title="衰减和失真"></a>衰减和失真</h3><p>在任何传输媒体上传输的信号，随着传输距离的增加，其能量在传输过程中不断损失，这样的损失称为衰减（attenuation）。对于导向传输媒体，衰减是随着距离指数级增长的。<br>定义相对衰减值：  </p><script type="math/tex; mode=display">N_f=-10lg(\frac{P_f}{P_{1000}})</script><p>$P_{1000}$为1000Hz频点的功率值。<br>为了减少衰减，在传输过程中需要考虑如下的三个问题：  </p><ul><li>接收到的信号有足够大的强度  </li><li>信号电平必须要比噪声电平高出某一个程度<br>前两个问题可以通过放大器和转发器解决，并且发送的信号强度本身应该足够强。  <div class="note note-info">            <p>但是信号强度过强也会导致：  </p><ul><li>可能使得传输设备过载。  </li><li>信号在接收机处重新反射回到传输线中，甚至形成驻波，损失能量。  </li><li>截止失真。  </li></ul>          </div>  </li><li>传输线中的阻抗会随着传输信号频率和传输距离的增加而增加，这是能量衰减的重要因素，因此衰减随着频率的变化而不同。<br>这个问题可以在某个频带范围内使用衰减均衡技术（attenuation equalization）使得衰减对各个频率的影响比较均匀。  </li></ul><h3 id="时延失真"><a href="#时延失真" class="headerlink" title="时延失真"></a>时延失真</h3><p>时延失真是由于导向媒体信号传播速度随着频率的不同而改变。对频带有限的信号而言，靠近中心频率的地方传播速度更快。不同频率的信号到达接收机的时间不同，从而产生不同频率信号的相移。<br>时延失真会导致码间串扰，是传输容量受限的主要因素。<br>均衡技术的使用可以减小时延失真。  </p><h3 id="噪声"><a href="#噪声" class="headerlink" title="噪声"></a>噪声</h3><p>噪声是传输过程中插入的无用信号，噪声限制了传输系统的性能。<br>噪声存在四类：  </p><ul><li>热噪声（thermal noise）<br>电子热运动产生的、在频域内均匀分布、无法被消除的噪声，又称为白噪声（white noise）。<br>热噪声功率可以表示为：  <script type="math/tex; mode=display">N=kTB</script>$k$：玻尔兹曼常量，$1.38×10^{-23}J/K$，$T$：开尔文温度，$n_0=kT$又称为热噪声密度。$B$：信道带宽。  </li><li>互调噪声（intermodulation noise）<br>互调噪声发生在不同频率的信号共享同一传输媒体时。不同频率的信号通过同一非线性传输元件（如放大器等）所产生的信号叠加可能对其他工作频率产生影响。   </li><li>串扰（crosstalk）<br>由于载有多路信号的相邻传输线发生电耦合，使得相邻传输线之间相互干扰产生的噪声。  </li><li>冲激噪声（impluse noise）<br>一种非连续的噪声，由不规则的脉冲或者持续时间短而振幅大的噪声尖峰组成。<br>在数字通信中，冲激噪声是差错的主要起因。  </li></ul><h2 id="导向传输媒体"><a href="#导向传输媒体" class="headerlink" title="导向传输媒体"></a>导向传输媒体</h2><p>传输媒体包括导向和非导向两种。导向媒体包括：双绞线、同轴线、光纤。非导向的传输媒体包括：真空、空气或者水等。<br>设计数据传输系统考虑的重要因素是数据率和传输和距离：数据率越大、传输距离越远，传输系统越好。  </p><h3 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h3><p>双绞线是最廉价的传输媒体。  </p><h4 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h4><p>通常，两个相邻的、相互绝缘的铜线相互正交时，相互之间的串扰是最小的。但是考虑到长度/占用空间和成本问题，实际使用时，两根相邻的铜线往往成一定的角度相互绞合，这就是双绞线。<strong>两根铜线以一定规则绞合在一起，减轻同一根电缆内的相邻线对的串扰</strong>。通常数百对线对捆扎在一起，并且用护皮包裹为一根线缆。同时，一捆双绞线中<strong>不同的相邻线对使用不同的绞距</strong>（周期绞合的距离，twist length），以减少低频串扰。通常绞距在5~15cm之间。<br>线材直径在0.4~0.9mm之间，直径越大的线材，其传输阻抗越大。<br>为了减少干扰，有时还会在双绞线外部用金属网罩加上护皮对线缆进行屏蔽，称为屏蔽双绞线(shielded twisted pair)，没有金属网罩加以屏蔽的双绞线是无屏蔽双绞线(unshielded twisted pair)。<br>无屏蔽双绞线可以在布线稀疏的环境下使用，屏蔽双绞线的价格更贵，但是在高数据率传输时有更好的表现。  </p><p>  <img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220405154012.png width=60%>  </p><p>  <img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220405160223.png width=50%>  </p><p>  此外，无屏蔽双绞线按照标准分为了3类、4类和5类线。<br>  3类线的单位距离绞数更低，通常用于传输话音数据。而5类线的单位距离绞数更高，通常用于传输数字数据。  </p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>在模拟信号传输中，在电话传输系统中，每部电话机都通过双绞线与端局进行连接，形成所谓的用户环路。话机挂断时，环路呈现高阻态。环路通过振铃使用户摘下听筒，摘机后整个用户环路呈现低阻态。<br>在数字信号传输中，连接数字数据交换机的传输媒介是双绞线。双绞线也可以用于局域网连接。  </p><h4 id="传输特性"><a href="#传输特性" class="headerlink" title="传输特性"></a>传输特性</h4><p>相比于光纤和同轴线，双绞线在传输距离、带宽和数据率上的局限性大。<br>在传输距离上，使用双绞线传输模拟信号的合适距离小于5km，数字信号则小于2~3km。<br>由于双绞线容易和电磁场发生电磁耦合，双绞线非常容易受到串扰和噪声的影响。冲激噪声也容易侵入双绞线。双绞线的衰减随着传输频率的增高而迅速增加。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220405152707.png width=50%>  </p><h3 id="同轴线"><a href="#同轴线" class="headerlink" title="同轴线"></a>同轴线</h3><h4 id="物理结构-1"><a href="#物理结构-1" class="headerlink" title="物理结构"></a>物理结构</h4><p>同轴线是由一根空心的圆柱形外导体和柱体内部的一根导线组成。内导线与外导体之间由不导电的物质进行填充以固定，外导线由保护罩或者屏蔽罩覆盖。相比于双绞线，同轴线可以用于更长的传输距离，且支持更多的站点共享同一链路。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220405160158.png width=50%>  </p><h4 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h4><p>电视传输、传输机和交换机之间的传输、计算机系统之间的短距离连接、局域网。<br>同轴线常用于短距离设备之间的连接。如果使用数字信号，同轴线缆可以在计算机系统间提供高速传输通道。<br>在隧道通信中，会在同轴线的保护罩上开孔以泄露电磁，提高隧道通信质量。  </p><h4 id="传输特性-1"><a href="#传输特性-1" class="headerlink" title="传输特性"></a>传输特性</h4><p>相比双绞线，同轴线不容易受到串扰和干扰的影响。因此可以更有效的应用于频率更高、数据率更快的环境中。<br>其性能上的限制来自于衰减、热噪声、交调噪声。交调噪声只在使用频分复用时才出现。<br>模拟传输传输过程中每隔几千米就需要使用放大器，频率越高，放大器的间隔就越接近。数字传输过程中，大约每一千米就需要一个转发器，数据率越高，转发器间隔越密集。  </p><h3 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h3><h4 id="物理结构-2"><a href="#物理结构-2" class="headerlink" title="物理结构"></a>物理结构</h4><p>  光纤的材质是玻璃（二氧化硅）或者塑料。使用高纯度二氧化硅熔丝的光纤和可以达到最低损耗。塑料光纤的价格虽然低，但是损耗较大，只能用于短距离链路传输（桌面传输），因此目前主流的材料仍然是二氧化硅。<br>  光纤由是三个同轴部分组成：芯(core)、包层/覆层(cladding)、防护罩(shield)。包层/覆层的作用是区别于芯的折射率，保证光不会泄漏出光纤芯。<br>  <img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220405165742.png width=50%>  </p><h4 id="传输特性-2"><a href="#传输特性-2" class="headerlink" title="传输特性"></a>传输特性</h4><p>  <strong>光纤通过完全内部反射(total internal reflection)来传输信号编码的光束</strong>。<strong>完全内部反射可以在任何一种反射率高于周围介质透明介质中发生。</strong><br>  光束以一定角度射入光纤中，入射角度平缓的光束被反射并沿着纤维向前传播，其他射线被周围的物质吸收。在光在光纤内部的反射根据光纤芯的折射率分布的不同有多种反射模式。  </p><ul><li><p>单模<br>如果光纤芯的半径小，光能够发生反射的角度也会减小，当光纤半径减小到只能允许一个角度的入射光可以通过光纤时，那么光线在两点之间直射。为了进一步保证直射，理论上单模光纤的折射率是均匀分布的。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220406171032.png width=50%><br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220406170952.png width=50%><br>由于单模传输只存在一条传播路径，不存在多模传输时的损耗，此时光传输的性能是最好的。单模光纤通常用于远距离传输中。  </p></li><li><p>多模突变/多模阶跃<br>多模阶跃光纤的折射率随着光纤半径的变化是一个阶跃函数，如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220406165550.png width=30%><br>在这样的折射率分布下，可以认为光沿着直线进行多个角度的反射。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220406165921.png width=50%>  </p></li><li><p>多模渐变<br>多模阶跃光纤的折射率随着光纤半径的变化是一个平滑的曲线函数，如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220406170159.png width=30%><br>在这样的折射率分布下，可以认为在非常小的一段距离内光沿着直线进行多个角度的反射，由于入射角的不断调整，光路最终会呈现出正弦波的形状，而不是以锯齿波的形状沿着涂覆层前进，因此相比于多模突变，固定距离下多模渐变光纤中光路总长度更小。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220406170522.png width=50%>  </p></li></ul><p>光纤通信中最重要的影响因素是<strong>模式散射</strong>，由于多模传输中光存在多条传播路径，每条路径的光到达终端的时间不同，造成相移。<br>除了模式散射之外，光纤通信中还有主要由于吸收和扩散造成的衰减。<br>真空中不同波长的光与衰减关系如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220405165945.png width=50%>  </p><div class="note note-info">            <p>光纤内的光速要比真空中光速更小，信号被转化为光信号时，信号的频率不会发生改变，但是波长却变小了。  </p>          </div><p>可以发现，<strong>波长在850nm、1310nm和1550nm</strong>附近的光衰减量较小，这三段光谱称为光的三个传输窗口。光通信一般使用波长在这三个窗口的光。由于技术限制，最早的光通信通常使用波长在850nm的光，由发光二极管提供光源。现在的光通信一般使用波长在1550nm的光，由激光器作为光源。<br><div class="note note-info">            <p>使用发光二极管作为光源其寿命和耐用度较高、价格便宜，但是只支持传输速率100Mbps以下，传输距离限制在几千米中。<br>激光器可以发出波长更长的光，因此可以支持更高的传输速率。  </p>          </div><br>使用波长越长的光进行通信可以达到更长的传输距离和更快的传输速率。  </p><h3 id="总结：不同传输线的传输特性"><a href="#总结：不同传输线的传输特性" class="headerlink" title="总结：不同传输线的传输特性"></a>总结：不同传输线的传输特性</h3><div class="table-container"><table><thead><tr><th style="text-align:center">传输线类型</th><th style="text-align:center">频率范围</th><th style="text-align:center">常见传输损耗</th><th style="text-align:center">常见时延</th><th style="text-align:center">转发器设置间隔 <br> /最大传输距离</th></tr></thead><tbody><tr><td style="text-align:center">双绞线<br>（单根）</td><td style="text-align:center">0-3.5kHz</td><td style="text-align:center">0.2dBm/km, 1kHz</td><td style="text-align:center">50μs/km</td><td style="text-align:center">2km</td></tr><tr><td style="text-align:center">双绞线<br>（多根组成的缆线）</td><td style="text-align:center">0-1MHz</td><td style="text-align:center">0.7dBm/km, 1kHz</td><td style="text-align:center">5μs/km</td><td style="text-align:center">2km</td></tr><tr><td style="text-align:center">同轴电缆</td><td style="text-align:center">0-500MHz</td><td style="text-align:center">7dBm/km, 10MHz</td><td style="text-align:center">4μs/km</td><td style="text-align:center">1-9km</td></tr><tr><td style="text-align:center">光纤</td><td style="text-align:center">186-370THz</td><td style="text-align:center">0.2-0.5dB/km</td><td style="text-align:center">5μs/km</td><td style="text-align:center">40km</td></tr></tbody></table></div><h2 id="无线传输"><a href="#无线传输" class="headerlink" title="无线传输"></a>无线传输</h2><h3 id="天线"><a href="#天线" class="headerlink" title="天线"></a>天线</h3><p>天线是一种用来发射和收集电磁能量的电导体系统，在传输系统中，天线可以看作是一种接口。由于天线的互易性，同一种天线对同一频率电磁波的接收能力和发送能力是一样的。<br><div class="note note-info">            <p>实际应用中，为了区分接收信号和发射信号，通常无线电的收发频率可以是不同的（频分双工,FDD），也可以使用同一频率，但使用不同的时隙（时分双工,TDD）。<br>在天线设置时通常两个天线一组，一个天线负责收发，另一个天线负责接收。两个天线间隔水平/垂直一些距离，称为隔离。  </p>          </div>  </p><p>常见的天线是各向同性天线/偶极子天线/全向天线(isotropic antenna/omidirectional antenna/dipole)和抛物面天线(parabolic reflective antenna)。<br>各向同性天线向四周辐射的能量均匀，而抛物面天线可以保证发射的电磁波都是平行波。  </p><h4 id="天线增益"><a href="#天线增益" class="headerlink" title="天线增益"></a>天线增益</h4><p>天线增益表示天线在某个方向上的能量集中程度。  </p><script type="math/tex; mode=display">G=\frac{4πA_e}{λ^2}</script><p>$A_e$是天线的有效面积。$\frac{λ^2}{4π}$是偶极子天线的有效面积。  </p><h3 id="地面微波"><a href="#地面微波" class="headerlink" title="地面微波"></a>地面微波</h3><ul><li>物理性质<br>地面微波是视距传播。微波天线和中继站通常建设在高处，以延长天线之间的距离，并且减少菲涅尔区的侵占。  </li><li>应用<br>地面微波主要用于长途电信服务、蜂窝系统、点对点的短距离传输，以及使用微波链路建立旁路以绕过本地的电话公司。  </li><li>传输特性<br>微波的主要损耗来自于衰减，自由空间衰减可以表示为：  <script type="math/tex; mode=display">L_{fs}|_{dB}=32.4+20lgd_{km}+20lgf_{MHz}</script>在高于10GHz的频段，由于波长和水珠的直径相似，在高频的无线电波传输过程中容易受到雨、雪、雾的影响。<br>此外还有来自其他电子电器的微波干扰。  </li></ul><h3 id="卫星微波"><a href="#卫星微波" class="headerlink" title="卫星微波"></a>卫星微波</h3><ul><li>物理性质<br>在传统的卫星通信链路中，卫星的主要作用是中继，将两个远距离的地面微波站连接链路。卫星从上行频段接收信号，放大或者再生后将其从下行频段发送给地面站。一个轨道卫星可以在多个频段上工作。  <div class="note note-info">            <p>卫星通信的上行链路是高频带宽链路，下行链路是低频带宽链路。因为对卫星发送的功率要求更小。<br>移动通信的上行链路是低频带宽链路，下行链路是高频带宽链路。因为对手机发送的功率要求更小。  </p>          </div>  卫星通信的设置可以是一对一的通信，也可以是多点通信。<br>为了使一个通信卫星有效工作，传统卫星通信中使用的卫星更希望是同步卫星（轨道高度是35863km），使得所有地球站都在直连范围内。  </li><li>应用<br>电视广播/长途电话传输/专用商业网络/全球定位  </li></ul><h3 id="无线传播方式"><a href="#无线传播方式" class="headerlink" title="无线传播方式"></a>无线传播方式</h3><p>常见的无线传播方式有三种：地波、天波和视距波。  </p><h4 id="地波传播"><a href="#地波传播" class="headerlink" title="地波传播"></a>地波传播</h4><p>在地波传播中，无线电波可以沿着地表面传输一段超出视距范围的距离，地波使用的频段在2MHz以下。这个频带内的电磁波沿着地表曲线传播是由多个原因造成的：  </p><ul><li>电磁波使地表出现感应电流，靠近地面的波阵面速度减慢，使波向下倾斜。  </li><li>衍射：2MHz以下的波对大气的衍射能力很弱，大部分会被大气散射，以至于无法穿透高层大气。   </li></ul><h4 id="天波传播"><a href="#天波传播" class="headerlink" title="天波传播"></a>天波传播</h4><p>由地面基站发射出去的信号被电离层反射回地球，通过多次电离层的反射，电磁波可以传播相当长的一段距离。  </p><h4 id="视距传播"><a href="#视距传播" class="headerlink" title="视距传播"></a>视距传播</h4><p>在空间波所能直达的两点间的传播。<br>其距离同在地面上人的视线能及的距离相仿，一般不超过50km。  </p><ul><li>光学视距和无线电视距<br>微波会被大气层弯曲和折射，而大气层的折射率是随着纬度的增加而连续降低的，因而会使得无线电波沿着地球的地表曲线弯曲，因此无线电视距要比光学视距更远一些。对于地面通信，发送天线和接收天线必须在双方的有效视距之内。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220413131811.png width=50%>  </li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>电信传输理论与工程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>0.通信网络概述</title>
    <link href="/2022/03/25/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E7%BD%91/0.%E9%80%9A%E4%BF%A1%E7%BD%91/"/>
    <url>/2022/03/25/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E7%BD%91/0.%E9%80%9A%E4%BF%A1%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<h1 id="通信网络概述"><a href="#通信网络概述" class="headerlink" title="通信网络概述"></a>通信网络概述</h1><h2 id="通信系统认知"><a href="#通信系统认知" class="headerlink" title="通信系统认知"></a>通信系统认知</h2><h3 id="通信发展背景"><a href="#通信发展背景" class="headerlink" title="通信发展背景"></a>通信发展背景</h3><p>通信技术发展的驱动力有两方面，其一是技术特性的发展，其二是需求的不断变化，可以简单归纳为技术(techique)和经济(economy)。  </p><ul><li>技术特性的发展，发展趋势包括：  <ul><li>速度越来越快、价格越来越低  </li><li>智能化：能提供不同的服务质量(QoS)和可自定义的安全管理服务  </li><li>因特网、万维网的连接和内外网的构建</li><li>移动性的不断增强</li></ul></li><li>新需求带来的新的服务，内容包括：  <ul><li>对高速局域网的需求  </li><li>企业对广域网的需求  </li><li>数字电器和数字资源带来的高通信量的需求  </li></ul></li></ul><h3 id="通信模型"><a href="#通信模型" class="headerlink" title="通信模型"></a>通信模型</h3><p>通信模型包括如下几个要素：  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220327161658.png width=50%>  </p><ul><li>源点(source)：生成传输数据</li><li>发送器（transmitter）：将信息转化和编码为传输系统中接受的电磁信号</li><li>传输系统（transmission system）：传输电磁信号，可以是传输线或者复杂的网络系统</li><li>接收器（receiver）：接收传输系统的信号，转化为可以被终点接收的数据信息</li><li>终端（destination）：接收来自接收器的数据信息  </li></ul><p>但是，传输系统的概念是相对的，在通信传输中，传输系统的概念：</p><ul><li>可以是微观的，也可以是宏观的  </li><li>可以是复杂的，也可以是简单的<br>传输系统的概念可以简单到任何能够独立实现传输功能的都是传输系统。可以直接在节点图上表示为两个节点之间的一条线。  </li></ul><h3 id="通信任务"><a href="#通信任务" class="headerlink" title="通信任务"></a>通信任务</h3><ul><li>传输系统的利用<br>如何充分利用传输设施，通常包括复用（多个用户之间共享通信资源）和拥塞控制（避免系统因为过量的传输服务请求而超载）技术。  </li><li>接口<br>任何通信设备都需要通过接口与传输系统连接。  </li><li>产生信号<br>产生的信号需要满足：(1)使得信号可以在传输系统上进行传播 (2)信号能够被接收器转换为数据。  </li><li>同步<br>接收器与发送器之间发送信号时，接收器需要知道信号的持续时间，发送时间和结束时间。  </li><li>交换管理<br>制定两个设备通信时的规则，包括传输是否同时、单次传输的数据量、数据格式和意外情况的应对。<br>交换管理中的两个重要任务是：  <ul><li>差错检测和纠正：检测传输内容时候有错，并进行一定程度的校正。  </li><li>流控制：避免终端不会因为源发送数据过快而无法及时接收和处理数据导致超载。  </li></ul></li><li>恢复<br>在传输发生故障而中断时能够从中断处继续工作，或者把涉及到的部分恢复到交换之前的状态。  </li><li>寻址和路由选择<br>选择传输过程中某条具体的路径，且保证终端能够且唯一的接收到数据。  </li><li>报文的格式化<br>使得在数据传输时数据的格式达成一致。  </li><li>网络管理<br>对通信系统进行设置，监控，在发生故障时进行处理。  </li><li>安全措施<br>确保只有期望的接收方可以接收到数据，且保证收到的数据不发生改动。  </li></ul><h3 id="信息的传输"><a href="#信息的传输" class="headerlink" title="信息的传输"></a>信息的传输</h3><p>信息传输的目标是：在最小花费的前提下，某种特定的设施能够提供所要求的性能，并且具有可接受的可靠性。<br>从目标来看，在设计传输系统时需要考虑<strong>传输媒体、通信技术和传输效率</strong>。  </p><ul><li>传输媒体<br>现在普遍使用的传输方式是光纤传输和无线传输，这其中常见的传输媒体是<strong>双绞线、同轴线、光纤、地面微波</strong>和<strong>卫星微波</strong>。<br>光纤传输具有容量大和安全性（几乎不可能被窃听）的特点。但是目前交换技术的发展成为了瓶颈。<br>无线传输具有：  <ul><li>个人可以轻松识别自己身份，并通过账号在广域内方便使用任何通信系统的能力。  </li><li>只用一个终端就能在不同环境下与信息服务连接的能力。  </li></ul></li><li>传输效率的提高<br>虽然传输设施的容量增加了，费用降低了，但是传输服务的支出仍然是企业服务中最大的一部分。提高传输效率可以减小通信系统的花费。常见的提高传输效率的技术有：  <ul><li>复用（multiplexing）<br>多个设备按照一定规则共享一个传输设施的通信资源，共享可以让该设施的费用由多个设备所属的用户分担。<br>常见的复用技术有频分复用、波分复用、同步时分复用和统计时分复用，以及码分复用。  </li><li>压缩（compression）<br>减小数据体积，使得低容量且较为便宜的传输设施能够满足特定的需求。  </li></ul></li></ul><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h3><p>通常广域网覆盖了很大的地理范围，内部包含了多个相互交换的节点，从一个设备触发的传输过程要通过路径选择（称为路由选择），途径选择的网络节点，最终到达某个终端。这些中途的网络节点不关心转发数据的内容，只提供数据交换功能，这样的传输称为透传（transparant transmission）。同时，局域网内部节点的拓扑结构通常是网状的(mesh)。  </p><h3 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h3><p>一般来说，相较于广域网的定义，局域网所囊括的地理范围更小，但是这样的定义仍然是灵活的。现在判断网络是局域网还是广域网主要是根据：1) 协议/信令/接口 是否通用 2) 网络内的资源是否所有人都可以使用。<br>通常情况下，局域网和局域网连接的设备都属于同一个组织，因此局域网内部的功能可以由组织自主定义，且局域网的网络管理由组织或者用户负责。<br>一般来说，局域网内的数据率要比广域网高得多。<br>局域网的常见配置是交换局域网和无限局域网，交换局域网可能含有一个或多个相互连接的交换机，每一个交换机连接了一些设备。这种拓扑结构是星型（star）。<br>从这里可以看出，交换的功能是进行小范围的节点通信。<br><div class="note note-info">            <p>注意计算机网络中的交换与通信网络中的交换机概念和定义都完全不同，此处指计算机网络中的交换和交换机。  </p>          </div> </p><h3 id="因特网"><a href="#因特网" class="headerlink" title="因特网"></a>因特网</h3><p>因特网（internet）是由1969年美国国防部开发的ARPANET演变而来的。因特网的终端系统称为主机（host），使用因特网的绝大多数主机会连接到某个局域网或者广域网上，这些网络通过路由器彼此相连。路由器的作用是在终端之间相互通信前在网络中进行大跨度范围的通信路径选择（称为路由）。  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220329091359.png width=50%>  </p><p>可以发现，一些局域网的作用是将本地设备进行汇聚，并通过路由器接入到多个相连的广域网中，这样的局域网称为接入网(AN)。为了保证接入网的高效运行和节省开支，<strong>接入网</strong>一般使用<strong>星形</strong>作为拓部结构。而多个相连的广域网最终组成核心网（CN），为了保证核心网的可靠性，<strong>核心网一般采用网状拓扑结构</strong>。<br><div class="note note-info">            <p>接入网和核心网的概念来源于通信网络，在计算机网络中一般更强调本地网络和因特网，但是两个概念趋近于融合。   </p>          </div><br>源点主机将需要发送的数据拆分为一个分组序列，称为IP数据报/IP分组。每个分组包含目标主机的唯一数字地址：IP地址。每个分组根据这个目的地址途径一系列的路由器和网络，路由器是连接两个网络的处理器，功能是将数据沿着从源到终端的路径从一个网络转发到另一个网络，每个路由器在接收到分组时会进行路由选择，并沿着该路径转发数据包。  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220329092403.png width=50%>  </p><h2 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h2><p>常用的拓扑结构如下表所示：  </p><div class="table-container"><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">结构</th><th style="text-align:left">优点</th><th style="text-align:left">缺点</th></tr></thead><tbody><tr><td style="text-align:left">星形<br>(最基本)</td><td style="text-align:left">每一个站点通过两条点对点链路与同一个中央节点连接：<br>一条链路负责发送，一条链路负责接收。中央节点的作用可以是实现广播功能，也可以实现帧交换功能。</td><td style="text-align:left">1. 新设备可以很方便地加入或者离开网络，可以提供更多，更方便的连接  <br>2.设备之间不会有干扰</td><td style="text-align:left">1. 可靠性低 <br>2.需要中央结点</td></tr><tr><td style="text-align:left">网形<br>(最基本)</td><td style="text-align:left">每个结点与可能不止一个其他结点相连。</td><td style="text-align:left">可靠性高，交换和路由设置更灵活。</td><td style="text-align:left">需要设置的链路数量更多，成本更高</td></tr><tr><td style="text-align:left">总线形*</td><td style="text-align:left">所有的站点通过标准的硬件接口直接连接到一个线性传输媒体上。</td><td style="text-align:left">新设备可以很方便地加入或者离开网络</td><td style="text-align:left">1. 可靠性低，如果主线断所有都断  <br> 2.需要采取某些机制避免碰撞  <br>3. 两端需要端子吸收信号</td></tr><tr><td style="text-align:left">环形*</td><td style="text-align:left">由若干段单向链路组成，每段链路的首尾通过转发器与其他链路的首/尾相连。</td><td style="text-align:left">被传输的信号在每一节点上再生，传输信息误码率可减到最少</td><td style="text-align:left">1. 结点故障会引起全网故障 <br>2.需要采取某些机制避免碰撞</td></tr><tr><td style="text-align:left">树形*</td><td style="text-align:left">从一个称为头端的点开始，延伸出多条缆线，每条缆线可以有多个分支。每条缆线可以视为一个总线形结构，缆线上有若干分接头。</td><td style="text-align:left">1.分支之间相对独立的同时分支之间的资源可以共享 <br> 2.新设备可以很方便地加入或者离开网络</td><td style="text-align:left">1.主线断，处处断 <br> 2.需要采取某些机制避免碰撞</td></tr></tbody></table></div><h3 id="通信网拓扑结构的演变"><a href="#通信网拓扑结构的演变" class="headerlink" title="通信网拓扑结构的演变"></a>通信网拓扑结构的演变</h3><ul><li>最初，结点之间的交换能力并不强，因此电信网采用的拓扑结构是网状结构，以保证端到端的连通性。并且当时的用户数量少，设置多条链路的开销并不大。  </li><li>随着用户数量的增大，网状拓扑结构多余链路的设置会带来更高的成本，因此电信网采用的拓扑结构是星形，当时此时已经有一些技术可以保证通信的可靠性，以弥补星形结构弱可靠性的缺点。  </li><li>电话费价格降低带来了业务量的增长，中央结点的负荷量增大，为了能够分担中央结点的负荷，此时中央结点之间由设置链路以分配各中央结点的负荷量，弥补交换能力的不足。用户接入数量的增多以及为了保证用户可以尽可能简单地接入网络，在用户连接端使用的拓扑结构仍然是星形。此时整个通信网被划分为核心网和接入网两大部分，并采用混合的拓扑结构。  </li><li>随着业务种类的增长，在这个阶段，中央结点的功能不再是单纯的交换，而有计算、存储等功能。进一步地，由于有足够高的数据率，这些功能节点可以被虚拟化至云服务器，并采用云计算技术提供支持。目前，为了进一步降低传播时延，部分云端的功能被拉入接入网，实现边缘计算。  </li></ul><h2 id="TCP-IP和OSI协议体系结构"><a href="#TCP-IP和OSI协议体系结构" class="headerlink" title="TCP-IP和OSI协议体系结构"></a>TCP-IP和OSI协议体系结构</h2><h3 id="协议和协议体系"><a href="#协议和协议体系" class="headerlink" title="协议和协议体系"></a>协议和协议体系</h3><p>通信双方在进行通信时还需要完成一些工作，比如：  </p><ul><li>源点系统激活直连的数据信道</li><li>源点系统确认终端已经准备好接收数据</li><li>格式转换  </li></ul><p>这些通信任务需要通信相关的设备和节点能够协同工作，协议就是一种指定协同工作方式和规则的体系结构，这些体系结构是由一组格式化和标准化的数据块承载，协议规定了通信的环境。<br>协议有三个关键因素:  </p><ul><li>语法：数据块的格式  </li><li>语义：包含控制信息  </li><li>定时：包括传输速率的匹配和数据包排序  </li></ul><p>同时，在协议体系中，通信任务被分解为若干个子任务，这些子任务的相互依赖关系形成栈结构。栈中的每一层需要依赖下一层执行更原始的功能，同时这一层也要向上一层提供服务。然而每一层又是相对独立的，即对每一层的设置和改动都不应该影响到其他层。两个通信系统必须要有相同的层次（称为对等层），才能建立层间通信。  </p><h3 id="TCP-IP结构"><a href="#TCP-IP结构" class="headerlink" title="TCP-IP结构"></a>TCP-IP结构</h3><p>TCP-IP的原始设想是两台计算机通过网络连接，源点应用程序将数据通过网络进行传送最终交付到目的计算机的应用程序中。根据这个设想可以将通信任务划分为如下的五层结构，从下到上依次是：  </p><ul><li>物理层：传输设备与传输媒体、网络的物理接口。  </li><li>网络接入层：端系统与相连网络之间的数据交换。与相连的两个系统提供网络接入，并进行路由选择。  </li><li>网际层/IP层：负责将数据传输跨越多个网络，这一层使用IP协议提供多个网络的路由。  </li><li>运输层/TCP层：保证数据包接收的顺序和可靠性，以及对属于不同应用的数据包的分配和交付。  </li><li>应用层：支持不同应用程序的逻辑。  </li></ul><h4 id="TCP和IP的操作"><a href="#TCP和IP的操作" class="headerlink" title="TCP和IP的操作"></a>TCP和IP的操作</h4><p>IP将来自某个主机的数据块经过多个路由器传递到另一个主机上，为了保证通信成功，每个主机都有一个唯一的全局互联网地址，称为IP地址。而TCP仅仅在端系统上实现，确保所有数据包都被可靠的交付给对应的应用程序，为了保证交付成功，主机上的每一个进程都会有一个内部唯一的地址，称为端口/端口号。而用户计算机上的应用程序可以调用计算机上不同的进程。  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220329131223.png width=50%>  </p><p>TCP/IP协议族中的每一层都只与它直接的相邻层进行操作，层与层之间的通信语言称为原语，原语大致分为4类：请求、指示、响应和证实。<br>在TCP/IP通信中，进程通过端口将发送数据（报文）递交给TCP，并指定目的地的端口和主机，这个过程会使用请求原语，同样地，TCP层将数据切分为更小的数据块便于管理，并在每个数据块前添加一段控制信息，（这段控制信息包括目的端口、序号、校验和等）并使用请求原语将报文向下递交给IP，IP也在TCP数据报之前附加一段控制信息，形成IP数据报，IP请求讲报文递交给网络接入层，并命令报文发送到路由器上。路由器检查IP数据报的首部，并通过路径转发数据，最终到达目的主机的网络接入层。网络接入层使用指示原语解包将数据传递到IP层，IP层对IP首部进行解包，也使用指示源语将数据传递到TCP层，TCP层解包TCP首部后将数据转发给对应的进程。   </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220329132806.png width=50%>   </p><p>上述过程称为“无证实的服务”。事实上，终端主机在接收到数据后还会通过指示源语向下传递确认信息，源的主机接受到确认信息后通过证实源语向上传递，加入这两个步骤的服务称为“证实的服务”。  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220329133102.png width=50%>   </p><h4 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h4><p>除了TCP协议外，还有另一种运输层协议，称为用户数据报协议（UPD），这是一种无连接的分组交换协议。UDP可以让一个进程通过最少的协议机制向另一个进程发送报文。其本质是在IP上增加了一个端口寻址的能力。  </p><h3 id="OSI参考模型体系结构"><a href="#OSI参考模型体系结构" class="headerlink" title="OSI参考模型体系结构"></a>OSI参考模型体系结构</h3><p>OSI体结构参考模型(OSIRM)包括7层，但是由于TCP协议成熟之时OSI协议尚处于开发阶段，因此整体上的OSI七层模型设计并未得到真正应用。不过基于OSI理念下仍然成功地开发出了很多有用的协议。  </p><figure class="half">  <img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220329133452.png width=32.7%>    <img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220329133650.png width=30%>  </figure> <h4 id="OSI框架的标准化"><a href="#OSI框架的标准化" class="headerlink" title="OSI框架的标准化"></a>OSI框架的标准化</h4><p>OSI框架的标准规定：  </p><ul><li>每一层功能有有成熟的定义，并且可以独立并行地为每一层开发标准。  </li><li>层与层之间的边界有成熟的定义，改变某一层的标准不会影响到一个层中现有的软件。  </li></ul><p>其标准化依赖于三个关键元素：</p><ul><li>协议规约：不同系统中同层的两个实体可以通过协议相互合作和交互</li><li>服务定义：每一层提供给上层的服务需要标准化</li><li>寻址：每一层可以向上一层的多个实体提供多种服务  </li></ul><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220329134115.png width=50%>  </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>通信和计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信工程</tag>
      
      <tag>通信网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>✨【置顶/必看】如何利用本网站</title>
    <link href="/2022/03/13/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E6%9C%AC%E7%BD%91%E7%AB%99/"/>
    <url>/2022/03/13/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E6%9C%AC%E7%BD%91%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<h1 id="如何利用本网站"><a href="#如何利用本网站" class="headerlink" title="如何利用本网站"></a>如何利用本网站</h1><p>这篇文章将告诉你如何更好的利用本网站当中的资料从而对你的学习生活真正有用。<br>本网站中的学习笔记主要包括如下几个部分：</p><ul><li><p>来自重庆邮电大学和布鲁内尔大学的课程笔记（在“分类”-“学习笔记”中），内容包括：  </p><ul><li>随课笔记，即每堂课结束后根据课堂内容和相关资料整理而成的笔记（以数字标号和章节内容为标题，例如“01.运算放大器”），侧重点为<strong>课堂知识的逻辑性连接</strong>和以及<strong>原理阐释</strong>。  </li><li>总结性笔记，即期末考试之前对整个课程内容，结合重邮和布鲁内尔的期末考试试卷系统性总结整理而成的笔记，侧重点为<strong>考试考点</strong>和<strong>重点题型相关的模型推导</strong>。  </li></ul><p>如何利用它们：  </p><ul><li>在假期或者上课之前作为预习材料。</li><li>在课后作为复习和总结资料的参考，<strong>建议自己先推导或者总结一遍，再与本网站中对应标题的文章进行核对</strong>。</li><li>在课后，如果疑难问题，可以将本网站作为参考查阅对应的知识点。  </li><li>在期末考试前作为自己总结资料的参考，<strong>建议自己先推导或者总结一遍，再与本网站中对应标题的文章进行核对</strong>。</li><li>在未来的生活中，作为参考资料进行查阅。  </li></ul></li><li><p>其他，包括：</p><ul><li>各培训机构的课堂笔记</li><li>互联网上公开课的课堂笔记</li><li>交流学习的笔记</li><li>其他作者的学习笔记</li><li>…  </li></ul><p>如何利用它们：  </p><ul><li>结合自己学习的内容进行补充学习。  </li><li>作为参考资料进行查阅。  </li></ul></li></ul><h2 id="课程资料清单"><a href="#课程资料清单" class="headerlink" title="课程资料清单"></a>课程资料清单</h2><p>截止目前，本网站中包含重邮-布鲁内尔课程内容如下：<br>第一学年  </p><ul><li>EE1655 数字系统与微处理器（Digital Systems and Microprocessors）【总结】  </li></ul><p>第二学年  </p><ul><li>A1110300 大学物理A（下） 【总结】</li><li>EE1618 电路与器件（Devices and Circuits） 【总结】</li><li>A1110130 概率论与数理统计（随机数学）【总结】 </li><li>EE2622 信号与系统（Fundamentals of Signals and Systems） 【随课/总结】</li><li>EE2623 计算机组成与接口（Computer Architecture and Interfacting） 【总结】</li><li>EE2632 天线与通信传输原理（通信信号传输，Communication Signals Transmission） 【随课/总结】</li></ul><p>第三学年  </p><ul><li>EE2624 数字信号处理 （Digital Signal Processing） 【随课/总结】</li><li>EE2626/A2010340 通信原理 （通信原理A，Principles of Communications） 【随课/总结】</li><li>EE2627 电子系统 （Electronic Systems） 【随课/总结】</li><li>EE2634 数字系统与可靠性工程（Digital Systems Design and Reliability Engineering） 【总结】</li><li>EE3 控制系统（Control System） 【随课/总结】</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>10. 连续系统状态空间的补偿器设计</title>
    <link href="/2022/03/13/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/10.%20%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4%E8%AE%BE%E8%AE%A1/"/>
    <url>/2022/03/13/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/10.%20%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="连续系统状态空间的补偿器设计"><a href="#连续系统状态空间的补偿器设计" class="headerlink" title="连续系统状态空间的补偿器设计"></a>连续系统状态空间的补偿器设计</h1><p>通过频率响应进行设计的缺陷是：<br>当系统的阶数高于2后，由于缺少用来高阶近似的参数而无法改进系统特定的极点。<br>状态空间中的设计可以通过一些数学方法寻找到这些参数，并对闭环系统特定的极点进行调整。<br>状态空间中的设计分为两部分:   </p><ul><li>控制器（controller）设计：通过指定控制器增益将状态变量反馈给系统的输入$u$。  </li><li>观测器（observer）设计：通过指定观测器增益将实际输出与估计输出之间的误差反馈给状态变量的微分。  </li></ul><p>上述两种设计中的增益可以通过匹配设计要求的系统特征方程与实际的系统特征方程的系数来得到。  </p><h2 id="全状态反馈控制器设计"><a href="#全状态反馈控制器设计" class="headerlink" title="全状态反馈控制器设计"></a>全状态反馈控制器设计</h2><p>对于一个n阶反馈控制系统，其闭环特征方程为：  </p><script type="math/tex; mode=display">s^n+a_{n-1}s^{n-1}+a_1s+a_0=0</script><p>这$n$个方程系数$a_i$会决定系统极点所在的位置。因此全状态反馈控制器(full-state feedback controller)的设计思路是引入$n$个可调整的参数$k_i$对系统特征方程的系数$a_i$进行调整，进而使得系统极点能够在设计要求的位置。这样的思路前提是系统是能控的。  </p><p>在全状态反馈控制器中，由$n$个可调整的参数$k_i$组成的向量$K$被添加在了反馈回路中，如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220313143921.png width=50%>  </p><p>根据系统框图可以得到系统的状态空间表示：  </p><script type="math/tex; mode=display">\vec{\dot{x}}=A\vec{x}+Bu=(A-BK)\vec{x}+Br</script><script type="math/tex; mode=display">y=C\vec{x}</script><p>如此，新的状态转换矩阵为：$Φ(s)=[sI-(A-BK)]$.<br>根据状态转换矩阵，可以得到改进后的系统特征方程为：  </p><script type="math/tex; mode=display">|Φ(s)|=|sI-(A-BK)|=0</script><h3 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h3><p>系统设计的准则是：  </p><ul><li>阶跃响应更快的达到稳定</li><li>增加系统的稳定性<br>根据系统的稳定性准则，系统的设计更需要极点在s域左半平面并且远离s平面的虚轴。可以通过增大控制器的增益$K$来得到符合要求的极点。  </li></ul><p>此外，可以通过增加额外的极点来与系统现有的零点抵消，更能增加系统的稳定性。  </p><h3 id="设计步骤"><a href="#设计步骤" class="headerlink" title="设计步骤"></a>设计步骤</h3><h4 id="相位变化型设计"><a href="#相位变化型设计" class="headerlink" title="相位变化型设计"></a>相位变化型设计</h4><p>如果系统以相位变化型给出：  </p><ul><li>检查系统原型的稳定性</li><li>根据系统设计要求中的过冲率和设置时间计算出系统要求的阻尼比$ζ$和固有频率$ω_n$，构建系统的二阶极点项：$(s^2+2ζω_ns+ω_n^2)$   </li><li>如果系统原型存在零点$(s+z)$，则添加新的极点项$(s+p),p=z$。<br>（此时可以得到设计要求的极点多项式为：$(s+p)(s^2+2ζω_ns+ω_n^2)$）</li><li>$n$个反馈控制系数$-k$，并计算得到矩阵$A-BK$。  </li><li>找到改进后系统的特征方程$|sI-(A-BK)|=0$。  </li><li>将$|sI-(A-BK)|=0$与$(s+p)(s^2+2ζω_ns+ω_n)=0$的系数进行匹配，使用待定系数法即可得到所有的$k$</li></ul><h4 id="非相位变化型设计"><a href="#非相位变化型设计" class="headerlink" title="非相位变化型设计"></a>非相位变化型设计</h4><p>如果系统原型没有以相位变化型给出$\begin{cases}<br>    \vec{\dot{z}}=A_z\vec{z}+B_zu\\<br>    y=C_z\vec{z}<br>\end{cases}$，那么可以假设有映射关系$\vec{z}=P\vec{x}$使得系统的状态空间表示为相位变化型。<br>那么有：  </p><script type="math/tex; mode=display">\vec{\dot{x}}=P^{-1}A_xP\vec{x}+P^{-1}B_xu</script><script type="math/tex; mode=display">y=C_xP\vec{z}</script><p>变换前后的控制矩阵和反馈控制向量有如下关系：  </p><script type="math/tex; mode=display">C_z=PC_x</script><script type="math/tex; mode=display">K_z=K_xP^{-1}</script><p>那么可以得到：  </p><script type="math/tex; mode=display">P=C_zC^{-1}_x</script><p>其中：<strong>$C_z$是系统非相位变化型表示中的控制矩阵，$C_x$是系统相位变化型表示中的能控矩阵。</strong>  </p><p>所以基本思路是：  </p><ul><li>求得现在系统的控制矩阵$C_z=[B_z|A_zB_z|…|A_z^{n-1}B_z]$</li><li>根据$|sI-A_z|=0$找到现在系统的特征方程。  </li><li>根据特征方程，写出系统状态空间表示的相位变化型，找到系统相位变化型的能控矩阵$C_x=[B_x|A_xB_x|…|A^{n-1}_xB_x]$</li><li>检验能控性。  </li><li>根据$P=C_zC^{-1}_x$得到$P$</li><li>根据相位变化型中的$A_x$，$B_x$，找到$A_x-B_xK_x$，并得到目标系统的特征方程$|sI-(A_x-B_xK_x)|=0$</li><li>根据设计目标求出$ω_n$和$ζ$，并构造系统的特征方程。  </li><li>将系统的特征方程与$|sI-(A_x-B_xK_x)|=0$进行系数匹配，得到$K_x$</li><li>利用$K_z=K_xP^{-1}$得到$K_z$</li></ul><h2 id="全状态观测器"><a href="#全状态观测器" class="headerlink" title="全状态观测器"></a>全状态观测器</h2><p>在实际工程中，测量系统的全部状态的开销非常大。观测器(observer/state estimator)可以预测系统状态并反馈，以此来减少需要测量的系统状态，进而节省设计支出。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220313163335.png width=50%><br>同全状态控制器的设计思路，全状态观测器通过设计一个常数向量$L$，使观测器的瞬态响应比受控回路的响应快，从而得到系统状态向量的快速更新估计。观测器的设计要求系统原型必须是能观的。<br>观测器系统的框图如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220313163647.png width=50%><br>整个系统又称为误差系统(error system)。  </p><p>设误差系统的状态误差为$\vec{\hat{x_e}}=\vec{x}-\vec{\hat{x}}$表示实际状态与观测器估计的差异：  </p><p>与系统原型的状态空间表示$\begin{cases}<br>    \vec{\dot{x}}=A\vec{x}+Bu\\<br>    y=C\vec{x}<br>\end{cases}$相减，得到：  </p><script type="math/tex; mode=display">\vec{\dot{x}}-\vec{\dot{\hat{x}}}=A(\vec{x}-\vec{\hat{x}})-L(y-\hat{y})</script><script type="math/tex; mode=display">y-\hat{y}=C(\vec{\dot{x}}-\vec{\dot{\hat{x}}})</script><p>进一步得到：  </p><script type="math/tex; mode=display">\vec{\dot{x}}-\vec{\dot{\hat{x}}}=(A-LC)(\vec{x}-\vec{\hat{x}})</script><script type="math/tex; mode=display">y-\hat{y}=C(\vec{\dot{x}}-\vec{\dot{\hat{x}}})</script><p>误差系统的特征方程为：  </p><script type="math/tex; mode=display">|sI-(A-LC)|=0</script><h3 id="设计步骤-1"><a href="#设计步骤-1" class="headerlink" title="设计步骤"></a>设计步骤</h3><ul><li>将系统原型改写为能观标准型，并检查系统原型的能观性。  </li><li>根据系统原型的能观标准型，得到其状态转移矩阵$Φ=A-LC$</li><li>根据系统的状态转换矩阵得到含有观测系数$l$的系统特征方程：$|sI-(A-LC)|=0$  </li><li>根据对系统设计的要求计算出要求的阻尼比$ζ$和固有频率$ω_n$，构造目标系统的特征方程。  </li><li>将目标系统的特征方程与$|sI-(A-LC)|=0$匹配，使用待定系数法得到观测向量$L$中的每一个元素$l$。  </li></ul><p>当原型系统$\begin{cases}<br>    \vec{\dot{z}}=A\vec{z}+Bu\\<br>    y=C\vec{z}<br>\end{cases}$没有以能观标准型给出时，那么可以假设有映射关系$\vec{z}=P\vec{x}$使得系统的状态空间表示为能观标准型。<br>那么有：  </p><script type="math/tex; mode=display">\vec{\dot{x}}=P^{-1}AP\vec{x}+P^{-1}Bu</script><script type="math/tex; mode=display">y=CP\vec{x}</script><p>变换前后的控制矩阵和反馈控制向量有如下关系：  </p><script type="math/tex; mode=display">O_z=PO_x</script><script type="math/tex; mode=display">L_z=L_xP^{-1}</script><p>那么可以得到$P=O_zO^{-1}_x$和$L_z$。<br>所以基本思路是：  </p><ul><li>找到现在系统的能观矩阵$O_z$  </li><li>根据$|sI-A|=0$找到现在系统的特征方程。  </li><li>根据特征方程，写出系统状态空间表示的能观标准型，找到系统的能观矩阵$O_x$并检验能观性。  </li><li>根据$P=O_z^{-1}O_x$得到$P$</li><li>根据相位变化型中的$A_x$，$B_x$，找到$A_x-L_xB_x$，并得到目标系统的特征方程$|sI-(A_x-L_xB_x)|=0$</li><li>根据设计目标求出$ω_n$和$ζ$，并构造系统的特征方程。  </li><li>将系统的特征方程与$|sI-(A_x-L_xB_x)|=0$进行系数匹配，得到$L_x$</li><li>利用$L_z=L_xP^{-1}$得到$L_z$</li></ul><h2 id="控制器和观测器的对偶性"><a href="#控制器和观测器的对偶性" class="headerlink" title="控制器和观测器的对偶性"></a>控制器和观测器的对偶性</h2><p>可以发现，控制器的设计方法和观测器的设计方法几乎一样。事实上，控制器系统和观测器系统在数学上呈现对偶性。<br>如果控制器系统的状态空间表示系数矩阵为$A$,$B$,$C$，<br>那么观测器系统的状态空间表示系数矩阵为$A^T$,$C^T$,$B^T$。<br>在MATLAB中，观测器系统和控制器系统的控制系数和观测系数向量都用命令<code>place()</code>生成，对控制器系统：<code>K=place(A,B,p)</code><br>对观测器系统：<code>L=place(A&#39;,C&#39;,p)</code>.<br>其中<code>p</code>是闭环系统所有极点组成的向量。  </p><h2 id="观测器和控制器的连接"><a href="#观测器和控制器的连接" class="headerlink" title="观测器和控制器的连接"></a>观测器和控制器的连接</h2><p>整个系统连接观测器和控制器后如图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220314123801.png width=50%>  </p><h3 id="引入系统输入"><a href="#引入系统输入" class="headerlink" title="引入系统输入"></a>引入系统输入</h3><p>在完成对观测器和控制器的设计之后，整个系统的状态空间表示为：  </p><script type="math/tex; mode=display">\vec{\dot{\hat{x}}}=A\vec{\hat{x}}+Bu+L(y-\hat{y})</script><script type="math/tex; mode=display">y=C\vec{\hat{x}}</script><p>同时，根据系统框图有：  </p><script type="math/tex; mode=display">u=-K\vec{\hat{x}}+r</script><p>带入状态方程，得到：  </p><script type="math/tex; mode=display">\vec{\dot{\hat{x}}}=A\vec{\hat{x}}+B(-K\vec{\hat{x}}+r)+L(y-C\vec{\hat{x}})</script><p>整理后有：  </p><script type="math/tex; mode=display">\vec{\dot{\hat{x}}}=(A-BK-LC)\vec{\hat{x}}+Ly+Br</script><p>通常增加常量$N$和向量$\vec{M}$以便进行调整：  </p><script type="math/tex; mode=display">\vec{\dot{\hat{x}}}=(A-BK-LC)\vec{\hat{x}}+Ly+\vec{M}r</script><script type="math/tex; mode=display">u=-K\vec{\hat{x}}+Nr</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220314124843.png width=50%>  </p><h3 id="全状态反馈"><a href="#全状态反馈" class="headerlink" title="全状态反馈"></a>全状态反馈</h3><p>在全状态反馈中，使用向量$\vec{N_x}$和标量$N_u$对系统进行调整：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220314125223.png width=50%>  </p><p>有：  </p><script type="math/tex; mode=display">\overline{N}=n_u+K\vec{n_x}</script><p>为了使稳态条件下$y=r$，令$\vec{x}=\vec{n_x}r$,$u=n_ur$，在稳态条件下，系统状态的微分为0，有：  </p><script type="math/tex; mode=display">0=A\vec{n_x}r+Bn_ur</script><script type="math/tex; mode=display">1=C\vec{n_x}+Dn_u</script><p>进一步矩阵化方程，有：  </p><script type="math/tex; mode=display">\begin{bmatrix}    0 \\ 1 \end{bmatrix}=\begin{bmatrix}    A & B \\    C & D \\\end{bmatrix}\begin{bmatrix}    \vec{n_x}\\ n_u\end{bmatrix}</script><p>即：  </p><script type="math/tex; mode=display">\begin{bmatrix}    \vec{n_x}\\ n_u\end{bmatrix}=\begin{bmatrix}    A & B \\    C & D \\\end{bmatrix}^{-1}\begin{bmatrix}    0 \\ 1 \end{bmatrix}</script><p>通过上述式子可以求得向量$\vec{n_x}$和标量$n_u$。<br>此时系统的传输函数为：  </p><script type="math/tex; mode=display">\frac{Y(s)}{R(s)}=\overline{N}C(sI-A+BK)^{-1}B</script><h3 id="Zero-assignment-Estimator"><a href="#Zero-assignment-Estimator" class="headerlink" title="Zero-assignment Estimator"></a>Zero-assignment Estimator</h3><p>根据如下的公式,对I型控制系统：  </p><script type="math/tex; mode=display">\frac{1}{K_v}=∑\frac{1}{z_i}-∑\frac{1}{p_i}</script><p>$z_i$和$p_i$分别是整个系统的闭环零点和极点。<br>上述公式被称为Truxal误差常数计算公式，可以发现通过改变系统的零点和极点分布，可以改变系统的速度误差常数$K_v$。可以发现，当闭环极点远离虚轴时，速度误差常数$K_v$会增大。<br>对系统$\begin{cases}<br>    \vec{\dot{\hat{x}}}=(A-BK-LC)\vec{\hat{x}}+Ly+\vec{M}r\\<br>    u=-K\vec{\hat{x}}+\overline{N}r<br>\end{cases}$，经过计算可以发现系统的零点由如下方程确定：  </p><script type="math/tex; mode=display">|sI-A+BK+LC-\frac{M}{N}K|=0</script><blockquote><p>计算过程详见：<br><a href="https://zhuanlan.zhihu.com/p/111317278#:~:text=Compensator%EF%BC%9A%E8%A7%82%E6%B5%8B%E5%99%A8%E4%B8%8E%E6%8E%A7%E5%88%B6%E5%BE%8B%E7%9A%84%E7%BB%93%E5%90%88%20Observer-Based%20Controller">https://zhuanlan.zhihu.com/p/111317278#:~:text=Compensator%EF%BC%9A%E8%A7%82%E6%B5%8B%E5%99%A8%E4%B8%8E%E6%8E%A7%E5%88%B6%E5%BE%8B%E7%9A%84%E7%BB%93%E5%90%88%20Observer-Based%20Controller</a></p></blockquote><p>可以发现，通过设置$N$和$M$就可以自由配置零点。这样的配置称为Zero-assignment Estimator。  </p><h2 id="补偿器设计"><a href="#补偿器设计" class="headerlink" title="补偿器设计"></a>补偿器设计</h2><p>简单来说，补偿器就是系统的控制器和观测器的结合：在反馈回路上，系统的误差可以被观测器捕捉，并将误差传递给控制器，由控制器对系统进行调整，并输出补偿值并在前项传输过程中对系统输入进行调整，使得可以进一步减小系统误差。这样的系统行为称为补偿(compansation)。  </p><h3 id="反馈补偿"><a href="#反馈补偿" class="headerlink" title="反馈补偿"></a>反馈补偿</h3><p>对于系统$\begin{cases}<br>    \vec{\dot{\hat{x}}}=(A-BK-LC)\vec{\hat{x}}+Ly+\vec{M}r\\<br>    u=-K\vec{\hat{x}}+\overline{N}r<br>\end{cases}$，如果选择$M=B\overline{N}$，并且带入$u=-K\vec{\hat{x}}+\overline{N}r$即可得到：  </p><script type="math/tex; mode=display">\vec{\dot{\hat{x}}}=(A-LC)\vec{\hat{x}}+Ly+Bu</script><script type="math/tex; mode=display">u=-K\vec{\hat{x}}+\overline{N}r</script><p>如此，观测器的输入将观测系统输出的反馈$y$和控制器的输出$u$，这样的补偿形式称为系统的反馈补偿/标准形式（standard case)：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220315152020.png width=50%>  </p><p>此时系统的特征方程为：  </p><script type="math/tex; mode=display">|sI-A+BK|=0</script><p>可以发现系统的特征方程与控制器的特征方程一致。在这种设置下，通过设置控制器的话参数就可以调整整个系统的极点分布，因此这种形式的补偿器通常是设置补偿系统的最优方案。  </p><h3 id="串联补偿"><a href="#串联补偿" class="headerlink" title="串联补偿"></a>串联补偿</h3><p>补偿器的串联补偿/标准形式（classical case）如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220315154017.png width=50%>  </p><p>对于系统$\begin{cases}<br>    \vec{\dot{\hat{x}}}=(A-BK-LC)\vec{\hat{x}}+Ly+\vec{M}r\\<br>    u=-K\vec{\hat{x}}+\overline{N}r<br>\end{cases}$，如果选$\overline{N}=0,M=-L$，那么有：  </p><script type="math/tex; mode=display">\vec{\dot{\hat{x}}}=(A-LC-BK)\vec{\hat{x}}+L(y-r)</script><script type="math/tex; mode=display">u=-K\vec{\hat{x}}+\overline{N}r</script><p>可以发现通过这样的参数设置可以将状态方程中的观测器输入改为$y-r$，即系统误差$e$.<br>此时，系统的特征方程为：  </p><script type="math/tex; mode=display">|sI-A+BK||sI-A+LC|=0</script><p>整个系统的极点由观测器和控制器共同决定。<br>此时系统补偿器的传递函数为：  </p><script type="math/tex; mode=display">D_c(s)=-\frac{U(s)}{Y(s)}=K(sI-A+BK)</script><h2 id="积分控制"><a href="#积分控制" class="headerlink" title="积分控制"></a>积分控制</h2><p>补偿系统的问题在于，控制器和观测器的引入都会导致非常大的稳态误差。其次，虽然可以通过选择合适的$\overline{N}$来让稳态误差归零，但是这样的方法鲁棒性低，系统原型中任何参数的改变都会让稳态误差重新不为0.<br>解决问题的思路是利用积分项能够增加系统的类的同时将系统误差减小到0的特点，在系统控制器之前增加一个增益为$K_e$的积分单元，这种方法称为积分控制。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220315162747.png width=60%>  </p><p>此时系统的状态空间表示为：  </p><script type="math/tex; mode=display">\vec{\dot{x}}=A\vec{x}+Bu</script><script type="math/tex; mode=display">\dot{x_N}=-C\vec{x}+r</script><script type="math/tex; mode=display">y=C\vec{x}</script><p>有：  </p><script type="math/tex; mode=display">\begin{bmatrix}    \vec{\dot{x}}\\    \dot{x_N}\end{bmatrix}=\begin{bmatrix}    A & 0\\    -C & 0\end{bmatrix}\begin{bmatrix}    \vec\\    x_N\end{bmatrix}+\begin{bmatrix}    B\\    0\end{bmatrix}u+\begin{bmatrix}    0\\    1\end{bmatrix}r</script><p>同时，$u=-K\vec{x}+K_ex_N=-[K -K_e]\begin{bmatrix}<br>    \vec{x} \\  x_N<br>\end{bmatrix}$，</p><script type="math/tex; mode=display">\begin{bmatrix}    \vec{\dot{x}}\\    \dot{x_N}\end{bmatrix}=\begin{bmatrix}    A-BK & BK_e\\    -C & 0\end{bmatrix}\begin{bmatrix}    \vec\\    x_N\end{bmatrix}+\begin{bmatrix}    0\\    1\end{bmatrix}r</script><script type="math/tex; mode=display">y=\begin{bmatrix}    C & 0\end{bmatrix}\begin{bmatrix}    \vec\\    x_N\end{bmatrix}</script><p>同样地，根据这个方程可以得到特征多项式为：  </p><script type="math/tex; mode=display">|sI-\begin{bmatrix}    A-BK & BK_e\\    -C & 0\end{bmatrix}|</script><h3 id="设计流程"><a href="#设计流程" class="headerlink" title="设计流程"></a>设计流程</h3><ul><li>利用设计要求设计控制器，并找到控制矩阵$K$</li><li>利用设计要求构造新的特征多项式</li><li>利用行列式$|sI-\begin{bmatrix}<br>  A-BK &amp; BK_e\\<br>  -C &amp; 0<br>\end{bmatrix}|$得到含有$K_e$的特征多项式</li><li>系数匹配，得到$K_e$</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>控制系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>09. 连续系统的状态空间表示和分析</title>
    <link href="/2022/03/12/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/9.%20%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4/"/>
    <url>/2022/03/12/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/9.%20%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="连续系统的状态空间表示和分析"><a href="#连续系统的状态空间表示和分析" class="headerlink" title="连续系统的状态空间表示和分析"></a>连续系统的状态空间表示和分析</h1><p>现代复杂控制系统中往往包含多个输入和多个输出，系统的分析更加复杂。使用一些数学方法可以简化对这些系统的分析。这些数学方法建立在对系统状态(state)的理解上：系统的状态是指系统变量、输入信号和用于描述系统动态变化的方程的集合，系统状态可以理解为系统的记忆，$t=t_0$时的系统状态能够记忆系统在$t&lt;t_0$时系统的全部输入和之前全部系统的状态。系统的状态可以提供对系统未来状态和系统输出的分析。  </p><h2 id="系统的状态空间表示"><a href="#系统的状态空间表示" class="headerlink" title="系统的状态空间表示"></a>系统的状态空间表示</h2><p>系统的响应可以用一系列的由状态变量($x_i$)和输入信号表示的一阶微分方程：  </p><script type="math/tex; mode=display">\dot{x_1}=a_{11}x_1+a_{12}x_2+...+a_{1n}x_n+b_{11}u_1+...b_{1m}u_m</script><script type="math/tex; mode=display">\dot{x_2}=a_{21}x_1+a_{22}x_2+...+a_{2n}x_n+b_{21}u_1+...b_{2m}u_m</script><script type="math/tex; mode=display">...</script><script type="math/tex; mode=display">\dot{x_n}=a_{n1}x_1+a_{n2}x_2+...+a_{nn}x_n+b_{n1}u_1+...b_{nm}u_m</script><p>其中$\dot{x}=\frac{d}{dt}x$.<br>这些系数和变量都可以被矩阵化：  </p><script type="math/tex; mode=display">\frac{d}{dt}\begin{bmatrix}    x_1 \\ x_2 \\ ⋮ \\ x_n\end{bmatrix}=\begin{bmatrix}    a_{11} & a_{12} & \dots &a_{1n}\\    a_{21} & a_{22} & \dots &a_{2n}\\    ⋮ & &\dots & ⋮ \\    a_{n1} & a_{n2} & \dots &a_{nn}\\\end{bmatrix}\begin{bmatrix}    x_1 \\ x_2 \\ ⋮ \\ x_n\end{bmatrix}+\begin{bmatrix}    b_{11} & \dots & b_{1m} \\    ⋮ & & ⋮ \\    b_{n1} & \dots & b_{nm}\end{bmatrix}\begin{bmatrix}    u_1 \\ u_2 \\ ⋮ \\ u_m\end{bmatrix}</script><p>上述矩阵化方程可以被简写为：  </p><script type="math/tex; mode=display">\vec{\dot{x}}=A\vec{x}+Bu</script><p>$A$是系统原型的系数矩阵(plant coeffient matrix)，$B$是控制矩阵(control matrix)。<br>这个微分方程称为系统的<strong>状态方程</strong>(state equation)，对应传递函数的极点多项式。<br>其中，$\vec{\dot{x}}$可以表示视为前一个时刻系统的状态（微分表示时延），$\vec{x}$和$u$是当前系统的状态和输入。即当系统之前的状态和当前的输入已知时，当前的系统状态被确定下来。<br>同时，线性系统的输出也可以由系统状态和输入信号两部分组成：  </p><script type="math/tex; mode=display">y=C\vec{x}+Du</script><p>$C$是系统的输出观测矩阵（output observation matrix），$D$是直接耦合矩阵(direct coupling matrix)。<br>这个微分方程称为系统的<strong>输出方程</strong>(output equation)，对应传递函数的零点多项式。<br>这两个方程组共同作用，可以准确的描述一个系统。用系统的状态方程和输出方程来描述系统的表达方式称为系统的状态空间表示（state-space representation/state-variable representation）。<br>某个特定系统的状态空间表达不是唯一的。<br>根据这两个方程可以建立如下的系统框图：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220312161154.png width=50%>  </p><h2 id="微分方程与状态空间的转换"><a href="#微分方程与状态空间的转换" class="headerlink" title="微分方程与状态空间的转换"></a>微分方程与状态空间的转换</h2><p>对于一个$n$阶微分方程：  </p><script type="math/tex; mode=display">\frac{d^ny}{dt^n}+a_{n-1}\frac{d^{n-1}y}{dt^{n-1}}+...+a_0y=b_0u</script><p>可以将系统的输出变量及其微分形式视为系统的状态变量：  </p><script type="math/tex; mode=display">x_1=y</script><script type="math/tex; mode=display">x_2=\frac{dy}{dt}⇒\dot{x_1}=x_2</script><script type="math/tex; mode=display">...</script><script type="math/tex; mode=display">x_n=\frac{d^{n-1}y}{dt^{n-1}}⇒\dot{x_n}=\frac{d^ny}{dt^n}=-a_0x_1-a_1x_2-...-a_{n-1}x_n+b_0u</script><p>整理后就可以得到一系列的系统的状态方程：  </p><script type="math/tex; mode=display">x_1=y</script><script type="math/tex; mode=display">\dot{x_1}=x_2</script><script type="math/tex; mode=display">...</script><script type="math/tex; mode=display">\dot{x_n}=-a_0x_1-a_1x_2-...-a_{n-1}x_n+b_0u</script><p>将这些状态方程矩阵化即可得到系统的状态方程与输出方程：  </p><script type="math/tex; mode=display">\vec{\dot{x}}=A\vec{x}+Bu</script><script type="math/tex; mode=display">y=C\vec{x}+Du</script><h3 id="信号流图与状态空间的转换"><a href="#信号流图与状态空间的转换" class="headerlink" title="信号流图与状态空间的转换"></a>信号流图与状态空间的转换</h3><p>信号流图可以从一系列的系统状态方程得到：  </p><ul><li>画出系统的输入$u$或者$r$，系统的每一个状态$x_i$，以及系统输出$y$的节点。  </li><li>根据每一个状态方程，将对应的节点用箭头连接，并标上对应的系数，注意用$\frac{1}{s}$表示微分。<br>下图表示了$\begin{cases}<br>  \dot{x_1}=x_2\\<br>  \dot{x_2}=x_3\\<br>  \dot{x_3}=-24x_1-26x_2-9x_3+24r\\<br>  y=x_1<br>\end{cases}$的信号流图：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220313134750.png width=50%>  </li></ul><h3 id="状态空间的表达形式（传递函数与状态空间的转换）"><a href="#状态空间的表达形式（传递函数与状态空间的转换）" class="headerlink" title="状态空间的表达形式（传递函数与状态空间的转换）"></a>状态空间的表达形式（传递函数与状态空间的转换）</h3><p>下面将介绍四种表达状态空间的形式，对于$n$阶微分方程：  </p><script type="math/tex; mode=display">\frac{d^ny}{dt^n}+a_{1}\frac{d^{n-1}y}{dt^{n-1}}+...+a_ny=\frac{d^nu}{dt^n}+b_{1}\frac{d^{n-1}u}{dt^{n-1}}+...+b_nu</script><p>$u$表示系统输入，$y$表示系统输出。<br>那么在s域中有系统的传递函数：  </p><script type="math/tex; mode=display">\frac{Y(s)}{U(s)}=\frac{b_0s^n+b_1s^{n-1}+...+b_n}{s^n+a_1s^{n-1}+...+a_{n-1}s+a_n}</script><h4 id="能控标准型"><a href="#能控标准型" class="headerlink" title="能控标准型"></a>能控标准型</h4><p>对于形如：  </p><script type="math/tex; mode=display">TF(s)=\frac{Y(s)}{U(s)}=\frac{b_0s^n+b_1s^{n-1}+...+b_n}{s^n+a_1s^{n-1}+...+a_{n-1}s+a_n}</script><p>的传递函数。<br>能控标准型（controllable-canonical form）的系数矩阵如下：  </p><script type="math/tex; mode=display">A=\begin{bmatrix}    -a_1 & -a_2 & ... & -a_{n-1} & -a_n \\    1 & 0 & ... & 0 & 0\\    0 & 1 & ... & 0 & 0\\    ⋮ & ⋮ & ⋱ & ⋮ & ⋮ \\    0 & 0 & ... & 1 & 0\\\end{bmatrix}</script><script type="math/tex; mode=display">B=\begin{bmatrix}    1 \\ 0 \\ ⋮ \\ 0\end{bmatrix}</script><script type="math/tex; mode=display">C=\begin{bmatrix}    b_1 & b_2 & b_3 &\dots&b_n\end{bmatrix}</script><script type="math/tex; mode=display">D=[b_0]</script><p>能控标准型在系统所有状态都已知的情况下分析系统是很有用的。  </p><h4 id="相位变化型"><a href="#相位变化型" class="headerlink" title="相位变化型"></a>相位变化型</h4><p>对于形如：  </p><script type="math/tex; mode=display">TF(s)=\frac{Y(s)}{U(s)}=\frac{b_0s^n+b_1s^{n-1}+...+b_n}{s^n+a_1s^{n-1}+...+a_{n-1}s+a_n}</script><p>的传递函数。<br>相位变化型（phase-variable form）的系数矩阵如下：  </p><script type="math/tex; mode=display">A=\begin{bmatrix}    0 & 1 & ... & 0 & 0\\    ⋮ & ⋮ & ⋱ & ⋮ & ⋮ \\    0 & 0 & ... & 1 & 0\\    0 & 0 & ... & 0 & 1\\    -a_n & -a_{n-1} & ... & -a_{2} & -a_1 \\\end{bmatrix}</script><script type="math/tex; mode=display">B= \begin{bmatrix}    0 \\ 0 \\ ⋮ \\ 1\end{bmatrix}</script><script type="math/tex; mode=display">C=\begin{bmatrix}    b_n & b_{n-1} & b_{n-2} &\dots&b_1\end{bmatrix}</script><script type="math/tex; mode=display">D=[b_0]</script><p><strong>相位变化型矩阵在控制器设计中十分有用。</strong>  </p><h4 id="能观标准型"><a href="#能观标准型" class="headerlink" title="能观标准型"></a>能观标准型</h4><p>对于形如：  </p><script type="math/tex; mode=display">TF(s)=\frac{Y(s)}{U(s)}=\frac{b_0s^n+b_1s^{n-1}+...+b_n}{s^n+a_1s^{n-1}+...+a_{n-1}s+a_n}</script><p>的传递函数。<br>能观标准型（observable-canonical form）的系数矩阵如下：  </p><script type="math/tex; mode=display">A=\begin{bmatrix}    -a_1 & 1 & 0 &... & 0 & 0 \\    -a_2 & 0 & 1 &... & 0 & 0\\    -a_3 & 0 & 0 &... & 0 & 0\\    ⋮ & ⋮ &⋮ &⋱ & ⋮ & ⋮ \\    -a_{n-1} & 0 & 0 &... & 0 & 1\\    -a_n & 0 & 0 &... & 0 & 0\\\end{bmatrix}</script><script type="math/tex; mode=display">B=\begin{bmatrix}    b_1 \\ b_2 \\ b_3 \\ ⋮ \\ b_n\end{bmatrix}</script><script type="math/tex; mode=display">C=\begin{bmatrix}    1 & 0 & 0 &\dots&0\end{bmatrix}</script><script type="math/tex; mode=display">D=[b_0]</script><p><strong>能观标准型在设计观测器时很有用。</strong>  </p><h4 id="对角标准型"><a href="#对角标准型" class="headerlink" title="对角标准型"></a>对角标准型</h4><p>对于形如：  </p><script type="math/tex; mode=display">\frac{Y(s)}{U(s)}=b_0+\frac{c_1}{s+p_1}+\frac{c_2}{s+p_2}+...+\frac{c_n}{s+p_n}</script><p>的传递函数。<br>在标准对角型（diagonal canonical form）下，状态矩阵$A$是一个对角矩阵，其对角线为其特征值，同时也是系统方程的极点。对角标准型只适用于系统没有重极点的情况。  </p><script type="math/tex; mode=display">A=\begin{bmatrix}    -p_1 & 0 & ... & 0 & 0\\    0 & -p_2 & ... & 0 & 0\\    ⋮ & ⋮ & ⋱ & ⋮ & ⋮ \\    0 & 0 & ... & 0 & -p_n\\\end{bmatrix}</script><script type="math/tex; mode=display">B=\begin{bmatrix}    1 \\ 1 \\ ⋮ \\ 1\end{bmatrix}</script><script type="math/tex; mode=display">C=\begin{bmatrix}    c_1 & c_2 & c_3 &\dots &c_n\end{bmatrix}</script><script type="math/tex; mode=display">D=[b_0]</script><h4 id="约旦标准型"><a href="#约旦标准型" class="headerlink" title="约旦标准型"></a>约旦标准型</h4><p>当系统有重极点时，系统的状态空间表示可以用约旦标准型表示。当系统的传输函数为：  </p><script type="math/tex; mode=display">\frac{Y(s)}{U(s)}=\frac{b_0s^n+b_1s^{n-1}+...+b_n}{(s+p_1)^3(s+p_4)...(s+p_n)}</script><p>其中的状态矩阵是：  </p><script type="math/tex; mode=display">A=\left[\begin{matrix}    -p_1 & 1 & 0 &... & 0 & 0\\    0 & -p_1 & 1 &... & 0 & 0\\    0 & 0 & -p_1 &... & 0 & 0\\    ⋮ & ⋮ & ⋮ & ⋱ & ⋮ & ⋮ \\    0 & 0 & ... & 0 & -p_n\\\end{matrix}\right]</script><script type="math/tex; mode=display">B=\left[ \begin{matrix}    0 \\ 0 \\ ⋮ \\ 1\end{matrix}\right]</script><script type="math/tex; mode=display">C=[\begin{matrix}    c_1 & c_2 & c_3 &\dots &c_n\end{matrix}]</script><script type="math/tex; mode=display">D=[b_0]</script><p>其中的$c_i$可以通过部分分式展开得到：  </p><script type="math/tex; mode=display">\frac{Y(s)}{U(s)}=b_0+\frac{c_1}{(s+p_1)^3}+\frac{c_1}{(s+p_1)^2}+\frac{c_1}{s+p_1}+\frac{c_2}{s+p_2}+...+\frac{c_n}{s+p_n}</script><h3 id="状态空间表示与信号流图的转换"><a href="#状态空间表示与信号流图的转换" class="headerlink" title="状态空间表示与信号流图的转换"></a>状态空间表示与信号流图的转换</h3><ul><li><p>相位变化型<br>  对传递函数$\frac{Y(s)}{U(s)}$，可将其分解为：  </p><script type="math/tex; mode=display">\frac{Y(s)}{U(s)}=\frac{V(s)}{U(s)}\frac{Y(s)}{V(s)}=\frac{∑b_is^{(m-i)}}{∑a_is^{(n-i)}}</script><p>  令$x_1=v$作为状态变量，对$\frac{V(s)}{U(s)}$可以得到一系列系统的状态方程。对$\frac{Y(s)}{V(s)}$可以得到系统的输出方程。<br>  再根据状态方程和输出方程即可绘制信号流图。<br>  <img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220313141835.png width=50%></p><p>  如果$x_1,x_2,x_3$的次序相反，那么得到的是能控标准型。  </p></li><li><p>能观标准型<br>对系统的传递函数$\frac{Y(s)}{U(s)}$，如果其写作如下的形式：  </p><script type="math/tex; mode=display">\frac{Y(s)}{U(s)}=\frac{b_0+b_1s^{-1}+...+b_ns^{-n}}{1+a_1s^{-1}+...+a_ns^{-n}}</script><p>则可以根据这个结构直接写出系统的状态方程和输出方程：  </p><script type="math/tex; mode=display">\dot{x_k}=-a_kx_1+x_{k+1}+b+ku,1≤k≤n-1</script><script type="math/tex; mode=display">\dot{x_n}=-a_nx_1+b_nu</script><script type="math/tex; mode=display">y=x_1+b+0u</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220313142033.png width=50%></p></li><li><p>级联型<br>如果系统的传递函数$\frac{Y(s)}{U(s)}$写作：  </p><script type="math/tex; mode=display">\frac{Y(s)}{U(s)}=\frac{(s+z)}{∏^n(s+p_i)}</script><p>那么可以视为：  </p><script type="math/tex; mode=display">\frac{x_n}{u}=\frac{1}{s+p_n}⇒\dot{x_n}=-p_ix_n+u</script><script type="math/tex; mode=display">\frac{x_k}{x_{k+1}}=\frac{1}{s+k_n}⇒\dot{x_k}=-p_ix_k+x_{k+1}</script><script type="math/tex; mode=display">\frac{y}{x_1}=s+z⇒y=\dot{x_1}+zx_1</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220313141619.png width=50%></p></li><li><p>并联型<br>如果系统的传递函数$\frac{Y(s)}{U(s)}$写作：  </p><script type="math/tex; mode=display">\frac{Y(s)}{U(s)}=∑\frac{α_i}{(s+p_i)}</script><p>那么系统的状态方程可以写作：  </p><script type="math/tex; mode=display">\dot{x_i}=-p_ix_i+α_i</script><p>系统的输出方程可以写作：  </p><script type="math/tex; mode=display">y=∑α_ix_i</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220313142926.png width=50%>  </p></li></ul><h2 id="状态空间表示分析"><a href="#状态空间表示分析" class="headerlink" title="状态空间表示分析"></a>状态空间表示分析</h2><h3 id="状态空间转换传输函数"><a href="#状态空间转换传输函数" class="headerlink" title="状态空间转换传输函数"></a>状态空间转换传输函数</h3><p>对于系统的状态方程：  </p><script type="math/tex; mode=display">\vec{\dot{x}}=A\vec{x}+Bu</script><p>由拉普拉斯变换得到：  </p><script type="math/tex; mode=display">s\vec{X}(s)=A\vec{X}(s)+B\vec{U}(s)</script><p>可以得到:  </p><script type="math/tex; mode=display">(sI-A)\vec{X}(s)=B\vec{U}(s)</script><p>整理可以得到：  </p><script type="math/tex; mode=display">\vec{X}(s)=[sI-A]^{-1}B\vec{U}(s)</script><p>令：</p><script type="math/tex; mode=display">Φ(s)=[sI-A]^{-1}</script><p>称其对应的矩阵$ϕ(t)$为状态转移矩阵(state transform matrix)，其后会进一步讨论这个矩阵的作用。<br>将其带入系统的输出方程的拉普拉斯变换中：$\vec{Y}(s)=C\vec{X}(s)+D\vec{U}(s)$，有：  </p><script type="math/tex; mode=display">\vec{Y}(s)=[CΦ(s)B+D]\vec{U}(s)</script><p>根据系统传递函数的定义可知：  </p><script type="math/tex; mode=display">T(s)=\frac{Y(s)}{U(s)}=C[sI-A]^{-1}B+D</script><p>$[sI-A]$的行列式$|sI-A|$结果为系统的特征多项式。  </p><h3 id="稳态误差"><a href="#稳态误差" class="headerlink" title="稳态误差"></a>稳态误差</h3><p>对于系统 $\begin{cases} \vec{\dot{x}}=A\vec{x}+Bu\\<br>y=C\vec{x} \end{cases}$，根据稳态误差的定义：$E(s)=\frac{1}{G(s)+1}R(s)$，有：  </p><script type="math/tex; mode=display">\begin{aligned}    E(s)&=R(s)[1-T(s)]\\    &=R(s)[1-C[sI-A]^{-1}B]\end{aligned}</script><p>有终值定理：  </p><script type="math/tex; mode=display">e(∞)=\lim_{s→0}sE(s)=\lim_{s→0}R(s)[1-C[sI-A]^{-1}B]</script><ul><li>当$R(s)=1$时，$e(∞)=1+CA^{-1}B$</li><li>当$R(s)=s$时，$e(∞)=\lim_{t→∞}[(1+CA^{-1}B)t+C(A^{-1})^2B$</li></ul><h3 id="系统分解（对角化）"><a href="#系统分解（对角化）" class="headerlink" title="系统分解（对角化）"></a>系统分解（对角化）</h3><p>对于系统 $\begin{cases} \vec{\dot{x}}=A\vec{x}+Bu\\ y=C\vec{x}+Du \end{cases}$，现在指定一组新的状态变量$z$，与$x$之间存在如下关系：  </p><script type="math/tex; mode=display">\vec{x}=P\vec{z}</script><p>且有$\vec{\dot{x}}=P\vec{\dot{z}}$.<br>$P$称为转换矩阵是$A$的特征向量$\vec{m}$组成的矩阵$[\vec{m_1} \vec{m_2}…\vec{m_n}]$，带入系统的状态空间表示中，有：  </p><script type="math/tex; mode=display">\begin{cases} \vec{\dot{z}}=P^{-1}AP\vec{z}+P^{-1}Bu\\ y=CP\vec{z}+Du \end{cases}</script><p>可以发现$P^{-1}AP$是$A$的对角矩阵。  </p><h2 id="齐次状态方程和非齐次状态方程"><a href="#齐次状态方程和非齐次状态方程" class="headerlink" title="齐次状态方程和非齐次状态方程"></a>齐次状态方程和非齐次状态方程</h2><p>已知系统的当前输入，则可以根据系统的状态方程求得系统的当前状态。简而言之，系统的当前状态就是系统状态方程的解。本小节将从简单的齐次状态方程入手寻找系统的当前状态。  </p><h3 id="齐次状态方程"><a href="#齐次状态方程" class="headerlink" title="齐次状态方程"></a>齐次状态方程</h3><p>对状态方程$\vec{\dot{x}}=A\vec{x}+Bu$，B等于0时的情况称为齐次状态方程(Homogeneous state equation)。换言之，系统的齐次状态方程表示了系统在零输入下系统的前一个状态和当前状态之间的关系，是系统的零输入响应(Zero-state response)。   </p><h4 id="齐次状态方程的解"><a href="#齐次状态方程的解" class="headerlink" title="齐次状态方程的解"></a>齐次状态方程的解</h4><p>对于齐次状态方程$\vec{\dot{x}}=A\vec{x}$，如果已知系统的初始状态$x(0)$，那么可以求解到：  </p><script type="math/tex; mode=display">x(t)=e^{At}x(0)</script><p>这是齐次状态方程的解，称为零输入解，其物理意义是伺服系统的自由振动情况。<br>称$ϕ(t)=e^{At}$为该系统的状态转移矩阵（时域）。  </p><h4 id="状态转移矩阵"><a href="#状态转移矩阵" class="headerlink" title="状态转移矩阵"></a>状态转移矩阵</h4><div class="note note-info">            <p>在数学上$ϕ(t)=e^{At}$与$Φ(s)=[sI-A]^{-1}$为拉普拉斯变换对：  </p><script type="math/tex; mode=display">ϕ(t)=e^{At}⇔Φ(s)=[sI-A]^{-1}</script>          </div>  <p>于是将$ϕ(t)$带入其次状态方程，其可以转化为：  </p><script type="math/tex; mode=display">x(t)=ϕ(t)x(0)</script><script type="math/tex; mode=display">x(t)=ϕ(t-t_0)x(t_0),t≥t_0</script><p>可以发现系统状态转移矩阵的作用是：<strong>已知系统在某一时刻$t_0$的系统状态$x(t_0)$，通过系统的状态转移矩阵，可以得到系统在$t_0$任何一个时刻$t$的系统状态$x(t)$</strong>。   </p><p>状态转移矩阵可以通过如下三种方法求得：  </p><ul><li>通过拉普拉斯反变换$[sI-A]^{-1}$求得</li><li>根据泰勒展开式：  <script type="math/tex; mode=display">e^{At}=I+At+\frac{1}{2!}A^2t^2+\frac{1}{3!}A^3t^3+...+\frac{1}{k!}A^kt^k+...</script>进行近似计算。  </li><li>如果状态矩阵$A$可以被写作约旦标准型$A^{J}$，有：  <script type="math/tex; mode=display">e^{At}=Se^{A^Jt}S^{-1}</script>即$e^{A^Jt}$的对角矩阵。  </li><li>如果状态矩阵$A$可以被对角化为$A^D$，有：  <script type="math/tex; mode=display">e^{At}=Pe^{A^Dt}P^{-1}</script>即$e^{A^Dt}$的对角矩阵。  </li></ul><h3 id="非齐次状态方程的解"><a href="#非齐次状态方程的解" class="headerlink" title="非齐次状态方程的解"></a>非齐次状态方程的解</h3><p>非齐次状态方程$\vec{\dot{x}}=A\vec{x}+Bu$的解是系统输入不为0时的解，其物理意义是伺服系统的受迫振动情况。<br>非齐次状态方程的解的格式为：  </p><ul><li>如果已知初始状态$x(0)$：  <script type="math/tex; mode=display">\vec{x}=e^{At}\vec{x}(0)+∫_0^te^{A(t-τ)}Bu(τ)dτ</script></li><li>如果已知某一状态$x(t_0)$：<script type="math/tex; mode=display">\vec{x}=e^{A(t-t_0)}\vec{x}(t_0)+∫_{t_0}^te^{A(t-τ)}Bu(τ)dτ</script></li></ul><h2 id="能控性和能观性"><a href="#能控性和能观性" class="headerlink" title="能控性和能观性"></a>能控性和能观性</h2><h3 id="能控性"><a href="#能控性" class="headerlink" title="能控性"></a>能控性</h3><p>在某一时刻$t_0$，如果系统可以通过控制向量将系统的状态$\vec{x}(t_0)$转变为系统的其他状态(即只要知道目前的状态，以后所有的状态都是已知的)，则系统是能控的(controllable)。换言之，如果系统状态和系统输入是独立的，那么系统是能控的。<br>对于系统$\begin{cases} \vec{\dot{x}}=A\vec{x}+Bu\\ y=C\vec{x}+Du \end{cases}$，它的状态方程是非齐次的，因此其状态方程的解为：  </p><script type="math/tex; mode=display">\vec{x}(t)=e^{A(t-t_0)}\vec{x}(t_0)+∫_{t_0}^te^{A(t-τ)}Bu(τ)dτ</script><p>假设$\vec{x}(t_0)=0$，有：  </p><script type="math/tex; mode=display">\vec{x}(0)=-∫_{0}^{t_0}e^{-Aτ}Bu(τ)dτ</script><p>带入$e^{-Aτ}=∑a_k(τ)A^k$，并令$β_k=∫_0^{t_0}a_k(τ)u(τ)dτ$，可以得到：  </p><script type="math/tex; mode=display">\vec{x}(0)=-∑_{k=0}^{n-1}A^kBβ_k</script><p>矩阵化该表达式，有：  </p><script type="math/tex; mode=display">\vec{x}(0)=-[B|AB|A^2B|…|A^{n-1}B]\begin{bmatrix}    β_0\\    -\\    β_1\\    -\\    ⋮\\    -\\    β_{n-1}\end{bmatrix}</script><p>如果满足上述式子成立，则称系统是完全状态能控的(completely state controllable)。<br>其中由$A$及其幂和$B$的乘积向量扩增的矩阵$[B|AB|A^2B|…|A^{n-1}B]$称为能控矩阵（controllability matrix），对于有$n$个状态的系统，它是一个$n×n$的方阵。通过之前的分析可以发现，<strong>当且仅当能控矩阵满秩，即其秩为$n$时，系统是完全状态能控(state controllable)的。</strong><br><div class="note note-info">            <p>满秩的等价条件：  </p><ul><li>组成扩增矩阵的向量$A^{i-1}B$线性无关</li><li>控制矩阵的行列式结果不为0</li></ul>          </div><br>同样地，如果将齐次方程的解带入到系统的输出方程，同理也可以在计算过程中得到一个$m × (n+1)$的输出内控矩阵：  </p><script type="math/tex; mode=display">[CB|CAB|CA^2B|…|CA^{n-1}B|D]</script><p><strong>当且仅当输出能控矩阵满秩即其秩为$m$（或者说组成扩增矩阵的向量$CA^{i-1}B$线性无关/输出控制矩阵行列式结果不为零）时，系统是完全输出能控(output controllable)的。</strong>  </p><h3 id="能观性"><a href="#能观性" class="headerlink" title="能观性"></a>能观性</h3><p>在某一时刻$t_0$，如果系统可以通过在有限时间内的输出（由输出矩阵和控制矩阵两部分决定）来判断系统初始状态$\vec{x}(0)$,则系统是能观的（observable）。系统的能观性与系统输出有关。<br>对其次系统$\begin{cases} \vec{\dot{x}}=A\vec{x}\\ y=C\vec{x} \end{cases}$而言，其能观矩阵(observability matrix)是一个$n×nm$的矩阵：  </p><script type="math/tex; mode=display">[C^T|A^TC^T|(A^T)^2C^T…|(A^T)^{n-1}C]</script><p>当系统的能观矩阵满秩（或者说组成扩增矩阵的向量$(A^T)^{i-1}C$线性无关/能观矩阵行列式结果不为零）时，表明系统是完全能观的（completely observable）。  </p><h3 id="对偶"><a href="#对偶" class="headerlink" title="对偶"></a>对偶</h3><p>系统的能控性和能观性是对偶的。<br>有如下结论：<br>对于系统I：$\begin{cases} \vec{\dot{x}}=A\vec{x}+Bu\\ y=C\vec{x} \end{cases}$和系统II：$\begin{cases} \vec{\dot{z}}=A^T\vec{z}+C^T\vec{v}\\ \vec{n}=B^T\vec{z} \end{cases}$，有：<br>如果系统I完全状态能控，那么系统II完全能观。  </p><h3 id="快速判断法"><a href="#快速判断法" class="headerlink" title="快速判断法"></a>快速判断法</h3><p>对于写作标准形式的系统矩阵，有可以根据状态矩阵$A$、$B$和$C$的形状快速判断系统能观性和能控性的方法。<br>对于约旦标准型：  </p><ul><li>如果对应$A^J$最后一列的矩阵$B$或者$S^{-1}B$($S$是将$A$转换为其约旦标准型$A^J$的转换矩阵)中的任意一行非零，同时$B$或者$S^{-1}B$中对应特征值的行非零，那么系统是能控的。  </li><li>如果对应$A^J$第一列的矩阵$CS$或$C$非零，同时$C$或者$CS$中对应特征值的非列零，那么系统是能观的。  </li></ul><p>对于对角型：  </p><ul><li>如果$B$不含有非零行，则系统是能控的。</li><li>如果$C$不含任何非零列，则系统是能观的。</li></ul><h2 id="可镇定性和可探测性"><a href="#可镇定性和可探测性" class="headerlink" title="可镇定性和可探测性"></a>可镇定性和可探测性</h2><h3 id="特征向量的模"><a href="#特征向量的模" class="headerlink" title="特征向量的模"></a>特征向量的模</h3><p>另外，某些系统可能呈现一定的能控性和能观性，称为部分能控或部分能观系统。此时可以通过探究状态矩阵$A$的特征值$λ_i$来研究每一个特征向量对应的模对系统可镇定性、能控性、能观性的贡献。  </p><ul><li>如果状态矩阵$A$的特征值$λ_i$在坐标轴左半平面，称其对应的模是可镇定的。  </li><li>如果矩阵$[(λ_iI-A)B]$满秩，那么特征值$λ_i$对应的模是能控的。  </li><li>如果矩阵$\begin{bmatrix}<br>  (λ_iI-A)\\<br>  C<br>\end{bmatrix}$满秩，那么特征值$λ_i$对应的模是能观的。  </li></ul><h3 id="可镇定性和可探测性的定义和对偶"><a href="#可镇定性和可探测性的定义和对偶" class="headerlink" title="可镇定性和可探测性的定义和对偶"></a>可镇定性和可探测性的定义和对偶</h3><p>对于一个部分可控的系统，如果非可控的模都稳定，且不稳定的模都可控，那么系统是可镇定(stablizable)的。<br>对于一个部分能观的系统，如果非能观的模都稳定，且能观的模都不稳定，那么系统是可探测(detectable)的。<br>对于完全能控的系统，它是可镇定的。<br>对于完全能观的系统，它是可探测的。<br>可以发现，可探测性和可镇定性是对偶的。  </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>控制系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>08. 通过频率响应对PID控制系统进行改进</title>
    <link href="/2022/03/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/8.%20%E9%80%9A%E8%BF%87%E9%A2%91%E7%8E%87%E5%93%8D%E5%BA%94%E8%AE%BE%E8%AE%A1/"/>
    <url>/2022/03/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/8.%20%E9%80%9A%E8%BF%87%E9%A2%91%E7%8E%87%E5%93%8D%E5%BA%94%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="通过频率响应对PID控制系统进行改进"><a href="#通过频率响应对PID控制系统进行改进" class="headerlink" title="通过频率响应对PID控制系统进行改进"></a>通过频率响应对PID控制系统进行改进</h1><p>在使用频率响应对系统进行设计时，通过波特图可以得到系统的稳定性；通过增大相位裕度可以减小过冲比：通常在设计时，相位裕度在45°到315°之间；增加低频幅值响应可以减小系统的稳态误差。  </p><h2 id="增益调整"><a href="#增益调整" class="headerlink" title="增益调整"></a>增益调整</h2><p>增益调整的方法是：  </p><ol><li>选择一个合适的$K$值，画出系统的频率响应图。  </li><li>通过设计标准中的过冲率($M_p$)要求，应用如下的公式得到$ζ$和$PM$：  <script type="math/tex; mode=display">ζ=-\frac{ln(M_p)}{\sqrt{π^2+ln^2M_p}}</script><script type="math/tex; mode=display">PM=arctan\frac{2ζ}{\sqrt{-2ζ^2+\sqrt{1+4ζ^4}}}</script></li><li>在波特图上找到设计标准中相位裕量所对应的频率$ω_{PM}$，并找到其对应的幅值响应，其对应的幅值响应$-AB$则是需要抬升的幅值。  </li><li>对系统增益进行修正，有：  <script type="math/tex; mode=display">AB=20lg(\frac{K_{ad}}{K})</script>即可得到修正后的增益$K_{ad}$。  </li></ol><h2 id="超前补偿和滞后补偿"><a href="#超前补偿和滞后补偿" class="headerlink" title="超前补偿和滞后补偿"></a>超前补偿和滞后补偿</h2><div class="note note-info">            <p>在许多材料里会将PID控制器(PID controller)和补偿器(compansator)的概念混为一谈。事实上，补偿器使由若干个控制器组成的控制群(control group)，PID控制器可以算作是P控制器、I控制器、D控制器组成的补偿器。但是补偿器的组成不止有这几种控制器。因此，PID控制器是一种补偿器，但补偿器不一定是PID控制器。<br>另外，补偿器中的“补偿”一词更多指对于整个系统输出的补偿。而本节中的滞后补偿和超前补偿中的补偿更多地是指对PID控制器的补偿。</p>          </div><h3 id="滞后补偿"><a href="#滞后补偿" class="headerlink" title="滞后补偿"></a>滞后补偿</h3><p>对于PI控制器：$G_c(s)=\frac{K(s+\frac{1}{T_i})}{s}$，由于积分项$\frac{1}{s}$的出现导致PI控制器在加入系统后会改变系统原本的类型，进而改变已经调整好的系统动态响应（系统达到稳态前的响应）。因此，需要一种补偿使其能在$s=0$时提供非常大的开环增益，进而减小稳态误差，但是在高频区保持增益为1，进而不会对系统的动态响应产生影响，这样的补偿称为滞后补偿(lag compansation)。  </p><script type="math/tex; mode=display">G_{lag}(s)=\frac{τs+1}{ατs+1},α>1</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220312100500.png width=50%>  </p><h4 id="滞后补偿器设计"><a href="#滞后补偿器设计" class="headerlink" title="滞后补偿器设计"></a>滞后补偿器设计</h4><p>滞后补偿器设计的思路是利用补偿将现在系统的幅度响应在补偿器设计要求的相位裕量处调整到0dB。  </p><ul><li>利用稳态误差的定义，找到系统增益$K$</li><li>绘制出$KG(s)H(s)$的波特图，从波特图上寻找系统的相位裕量$PM$</li><li>在波特图上找到符合补偿器设计要求的相位裕量$PM’+Φ$（其中$Φ$是修正系数），找到对应的增益穿越频率$ω’_{gc}$。  </li><li>找到$ω’_{gc}$对应的幅值$K’$，并计算：<script type="math/tex; mode=display">α=10^{\frac{K'}{20}}</script></li><li>令:<script type="math/tex; mode=display">τ=\frac{10}{ω'_{gc}}</script></li><li>带入$α$和$τ$，得到滞后补偿器的前向传输方程$G_{lag}(s)$。  </li></ul><p>添加滞后补偿器后，系统的前向传输方程/开环传递函数表示为：  </p><script type="math/tex; mode=display">KG_{lag}(s)G(s)H(s)</script><div class="note note-info">            <p>如果设计要求是阻尼比$ζ$，通常阻尼比可以通过如下公式近似为系统设计对相位裕量的要求：  </p><script type="math/tex; mode=display">PM(°)⩰100ζ</script>          </div><h3 id="超前补偿"><a href="#超前补偿" class="headerlink" title="超前补偿"></a>超前补偿</h3><p>对PD控制器：$G_c(s)=T_ds+1$，其幅值随着频率的升高而线性升高，但是这种特性会放大高频噪声，使系统抗噪性下降。因此，需要一种补偿通过增加一个极点进而在高频处降低系统幅值，这样的补偿称为超前补偿(lead compansation)。  </p><script type="math/tex; mode=display">G_{lead}(s)=\frac{τs+1}{βτs+1},β<1</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220312100539.png width=50%>  </p><h4 id="超前补偿器设计"><a href="#超前补偿器设计" class="headerlink" title="超前补偿器设计"></a>超前补偿器设计</h4><p>超前补偿器的设计思路是将相位波特图在高频处的部分进行抬升，具体的设计步骤是：  </p><ul><li>利用稳态误差的定义，找到系统增益$K$</li><li>绘制出$KG(s)H(s)$的波特图，从波特图上寻找系统的相位裕量$PM$</li><li>通过公式：  <script type="math/tex; mode=display">φ_m=(PM'+φ_c)-PM</script>其中$PM’$是设计要求的相位裕量，$Φ$是修正系数。<br>计算出需要抬升的相位。  </li><li>利用公式：  <script type="math/tex; mode=display">β=\frac{1-sinφ_m}{1+sinφ_m}</script>计算得到β。  </li><li>在波特图上找到幅值为$-10lg\frac{1}{β}$对应的频率$ω’_m$，令:<script type="math/tex; mode=display">τ=\frac{1}{ω'_{m}\sqrt{β}}</script></li><li>带入$β$和$τ$，得到超前补偿器的前向传输方程$G_{lead}(s)$。  </li></ul><p>添加滞后补偿器后，系统（称为补偿系统）的前向传输方程/开环传递函数表示为：  </p><script type="math/tex; mode=display">KG_{lead}(s)G(s)H(s)</script><div class="note note-warning">            <p>在工程中，还需要绘制补偿系统的波特图以检验相位裕量和增益裕量以及稳态误差系数是否满足设计要求。<br>如果不满足，则应当降低$β$的值，重新计算$τ$并找到一组符合设计要求的参数。  </p>          </div><h3 id="超前-滞后补偿"><a href="#超前-滞后补偿" class="headerlink" title="超前-滞后补偿*"></a>超前-滞后补偿*</h3><p>超前滞后补偿可以改善稳态误差，也可以加快系统达到稳定的速度。超前-滞后补偿的传递函数为：  </p><script type="math/tex; mode=display">G_{lag-lead}(s)=\frac{(τ_{lag}s+1)(τ_{lead}s+1)}{(ατ_{lag}s+1)(βτ_{lead}s+1)}</script><p>在设计时通常选取$α=\frac{1}{β}$，如此，在低频时补偿器增益将为0dB。<br>通常在设计时先通过设计要求找到$α$，并设计出滞后补偿器，再利用$β=\frac{1}{α}$设计出超前补偿器。  </p><h3 id="使用MATLAB设计超前-滞后补偿器"><a href="#使用MATLAB设计超前-滞后补偿器" class="headerlink" title="使用MATLAB设计超前/滞后补偿器"></a>使用MATLAB设计超前/滞后补偿器</h3><p>在MATLAB中，可以使用APP：Control System Designer（或者通过命令<code>sisotool</code>唤出）设计超前/滞后补偿器。  </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>控制系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>07. PID 控制系统</title>
    <link href="/2022/03/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/7.%20PID%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/03/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/7.%20PID%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="PID-控制系统"><a href="#PID-控制系统" class="headerlink" title="PID 控制系统"></a>PID 控制系统</h1><h2 id="基本PID控制元件"><a href="#基本PID控制元件" class="headerlink" title="基本PID控制元件"></a>基本PID控制元件</h2><p>控制器是在控制系统中用于控制系统误差的一种元件，其输入信号为系统误差。PID控制器是控制系统中最常用的控制器类型，基本的控制器有P控制器、I控制器、D控制器三种。这个控制器把收集到的数据和一个参考值进行比较，然后把这个差别用于计算新的输入值，这个新的输入值的目的是可以让系统的数据达到或者保持在参考值。PID控制器可以根据历史数据和差别的出现率来调整输入值，使系统更加准确而稳定。PID控制器的比例单元（P）、积分单元（I）和微分单元（D）分别对应目前误差、过去累计误差及未来误差。若是不知道受控系统的特性，一般认为PID控制器是最适用的控制器。藉由调整PID控制器的三个参数，可以调整控制系统，设法满足设计需求。控制器的响应可以用控制器对误差的反应快慢、控制器过冲的程度及系统震荡的程度来表示。  </p><h3 id="P-控制器-比例控制器"><a href="#P-控制器-比例控制器" class="headerlink" title="P 控制器/比例控制器"></a>P 控制器/比例控制器</h3><p>P控制器，又称比例控制器（Proportional controller），其传输函数为：  </p><script type="math/tex; mode=display">D_c(s)=K_P</script><p>$K_p$称为比例增益。<br>P控制器的系统输出与输入的系统误差$e$成比例：  </p><script type="math/tex; mode=display">y(t)=K_Pe</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220311105001.png width=50%>  </p><p>P控制器可以降低上升时间$t_r$，但是无法消去稳态误差。  </p><h3 id="I-控制器-积分控制器"><a href="#I-控制器-积分控制器" class="headerlink" title="I 控制器/积分控制器"></a>I 控制器/积分控制器</h3><p>I控制器，又称积分控制器(Intergral controller)，传输函数为：  </p><script type="math/tex; mode=display">D_c(s)=\frac{K_I}{s}</script><p>$K_I$称为积分增益。<br>P控制器的系统输出与输入的系统误差$e$的积分成比例：  </p><script type="math/tex; mode=display">y(t)=K_I∫edt</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220311104927.png width=50%>  </p><p>I控制器可以通过增加一个极点$s=0$来消去稳态误差，但是会增加系统的类型，使得系统的稳定性降低、瞬态响应变化更加剧烈。  </p><h3 id="D-控制器-微分控制器"><a href="#D-控制器-微分控制器" class="headerlink" title="D 控制器/微分控制器"></a>D 控制器/微分控制器</h3><p>D控制器，又称微分控制器(Derivative controller)，传输函数为：  </p><script type="math/tex; mode=display">D_c(s)=K_Ds</script><p>$K_I$称为积分增益。<br>P控制器的系统输出与输入的系统误差$e$的微分成比例：  </p><script type="math/tex; mode=display">y(t)=K_D \frac{d}{dt}e</script><p>D控制器通过增加一个零点来改进系统稳定性、并使得瞬态响应变化更平稳、过冲率降低，但是会放大高频噪声。由于稳态误差信号为常数信号，斜率为0，因此D控制器对稳态误差信号没有响应。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220311104849.png width=50%>  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220420161557.png width=50%>  </p><h2 id="组合控制器"><a href="#组合控制器" class="headerlink" title="组合控制器"></a>组合控制器</h2><p>由于P/D/I控制器单独使用都有缺陷，因此在工程设计上常常将其组合使用。  </p><h3 id="PI-控制器"><a href="#PI-控制器" class="headerlink" title="PI 控制器"></a>PI 控制器</h3><p>PI控制器相比于I控制器能够在零频上对增益进行补偿，因此可以减小稳态误差。<br>PI控制器的传递函数为：  </p><script type="math/tex; mode=display">D_c(s)=\frac{K}{s}(s+\frac{1}{T_1})=K+\frac{K}{T_1s}</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220311104256.png width=50%>  </p><p>通过其波特图可以发现：PI控制器通过减少系统在高频部分的增益来减少相位裕量，同时系统的高频分量常常是噪声，因此PI控制器也可以起到限制噪声的作用。<br>同时，由于$\lim_{s→∞}D_c(s)=K$,PI控制器没有稳态误差(Offset)。  </p><h3 id="PD-控制器"><a href="#PD-控制器" class="headerlink" title="PD 控制器"></a>PD 控制器</h3><p>由于D控制器对稳态误差没有响应，因此在使用时常常与P控制器连用以改进这一特性。<br>PD控制器的传递函数为：  </p><script type="math/tex; mode=display">D_c(s)=T_Ds+1</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220311105512.png width=50%>  </p><p>通过其波特图可以发现：PD控制器降低了系统在低频部分的增益，同时增加了在高频部分的增益，因此PD控制器增加了相位裕量。<br>但同时由于系统噪声常常位于高频，PD控制器也会放大系统的噪声。  </p><h3 id="PID-控制器"><a href="#PID-控制器" class="headerlink" title="PID 控制器"></a>PID 控制器</h3><p>PID控制器能够减小系统响应的振荡，同时PID控制器自身不会有稳态误差。<br>PID控制器的传输函数为：  </p><script type="math/tex; mode=display">D_c(s)=K_P+\frac{K_I}{s}+K_Ds···\text{并联形式}</script><script type="math/tex; mode=display">D_c(s)=K_P(1+\frac{1}{T_is}+T_ds)···\text{标准形式}</script><p>其中，$T_i=\frac{K_P}{K_I}$，$T_d=\frac{K_D}{K_P}$  </p><p>PID控制器的波特图形状取决于$T_i$和$T_d$的值，通常取$T_i=4T_d$：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220311111843.png width=50%>  </p><p>下图展示了PID控制器中参数调节对其阶跃响应的影响。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/PID_Compensation_Animated.gif width=50%></p><h2 id="PID控制器的调节方法"><a href="#PID控制器的调节方法" class="headerlink" title="PID控制器的调节方法"></a>PID控制器的调节方法</h2><p>通过实验对PID控制器进行调整的方法称为齐格勒－尼科尔斯方法(Ziegler-Nichols method)，其方法包括两种调节方式：  </p><ul><li>阶跃响应法</li><li>频率响应法</li></ul><h3 id="阶跃响应法"><a href="#阶跃响应法" class="headerlink" title="阶跃响应法"></a>阶跃响应法</h3><p>阶跃响应法（Step response method）适用对象是系统的阶跃响应呈现“s”形状的曲线，如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220311112830.png width=50%></p><p>这个曲线可以描述为：  </p><script type="math/tex; mode=display">\frac{C(s)}{U(s)}=\frac{Ke^{-Ls}}{Ts+1}</script><p>其中曲线拐点（曲线二阶导为0的点）对应的切线与$x$轴的交点将$x$轴分为两部分：$L$和$T$，其中$T$是拐点处的切线与$c(t)=K$（即渐近线/最大值）的交点所对应的$x$轴坐标到切线与$x$轴的交点的距离；$L$是切线与$x$轴的交点到坐标原点的距离。<br>根据曲线可以得到$K$、$L$、$T$三个常数，并依据如下的表格进行PID控制器的设计：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220311113843.png width=50%>   </p><h3 id="频率响应法"><a href="#频率响应法" class="headerlink" title="频率响应法"></a>频率响应法</h3><p>频率响应法（Frequncy response method）适用于需要改进的系统（plant）在s域原点存在零点。<br>频率响应法的步骤是：</p><ul><li>首先应用P控制器改进开环传递函数，改进后系统的闭环传递函数为：  <script type="math/tex; mode=display">\frac{C(s)}{R(s)}=\frac{K_P+∏(s+z_i)}{K_P+∏(s+p_i)}</script></li><li>将$K_P$的值增加，直到系统达到临界稳定条件，得到此时的$K_P=K_{cr}$。<br>或者应用劳斯判据求出劳斯表第一列每一项等于0时最小的$K_P$得到此时的$K_P=K_{cr}$。</li><li>根据系统闭环传递函数的特征方程，求得方程$K=K_{cr}$时的解，对应角频率$ω_{cr}$，根据$P_{cr}=\frac{2π}{ω_{cr}}$找到系统临界稳定时系统阶跃响应的振荡周期$P_{cr}$。  </li><li>根据下表得到PID控制器的参数并设计。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220311130506.png width=50%>  </li></ul><p>在MATLAB中可以使用PID Tuner应用，选择“import new plant”导入使用<code>tf()</code>命令生成的系统传递函数，选择“show parameter”展示当前PID控制器的参数，并对其进行调制，直到满足设计要求。  </p><h2 id="PID控制器的改进"><a href="#PID控制器的改进" class="headerlink" title="PID控制器的改进"></a>PID控制器的改进</h2><p>对于常规的PID系统（如下图所示），如果输入信号$R(s)$为阶跃函数时，由于控制中出现的微分项$T_ds$，控制模块的输出：操纵变量中会含有冲激函数（$\frac{d}{dt}u(t)=δ(t)$）。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220311131541.png width=50%>  </p><p>为了解决这一办法，通常应用常规PID系统时，会对微分项进行修正：  </p><script type="math/tex; mode=display">T_ds⇒\frac{T_ds}{1+γT_ds},γ≈0.1</script><p>这样的修正虽然可以保证操纵变量中没有冲激函数，但是操纵变量中仍然会存在一个多余的脉冲函数（这种现象称为set-point kick）。  </p><h3 id="PI-D控制器和I-PD控制器"><a href="#PI-D控制器和I-PD控制器" class="headerlink" title="PI-D控制器和I-PD控制器"></a>PI-D控制器和I-PD控制器</h3><p>一种改进的方法是将微分模块放置在系统的反馈部分，这样使得前馈信号不会受到影响。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220311132246.png width=50%>  </p><p>此外由于D控制器无法对稳态误差进行响应，因此可以将比例模块和微分模块同时设置在系统的反馈部分，称为I-PD控制器。  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220311143740.png width=50%>  </p><h2 id="系统自由度"><a href="#系统自由度" class="headerlink" title="系统自由度"></a>系统自由度</h2><h3 id="单自由度系统及设计"><a href="#单自由度系统及设计" class="headerlink" title="单自由度系统及设计"></a>单自由度系统及设计</h3><p>标准的PID系统中，其三个输入：系统输入$R(s)$、反馈噪声$N(s)$和干扰$D(s)$的闭环传递函数可以知一推三，称为单自由度PID控制系统。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220311133804.png width=50%>  </p><p>从上图中可以得出：  </p><script type="math/tex; mode=display">G_{yr}=\frac{Y(s)}{R(s)}=\frac{G_cG_p}{1+G_cG_p}</script><script type="math/tex; mode=display">G_{yd}=\frac{Y(s)}{D(s)}=\frac{G_p}{1+G_cG_p}</script><script type="math/tex; mode=display">G_{yn}=\frac{Y(s)}{N(s)}=-\frac{G_cG_p}{1+G_cG_p}</script><p>可以得到：  </p><script type="math/tex; mode=display">G_{yr}=\frac{G_p-G_{yd}}{G_p}</script><script type="math/tex; mode=display">G_{yn}=\frac{G_{yd}-G_p}{G_p}</script><p>PID控制系统的传递函数又可以写作如下形式：  </p><script type="math/tex; mode=display">G_c(s)=\frac{K(as+1)(bs+1)}{s}</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220311133804.png width=50%>  </p><p>对如图所示的系统，如果$G(s)$为二阶，且假设整个系统的闭环传递函数的极点多项式为$(s+p_0)(s^2+2ζω_ns+ω_n)$，可以发现极点为三部分组成：其中两个极点共轭:$s=a±jb$，另一个极点为实数，且通常取$p_0=5ζω_n$使得实极点对系统响应的影响较小。<br>可以根据系统设计的要求得到$ζ$和$ω_n$，并得到$(s+p_0)(s^2+2ζω_ns+ω_n)$。通过展开这个多项式，应用待定系数法可以得到$a,b,K$的值。  </p><h4 id="去零法"><a href="#去零法" class="headerlink" title="去零法"></a>去零法</h4><p>对系统：  </p><script type="math/tex; mode=display">\frac{Y(s)}{R(s)}=\frac{p(s)}{s^{n+1}+a_ns^n+...+a_2s^2+a_1s+a_0}</script><p>如果将极点多项式$p(s)$设置为零点多项式的低次项，比如：  </p><script type="math/tex; mode=display">p(s)=a_2s^2+a_1s+a_0</script><p>如此，系统的阶跃、一阶($R(s)=s$)、二阶响应($R(s)=\frac{1}{2}s^2$)将会没有稳态误差，这种方法称为去零法（zero-placement approach）。  </p><h3 id="双自由度系统"><a href="#双自由度系统" class="headerlink" title="双自由度系统"></a>双自由度系统</h3><p>整个系统的闭环传输函数中如果三个开环增益中的一个已知，则另外两个中一个已知，另一个未知，这样的系统称为双自由度系统，如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220311144957.png width=50%>  </p><script type="math/tex; mode=display">G_{yr}=\frac{Y(s)}{R(s)}=\frac{G_{c1}G_p}{1+(G_{c1}+G_{c2})G_p}</script><script type="math/tex; mode=display">G_{yd}=\frac{Y(s)}{D(s)}=\frac{G_p}{1+(G_{c1}+G_{c2})G_p}</script><script type="math/tex; mode=display">G_{yn}=\frac{Y(s)}{N(s)}=-\frac{(G_{c1}+G_{c2})G_p}{1+(G_{c1}+G_{c2})G_p}</script><p>可以推出：  </p><script type="math/tex; mode=display">G_{yr}=G_{c1}G_{yd}</script><script type="math/tex; mode=display">G_{yn}=\frac{G_{yd}-G_p}{G_p}</script><h4 id="双自由度系统的优点"><a href="#双自由度系统的优点" class="headerlink" title="双自由度系统的优点"></a>双自由度系统的优点</h4><p>双自由度PID控制器可以解决常规PID控制器在实际应用中不兼容的问题。<br>双自由度系统有：  </p><ul><li>非常低的过冲  </li><li>不容易受干扰影响  </li><li>调节时间很短  </li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>控制系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>06. 时延·非最小相位·系统近似方法</title>
    <link href="/2022/03/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/6.%20%E7%89%B9%E6%AE%8A%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%BF%91%E4%BC%BC/"/>
    <url>/2022/03/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/6.%20%E7%89%B9%E6%AE%8A%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%BF%91%E4%BC%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="时延·非最小相位·系统近似方法"><a href="#时延·非最小相位·系统近似方法" class="headerlink" title="时延·非最小相位·系统近似方法"></a>时延·非最小相位·系统近似方法</h1><h2 id="时延的影响"><a href="#时延的影响" class="headerlink" title="时延的影响"></a>时延的影响</h2><p>时延(Time-delay)指系统输入到对该输出进行响应之间的一段时间，在s域中长度为$T$时间的时延表示为：$e^{-sT}$。<br>由$s=jω$，系统$G(jω)$时移后的结果为：  </p><script type="math/tex; mode=display">G'(jω)=|G(jω)|e^{j∠G(jω)}e^{-jωT}=|G(jω)|e^{j∠[G(jω)-ωT]}</script><p>可以发现，时延对系统的幅频响应没有影响，而使相频响应下降$-ωT$。<br>因此，此时的相位裕度应该为：  </p><script type="math/tex; mode=display">PM_{delay}=PM-ω_{gc}T</script><h3 id="对系统稳定性的影响"><a href="#对系统稳定性的影响" class="headerlink" title="对系统稳定性的影响"></a>对系统稳定性的影响</h3><p>下图展示了$TF(s)=\frac{5}{s+5}$在不同时延下的奈奎斯特图：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220309094826.png width=80%>  </p><p>可以发现，加入时延之后，系统的奈奎斯特图会在实轴交点处出现更多的对数螺旋曲线。<br>此时规定，以第一过零点来判断系统的幅值裕度。  </p><h3 id="对阶跃响应的影响"><a href="#对阶跃响应的影响" class="headerlink" title="对阶跃响应的影响"></a>对阶跃响应的影响</h3><p>加入时延之后，系统的阻尼比减小，阶跃响应的图像的振荡更加剧烈。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220309092210.png width=50%>  </p><h2 id="非最小相位系统"><a href="#非最小相位系统" class="headerlink" title="非最小相位系统"></a>非最小相位系统</h2><p>真分传递函数（exactly proper transfer function/proper transfer function）指传递函数分子多项式的次数不超过分母多项式的次数。若分子的次数小于分母的次数，则称为严格真分传递函数（strictly proper transfer function）。<br>当系统的传递函数稳定，且在s域右半平面存在零点时，称系统是非最小相位系统。最小相位系统在波特图上高频稳定区域的相位角应当为$-90°r$，其中$r$是传递函数分子分母最高次数的差值。非最小相位系统在高频的相位角不存在如上的关系。<br>非最小相位的出现不能够保证“初始下冲”，“过冲”和过零的出现。  </p><h3 id="初始下冲"><a href="#初始下冲" class="headerlink" title="初始下冲"></a>初始下冲</h3><p>初始下冲（initial undershoot）指在初始点偏离阶跃响应最终的渐近方向。<br>如果真分传递函数$G(s)$中存在奇数个正零点，或者严格真分传递函数$G(s)$的$G(s)-G(∞)$存在奇数个正零点那么对应的系统会出现初始下冲。如果系统是非最小相位的，则不能保证出现初始下冲。  </p><center class="half"><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220309103736.png width=30%><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220309103819.png width=30%></center>  <h3 id="过零次数"><a href="#过零次数" class="headerlink" title="过零次数"></a>过零次数</h3><p>如果真分传递函数$G(s)$中存在奇数个正零点，其正零点的个数对应拐点的个数，也是其阶跃响应过零(crossing zero)的次数。<br><div class="note note-warning">            <p>过零次数不包括点(0,0)。  </p>          </div>  </p><p>如果严格真分传递函数$G(s)$的$G(s)-G(∞)$存在奇数个正零点，其正零点的个数对应拐点的个数，也是$G(s)$阶跃响应过零(crossing zero)的次数。<br>如果系统是非最小相位的，则不能保证其过零次数一定为正零点个数。  </p><h2 id="高阶系统近似方法"><a href="#高阶系统近似方法" class="headerlink" title="高阶系统近似方法"></a>高阶系统近似方法</h2><h3 id="主极点近似"><a href="#主极点近似" class="headerlink" title="主极点近似"></a>主极点近似</h3><p>通过对每个极点对整个系统的贡献时间长短分析，可以发现s域左半平面越接近虚轴的极点对系统影响的持续时间最长，称系统中s域左半平面最接近虚轴的极点为主极点（dominant pole）。主极点近似则是使用主极点对应的子系统传输函数以拟合整个系统的传输函数。<br>对于一阶项组成的系统，有：  </p><script type="math/tex; mode=display">[H(s)=\frac{K}{(s+a)(s+b)}]≈[H_{dp}(s)=\frac{K_{dp}}{s+a}]</script><p>其中$a$是主极点，且满足：  </p><script type="math/tex; mode=display">H(0)=H_{dp}(0)</script><p>利用上述式子可以求得$K_{dp}$。<br>对于含有二阶项的系统，则<strong>将共轭复根的实部$ζω_0$与其他极点进行比较</strong>，有：  </p><script type="math/tex; mode=display">[H(s)=\frac{aω^2_n}{(s+a)(s^2+2ζω_ns+ω_n^2)}]≈\begin{cases} &\frac{a}{s+a},a<<ζω_0\\ &\frac{ω^2_n}{s^2+2ζω_ns+ω_n^2},α>>ζω_0\\\end{cases}</script><p>主极点近似的局限性为，如果子系统有相同的极点（即含有$(s+a)^N$），则由于无法确定主极点而无法使用主极点近似。  </p><h3 id="零极点对消"><a href="#零极点对消" class="headerlink" title="零极点对消"></a>零极点对消</h3><p>当系统的零点和极点非常接近时，可以直接视为相同项而进行分子分母化简。例如：  </p><script type="math/tex; mode=display">H(s)=\frac{s+å}{(s+a)(s+b)}≈\frac{1}{s+b},å≈a</script>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>控制系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05. 尼柯尔斯图的绘制和分析</title>
    <link href="/2022/03/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/5.%20%E5%B0%BC%E6%9F%AF%E5%B0%94%E6%96%AF%E5%9B%BE/"/>
    <url>/2022/03/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/5.%20%E5%B0%BC%E6%9F%AF%E5%B0%94%E6%96%AF%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="尼柯尔斯图的绘制和分析"><a href="#尼柯尔斯图的绘制和分析" class="headerlink" title="尼柯尔斯图的绘制和分析"></a>尼柯尔斯图的绘制和分析</h1><h2 id="尼柯尔斯图的绘制"><a href="#尼柯尔斯图的绘制" class="headerlink" title="尼柯尔斯图的绘制"></a>尼柯尔斯图的绘制</h2><p>使用奈奎斯特曲线与M环和N环交点来求闭环传递函数的幅频响应和相频响应的缺点是M环和N环都没有以对数形式给出，难以求其增益。尼柯尔斯图是一种从波特图得到灵感、改进M环和N环绘制的图像，如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220309083635.png width=50%>  </p><p>尼柯尔斯图由两部分构成：</p><ul><li>线性坐标表示开环传递函数的幅值和相位，其中横轴表示开环相位，纵轴表示开环幅值。  </li><li>非线性坐标表示M环和N环，M环的每条曲线以分贝值作为标识，N环的每条曲线以角度作为标识。  </li></ul><h3 id="绘制尼柯尔斯图的步骤"><a href="#绘制尼柯尔斯图的步骤" class="headerlink" title="绘制尼柯尔斯图的步骤"></a>绘制尼柯尔斯图的步骤</h3><ul><li>将$G(s)$转化为$G(jω)$，并分离实部和虚部。  </li><li>利用定义得到相频响应$∠G(jω)$和幅频响应$|G(jω)|$。  </li><li>列表，从$ω=0$开始找到每一个$ω$对应的幅值(dB)和相位。  </li></ul><div class="note note-warning">            <p>注意$arctan()$是一个周期为180°的周期函数，因此可以通过±180°对运算结果进行调整，使得运算结果可以落在尼柯尔斯图的横轴范围上。  </p>          </div>  <ul><li>找到$ω=∞$对应的幅值(dB)和相位.</li><li>在尼柯尔斯图的直角坐标上找到对应的点，连接成线</li><li>标出$ω=0$和$ω=∞$的位置。</li></ul><p>在MATLAB中，可以使用命令<code>nichols()</code>绘制系统的尼柯尔斯图。  </p><h4 id="使用卡西欧计算器fx-991CN-X辅助绘制尼柯尔斯图-波特图"><a href="#使用卡西欧计算器fx-991CN-X辅助绘制尼柯尔斯图-波特图" class="headerlink" title="使用卡西欧计算器fx-991CN X辅助绘制尼柯尔斯图/波特图"></a>使用卡西欧计算器fx-991CN X辅助绘制尼柯尔斯图/波特图</h4><ol><li>开机，按【菜单/设置】键进入菜单，按【7】进入表格模式  </li><li>表格模式中显示$f(x)$，输入$20lg|H(jω)|$的表达式，其中$ω$以【$x$】表示，输入完成后按【=】键  </li><li>按【SHIFT】键后按【菜单/设置】键进入设置，按【2】后选择【1】将计算模式调整到角度制（D）</li><li>显示$g(x)$，输入$arctan(∠H(jω))$的表达式，其中$ω$以【$x$】表示，输入完成后按【=】键 </li><li>显示“表格范围”，设置$x$的取值范围，使用【↑】【↓】选择输入对象，输入合适的开始值、终止值和步长，每一项输入完成后按【=】键  </li><li>按下【=】键，计算器会得出从起始值到终止值，每隔一个步长的$x_i$所对应的$f(x_i)$和$g(x_i)$，根据此进行作图  </li></ol><ul><li>如果发现得到的$g(x)$不在尼柯尔斯图的横坐标范围内，则需要按【AC】键后按【↓】键退回到$g(x)$的设置，将表达式调整180°的倍数$arctan(∠H(jω))±180°$，（角度符号可以由在$g(x)$界面按【OPTN】键后按【2】再按【1】选择）重复上述步骤。</li></ul><h2 id="尼柯尔斯图的分析"><a href="#尼柯尔斯图的分析" class="headerlink" title="尼柯尔斯图的分析"></a>尼柯尔斯图的分析</h2><h3 id="幅值裕量和相位裕量"><a href="#幅值裕量和相位裕量" class="headerlink" title="幅值裕量和相位裕量"></a>幅值裕量和相位裕量</h3><p>尼柯尔斯图上的幅值裕量为-180°时的幅值到0dB的距离。<br>相位裕量为-180°到0dB时的相位的距离。<br>通过相位裕量和幅值裕量的分布可以判断系统的稳定性，如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220309084612.png width=50%>  </p><h3 id="闭环幅频响应和相频响应"><a href="#闭环幅频响应和相频响应" class="headerlink" title="闭环幅频响应和相频响应"></a>闭环幅频响应和相频响应</h3><p>只需要找到尼克尔斯曲线与M环和N环的交点，分别连线即可。  </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>控制系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04. 波特图的绘制和分析·电路实现</title>
    <link href="/2022/03/07/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/4.%20%E6%B3%A2%E7%89%B9%E5%9B%BE/"/>
    <url>/2022/03/07/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/4.%20%E6%B3%A2%E7%89%B9%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="波特图·电路实现"><a href="#波特图·电路实现" class="headerlink" title="波特图·电路实现"></a>波特图·电路实现</h1><p>波特图(Bode plot)是一种直接表示系统幅度值和相位随着频率变化的图像，是最简单的对系统频率响应的可视化工具。其横轴为$ω$，纵轴为$|H(jω)|_{dB}$和$∠H(jω)$，如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220303194338.png width=50%>  </p><h2 id="使用MATLAB绘制波特图"><a href="#使用MATLAB绘制波特图" class="headerlink" title="使用MATLAB绘制波特图"></a>使用MATLAB绘制波特图</h2><p>在MATLAB中，当系统传递函数已知的情况下，可以使用函数<code>bode()</code>直接生成对应系统的波特图，例如：<br><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs M">num<span class="hljs-built_in">=</span>[<span class="hljs-number">8</span>,<span class="hljs-number">18</span>,<span class="hljs-number">32</span>] <span class="hljs-comment">%传递函数的分子系数</span><br>den<span class="hljs-built_in">=</span>[<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">14</span>,<span class="hljs-number">24</span>] <span class="hljs-comment">%传递函数的分母系数</span><br>sys<span class="hljs-built_in">=</span>tf(num,den) <span class="hljs-comment">%构建系统传递函数</span><br>bode(sys)<br></code></pre></td></tr></table></figure><br>即可得到$G(s)=\frac{8s^2+18s+32}{s^3+6s^2+14s+24}$的波特图，如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220317205459.png width=50%></p><h2 id="采样法绘制波特图"><a href="#采样法绘制波特图" class="headerlink" title="采样法绘制波特图"></a>采样法绘制波特图</h2><p>使用采样来绘制波特图的方法是：  </p><ul><li>令传递函数中的$s=jω$，得到$G(jω)$</li><li>$G(jω)$的分子分母同时乘以分母表达式的共轭形式，以化简得到:  <script type="math/tex; mode=display">G(jω)=A(ω)+jB(ω)</script>的形式。  </li><li>取不同的$ω$值对其幅频响应和相频响应进行采样，利用采样点绘制波特图。  </li></ul><p>使用采样绘制波特图的难点是波特图的准确性取决于采样点的数目和采样点的位置。如果传递函数结构复杂，那么计算所有采样点所需要的计算量太大。  </p><h2 id="渐近线近似绘制的理论基础"><a href="#渐近线近似绘制的理论基础" class="headerlink" title="渐近线近似绘制的理论基础"></a>渐近线近似绘制的理论基础</h2><p>渐进线近似法（Asymptotic Bode Plot）是一种将传递函数结构分为若干个区间，对每个区间使用直线来渐进拟合每个区间的频率响应情况。相比于采样法，渐近线近似法的计算量更小，并且渐进误差在可允许的范围内，是一种便捷的手绘波特图的方法。  </p><h3 id="传递函数的级联形式"><a href="#传递函数的级联形式" class="headerlink" title="传递函数的级联形式"></a>传递函数的级联形式</h3><p>对于系统传递函数：  </p><script type="math/tex; mode=display">H(s)=\frac{K∏(s+z_i)}{∏(s+p_i)}</script><p>如果将每一个括号的常数项进行归一化，就得到系统传递函数的级联形式：  </p><script type="math/tex; mode=display">H(s)=\frac{K∏z_i(\frac{1}{z_i}s+1)}{∏p_i(\frac{1}{p_i}s+1))}</script><h3 id="传递函数的元素及其渐进线近似波特图"><a href="#传递函数的元素及其渐进线近似波特图" class="headerlink" title="传递函数的元素及其渐进线近似波特图"></a>传递函数的元素及其渐进线近似波特图</h3><p>对于任意系统的传递函数，其分子分母都由如下几项相乘得到：  </p><ul><li>常数项$K$：称为增益</li><li>$s$：称为积分环节（分母）或者微分环节（分子）</li><li>一阶项$(s+1)$：称为惯性环节（分母）</li><li>二阶项$(s^2+2ζs+1)$   </li></ul><p>通过分别讨论这几个元素的波特图，进而可以推理出任意传递函数的波特图。  </p><ul><li><p>常数项$K$<br>常数项$K$在波特图上表示时，其幅值和相位都不随着频率而变化，其幅值恒定为$20lgK$，相位恒定为$0°$不变。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220307101431.png width=50%>  </p></li><li><p>$s$<br>对分子中的$s$项（表示为$s^{+1}$）：<br>幅值: $20lg(s)=20lg(ω_0)$，$ω_0$表示作图的起始频率。当波特图的横轴为$lg(ω)$时，其在波特图上为从零点向上，<strong>斜率为$20dB/decade$的直线</strong>。<br>相位：$arctan(\frac{ω}{0})=90°$，其相位恒定为90°不变。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220307102016.png width=50%><br>对分母中的$s$项（表示为$s^{-1}$）：<br>幅值: $20lg(\frac{1}{s})=-20lg(ω_0)$，当波特图的横轴为$lg(ω)$时，其在波特图上为从零点向下，斜率为$-20dB/decade$的直线。<br>相位：$-arctan(\frac{ω}{0})=-90°$，其相位恒定为-90°不变。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220307102109.png width=50%>  </p></li></ul><div class="note note-warning">            <p>注意，使用对数方格纸作图时，需要选取起始频率$ω_0$（横轴原点为:0.1rad/s或者0.001rad/s），如果存在$s$项，波特图的起始幅值应当为：  </p><script type="math/tex; mode=display">±20lg(ω_0)+20lg(K)</script><p>$+20lg(ω_0)$:$s$位于分子；$-20lg(ω_0)$:$s$位于分母。  </p>          </div><div class="note note-info">            <p>对数方格纸的横轴是非均匀的，表示其坐标轴上数值对数分布，横轴是均匀的数值分布。因此，对于坐标轴横轴上的两个点:$x_1$、$x_2$。满足关系：   </p><script type="math/tex; mode=display">k(x_1-x_2)=y(x_1)-y(x_2)</script><p>其中$k$称为对数斜率：  </p><script type="math/tex; mode=display">k=\frac{y(x_1)-y(x_2)}{x_1-x_2}</script><p>单位为$dB/decade$。  </p>          </div>   <ul><li><p>一阶项$(Ts+1)$<br>对$(\frac{s}{T}+1)^{+1}$：<br>幅值：$20lg(1+jωT)=20lg(\sqrt{1+ω^2T^2})$,其波特图近似为：  </p><ul><li>当$0&lt;ω&lt;\frac{1}{T}$，幅值为0  </li><li>当$ω&gt;\frac{1}{T}$，幅值为$20lg(ω)$  </li></ul><p>相位：$arctan(ωT)$,其波特图近似为：  </p><ul><li>当$0&lt;ω&lt;\frac{0.1}{T}$，相位为0°  </li><li><p>当$\frac{0.1}{T}&lt;ω&lt;\frac{10}{T}$，斜率为$5°T$($45°/decade$)的直线 </p></li><li><p>当$ω&gt;\frac{10}{T}$，相位为90°<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220327152909.png width=50%><br>同理，$(\frac{s}{T}+1)^{-1}$的波特图如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220307103344.png width=50%>  </p></li></ul></li><li><p>二阶项$(s^2+2ζs+1)$<br>对$(\frac{s^2}{ω_n^2}+2\frac{ζ}{ω_n}s+1)^{+1}$，有：</p><script type="math/tex; mode=display">\frac{1}{T}=ω_n</script><p>幅值：$20lg(\sqrt{(1-\frac{ω^2}{ω_n^2}+(2ζ\frac{ω^2}{ω_n^2}))})$，其波特图近似为：  </p><ul><li>当$0&lt;ω&lt;\frac{1}{T}$，幅值为0  </li><li>当$ω&gt;\frac{1}{T}$，幅值为$40lg(ω)$  </li></ul><p>相位：$arctan\frac{2ζ\frac{ω}{ω_n}}{1-\frac{ω}{ω_n^2}}$，其波特图近似为：  </p><ul><li>当$0&lt;ω&lt;\frac{0.1}{T}$，相位为0°  </li><li>当$\frac{0.1}{T}&lt;ω&lt;\frac{10}{T}$，斜率为$10°T$($90°/decade$)的直线   </li><li>当$ω&gt;\frac{10}{T}$，相位为180°<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220307104134.png width=50%><br>同理，$(\frac{s^2}{ω_n^2}+2\frac{ζ}{ω_n}s+1)^{-1}$的波特图如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220307104248.png width=50%>  </li></ul><p>此外，二阶系统由于存在阻尼，在峰值位置$ω_p$需要对峰值进行修正：<br>在峰值处，有$\frac{d}{dω}|H(jω)|=0$，其中$ω_p=ω_n\sqrt{1-2ζ^2}$，代回求得峰值为：  </p><script type="math/tex; mode=display">|H(jω_p)|_{dB}=-20lg(2ζ\sqrt{1-ζ^2})</script><p>当$0&lt;ζ&lt;\frac{1}{√2}$时，可以视为$ω_p=ω_n$，那么该点的值可以近似为：  </p><script type="math/tex; mode=display">|H(jω_n)|_{dB}=-20lg(2ζ)</script><p>因此，当$0&lt;ζ&lt;\frac{1}{√2}$时，需要在$\frac{1}{T}$处增加$-20lg(2ζ)$进行修正。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220307105436.png width=50%></p></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>对幅频响应：  </p><ul><li><strong>对每一个$n$阶数项，其极点会给幅频响应带来一个$-20×n dB/decade$频程斜率的变化；其零点会给幅频响应带来一个$+20×n dB/decade$频程斜率的变化。</strong>  </li></ul><p>对相频响应：  </p><ul><li><p><strong>对每一个$n$阶数项，其极点会在$ω∈(\frac{0.1}{T},\frac{10}{T})$提供$-45°×n /decade$的斜率变化；其零点会在$ω∈(\frac{0.1}{T},\frac{10}{T})$提供$+45°×n /decade$的斜率变化。</strong>  </p></li><li><p><strong>对每一个$n$阶数项，其极点会给相频响应带来一个$-90°×n$的相位变化；其零点会给相频响应带来一个$+90°×n$的相位变化。</strong></p></li></ul><h3 id="传递函数的级联"><a href="#传递函数的级联" class="headerlink" title="传递函数的级联"></a>传递函数的级联</h3><p>对级联系统，其每一个子系统的传递函数为$F_i(jω)$，有整个系统的传递函数：  </p><script type="math/tex; mode=display">F(jω)=∏F_i(jω)</script><p>系统的幅值和相位为：  </p><script type="math/tex; mode=display">|F(jω)|_{dB}=|F_i(jω)|_{dB}</script><script type="math/tex; mode=display">∠F(jω)=∑∠F_i(jω)</script><p>可以发现，整个系统的波特图可以通过各子部分的波特图叠加得到。<strong>因此，对任何一个传递函数，其整个波特图都可以被分解为若干个元素的波特图的叠加</strong>。  </p><h2 id="绘制渐近线波特图的方法"><a href="#绘制渐近线波特图的方法" class="headerlink" title="绘制渐近线波特图的方法"></a>绘制渐近线波特图的方法</h2><h3 id="图形法"><a href="#图形法" class="headerlink" title="图形法"></a>图形法</h3><ul><li>在对数格纸上画出每一个子部分的波特图</li><li>将每个部分的波特图叠加，最终得到整个系统的波特图</li></ul><p>下面几张图展示了图形法画出$G(s)=\frac{20s}{s+10}$的幅值波特图：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220307110846.png width=80%><br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220307111023.png width=80%>  </p><h3 id="表格法"><a href="#表格法" class="headerlink" title="表格法"></a>表格法</h3><ul><li>首先将系统传递函数改写为级联形式  </li><li>列出系统传递函数中所有的零点和极点，从小到大排列，从而将整个系统的波特图分为几个区间</li><li>看系统方程的每个元素在对每段区间波特图的斜率贡献  </li><li>将每个元素的斜率贡献全部叠加，得到系统在每段区间上的斜率。  </li><li>找到初始值。  </li><li>利用:<br>在区间$(x_1,x_2)$上，纵轴的变化量$Δ=y_1-y_2$可以求得为：  <script type="math/tex; mode=display">Δ=klg\frac{x_2}{x_1}</script>因此每一段区间的起始值为：  <script type="math/tex; mode=display">O=O_{-1}+Δ</script>$O_{-1}$是上一段区间的起始值。<br>找到每一段区间的起点。  </li><li>连接所有点，画图。  </li></ul><p>下表展示了表格法画出$G(s)=\frac{s+1}{s(0.1s+1)(0.4s+1)}$的幅值波特图对应的表格：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220627202808.png width=80%><br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220317202114.png width=80%>  </p><p>真实的波特图可以通过MATLAB中使用命令<code>bode()</code>得到，下图展示了$G(s)=\frac{s+1}{s(0.1s+1)(0.4s+1)}$的幅值波特图。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220317203848.png width=80%></p><h2 id="波特图特征"><a href="#波特图特征" class="headerlink" title="波特图特征"></a>波特图特征</h2><h3 id="穿越频率"><a href="#穿越频率" class="headerlink" title="穿越频率"></a>穿越频率</h3><p>定义相位穿越频率（Phase crossover frequency）为相位波特图在-180°时对应的最小频率$ω_{pc}$。<br>增益穿越频率（Gain crossover frequency）为幅值波特图在0dB时对应的最小频率$ω_{gc}$。  </p><h3 id="增益裕量和相位裕量"><a href="#增益裕量和相位裕量" class="headerlink" title="增益裕量和相位裕量"></a>增益裕量和相位裕量</h3><p>在波特图上，<br>增益裕量是0dB与相位穿越频率对应的幅值之差：  </p><script type="math/tex; mode=display">GM|_{dB}=0-|H(jω_{pc})|</script><p>相位裕量是增益穿越频率对应的相位与-180°之差：  </p><script type="math/tex; mode=display">PM=∠H(jω_{gc})-(-180°)</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220307111837.png width=50%></p><h3 id="增益裕量和相位裕量与稳定性"><a href="#增益裕量和相位裕量与稳定性" class="headerlink" title="增益裕量和相位裕量与稳定性"></a>增益裕量和相位裕量与稳定性</h3><p><strong>如果相位裕量和增益裕量都大于0，</strong>则系统稳定<strong>。<br>如果相位裕量和增益裕量都为0，则系统处于临界稳定。<br>如果相位裕量和增益裕量中有一个小于零，则系统不稳定。</strong><br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220307112342.png width=60%>  </p><div class="note note-info">            <p>系统处于临界稳定时导致系统临界的增益部分$K_c$可以由如下公式给出：  </p><script type="math/tex; mode=display">GM=20lg\frac{K_c}{K}</script><p>其中$K$为系统增益。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220307112654.png width=30%>  </p>          </div><h2 id="从波特图反推开环传递函数"><a href="#从波特图反推开环传递函数" class="headerlink" title="从波特图反推开环传递函数"></a>从波特图反推开环传递函数</h2><h3 id="阻尼和固有频率"><a href="#阻尼和固有频率" class="headerlink" title="阻尼和固有频率"></a>阻尼和固有频率</h3><p>当相位裕量小于60°时，相位裕量、阻尼、带宽之间有如下关系：  </p><script type="math/tex; mode=display">PM=100°ζ</script><script type="math/tex; mode=display">\frac{B}{ω_n}=1-0.5ζ</script><p>其中$B$是系统带宽，是幅值为-3dB对应的频率。<br>可以通过波特图找出相位裕量和带宽，以此求得二阶系统的阻尼和固有频率。  </p><h3 id="初始值与系统类型"><a href="#初始值与系统类型" class="headerlink" title="初始值与系统类型"></a>初始值与系统类型</h3><p>系统类型与其波特图关系如下所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220307115722.png width=50%>  </p><p>可以发现，通过初始值即可确定系统类型，即分母中$s^N$项的次数。0型系统的初始值为$20lgK_p$，I型系统的初始值为-20dB，II型系统的初始值为-40dB。  </p><h3 id="终段斜率与系统阶数"><a href="#终段斜率与系统阶数" class="headerlink" title="终段斜率与系统阶数"></a>终段斜率与系统阶数</h3><p>系统波特图的最后一段斜率与系统阶数关系为：  </p><script type="math/tex; mode=display">k=-20O</script><h3 id="零极点推断"><a href="#零极点推断" class="headerlink" title="零极点推断"></a>零极点推断</h3><h4 id="系统增益"><a href="#系统增益" class="headerlink" title="系统增益"></a>系统增益</h4><p>系统增益满足：  </p><script type="math/tex; mode=display">α=20lgK±20N_0lgω_0</script><p>其中$ω_0$为初始频率，$α$为初始频率对应的幅值。  </p><h4 id="积分和微分环节"><a href="#积分和微分环节" class="headerlink" title="积分和微分环节"></a>积分和微分环节</h4><p>可以根据初始斜率判断积分/微分环节$s$的存在：<br>初始斜率为$±20N_0$，如果初始斜率为正，则代表系统存在$N_0$个积分环节，如果初始斜率为负，则代表系统存在$N_0$个微分环节。  </p><h4 id="一阶和二阶项结构"><a href="#一阶和二阶项结构" class="headerlink" title="一阶和二阶项结构"></a>一阶和二阶项结构</h4><p>根据之前的讨论可以知道：  </p><ul><li>系统波特图上的转折点对应频率为系统的零点或者极点</li><li>波特图上发生斜率变化一定由加入的零点/极点极点造成：一阶项对初始斜率的贡献为$20dB$,二阶项对斜率的贡献为$40dB$。如果元素位于分母（极点），则斜率贡献为负，如果元素位于分子（零点），则斜率贡献为正。  </li></ul><p>根据这两条理论则可以判断每一个区间上影响其斜率变化的极点/零点结构类型。  </p><p>如果存在修正，可以根据在固有频率处修正前后的幅值差求得$ζ$:  </p><script type="math/tex; mode=display">M_c=20lg(2ζ)</script><h2 id="控制系统的电路实现"><a href="#控制系统的电路实现" class="headerlink" title="控制系统的电路实现"></a>控制系统的电路实现</h2><p>根据波特图的理论分析，任何一个系统的传递函数都可以表示为前文提到的元素组成，这些元素的电路图如下表所示：  </p><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">传递函数</th><th style="text-align:center">电路图</th></tr></thead><tbody><tr><td style="text-align:center">比例环节</td><td style="text-align:center">$G(s)=\frac{R_2}{R_1}=K$</td><td style="text-align:center"><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220514232750.png width=50%></td></tr><tr><td style="text-align:center">惯性环节</td><td style="text-align:center">$G(s)=\frac{R_2}{R_1}\frac{1}{R_2Cs+1}=\frac{K}{Ts+1}$</td><td style="text-align:center"><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220514232904.png width=50%></td></tr><tr><td style="text-align:center">积分环节</td><td style="text-align:center">$G(s)=\frac{1}{R_1Cs}=\frac{1}{Ts}$</td><td style="text-align:center"><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220514233016.png width=50%></td></tr><tr><td style="text-align:center">振荡环节</td><td style="text-align:center">$G(s)=\frac{\frac{K}{T_1}}{s^2+\frac{s}{T_1}+\frac{K}{T_1}}$ <br> $K=\frac{R_2}{R_1},T_1=R_2C_1$</td><td style="text-align:center"><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220514233401.png width=50%></td></tr></tbody></table></div><p>更多有关控制系统电路实现的内容请参考专为本专业、本课程设计的实验用具：THKKL-1 Control Theory Experimental Box，浙江天煌教仪的实验指导书：<a href="/files/THKKL-1_Control_Theory_Experimental_Box.pdf">点此链接下载</a></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>控制系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03. 极坐标图/奈奎斯特图的绘制和分析</title>
    <link href="/2022/03/03/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/3.%20%E9%A2%91%E7%8E%87%E5%93%8D%E5%BA%94%E5%8F%8A%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/"/>
    <url>/2022/03/03/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/3.%20%E9%A2%91%E7%8E%87%E5%93%8D%E5%BA%94%E5%8F%8A%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="极坐标图-奈奎斯特图的绘制和分析"><a href="#极坐标图-奈奎斯特图的绘制和分析" class="headerlink" title="极坐标图/奈奎斯特图的绘制和分析"></a>极坐标图/奈奎斯特图的绘制和分析</h1><h2 id="正弦输入时的系统输出"><a href="#正弦输入时的系统输出" class="headerlink" title="正弦输入时的系统输出"></a>正弦输入时的系统输出</h2><p>二阶线性系统的转换方程可以表示为：  </p><script type="math/tex; mode=display">T(s)=\frac{Kω_n^2}{s^2+2ζω_ns+ω_n^2}</script><p>系统输入为正弦信号$r(t)=Asinωt$是工程中最常见的情况，此时系统的输出为：  </p><script type="math/tex; mode=display">C(s)=\frac{Kω_n^2}{s^2+2ζω_ns+ω_n^2}\frac{Aω}{s^2+ω^2}</script><p>对其进行拉普拉斯反变换后得到$c(t)$，改变$ω$的值，可以发现系统的瞬态响应的幅值和相位随着$ω$的变化而变化：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220303100328.png width=48%><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220303100411.png width=50%></p><p>对于稳定系统，可以发现当输入为正弦信号时，系统输出最终都会收敛到某个正弦信号上，最终收敛到的正弦信号参数与输入的正弦信号的幅值和相位是不同的，且随着输入频率$ω$的变化而变化，像这样的系统输出随着系统输入信号频率变化而变化的响应称为系统的频率响应，它分为系统的幅度值-频率响应，简称幅频响应(Magnitude frequency response)和系统的相位-频率响应，简称相频响应(Phase frequency response)两部分。  </p><p>输入信号的频率$ω$会改变系统的瞬态响应的幅值和相位，有必要对系统进行进一步的研究以定量分析这种影响。  </p><h2 id="系统的频率响应概述"><a href="#系统的频率响应概述" class="headerlink" title="系统的频率响应概述"></a>系统的频率响应概述</h2><p>对系统的转换方程$H(s)$，根据s域定义$s=jω,j^2=-1$，得到：   </p><script type="math/tex; mode=display">H(jω)=H(s)|_{s=jω}</script><p>$H(jω)$称为系统的频率响应。<br>定义系统方程$H(jω)$的幅度值-频率响应为其转换方程的绝对值表达：  </p><script type="math/tex; mode=display">|H(jω)|</script><p>以分贝形式表达为：  </p><script type="math/tex; mode=display">|H(jω)|_{dB}=20lg|H(jω)|</script><p>系统方程$H(jω)$的相位-频率响应为其转换方程的实部和虚部组成的夹角：  </p><script type="math/tex; mode=display">∠H(jω)=arctan\frac{Im[H(jω)]}{Re[H(jω)]}</script><p>系统的频率响应可以由幅频响应和相频响应两部分表示：  </p><script type="math/tex; mode=display">H(jω)=|H(jω)|e^{j∠H(jω)}</script><p>系统的频率响应、幅频响应和相频响应在复平面上可以表示为：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220303200958.png width=50%></p><p>由于系统的频率响应本来就是一个复函数，因此可以通过对分母乘以共轭项的方式分离出频率响应的实部和虚部。根据勾股定理即可找到系统的幅频响应和相频响应。<br>例如一阶单位反馈控制系统$H(jω)=\frac{K}{1+jωT}$，有:  </p><script type="math/tex; mode=display">H(jω)=\frac{K}{1+jωT}\frac{1-jωT}{1-jωT}=\frac{K}{1+ω^2T^2}-j\frac{KωT}{1+ω^2T^2}</script><p>由勾股定理：  </p><script type="math/tex; mode=display">\begin{aligned}    |H(jω)|=&\sqrt{\left(\frac{K}{1+ω^2T^2}\right)^2+\left(-\frac{KωT}{1+ω^2T^2}\right)^2}\\    =&\frac{K}{\sqrt{1+ω^2T^2}}\end{aligned}</script><script type="math/tex; mode=display">∠H(jω)=arctan(\frac{-KωT}{K})=arctan(-ωT)</script><h2 id="极坐标图"><a href="#极坐标图" class="headerlink" title="极坐标图"></a>极坐标图</h2><p>系统的幅频响应和相频响应可以视作极坐标，进而能够通过系统的幅频响应和相频响应在极坐标系上形成的轨迹来表示系统的频率响应。  </p><script type="math/tex; mode=display">(ρ,θ)=(|H(jω)|,∠H(jω))</script><p>根据系统的频率响应、幅频响应和相频响应的几何关系，上述极坐标也可以等效为：</p><script type="math/tex; mode=display">(Re,Im)=(Re[H(jω)],Im[H(jω)])</script><p>比如，一阶单位反馈控制系统的极坐标可以表示为：  </p><script type="math/tex; mode=display">(\frac{K}{\sqrt{1+ω^2T^2}},arctan(-ωT))|_{polar}↔(\frac{K}{1+ω^2T^2},-\frac{KωT}{1+ω^2T^2})</script><p>每一个特定的$ω$值：$ω=ω_1$在极坐标上都是一个唯一的点，所有点连接而成的轨迹即可表示系统的频率响应。<br>此外，系统方程的轨迹上还需要用箭头标示出从$ω=0$到$ω=∞$的箭头，以反映系统随频率的变化。  </p><p>因此极坐标图有两种：一种以$(Re,Im)=(Re[H(jω)],Im[H(jω)])$为理论基础，绘图为直角坐标图：横轴为实轴，纵轴为虚轴。另一种以$(\frac{K}{\sqrt{1+ω^2T^2}},arctan(-ωT))|_{polar}$为理论基础，图为极坐标图。  </p><p>极坐标图如下图所示：<br>直角坐标<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220303204851.png width=50%><br>极坐标<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/E33F546FE97735E907289B72D58F9E69.png width=50%>  </p><p>极坐标图最大的优点是能够在一张图上同时反应幅度值和相位随着频率的变化情况。  </p><h3 id="极坐标图-直角坐标-的画法"><a href="#极坐标图-直角坐标-的画法" class="headerlink" title="极坐标图(直角坐标)的画法"></a>极坐标图(直角坐标)的画法</h3><ol><li>对$H(jω)$分子分母同时乘以分母的共轭部分，并$H(jω)$的分离出实部和虚部</li><li>找到$ω=0$在极坐标上点</li><li>找到$ω=∞$在极坐标上的点</li><li>列方程，找到实部$Re[H(jω)]=0$时对应的$ω$，并在极坐标上找到对应的点</li><li>列方程，找到虚部$Im[H(jω)]=0$时对应的$ω$，并在极坐标上找到对应的点</li><li>找到可能的$ω$为其他值时在极坐标上对应的点</li><li>从$ω=0$的点开始，划出连接所有点的轨迹，直到最终到达$ω=∞$的点，并标出箭头  </li></ol><div class="note note-info">            <p>方程$Re[H(jω)]=0$和$Im[H(jω)]=0$根的个数决定了频率响应曲线会穿过坐标轴多少次。  </p>          </div><h4 id="使用卡西欧计算器fx-991CN-X辅助绘制极坐标图"><a href="#使用卡西欧计算器fx-991CN-X辅助绘制极坐标图" class="headerlink" title="使用卡西欧计算器fx-991CN X辅助绘制极坐标图"></a>使用卡西欧计算器fx-991CN X辅助绘制极坐标图</h4><ol><li>开机，按【菜单/设置】键进入菜单，按【7】进入表格模式  </li><li>表格模式中显示$f(x)$，输入$Re[H(jω)]$的表达式，其中$ω$以【$x$】表示，输入完成后按【=】键  </li><li>显示$g(x)$，输入$Im[H(jω)]$的表达式，其中$ω$以【$x$】表示，输入完成后按【=】键 </li><li>显示“表格范围”，设置$x$的取值范围，使用【↑】【↓】选择输入对象，输入合适的开始值、终止值和步长，每一项输入完成后按【=】键  </li><li>按下【=】键，计算器会得出从起始值到终止值，每隔一个步长的$x_i$所对应的$f(x_i)$和$g(x_i)$，根据此进行作图  </li></ol><h3 id="极坐标图-极坐标-的画法"><a href="#极坐标图-极坐标-的画法" class="headerlink" title="极坐标图(极坐标)的画法"></a>极坐标图(极坐标)的画法</h3><ol><li>$H(jω)$分子分母同时乘以分母的共轭部分，并$H(jω)$的分离出实部和虚部  </li><li>对$H(jω)$求解出$|H(jω)|$和$∠H(jω)$  </li><li>使用卡西欧计算器fx-991CN X的表格模式，设置$f(x)$和$g(x)$分别为$|H(jω)|$和$∠H(jω)$，并设置合适的步长和终点，输入完成后按【=】键，得到极坐标绘图所需的表格  </li><li>按照表格在极坐标纸上描点连线即可  </li></ol><div class="note note-warning">            <p>这种方法绘制起来比较困难，建议使用直角坐标进行绘图。  </p>          </div><h2 id="奈奎斯特稳定判据"><a href="#奈奎斯特稳定判据" class="headerlink" title="奈奎斯特稳定判据"></a>奈奎斯特稳定判据</h2><p>极坐标图的优点是能用一条曲线同时反映系统的幅频响应和相频响应，但是相比于波特图，极坐标图无法直接通过观察曲线走向得到系统的稳定性分析，因此需要引入奈奎斯特稳定性判据理论，以此对极坐标图进行改进，改进后的极坐标图称为奈奎斯特图，其优点是用一条曲线同时反映系统的幅频响应和相频响应，也能够通过曲线直接判断系统的稳定性。  </p><div class="note note-info">            <p>本节参考：<br>[奈奎斯特稳定判据 西安交通大学-刘剑毅]<a href="https://gr.xjtu.edu.cn/c/document_library/get_file?folderId=1797493&amp;name=DLFE-28935.pdf">https://gr.xjtu.edu.cn/c/document_library/get_file?folderId=1797493&amp;name=DLFE-28935.pdf</a><br>[知乎：奈奎斯特稳定判据]<a href="https://zhuanlan.zhihu.com/p/33007435">https://zhuanlan.zhihu.com/p/33007435</a>  </p>          </div><h3 id="柯西辐角原理"><a href="#柯西辐角原理" class="headerlink" title="柯西辐角原理"></a>柯西辐角原理</h3><p>根据三角函数$y=sinx$的定义，一个矢量<strong>逆时针</strong>旋转一圈时，对应的三角函数相位角变化为$2π$，如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/R-C.gif width=50%></p><p>对复变函数：  </p><script type="math/tex; mode=display">F(s)=\frac{Y(s)}{X(s)}=\frac{K∏(s+z_i)}{∏(s+p_i)}</script><p>有复变函数的辐角表示为复变函数所有零向量$Δ(s+z_i)$（s域上$s$到某一零点$z_i$的矢量）的角度和减去所有极向量$Δ(s+p_i)$（s域上$s$到某一极点$p_i$的矢量）的角度和：  </p><script type="math/tex; mode=display">∠F(s)=∑Δ(s+z_i)-∑Δ(s+p_i)</script><p>柯西辐角原理(Cauchy’s Argument Principle)首先提出了一个前提:<br><strong>使用映射律$s→F(s)$对每一个$s$进行映射时：s域(σ-jω)上除了极点外的每一点，在$F(s)$ 平面(Re-Im)上都有一点能够与之对应。如果s域内有一条顺时针运动的闭合曲线，那么$F(s)$平面上也必然有一条与其对应的闭合曲线，其旋转方向取决于函数$F(s)$的性质。</strong>  </p><p>那么，根据这个前提有如下推论：  </p><ul><li>s域内的闭合曲线包围$F(s)$的一个零点$z_i$，曲线运动方向为顺时针旋转一周，其相位角变化为-2π，其他矢量角变化为0。根据$∠F(s)=∑Δ(s+z_i)-∑Δ(s+p_i)$，则$F(s)$的相位角变化为-2π。即$F(s)$绕$F(s)$平面原点逆时针旋转一周。   </li><li>s域内的闭合曲线包围$F(s)$的一个极点$p_i$，曲线运动方向为顺时针旋转一周，其相位角变化为-2π，其他矢量角变化为0。根据$∠F(s)=∑Δ(s+z_i)-∑Δ(s+p_i)$，则$F(s)$的相位角变化为2π。即$F(s)$绕$F(s)$平面原点顺时针旋转一周。   </li></ul><p>从上述推论可以得到：<br>s域上的闭合曲线如果包围了$F(s)$的$Z$个零点、$P$个极点，并且闭合曲线不通过$F(s)$的任何零点或者极点，当$s$沿着闭合曲线顺时针运动一周，在$F(s)$对应包围原点的闭合圈数$N$为：  </p><script type="math/tex; mode=display">N=P-Z</script><p>$N&gt;0$表示逆时针包围圈数，$N&lt;0$表示顺时针包围圈数。<br>该结论称为柯西辐角原理。  </p><h3 id="奈奎斯特路径"><a href="#奈奎斯特路径" class="headerlink" title="奈奎斯特路径"></a>奈奎斯特路径</h3><div class="note note-info">            <p>尽管有些资料对极坐标图和奈奎斯特图的概念不做区分，但事实上两者是不一样的。本章中认为奈奎斯特图中应当包含频率响应的镜像部分以及频率从$0^-$到$0^+$变化时系统的频率响应轨迹。  </p>          </div><p>奈奎斯特路径为一段在s域上的闭合矢量路径，其涵盖了s域的右半轴，如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220304101920.png width=50%>  </p><p>奈奎斯特路径为分为三部分：  </p><ul><li>i：频率$ω$由$0^+$变化到$+∞$，则$s=jω+σ$运动轨迹为(i).</li><li>ii：除虚轴以外的整个右半平面，$s=jω+σ=Re^{jθ}，R=∞$，角度$θ$由$\frac{π}{2}$变化到$-\frac{π}{2}$.</li><li>iii: 频率$ω$由$∞^-$变化到$0^-$，则$s=jω+σ$运动轨迹为(iii).</li></ul><h4 id="奈奎斯特路径的特殊情况"><a href="#奈奎斯特路径的特殊情况" class="headerlink" title="奈奎斯特路径的特殊情况"></a>奈奎斯特路径的特殊情况</h4><p>如果系统的开环极点在奈奎斯特路径的i和iii上，则奈奎斯特路径需要绕过：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220304112314.png width=50%>  </p><p>每一个绕路的小半圆可以表示为$\lim_{ρ→0}ρe^{jθ}$。  </p><h3 id="系统传递函数的映射"><a href="#系统传递函数的映射" class="headerlink" title="系统传递函数的映射"></a>系统传递函数的映射</h3><p>对系统$T(s)$，<br>有系统的开环传递函数：</p><script type="math/tex; mode=display">T_{ol}=G(s)H(s)=\frac{B(s)}{A(s)}</script><p>其中$B(s)=∏(s+z_i),A(s)=∏(s+p_i)$.<br>系统的闭环传递函数：  </p><script type="math/tex; mode=display">T_{cl}(s)=\frac{G(s)}{1+G(s)H(s)}=\frac{A(s)G(s)}{A(s)+B(s)}</script><p>可以发现$A(s)+B(s)$为闭环传递函数得出极点的多项式。<br>定义  </p><script type="math/tex; mode=display">F(s)=1+G(s)H(s)</script><p>表示系统的特征多项式，有：  </p><script type="math/tex; mode=display">F(s)=\frac{A(s)+B(s)}{A(s)}=\frac{闭环极点}{开环极点}</script><p>讨论使用$F(s)$映射奈奎斯特路径：  </p><ul><li>i：$ω$由$0^+$变化到$+∞$时$F(s)$的变化对应$F(s)$的频率响应。根据$F(s)=1+G(s)H(s)$，$F(s)$的频率特性实则为开环传递函数的频率响应向右平移一个单位。  </li><li>ii: $s=Re^{jθ}，R=∞$，角度$θ$由$\frac{π}{2}$变化到$-\frac{π}{2}$对应$F(s)→1$</li><li>iii：$ω$由$∞^-$变化到$0^-$时$F(s)$的变化对应$F(s)$的频率特性以实轴对称的镜像.  </li></ul><p>通过上述方式就可以绘制出奈奎斯特路径在$F(s)$上的映射，根据柯西辐角原理以及对函数$F(s)$的定义：  </p><script type="math/tex; mode=display">F(s)=\frac{A(s)+B(s)}{A(s)}=\frac{闭环极点}{开环极点}</script><p>可以重新建立柯西辐角原理公式：  </p><script type="math/tex; mode=display">N=P-Z</script><p>由于奈奎斯特路径在$s$域上只包含s域的右半轴部分，因此： $Z$为$F(s)$在s域右半轴的零点，是系统$T(s)$在s域右半轴的闭环极点（即$\frac{G(s)}{1+G(s)H(s)}$的极点），$P$为$F(s)$在s域右半轴的极点，是系统$T(s)$在s域右半轴的开环极点（即$G(s)H(s)$的极点），$N$为奈奎斯特路径在$F(s)$上的映射轨迹包围$F$域原点$(0,0)$的次数。<br>改写上述公式：  </p><script type="math/tex; mode=display">Z=P-N</script><p>根据系统的稳定性准则：当系统的闭环传递函数中所有的极点都位于s域左半轴时，系统是稳定的。那么，<strong>当$Z=0$时，系统在s域右半轴不存在任何极点，表明系统是稳定的。</strong>  </p><p>根据$F(s)=1+G(s)H(s)$，$F$平面上奈奎斯特曲线包围原点的情况等于$GH$平面上奈奎斯特曲线包围$(-1,0)$的情况。因此，<strong>只需要研究开环传递函数包围$(-1,0)$的情况，就可以得出闭环系统的稳定性。</strong><br>此时$N$应当表述为奈奎斯特路径在$G(s)H(s)$上的映射轨迹包围$GH$域$(-1,0)$的次数。<br>总结奈奎斯特稳定判据为：<br><strong>当频率$ω$从$-∞$向$+∞$变化时，$GH$平面上奈奎斯特曲线包围点$(-1,0)N$次</strong>，当</p><script type="math/tex; mode=display">Z=P-N=0</script><p>其中$P$为系统开环传递函数$G(s)H(s)$的在s域右半轴的极点个数<br>$N$拥有极性，逆时针包围点$(-1,0)$时$N&gt;0$,顺时针包围点$(-1,0)$时$N&lt;0$<br><strong>系统在s域右半轴不存在任何极点，表明系统是稳定的。</strong></p><div class="note note-info">            <p>某些资料上N的极性与此处所述相反，判别式为$Z=P+N=0$，且$N$代表半圈数而非完整圈数。本课程认为根据三角函数定义和相角变化，在逆时针包围时作为$N&gt;0$更为合理。而奈奎斯特路径和辐角定理的条件都是闭合曲线，因此$N$代表整个圈数更为合理。  </p>          </div><p>因此，根据奈奎斯特稳定判据判断系统稳定的方法：  </p><ol><li>找到系统开环传递函数$G(s)H(s)$的在s域右半轴的极点个数$P$。  </li><li>画出奈奎斯特曲线，并且找到$N$。  </li><li>利用$Z=P-N$，判断$Z$是否为0，得出稳定性结论。  </li></ol><h3 id="奈奎斯特曲线的画法"><a href="#奈奎斯特曲线的画法" class="headerlink" title="奈奎斯特曲线的画法"></a>奈奎斯特曲线的画法</h3><p>从上述结论来看，要画出$G(s)H(s)$的奈奎斯特曲线，才能够找到$N$的值。奈奎斯特曲线的画法如下：  </p><ol><li>绘制出$G(s)H(s)$的极坐标图，代表$G(s)H(s)$的频率响应曲线，对应路径i</li><li>绘制出$G(s)H(s)$的频率响应曲线以实轴为对称轴的镜像，对应路径iii</li><li><ul><li>路径ii(奈奎斯特图上从$0^-$到$0^+$的路径)在$F(s)$中对应原点(0,0)。  </li><li>此外，如果系统的开环极点在奈奎斯特路径的i和iii上，此时这段绕过的路径对应将路径i和iii的映射以$R→∞$的半圆首尾($0^-→0^+$)连接的路径。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220304112314.png width=50%>    </li></ul></li></ol><p>第三步补充路径的方法如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220304115220.png width=50%>  </p><p>如下图表示了$G(s)=\frac{1}{s(s+1)}$的奈奎斯特图：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220304113517.png width=50%></p><h3 id="奈奎斯特图特征"><a href="#奈奎斯特图特征" class="headerlink" title="奈奎斯特图特征"></a>奈奎斯特图特征</h3><h4 id="根据稳定性判断系统传递函数参数"><a href="#根据稳定性判断系统传递函数参数" class="headerlink" title="根据稳定性判断系统传递函数参数"></a>根据稳定性判断系统传递函数参数</h4><p>对系统开环传递函数$G(s)=\frac{K}{∏(s+p_i)}$，如果系统稳定，那么$N=P$。需要找到奈奎斯特曲线与实轴的所有交点：$(c_i,0)$，并判断其与$-\frac{1}{K}$的大小，根据$N=P$的临界条件来确定$K$的取值范围。<br>当奈奎斯特曲线正好穿过点(-1,0)时，系统处于临界稳定状态，系统的稳定和不稳定处于随机中。  </p><h4 id="增益裕量和相位裕量"><a href="#增益裕量和相位裕量" class="headerlink" title="增益裕量和相位裕量"></a>增益裕量和相位裕量</h4><p>定义增益裕量(Gain margin)$G_m$为使得系统处于临界稳定状态的增益。增益裕度可以通过奈奎斯特图上表示为相位角为$-180°$时对应的幅值$-\frac{1}{a}$求得：  </p><script type="math/tex; mode=display">G_m|_{dB}=20lg(a)</script><p>定义相位裕量(Phase margin)$P_m$为使得系统处于系统处于临界稳定状态的相位。相位裕量可以通过奈奎斯特图上单位圆与奈奎斯特图交点连线与实轴的负半轴夹角测量得到，如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220306085527.png width=50%></p><h4 id="灵敏度函数"><a href="#灵敏度函数" class="headerlink" title="灵敏度函数"></a>灵敏度函数</h4><p>如果开环传递函数为$G(s)H(s)$，定义系统的灵敏度函数(sensitivity function)为：  </p><script type="math/tex; mode=display">S(s)=\frac{1}{1+G(s)H(s)}</script><p>灵敏度函数的最大值$M_{s}$可以反应系统的鲁棒性。而灵敏度穿越频率（sensitivity crossover frequency）指灵敏度函数幅值为1时对应的角频率，以$ω_{sc}$表示。<br>在奈奎斯特图上，$1+GH$可以表示为-1到奈奎斯特曲线的向量，$\frac{1}{M_{s}}$是-1到奈奎斯特曲线的最短距离。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220304121001.png width=40%>  </p><h4 id="M环和N环"><a href="#M环和N环" class="headerlink" title="M环和N环"></a>M环和N环</h4><p>M环和N环是单位反馈系统的幅频响应和相频响应的轨迹。对于单位反馈系统，其闭环传输函数为：$T(s)=\frac{G(s)}{1+G(s)}$。其中$G(s)=P(s)+jQ(s)$.<br>有：  </p><script type="math/tex; mode=display">T(jω)=\frac{P(ω)+jQ(ω)}{P(ω)+1+jQ(ω)}</script><p>定义：  </p><script type="math/tex; mode=display">M^2=|T^2(jω)|=\frac{P^2(ω)+Q^2(ω)}{(P(ω)+1)^2+Q^2(ω)}</script><p>重新整理后可得：  </p><script type="math/tex; mode=display">(P+\frac{M^2}{M^2-1})^2+Q^2=\frac{M^2}{(M^2-1)^2}</script><p>可以发现这是一个半径为$\frac{M}{M^2-1}$，以$(-\frac{M^2}{M^2-1},0)$形成的圆的轨迹。这个圆随着M的变化而变化：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220304122140.png width=50%></p><p>同理可以得到反映单位控制系统相位变化的N环：  </p><script type="math/tex; mode=display">φ=arctan\frac{\frac{Q}{P}-\frac{Q}{P+1}}{1+\frac{Q}{P}\frac{Q}{P+1}}</script><script type="math/tex; mode=display">(P+\frac{1}{2})^2+(Q-\frac{1}{2N})^2=\frac{N^2+1}{4N^2}</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220304123727.png width=50%></p><p>可以发现，系统的闭环响应可以通过系统的奈奎斯特图（由开环传递函数得到）与M环和N环的交点轨迹得到：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220304123922.png width=50%></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>控制系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02. 控制系统的瞬态和稳态响应分析</title>
    <link href="/2022/02/28/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/2.%20%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/"/>
    <url>/2022/02/28/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/2.%20%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="控制系统的瞬态和稳态响应分析"><a href="#控制系统的瞬态和稳态响应分析" class="headerlink" title="控制系统的瞬态和稳态响应分析"></a>控制系统的瞬态和稳态响应分析</h1><p>对于控制系统而言，其系统方程由两部分组成：系统在到达稳定状态前的响应——称为瞬态响应（$c_{tr}(t)$，Transient response）和系统在达到稳定状态后的响应——称为稳态响应（$c_{ss}(t)$，Steady-state response），整个系统响应$c(t)$表示为：  </p><script type="math/tex; mode=display">c(t)=c_{tr}(t)+c_{ss}(t)</script><p>定义系统的误差信号(error signal)为$e(t)$，是输入与输出的差值：  </p><script type="math/tex; mode=display">e(t)=r(t)-c(t)</script><p>如果系统在稳态条件下的输出与输入不等，其输入与输出的差值称为稳态误差（$e_{ss}(t)$，Steady-state error），它反映了系统的准确性：  </p><script type="math/tex; mode=display">e_{ss}(t)=r(t)-c_{ss}(t)</script><h2 id="基本信号类型"><a href="#基本信号类型" class="headerlink" title="基本信号类型"></a>基本信号类型</h2><p>由于基本信号类型已在课程“信号与系统”中详述，在此不做过多描述。<br>在控制系统分析中会用到的基本信号如下表所示：  </p><div class="table-container"><table><thead><tr><th style="text-align:center">信号类型</th><th style="text-align:center">表达式（时域）</th><th style="text-align:center">表达式（s域）</th><th style="text-align:center">图示</th></tr></thead><tbody><tr><td style="text-align:center">单位冲击信号</td><td style="text-align:center">$δ(t)=1,t=0$</td><td style="text-align:center">$δ(s)=1$</td><td style="text-align:center"><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210319194902.png width=40%></td></tr><tr><td style="text-align:center">单位阶跃信号</td><td style="text-align:center">$u(t)=\begin{cases}1,t≥0 \\0,t&gt;0 \end{cases}$</td><td style="text-align:center">$u(s)=\frac{1}{s}$</td><td style="text-align:center"><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220301184353.png width=40%></td></tr><tr><td style="text-align:center">单位斜坡信号</td><td style="text-align:center">$r(t)=tu(t)=\begin{cases}t,t≥0 \\0,t&gt;0 \end{cases}$</td><td style="text-align:center">$r(s)=\frac{1}{s^2}$</td><td style="text-align:center"><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220301184956.png width=40%></td></tr><tr><td style="text-align:center">单位圆锥信号</td><td style="text-align:center">$x(t)=\begin{cases}\frac{1}{2}t^2,t≥0 \\0,t&gt;0 \end{cases}$</td><td style="text-align:center">$x(s)=\frac{1}{s^3}$</td><td style="text-align:center"><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220301185200.png width=40%></td></tr></tbody></table></div><h2 id="瞬态响应分析"><a href="#瞬态响应分析" class="headerlink" title="瞬态响应分析"></a>瞬态响应分析</h2><p>对系统进行瞬态响应分析时，应当对<strong>系统的转换方程</strong>进行分析。  </p><h3 id="一阶系统的瞬态响应分析"><a href="#一阶系统的瞬态响应分析" class="headerlink" title="一阶系统的瞬态响应分析"></a>一阶系统的瞬态响应分析</h3><p>一阶系统框图如下图所示，该框图可以被化简为开环系统：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220301185744.png width=50%>  </p><p>一阶系统的转换方程为：  </p><script type="math/tex; mode=display">T(s)=\frac{1}{Ts+1}</script><p>其中$T$是一个常数。  </p><h4 id="单位阶跃响应"><a href="#单位阶跃响应" class="headerlink" title="单位阶跃响应"></a>单位阶跃响应</h4><p>带入输入为单位阶跃信号，即$R(s)=\frac{1}{s}$，求得：  </p><script type="math/tex; mode=display">C(s)=\frac{1}{(Ts+1)s}</script><p>利用部分分式展开求得$C(s)$的拉普拉斯反变换：  </p><script type="math/tex; mode=display">c(t)=1-e^{-\frac{t}{T}},t≥0</script><p>可以发现$c(0)=0$，$\lim_{t→∞}c(t)=1$，$c(t)$的图像整体是一条从0出发，渐近线为1的指数曲线：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220301190511.png width=70%>  </p><p>根据图像可以发现：  </p><ul><li>$t=T$时，$c(T)=0.632$，$t=5T$时，$c(T)=0.993$，此时可以认为系统已经达到最大峰值。  </li><li>图像在$t=0$时的斜率为：$\frac{d}{dt}c(t)|_{t=0}=\frac{1}{T}$  </li></ul><h4 id="系统的其他类型响应"><a href="#系统的其他类型响应" class="headerlink" title="系统的其他类型响应"></a>系统的其他类型响应</h4><p>相同地，带入$R(s)=\frac{1}{s^2}$、$R(s)=1$对应求得其单位斜坡响应和单位冲激响应。  </p><div class="note note-info">            <p>对于线性系统而言，系统的单位斜坡响应也可以通过在时域对系统的单位阶跃响应在0到t上积分得到：  </p><script type="math/tex; mode=display">c_{ramp}(t)=\int_0^tc_{step}(t)dt</script><p>同样地，线性系统的单位冲击响应也可以通过在时域对系统的单位阶跃响应求导得到：  </p><script type="math/tex; mode=display">c_{impluse}(t)=\frac{d}{dt}c_{step}(t)</script>          </div><p>对系统单位斜坡响应：$c(t)=t-T+Te^{-\frac{t}{T}},t≥0$，其误差最终(即稳态误差)会趋近于$T$:<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220301192544.png width=40%></p><p>系统的单位冲激响应的可通过系统的转换方程的反拉普拉斯变换得到，单位冲激响应为：$c(t)=\frac{1}{T}e^{-\frac{t}{T}},t≥0$：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220301192735.png width=40%>  </p><h3 id="二阶系统的瞬态响应分析（控制系统视角）"><a href="#二阶系统的瞬态响应分析（控制系统视角）" class="headerlink" title="二阶系统的瞬态响应分析（控制系统视角）"></a>二阶系统的瞬态响应分析（控制系统视角）</h3><p>最经典的二阶系统是伺服系统（Servo system/servomechanism），它是一种通过力学装置实现的反馈控制系统，伺服系统通过反馈控制达到对一个机械系统的位置、速度和加速度的控制。伺服系统由伺服控制器$K$，负载(包括惯性$J$和粘性摩擦$B$)组成，系统模型可以表示为：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220301195144.png width=50%>  </p><p>系统转换方程为：  </p><script type="math/tex; mode=display">T(s)=\frac{K}{Js^2+Bs+K}</script><p>其中判别式$Δ=B^2-4JK$决定了极点的分布情况。<br>伺服系统是一种机械装置。在结构力学中，定义材料的固有频率$ω_n$、衰减$σ$和阻尼比（damped ratio）$ζ$与上述参数存在下列关系：  </p><script type="math/tex; mode=display">\frac{K}{J}=ω^2_n,\frac{B}{J}=2ζω_n=2σ</script><div class="note note-info">            <p>结构力学视角下的二阶伺服系统瞬态分析过程请参阅:<br>[如何理解单自由度系统振动-知乎]<a href="https://zhuanlan.zhihu.com/p/263045899">https://zhuanlan.zhihu.com/p/263045899</a><br>推荐查阅以便获得对本小节形象化的理解。  </p>          </div><p>带入可以得到：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220301195846.png width=50%>  </p><p>系统的转换方程为：  </p><script type="math/tex; mode=display">T(s)=\frac{ω_n^2}{s^2+2ζω_ns+ω_n^2}</script><div class="note note-info">            <p>信号与系统中对于阻尼比的定义，对于二阶系统的特征多项式：$(s+p_1)(s+p_2)$，可以整理出$s^2+2ζω_ns+ω_n^2$的形式，其中$ζ$为阻尼比(Damping ratio)，$ω_n$称为系统的固有频率(Nature Frequency)。  </p>          </div><p>此时使用判别式进行检验，当$B^2=4JK$时，计算得到$\frac{B}{J}=4\frac{K}{B}$，带入阻尼比等参数，最终得到$ζ=1$。可以发现，极点的分布始终只与$ζ$与0、1的关系有关。<br>根据阻尼比的不同，可以分为$ζ=0$（零阻尼，Undamped），$0&lt;ζ<1$(欠阻尼，underdamped)，$ζ=1$(临界阻尼，critically damped)和$ζ>1$（过阻尼，over damped）四种情况。  </p><h4 id="单位阶跃响应-1"><a href="#单位阶跃响应-1" class="headerlink" title="单位阶跃响应"></a>单位阶跃响应</h4><p>带入$R(s)=\frac{1}{s}$，得到系统的单位阶跃响应：  </p><script type="math/tex; mode=display">\begin{aligned}    C(s)=&\frac{ω_n^2}{(s^2+2ζω_ns+ω_n^2)s}\\    =&\frac{1}{s}-\frac{s+ζω_n}{(s+ζω_n)^2+ω_d^2}-\frac{ζω_n}{(s+ζω_n)^2+ω_d^2}\end{aligned}</script><p>其中$ω_d$称为阻尼固有频率$ω_d=ω_n\sqrt{1-ζ^2}$。  </p><ul><li>零阻尼：$ζ=0$<br>$ζ=0$时，根据判别式得出，全部的极点都位于s域的虚轴上。<br>此时对其做反变换得到：  <script type="math/tex; mode=display">c(t)=1-cosω_nt,t≥0</script></li><li>欠阻尼：$0&lt;ζ&lt;1$<br>此时特征方程的根由实部和虚部组成，极点在s域左半平面上。<br>反变换结果为：  <script type="math/tex; mode=display">c(t)=1-\frac{e^{-ζω_nt}}{\sqrt{1-ζ^2}}sin(ω_dt+arctan\frac{\sqrt{1-ζ^2}}{ζ})</script>同理，可以通过拉普拉斯反变换得到其他两种情况的系统输出方程，并且根据特征方程的根的情况找到极点在s域的分布。四种情况如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220301203250.png width=100%>  </li></ul><p>可以发现，相比于其他情况，临界阻尼时系统达到稳定用时最短；而过阻尼时系统的响应总是滞后于输出；系统在零阻尼状态下永远不可能稳定。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220301204340.png width=60%>  </p><h4 id="欠阻尼情况的分析"><a href="#欠阻尼情况的分析" class="headerlink" title="欠阻尼情况的分析"></a>欠阻尼情况的分析</h4><p><strong>阻尼比在传输线理论中的意义是反映了负载吸收能量与发射能量之间的关系。</strong><br>如果负载阻抗大于传输线的特征阻抗，那么负载端多余的能量就会反射回源端，由于负载端没有吸收全部能量，故称这种情况为欠阻尼。<br>如果负载阻抗等于传输线的特征阻抗，即阻抗匹配，那么负载正好吸收发射源发射的全部能量，这种情况是临界阻尼。<br>如果负载阻抗小于传输线的特征阻抗，负载消耗比当前源端提供的能量更多的能量，故通过反射来通知源端输送更多的能量，这种情况称为过阻尼。<br>通信工程中经常遇到的是欠阻尼情况。在欠阻尼的情况下，系统特征方程的根为：  </p><script type="math/tex; mode=display">s=-ζω_n±jω_n\sqrt{1-ζ^2}</script><p>定义滞后角$β=arctan\frac{\sqrt{1-ζ^2}}{ζ}$:<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220301210029.png width=30%></p><p>有如下衡量系统达到稳定性快慢的指标：  </p><ul><li>上升时间$t_r$（rise time）：对于二阶过阻尼系统，定义为阶跃响应曲线从稳态值的10%上升到90%所需的时间。对于二阶欠阻尼系统，也可定义为响应从0第一次上升到终值所需的时间。<br>令$c(t)=1$，得到$t=\frac{kπ-β}{ω_d},k∈Z^*$.  <script type="math/tex; mode=display">t_r=\frac{π-β}{ω_d}</script></li><li>滞后时间$t_d$（delay time）：系统响应第一次达到0.5倍终值时所需要的时间。  </li><li>峰值时间$t_p$（peak time）：阶跃响应曲线越过稳态值达到第一个峰值所需要的时间。<br>根据导数在极值点为0可以得到：  <script type="math/tex; mode=display">\begin{aligned}    \frac{dc(t)}{dt}&=0\\    &=\frac{e^{-ζω_nt}}{\sqrt{1-ζ^2}}[ζω_nsin(ω_dt+β)-ω_dcos(ω_dt+β)]\end{aligned}</script>由于$\frac{e^{-ζω_nt}}{\sqrt{1-ζ^2}}≠0$，解得$ω_dt+β=kπ+arctan\frac{ω_d}{ζω}$.<br>最终得到：  <script type="math/tex; mode=display">t_p=\frac{π}{ω_d}</script>此时峰值为:  <script type="math/tex; mode=display">c(t_p)=1+e^{-\frac{πζ}{\sqrt{1-ζ^2}}}</script></li><li>调节时间$t_s$(settling time)：阶跃响应曲线达到并永远保持在一个允许误差范围(误差带：通常取±5%或±2%)内，所需的最短时间。  <script type="math/tex; mode=display">t_s=4T=\frac{4}{ζω_n}(\text{达到0.98})</script><script type="math/tex; mode=display">t_s=3T=\frac{3}{ζω_n}(\text{达到0.95})</script><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220301190511.png width=50%>  </li><li>超调量/过冲率$M_p$（maximum perent overshoot）：阶跃响应曲线的最大偏离量$c(t_p)$与终值之差的百分比。  <script type="math/tex; mode=display">M_p=\frac{c(t_p)-c(∞)}{c(∞)}×100\%,c(∞)=1</script><script type="math/tex; mode=display">M_p=e^{-\frac{πζ}{\sqrt{1-ζ^2}}}×100\%</script></li></ul><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220301212556.png width=80%>  </p><div class="note note-info">            <p>由于线性系统的单位冲激响应和单位阶跃响应互为导数关系，因此在单位冲激响应第一次达到零时，对应峰值时间，此时累计时间面积最大，对应峰值$1+M_p$。  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220301213038.png width=60%>  </p>          </div><h2 id="稳态响应分析"><a href="#稳态响应分析" class="headerlink" title="稳态响应分析"></a>稳态响应分析</h2><h3 id="系统的稳定性"><a href="#系统的稳定性" class="headerlink" title="系统的稳定性"></a>系统的稳定性</h3><p>系统要具有稳定性，对系统的稳态响应分析才有意义。系统的稳定性分为绝对稳定性和相对稳定性，绝对稳定性则是根据稳定性定义直接判断当时间趋于无穷时系统时候收敛，而相对稳定性(relative stability)关注的是系统达到稳定的快慢。<br>相对稳定性可以通过调节时间$t_p$反映，$t_p$越长则系统达到稳定的时间越长。此外，在$s$域上，系统的极点分布越远离虚轴，系统达到稳定的时间越短。  </p><h4 id="劳斯–赫尔维茨稳定性判据-劳斯判据"><a href="#劳斯–赫尔维茨稳定性判据-劳斯判据" class="headerlink" title="劳斯–赫尔维茨稳定性判据/劳斯判据"></a>劳斯–赫尔维茨稳定性判据/劳斯判据</h4><p>劳斯–赫尔维茨稳定性判据/劳斯判据(Routh–Hurwitz stability criterion)是控制理论中的一个数学判据，是线性时不变系统稳定的充分必要条件。<br>对于n阶系统的特征多项式：  </p><script type="math/tex; mode=display">D(n)=a_ns^n+a_{n-1}s^{n-1}+...+a_1s+a_0</script><p>以下列递推方法计算：  </p><script type="math/tex; mode=display">b_i=\frac{a_{n-1}×a_{n-2i}-a_n×a_{n-(2i+1)}}{a_{n-1}}</script><script type="math/tex; mode=display">c_i=\frac{b_1×a_{n-2i}-a_{n-1}×b_{i+1}}{b_{1}}</script><script type="math/tex; mode=display">...</script><p>带入如下的劳斯表中：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220302110436.png width=50%>  </p><p>对劳斯表的每一行提取公因式化简，如果化简后的劳斯表中的第一列全为正，则该LTI系统是稳定系统。  </p><div class="note note-info">            <p>常用的劳斯表元素：  </p><script type="math/tex; mode=display">b_1=-\frac{1}{a_{n-1}}\left|\begin{matrix}  a_n & a_{n-2}\\  a_{n-1} & a_{n-3}\end{matrix}\right|</script><script type="math/tex; mode=display">b_2=-\frac{1}{a_{n-1}}\left|\begin{matrix}  a_n & a_{n-4}\\  a_{n-1} & a_{n-5}\end{matrix}\right|</script><script type="math/tex; mode=display">c_1=-\frac{1}{b_{1}}\left|\begin{matrix}  a_{n-1} & a_{n-3}\\  b_1 & b_2\end{matrix}\right|</script>          </div><h3 id="稳定系统的前向传递函数和稳态类型"><a href="#稳定系统的前向传递函数和稳态类型" class="headerlink" title="稳定系统的前向传递函数和稳态类型"></a>稳定系统的前向传递函数和稳态类型</h3><p>对于稳定系统当时间趋于无穷时，系统达到稳定。此时传递函数退化为前向传递函数$G(s)$.<br>因此<strong>稳态响应的分析是基于前向传递函数的</strong>。<br>系统的前向传递函数可以表示为：  </p><script type="math/tex; mode=display">G(s)=\frac{K(T_as+1)(T_bs+1)...(T_ms+1)}{s^v(T_1s+1)(T_2s+1)...(T_ps+1)}</script><p>根据前项传递函数的分母的$s^v$对系统进行分类：前项传递函数的分母为分母的$s^v$则系统为$v$型系统(V-type system)，是系统在s域上的重极点数目。其物理意义是开环传递函数中含有的积分环节的个数。工程上按照$v$的值分别称系统为0型，1型，2型，$v&gt;2$的系统实际上极少遇到，因为含有多于两个积分单元的系统很难使之稳定，因此一般情形下只使用0型，1型和2型的系统。  </p><h3 id="稳态误差"><a href="#稳态误差" class="headerlink" title="稳态误差"></a>稳态误差</h3><div class="note note-warning">            <p>对稳定的系统计算稳态误差才有意义。  </p>          </div><p>根据误差比的定义：$\frac{E(s)}{R(s)}=\frac{1}{1+G(s)}$, 可以得到：  </p><script type="math/tex; mode=display">E(s)=\frac{1}{1+G(s)}R(s)</script><p>由稳态误差的定义：$e_{ss}=\lim_{t→∞}e(t)$，由终值定理：  </p><script type="math/tex; mode=display">e_{ss}=\lim_{s→0}sE(s)=\lim_{s→0}\frac{sR(s)}{1+G(s)}</script><h4 id="静态误差系数"><a href="#静态误差系数" class="headerlink" title="静态误差系数"></a>静态误差系数</h4><p>静态误差系数(static error coefficient)分为静态位置误差系数、静态速度误差系数、静态加速度误差系数。分别代表了控制系统中，一个系统对阶跃输入、斜坡输入、抛物线信号输入响应消除或减少稳态误差的能力。当系统输入信号形式、输出量的期望及容许的稳态位置误差确定后，可以方便的根据静态误差系数去选择系统的型别和开环增益，进行控制系统设计。但是静态误差系数仅对单位反馈控制系统有着明确的物理意义。  </p><ul><li><p>静态位置误差系数(static position error constant)<br>定义静态位置误差系数$K_p$表示各型系统在阶跃输入$r(t)=Ru(t)$作用下的位置误差，其中$R$为输入阶跃函数幅值。<br>可以计算得出稳态误差为：  </p><script type="math/tex; mode=display">e_{ss}(∞)=\begin{cases}  \frac{R}{1+K},v=0\\  0,v≥1\end{cases}</script><p>在单位阶跃输入$r(t)=u(t)$（即$R(s)=\frac{1}{s}$）作用下，其稳态误差是期望输出1和实际输出$\frac{K}{1+K}$之间的位置误差，定义为：</p><script type="math/tex; mode=display">K_p=\lim_{s→0}G(s)=G(0)=\lim_{s→0}\frac{K}{s^v}</script></li><li><p>静态速度误差系数(static velocity error constant)<br>在速度输入作用下，即$r(t)=Rt$，其中$R$为输入速度函数斜率，可以算出稳态误差为:  </p><script type="math/tex; mode=display">e_{ss}(∞)=\begin{cases}  ∞,v=0\\  \frac{R}{K},v=1\\  0,v≥2\end{cases}</script><p>定义静态速度误差系数：  </p><script type="math/tex; mode=display">K_v=\lim_{s→0}sG(s)=\lim_{s→0}\frac{K}{s^{v-1}}</script></li><li><p>静态加速度误差系数(static acceleration error constant)<br>在加速度输入作用下，即$r(t)=\frac{1}{2}Rt^2$，其中$R$为输入加速度函数速度变化率，可以算出稳态误差为：  </p><script type="math/tex; mode=display">e_{ss}(∞)=\begin{cases}  ∞,v=0,1\\  \frac{R}{K},v=2\\  0,v≥3\end{cases}</script><p>定义静态加速度误差系数：  </p><script type="math/tex; mode=display">K_a=\lim_{s→0}s^2G(s)=\lim_{s→0}\frac{K}{s^{v-2}}</script></li></ul><p>可以将三种稳态误差系数总结表格如下：  </p><div class="table-container"><table><thead><tr><th style="text-align:center">系统类型</th><th style="text-align:center">位置误差 <br> $r(t)=1$ <br>$K_p=\lim_{s→0}\frac{K}{s^{v}}$</th><th style="text-align:center">速度误差 <br> $r(t)=t$ <br>$K_v=\lim_{s→0}\frac{K}{s^{v-1}}$</th><th style="text-align:center">加速度误差 <br> $r(t)=\frac{1}{2}t^2$ <br>$K_a=\lim_{s→0}\frac{K}{s^{v-2}}$</th></tr></thead><tbody><tr><td style="text-align:center">0型</td><td style="text-align:center">$\frac{1}{1+K_p}$</td><td style="text-align:center">$∞$</td><td style="text-align:center">$∞$</td></tr><tr><td style="text-align:center">I型</td><td style="text-align:center">$0$</td><td style="text-align:center">$\frac{1}{K_v}$</td><td style="text-align:center">$∞$</td></tr><tr><td style="text-align:center">II型</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$\frac{1}{K_a}$</td></tr></tbody></table></div><h2 id="非单位反馈系统的瞬态稳态响应分析方法"><a href="#非单位反馈系统的瞬态稳态响应分析方法" class="headerlink" title="非单位反馈系统的瞬态稳态响应分析方法"></a>非单位反馈系统的瞬态稳态响应分析方法</h2><p>上述对系统的瞬态稳态响应分析都建立在反馈系数$H(s)=1$的条件下，这种系统称为单位反馈系统，当$H(s)≠1$时，只需要利用系统框图化简为单位反馈系统即可：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220302104801.png width=50%></p><h3 id="非单位反馈系统的稳态误差系数"><a href="#非单位反馈系统的稳态误差系数" class="headerlink" title="非单位反馈系统的稳态误差系数"></a>非单位反馈系统的稳态误差系数</h3><ul><li>静态位置误差系数<script type="math/tex; mode=display">K_p=\lim_{s→0}G(s)H(s)</script></li><li>静态速度误差系数<script type="math/tex; mode=display">K_v=\lim_{s→0}sG(s)H(s)</script></li><li>静态加速度误差系数<script type="math/tex; mode=display">K_a=\lim_{s→0}s^2G(s)H(s)</script></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>控制系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01. 控制系统的组成和模型表示</title>
    <link href="/2022/02/28/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/1.%20%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/"/>
    <url>/2022/02/28/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/1.%20%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="控制系统的组成和模型表示"><a href="#控制系统的组成和模型表示" class="headerlink" title="控制系统的组成和模型表示"></a>控制系统的组成和模型表示</h1><h2 id="控制系统概述及其结构"><a href="#控制系统概述及其结构" class="headerlink" title="控制系统概述及其结构"></a>控制系统概述及其结构</h2><p>一个基本的系统由输入、输出和处理(Process)三部分构成。其中的处理是用于实现系统功能的装置(Device)，比如某些函数、子系统、功能等。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220301093748.png width=50%>  </p><p>控制系统是一种可以调整内部配置达到所需要的响应的系统。控制系统同时是为了使被控制对象达到预定的理想状态而实施的。控制系统使被控制对象趋于某种需要的稳定状态。下图反映了一个基本的反馈控制系统。  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220301093221.png width=50%>  </p><p>如上图所示，基本的反馈控制系统包括控制器(Controller)和处理(Process)两部分，通过对控制器和处理进行输入和可能含有的系统反馈来调整当前的系统输出。  </p><p>在控制系统中有如下的输出变量：  </p><ul><li><strong>受控变量</strong>（Controlled Variable）：整个控制系统的输出变量，是一种可被测量和控制的状态或值。  </li><li><strong>操纵变量</strong>（Manipulated Variable）：控制器的输出变量，并且该输出变量可以影响整个控制系统的输出，即受控变量。  </li></ul><p>此外，控制系统中还可能存在一些其他可能对系统产生不利影响的杂信号，称为干扰（Disturbance）。  </p><p>在电子系统中，控制系统还包括其他两个组成部分：    </p><ul><li>传感器(Sensor)：将物理参数转换为电子信号输出的转置，通常在转换过程中含有噪声。  </li><li>驱动器(Actuator)：将电子信号转换为物理输出的转置。  </li></ul><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220301093051.png width=70%></p><h3 id="控制系统的分类"><a href="#控制系统的分类" class="headerlink" title="控制系统的分类"></a>控制系统的分类</h3><p>无反馈称为<strong>开环控制系统</strong>（open-loop control system），这种系统的输入直接供给控制器，并通过控制器对受控对象产生控制作用。其主要优点是结构简单、价格便宜、容易维修；缺点是精度低，容易受环境变化（例如电源波动、温度变化等）的干扰。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220301094925.png width=60%>  </p><p>有反馈称为<strong>闭环控制系统</strong>（closed-loop control system），输入与反馈信号比较后的差值（即偏差信号）加给控制器，然后再调节受控对象的输出，从而形成闭环控制回路。所以，闭环系统又称为反馈控制系统，这种反馈称为负反馈。与开环系统相比，闭环系统具有突出的优点，包括精度高、动态性能好、抗干扰能力强等。它的缺点是结构比较复杂，价格比较贵，对维修人员要求较高。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220301095016.png width=60%><br>反馈控制可以存在多个，或者嵌套关系，如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220301095829.png width=60%>  </p><div class="note note-warning">            <p>由于正反馈存在不稳定性，因此本课程的研究对象主要为负反馈系统。  </p>          </div><p>反馈控制的目的在于：  </p><ul><li>让系统实现定式功能  </li><li>减小系统的变化和干扰对系统的影响</li><li>让系统动态地根据需求而变化</li><li>让原本不稳定的系统持续地稳定</li></ul><p>此外，系统还可以分为：  </p><ul><li>线性/非线性系统：如果输入和输出的关系为线性，则为线性系统，否则为非线性系统。  </li><li>时变/时不变系统：如果系统输出与时间无关，则为时不变系统，否则为时变系统。  </li><li>因果/非因果系统：如果系统输出仅与当前输入和之前的输出有关，与未来输入无关，则为因果系统，否则为非因果系统。  </li><li>连续/离散系统：如果系统所有的变量都随时间连续变化，则为连续系统。如果系统存在一个或多个变量，其值仅在某些特定时刻已知，则为离散系统。  </li><li>确知/随机系统： 如果系统随输入的响应是可重复可预测的，则为确知系统，否则为随机系统。  </li></ul><p>本课程主要讨论线性时不变系统（LIT system）。</p><h2 id="系统模型：描述系统的方式"><a href="#系统模型：描述系统的方式" class="headerlink" title="系统模型：描述系统的方式"></a>系统模型：描述系统的方式</h2><h3 id="微分方程"><a href="#微分方程" class="headerlink" title="微分方程"></a>微分方程</h3><p>系统可以描述为系统输入$x(t)$和系统输出$y(t)$之间的线性微分方程：  </p><script type="math/tex; mode=display">\frac{d^n}{dt^n}y+a_{n-1}\frac{d^{n-1}}{dt^{n-1}}y+...+a_1\frac{d}{dt}y+a_0y=b_m\frac{d^m}{dt^m}x+...+b_1\frac{d}{dt}x+b_0x</script><h3 id="转换方程"><a href="#转换方程" class="headerlink" title="转换方程"></a>转换方程</h3><p>在s域下，系统的微分方程表示为：  </p><script type="math/tex; mode=display">Y(s)[s^n+a_{n-1}s^{n-1}+...+a_1s+a_0]=X(s)[b_ms^m+b_{m-1}s^{m-1}+...+b_1s+b_0]</script><p>定义系统的转换方程为：  </p><script type="math/tex; mode=display">H(s)=\frac{Y(s)}{X(s)}=\frac{b_ms^m+b_{m-1}s^{m-1}+...+b_1s+b_0}{s^n+a_{n-1}s^{n-1}+...+a_1s+a_0}</script><p>其中：$n$是系统的阶<br>定义系统的特征方程为：$s^n+a_{n-1}s^{n-1}+…+a_1s+a_0=0$<br>特征方程的根称为系统的极点(Pole)，以×表示。<br>$H(s)=0$的根称为系统的零点(Zero)，以○表示。  </p><h3 id="系统框图"><a href="#系统框图" class="headerlink" title="系统框图"></a>系统框图</h3><h4 id="标准反馈控制系统的系统框图"><a href="#标准反馈控制系统的系统框图" class="headerlink" title="标准反馈控制系统的系统框图"></a>标准反馈控制系统的系统框图</h4><p>标准的反馈控制系统框图如下所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220301121950.png width=50%><br>其中$G(s)$为前向传递函数，$H(s)$为反馈传递函数，$E(s)$为误差，是输入与输出的差值，有$E(s)=R(s)-C(s)$。<br>$G(s)H(s)$为系统的开环传递函数。<br>整个反馈系统的转换方程为：  </p><script type="math/tex; mode=display">\frac{C}{R}=\frac{G}{1± GH}</script><p>这也称为系统的控制比(Control ratio)。<br>系统的误差比为：  </p><script type="math/tex; mode=display">\frac{E}{R}=\frac{1}{1± GH}</script><h4 id="系统框图化简"><a href="#系统框图化简" class="headerlink" title="系统框图化简"></a>系统框图化简</h4><p>系统框图化简遵循如下的六个规则：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220301123109.png width=100%>  </p><h3 id="信号流图"><a href="#信号流图" class="headerlink" title="信号流图"></a>信号流图</h3><p>信号流图的基本组成部分包括：</p><ul><li>节点：表示求和 </li><li>箭头：表示流动的方向</li><li>箭头上方的标注表示乘法器或者其他系统</li></ul><p>一个基本的信号流单元如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220301123502.png width=50%></p><p>信号流图中可能会出现自循环(Self-loop)，自循环中箭头的方向对信号流分析没有影响，一般规定为顺时针。<br>如下图的$x_3=A_{31}x_1+A_{32}x_2+A_{33}x_3$<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220301123827.png width=50%></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>控制系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>0. 课程简介</title>
    <link href="/2022/02/28/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/0.%20%E8%AF%BE%E7%A8%8B%E7%AE%80%E4%BB%8B/"/>
    <url>/2022/02/28/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/0.%20%E8%AF%BE%E7%A8%8B%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>控制系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>判断题和填空题</title>
    <link href="/2022/02/18/%E9%9B%85%E6%80%9D/%E9%9B%85%E6%80%9D%E9%98%85%E8%AF%BB/%E5%88%A4%E6%96%AD%E9%A2%98%E5%92%8C%E5%A1%AB%E7%A9%BA%E9%A2%98/"/>
    <url>/2022/02/18/%E9%9B%85%E6%80%9D/%E9%9B%85%E6%80%9D%E9%98%85%E8%AF%BB/%E5%88%A4%E6%96%AD%E9%A2%98%E5%92%8C%E5%A1%AB%E7%A9%BA%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="填空题和判断题"><a href="#填空题和判断题" class="headerlink" title="填空题和判断题"></a>填空题和判断题</h1><h2 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h2><h3 id="题目类型"><a href="#题目类型" class="headerlink" title="题目类型"></a>题目类型</h3><ul><li>相关核心话题词在文章中分布集中/定位明显<br>比如：笔记填空、表格填空、图表填空、流程图填空、有词库和没有词库的摘要填空（词库中的词会被同义替换）  </li><li>信息分散各段<br>比如：句子填空和简答题（低频出题）  </li></ul><h3 id="题型特点"><a href="#题型特点" class="headerlink" title="题型特点"></a>题型特点</h3><ul><li>题目上方有字数限制，注意要求：”NO MORE THAN”、”AND/OR A NUMBER”等<br>如果出现”NO MORE THAN”，表明至少有一空的答案会达到要求的字数上限。  </li><li>考察文章细节</li><li>顺序出题</li><li>原词抄写</li></ul><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ul><li>勾画定位词和考点词（一定会有同义替换的词）</li><li>预判填空中的词性（名词/动词）、词形（单/复数）、词义（表示人/事/物/地）、词向（正面/负面）</li><li>在文章中找定位  <ul><li>找定位词，定位词又可分为大定位词（只在某几段中提到的词）和小定位词（某一段中的特有的词）  </li><li>利用表格等的小标题和表头定位</li><li>利用其他题目的题号卡出未出题的段落</li></ul></li><li>原词抄写</li><li>检查字数和词形是否符合要求</li></ul><h3 id="解题技巧"><a href="#解题技巧" class="headerlink" title="解题技巧"></a>解题技巧</h3><ul><li>如果题干一句有多空，必然答案来自于同一段</li><li>答案定位较为集中时可能题目会出现乱序</li></ul><h2 id="判断题"><a href="#判断题" class="headerlink" title="判断题"></a>判断题</h2><h3 id="题目类型-1"><a href="#题目类型-1" class="headerlink" title="题目类型"></a>题目类型</h3><p>按填写内容可分为两种：  </p><ul><li>TRUE/FALSE/NOT GIVEN:判断事实陈述是否正确，常在Passage1中出现。  </li><li>YES/NO/NOT GIVEN：判断表述是否符合作者观点<br>做题时一定要看清楚题目的填写要求。  </li></ul><h3 id="考察类型"><a href="#考察类型" class="headerlink" title="考察类型"></a>考察类型</h3><p>考点类型包括五种：<br>五种考点相关的词应当着重核对。  </p><ul><li>是非<br>关注题干中的主谓、形容词和动宾结构。<br>注意: rately/hardly/seldom/few/little 都表示否定<br>在事实描述中需要注意表述中含有的主观情感，比如“Elon suprised about the findings.”  </li><li>比较<br>关注比较对象、比较事件和比较词（表示异同的词语：Distinguish/share with）<br>注意比较对象有可能是暗含的。  </li><li>因果<br>因果类题目要注意两种考点：  <ul><li>因果倒置：需要理清文章中的逻辑词和逻辑关系  </li><li>唯一原因：雅思题目中默认原因是唯一的，如果原因是文章中提到的，但是不匹配，表述应当为FALSE，如果是文章中不存在的原因，表述应当为NOT GIVEN  </li></ul></li><li>绝对<br>关注绝对词：every/only/most/same等等<br>一个题中只有一个考点词，如果题干中出现绝对词，大概率会是考点词  </li><li>数字<br>关注：数字的准确性（比如大于、小于、超过等描述）<br>注意”both/sole/only”等词语表示的唯一性或者不唯一性。<br>当”both…and…”出现在题干中时，需要保证and前后的主体都符合描述才能算TRUE。<br>题干中出现时间时，时间不太可能作为考点，更多情况下，时间作为定位词使用。  </li><li>目的<br>关注表目的的介词：“to/for”，词语“goal/aim/purpose”等等。<br>需要注意，题干表述中除非明确写到“one of”，否则认为题干表述的目的是唯一的。  </li></ul><h3 id="难点：FALSE-和-NOT-GIVEN"><a href="#难点：FALSE-和-NOT-GIVEN" class="headerlink" title="难点：FALSE 和 NOT GIVEN"></a>难点：FALSE 和 NOT GIVEN</h3><p>NOT GIVEN：题目与文章表述无关，根据原文信息无法确定。<br>FALSE： 题目与文章表述相悖（相反或者相斥）  </p>]]></content>
    
    
    <categories>
      
      <category>雅思笔记</category>
      
      <category>雅思阅读</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>选择题和匹配题</title>
    <link href="/2022/02/18/%E9%9B%85%E6%80%9D/%E9%9B%85%E6%80%9D%E5%90%AC%E5%8A%9B/%E9%80%89%E6%8B%A9%E5%92%8C%E5%8C%B9%E9%85%8D/"/>
    <url>/2022/02/18/%E9%9B%85%E6%80%9D/%E9%9B%85%E6%80%9D%E5%90%AC%E5%8A%9B/%E9%80%89%E6%8B%A9%E5%92%8C%E5%8C%B9%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="单项选择题"><a href="#单项选择题" class="headerlink" title="单项选择题"></a>单项选择题</h2><h3 id="考点题型"><a href="#考点题型" class="headerlink" title="考点题型"></a>考点题型</h3><p>给一个问题和题干，有三个选项。<br>问题可能是完整的，也可能是不完整的。<br><strong>正确答案通常以改述形式出现。一般而言，动词、形容词、短语词组不会以原型出现。</strong><br>单选题设问通常在原因(reason/why/because)/目的(aim/purpose/intend)/事实(what/how/suprise)/计划(next/going to)。  </p><h3 id="做题技巧"><a href="#做题技巧" class="headerlink" title="做题技巧"></a>做题技巧</h3><ul><li>提取并勾画题干中的主旨大意</li><li>圈选项中的主旨关键词</li></ul><h4 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h4><p>关键词是句子的主旨大意词，一般一道题有3-4个题。<br>e.g. According to Debble, <em>why</em> some people <em>fail</em> to <em>eat</em> a balanced <em>diet</em>?<br><strong>正确选项的关键词通常会改述，而干扰项的关键词通常会以原词出现</strong>。  </p><h2 id="多项选择题"><a href="#多项选择题" class="headerlink" title="多项选择题"></a>多项选择题</h2><p>通常，多项选择题中的每一个选项都会提到，在审题时应当注意题干中的限定信息。<br>限定信息通常会使用同义替换。<br>此外，多选题中的选项是乱序出现的，不会根据录音中的出现顺序排列。  </p><h3 id="做题方法"><a href="#做题方法" class="headerlink" title="做题方法"></a>做题方法</h3><ul><li>读题，理解题干中的限定信息。  </li><li>听力过程中，先甄别选项。  </li><li>听到选项之后，判断录音描述是否和题干中的限定信息相符。  </li></ul><h2 id="匹配题"><a href="#匹配题" class="headerlink" title="匹配题"></a>匹配题</h2><h3 id="观点类匹配题"><a href="#观点类匹配题" class="headerlink" title="观点类匹配题"></a>观点类匹配题</h3><p>观点类的匹配题注意把握说话人的观点。<br>选项是顺序出现的。  </p><ul><li>表示观点的词汇</li><li>说话人的语音语调也会表示观点</li></ul><h3 id="笔记法"><a href="#笔记法" class="headerlink" title="笔记法"></a>笔记法</h3><ol><li>看问题，设问的考点词（比如:what changes）  </li><li>快速扫读选项，查看选项描述的内容方面  </li><li>记录听到的每一个题号相关的表述，记录的时候用符号表示 否定(/)/增加(↑)/减小(↓)/倍数 等等  </li><li>根据笔记还原听到的内容，匹配选项  </li></ol>]]></content>
    
    
    <categories>
      
      <category>雅思笔记</category>
      
      <category>雅思听力</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>填空题和地图题</title>
    <link href="/2022/02/18/%E9%9B%85%E6%80%9D/%E9%9B%85%E6%80%9D%E5%90%AC%E5%8A%9B/%E5%A1%AB%E7%A9%BA%E9%A2%98%E5%92%8C%E5%9C%B0%E5%9B%BE%E9%A2%98/"/>
    <url>/2022/02/18/%E9%9B%85%E6%80%9D/%E9%9B%85%E6%80%9D%E5%90%AC%E5%8A%9B/%E5%A1%AB%E7%A9%BA%E9%A2%98%E5%92%8C%E5%9C%B0%E5%9B%BE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="填空题和地图题"><a href="#填空题和地图题" class="headerlink" title="填空题和地图题"></a>填空题和地图题</h1><h2 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h2><h3 id="考点题型"><a href="#考点题型" class="headerlink" title="考点题型"></a>考点题型</h3><p>填空题一般在Part1中出现。<br>填空题和选择题占比基本上50%，还有可能出现标注题。<br>所有答案与录音顺序一致。<br>人命、地名(给出拼写/非拼写)：占1-2分。<br>数字，占1-2分。<br>日期，占1-2分。<br>场景词汇。  </p><div class="note note-info">            <p>January/February/March/April/May/June/July/August/September/October/November/December<br>Monday/Tuesday/Wednesday/Thursday/Friday/Saturday/Sunday  </p>          </div><h3 id="做题技巧"><a href="#做题技巧" class="headerlink" title="做题技巧"></a>做题技巧</h3><p>听力前：<br>圈出字数要求，根据标题预测对话双方关系。<br>勾画定位词：<br>黑体字/大写/数字/名词/地名<br>描述空格词的形容词/词组，这些词往往容易被同义替换，答案容易出现在这些词的同义替换前后。    </p><h2 id="笔记填空题"><a href="#笔记填空题" class="headerlink" title="笔记填空题"></a>笔记填空题</h2><p>笔记填空题通常在Part4中出现，是学术环境下的讲座或者报告，但是不涉及专业知识。在Part4中听力录音随10道题全部播放，中间不会有暂停。<br>在Part4结束后，雅思纸笔考试会有10分钟的填涂答案时间，雅思机考会有2分钟的检查时间。  </p><h3 id="题型特点"><a href="#题型特点" class="headerlink" title="题型特点"></a>题型特点</h3><ul><li>题目要求中有字数要求</li><li>Form和Note题注意有黑体字小标题以及笔记中含有的逻辑关系</li><li>Table题注意看清楚表头与题号顺序</li><li>答案<strong>不可以</strong>对听力中原词做改变</li><li>以下2种情况会导致即使听到答案也不算正确：<ul><li>超过规定字数要求</li><li>单词拼写错误或者形式不准确，比如名词单复数使用</li></ul></li><li>对缩略式(如：I’ve …; she’s … )不进行考察</li><li>带连字符的单词(如：ex-boyfriend) 算1个单词</li></ul><h3 id="做题方法"><a href="#做题方法" class="headerlink" title="做题方法"></a>做题方法</h3><ul><li>在录音播放前对空格的词性、单复数和倾向进行预测。<br>在预测时应当结合上下文理解，注意句子中的指代，补完题目所在部分缺失的主语，并且注意限制信息。  </li><li>在听力过程中，抓住定位词。<br>定位词能够帮助定位录音的位置，定位词通常是：  <ul><li>表格中的黑体、小标题</li><li>该句所在的动词，但是动词极有可能被同义替换</li><li>一些低频或者专有名词</li></ul></li></ul><h2 id="地图题"><a href="#地图题" class="headerlink" title="地图题"></a>地图题</h2><p>地图题一般在Part2中出现。  </p><h3 id="相关词汇"><a href="#相关词汇" class="headerlink" title="相关词汇"></a>相关词汇</h3><h4 id="室外"><a href="#室外" class="headerlink" title="室外"></a>室外</h4><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/57fd432f96b69332756b72e3bf8f439.png width=50%>  </p><ol><li>Crossroads</li><li>Intersection/Junction/Brunch</li><li>Corner/Bend</li><li>Flyover</li><li>Traffic lights</li><li><p>Roundabout 环岛  </p><div class="note note-info">            <p>需要注意环岛的出口顺序是顺时针的。  </p>          </div><p>Exit/Turning 出口<br>Footpath 小路<br>Wing road 蜿蜒小路  </p></li></ol><h4 id="室内"><a href="#室内" class="headerlink" title="室内"></a>室内</h4><ul><li>Corridor 过道</li><li>Main hall</li><li>Room</li><li>Entrance</li></ul><h3 id="做题方法-1"><a href="#做题方法-1" class="headerlink" title="做题方法"></a>做题方法</h3><p>根据听力录音的描述，可以将地图题分为静态图和动态图。如果说话人是通过路线描述位置的，该题为动态图题；如果是通过直接表述建筑物位置和建筑物之间的相对关系，该题为静态图题。  </p><h4 id="动态图"><a href="#动态图" class="headerlink" title="动态图"></a>动态图</h4><ul><li>地图题是顺序题、且会原词复现。   </li><li>在听力中，需要注重起点的位置。由于每一道题相互独立，不相关，因此听完一道题之后需要回到起点。   </li><li>听力中描述的方向都是相对的、取决于描述人所处的位置和朝向，在叙述中会动态变化。  </li></ul><h4 id="静态图"><a href="#静态图" class="headerlink" title="静态图"></a>静态图</h4><ul><li>通常可以利用图中出现的几个地理信息定位到某个选项。  </li><li>关注图中出现的专有名词，非专有名词可能会有同义替换。   </li><li>要注意分别录音中提到的对话中描述的时间（有些路标可能会随着时间变化）。  </li><li>静态图的录音语速可能会很快、信息密度高，需要注意节奏。  </li></ul>]]></content>
    
    
    <categories>
      
      <category>雅思笔记</category>
      
      <category>雅思听力</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Part A：流程图和地图</title>
    <link href="/2022/02/15/%E9%9B%85%E6%80%9D/%E9%9B%85%E6%80%9D%E5%86%99%E4%BD%9C/%E6%B5%81%E7%A8%8B%E5%9B%BE%E5%92%8C%E5%9C%B0%E5%9B%BE/"/>
    <url>/2022/02/15/%E9%9B%85%E6%80%9D/%E9%9B%85%E6%80%9D%E5%86%99%E4%BD%9C/%E6%B5%81%E7%A8%8B%E5%9B%BE%E5%92%8C%E5%9C%B0%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="Part-A：流程图和地图"><a href="#Part-A：流程图和地图" class="headerlink" title="Part A：流程图和地图"></a>Part A：流程图和地图</h1><p>流程图和地图题都不需要筛选信息，图像中出现的所有词汇都必须提及原词或其同义替换。  </p><h2 id="地图"><a href="#地图" class="headerlink" title="地图"></a>地图</h2><p>地图题三要素：  </p><ul><li>设施名称/地名</li><li>位置关系：需要遵从一些顺序进行描述，题目中未给出指南针的情况默认朝上为北。  </li><li>面积大小</li></ul><p>地图题可以大致分为两类：  </p><ul><li>变化型地图题：地图随时间变化<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220215163427.png width=50%><br>描述时描述初始状态和后续的变化，这些变化可能有：  <ul><li>方位</li><li>设施</li><li>面积：面积变化的大小和方向需要描述  </li></ul></li><li>结构对比型地图题：比较不同结构的两个图<br>例如：对比澳大利亚和日本的办公室结构<br>相同点和不同点各写一段。  </li></ul><p>语料：  </p><ul><li>lie/stand/sit ⋆取决于建筑物高度  </li><li>be situated/located</li><li>intersection/crossing 十字路口</li><li>T-junction T字路口</li><li>bend 转弯处</li><li>top left-hand corner 左上角</li><li>bottom right-hand corner 右下角</li></ul><hr><ul><li>sourthward adj./adv. 朝南 </li><li>in（内部）/on（接壤）/to（分离） the east of </li><li>nearby/in close proximity to/next to/neighbor to/by the side of</li><li>along 沿着</li><li>opposite to/face with 在…对面</li><li>be parallel with</li><li>be vertical to 与…垂直</li><li>be surrounded by</li><li>roughly/approximately 大致的</li></ul><hr><ul><li>disappear/vanish/remove/be torn down/be demolished</li><li>appear/emerge/be built/be constructed</li><li>transform/reconstruct/rebuild 改建</li></ul><hr><ul><li>expand the scale/size</li></ul><h3 id="开头段"><a href="#开头段" class="headerlink" title="开头段"></a>开头段</h3><p>介绍背景：通常介绍该地区的背景，并提及变化/差异。<br>The map below illustrates…</p><h3 id="主体段"><a href="#主体段" class="headerlink" title="主体段"></a>主体段</h3><p>例文：<br>Chronologically, during the first 15 years from 1868 to 1883, Chorleywood was merely a very small village with two main roads to its west and north respectively.<br>From 1883 to 1992, it can be identified see that the village expanded to south, almost tripled the original scale. Besides, a railway line was built across the new area from west to east and there emerged the Chorleywood Station.  </p><p>地图题一定要使用倒装句以变换句式。<br>地点状语+不及物动词+主体。<br>e.g.: On the mountain stands a temple.<br>e.g.: In front of the hotel emerged a new metro station.  </p><h3 id="概述段"><a href="#概述段" class="headerlink" title="概述段"></a>概述段</h3><p>一般使用时间或者地点作为主语综述变化或者差异。<br>例文：<br>Overall, the time witnessed the development of Chorleywood.</p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p>流程图有两种：循环流程图和单项流程图。<br>单项流程图直接按顺序描述所有要素即可。<br>循环流程图需要综合和整理。  </p><h3 id="流程图要素"><a href="#流程图要素" class="headerlink" title="流程图要素"></a>流程图要素</h3><ul><li>材料</li><li>工具</li><li>环境</li><li>场所</li></ul><p>语法要点：  </p><ul><li>一般现在时</li><li>被动语态</li><li>步骤连接词</li></ul><h3 id="语料"><a href="#语料" class="headerlink" title="语料"></a>语料</h3><ul><li>the circle continues until…</li><li>at this point, a circle has been completed, a new one will begin.  </li><li>be v.-ed in the v.-ing stage</li><li>first of all</li></ul><hr><ul><li>ultimately/eventually</li><li>the last/final stage is to do</li></ul><hr><ul><li>before/until/once/after/A, after which B</li><li>in following/next/second stage is to do</li><li>the next step in the process is</li></ul><p>装置复杂，过程简单的科技图可以先描述装置构造，再描述流程。<br>如果图中有生词，需要根据图片描述猜测词性（根据箭头，同结构的已知图）。如果可以猜测出为名词，则不做同义替换直接使用。-er结尾的工具名词可以提取有关动词。动词转义为被动语态或者根据图像使用“be v1.-ed in the v2.-ing stage”结构进行同义替换（v1是熟词被动，v2是生词）。  </p>]]></content>
    
    
    <categories>
      
      <category>雅思笔记</category>
      
      <category>雅思写作</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Part 3</title>
    <link href="/2022/02/12/%E9%9B%85%E6%80%9D/%E9%9B%85%E6%80%9D%E5%8F%A3%E8%AF%AD/Part3/"/>
    <url>/2022/02/12/%E9%9B%85%E6%80%9D/%E9%9B%85%E6%80%9D%E5%8F%A3%E8%AF%AD/Part3/</url>
    
    <content type="html"><![CDATA[<h1 id="Part-3"><a href="#Part-3" class="headerlink" title="Part 3"></a>Part 3</h1><h2 id="设问角度"><a href="#设问角度" class="headerlink" title="设问角度"></a>设问角度</h2><p>Part 3的问题基于Part 2的话题和关键词提问，通常会和社会和公共相关，是值得讨论的问题。Part 3的回答会决定口语考试评分上限。每个问题的回答应当持续大概1分钟左右。  </p><p>提问的角度有：  </p><ul><li>What - 要求列举信息 “what kinds of jobs can easily get money in China?”   </li><li>Why - 询问原因 “why do some people have strong desire to be famous?”   </li><li>Opinion - 询问观点/比较  “Do you think it is good to be famous?”/“A or B, what is more better?”<br>不建议只说一个观点  </li><li>Evaluation/ Pros &amp; Cons - 询问优点和缺点 “what are the pros and cons of online shopping?”   </li><li>Difference - 询问差异，选择一个特定的角度询问某个话题的差别”how is the shopping habit different between young people and old people”   </li></ul><p>拓展回答的方法往往是寻找极端的例子，并阐述。通常思路越简单清晰越好。  </p><h2 id="回答"><a href="#回答" class="headerlink" title="回答"></a>回答</h2><h3 id="回答结构"><a href="#回答结构" class="headerlink" title="回答结构"></a>回答结构</h3><ul><li>使用口头表达开头  <ul><li>It is hard to do the judgment on this question because I’m a college student who is lack of experience, but I could say there could be numberous reasons for that…   </li><li>It depends on how you look at this question, in some occassions…, on the other hand…     </li></ul></li></ul><h3 id="应对要点"><a href="#应对要点" class="headerlink" title="应对要点"></a>应对要点</h3><ul><li>使用一些口头表达以拖延时间进行思考</li><li>使用批判性的思维以拓展话题:至少从两个角度陈述，比如递进连接词（the first thing I could think about is…, in addiation）和对比连接词（On the other hand）  </li><li>组织语言：使用委婉和不确定的表达以展示客观性（e.g. more likely to do/ tend to do/ be prone to）  </li><li>尽量举例和列数字<ul><li>for instance/example</li><li>like</li><li>take for example</li><li>say</li><li>according to </li><li>stastically speaking</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>雅思笔记</category>
      
      <category>雅思口语</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Part B：观点描述题</title>
    <link href="/2022/02/12/%E9%9B%85%E6%80%9D/%E9%9B%85%E6%80%9D%E5%86%99%E4%BD%9C/%E9%9B%85%E6%80%9D%E5%A4%A7%E4%BD%9C%E6%96%87/"/>
    <url>/2022/02/12/%E9%9B%85%E6%80%9D/%E9%9B%85%E6%80%9D%E5%86%99%E4%BD%9C/%E9%9B%85%E6%80%9D%E5%A4%A7%E4%BD%9C%E6%96%87/</url>
    
    <content type="html"><![CDATA[<h1 id="Part-B：观点描述题"><a href="#Part-B：观点描述题" class="headerlink" title="Part B：观点描述题"></a>Part B：观点描述题</h1><h2 id="审题"><a href="#审题" class="headerlink" title="审题"></a>审题</h2><h3 id="题目类型"><a href="#题目类型" class="headerlink" title="题目类型"></a>题目类型</h3><ol><li><p>立场型(Argument)<br>A. 是否同意?选哪边？（尽量不中立）<br>Do you agree or disagree?/Which would be better?<br>B.  有多大程度同意（可选中立）<br>⋆To what extent  do you agree or disagree?  </p><ul><li>I totally agree/disagree with…</li><li>It can be desicribed as a double-edge sword.<br>可以选一边作答。  </li></ul></li><li><p>分析利弊型(Evalulation)<br>Do the <strong>advantages</strong> of this <strong>outweigh</strong> the disadvantages?<br>优缺点两方面构思，两边都要提到。<br>利大于弊：先说好处，最后让步说弊（一定要提弊端），最好不要说两面同等占比  </p><ul><li>I think the advantage of this outweigh the disadvantage</li></ul></li></ol><div class="note note-warning">            <p>只是如果只是单纯询问优缺点是什么，则只需要主观列举，不要加入自己的看法。<br>What are the advantages and disadvantages?   </p>          </div><ol><li><p>双边讨论型(Discussion)<br>⋆<strong>Disscus</strong> both views and give your own view.<br>要讨论两边（比如要独立讨论），再给出自己的立场，或者两边都支持/不支持   </p></li><li><p>综合分析型(Report，低频)<br>What are the <strong>reasons</strong> and give your measures to reduce it?<br>To discuss the Causes / Problems / <strong>Solutions</strong>.<br>从原因分析，结合实际的生活作答，纯客观说明，怎么提问怎么回答<br>其他类型的题目，根据题意作答  </p></li></ol><h3 id="话题"><a href="#话题" class="headerlink" title="话题"></a>话题</h3><p>常见的话题包括：<br>教育、科技、环境、政府决策、社会发展、犯罪、文化、媒体  </p><h3 id="话题关键词"><a href="#话题关键词" class="headerlink" title="话题关键词"></a>话题关键词</h3><p>话题关键词展示了题干中的观点、争议点和观点的描述对象。<br>应当注意：观点的主谓（观点对象）、修饰成分（确定描述对象）、逻辑关系（比较对象）。<br><strong>如果题干中的观点含有并列结构，应当分段分别论证。</strong><br>例如： Some people think <u>this has negative effects</u> and <u>should be banned</u>.  </p><h4 id="观点主谓"><a href="#观点主谓" class="headerlink" title="观点主谓"></a>观点主谓</h4><p>观点中的主语陈述了对象。<br>观点中的谓语动词是观点的重点，应该特别注意区分。<br>例如： “Students <u>should spend a period of time</u> to study in different country to learn the different cultures.”中重点应当是出国而不是学习其他文化。“Government <u>should make people responsible</u> for environmental protection”中观点的重点是在政府强制。    </p><h4 id="修饰成分"><a href="#修饰成分" class="headerlink" title="修饰成分"></a>修饰成分</h4><p>观点中的修饰成分通常表示目的，限定了讨论的方向，但并非是讨论的重点。<br>例如：“<u>In modern society</u>, it is of more disadvantage to become elderly.”中所有的优点和缺点应当围绕现代社会发展展开。  </p><h4 id="逻辑关系"><a href="#逻辑关系" class="headerlink" title="逻辑关系"></a>逻辑关系</h4><ul><li>极端词<br>观点中的逻辑关系包括形容词最高级(best/most)/极端的形容词和副词(all/only)/含有极端意义的动词(ban/stop/forbid)。<br>例如：“the best way to solve this problem is to limit the cars on road.”<br>通常题目观点出现极端词时，比较容易反驳题目中的观点。此时可以采取让步反驳的方式，先认同对方的合理性，再进行反驳，体现出辩证。  </li><li>取代关系<br>在出现取代关系时（比如”the museums should be cancled because people can explore exhibitors on the Internet.”），证明取代的重点应当放在证明二者的同一性和重合部分，证明不能被取代的重点放在独一性。  </li><li>因果关系<br>观点中因果关系的作用是限定描述的内容，在写作时应当紧扣原因论述。  </li></ul><h3 id="审题步骤"><a href="#审题步骤" class="headerlink" title="审题步骤"></a>审题步骤</h3><ul><li>先看题干最下方的题目类型，写作任务  </li><li>根据一些描述观点性的词语（claim/say/consider）找到题干中的观点  </li><li>回到题干前找话题</li><li>看题干给出的背景</li></ul><h2 id="构思"><a href="#构思" class="headerlink" title="构思"></a>构思</h2><h3 id="确定立场"><a href="#确定立场" class="headerlink" title="确定立场"></a>确定立场</h3><p>先构思一些正反理由，根据理由的数量选择立场。   </p><h3 id="构建分论点"><a href="#构建分论点" class="headerlink" title="构建分论点"></a>构建分论点</h3><p>如果题干中有概括性的词语，应当首先对其细化。  </p><h4 id="维度法"><a href="#维度法" class="headerlink" title="维度法"></a>维度法</h4><p>分论点思路可以从三个维度考虑：  </p><ul><li>长视短视：从长远的角度思考  </li><li>外在内在：表面上和实际上  </li><li>个体整体：对个人和对整个集体  </li></ul><h4 id="主题法"><a href="#主题法" class="headerlink" title="主题法"></a>主题法</h4><p>从一些固定的视角去考虑优势和劣势，进行构思。这些话题包括：  </p><ul><li>钱/经济/就业<br>例如:”In the future, robots will replace most of the manual labour?”<ul><li>pros: <ul><li>lower cost</li></ul></li><li>cons: <ul><li>a large expanditure of mantenace and manufacture</li><li>unemployment</li></ul></li></ul></li><li>时间和效率<ul><li>pros: <ul><li>enhance the efficiency and more productivity</li><li>higher precision and accurancy</li></ul></li><li>cons:  <ul><li>might break the control.</li></ul></li></ul></li><li>空间/安全<br>例如：”some people prefer ‘horizontal city’, where there are few tall buildings, while others enjoy ‘vertical city’ with many tall buildings”  <ul><li>pros(vertical city):  <ul><li>provide higher land utility</li><li>higher population density</li></ul></li><li>cons(vertical city):  <ul><li>safty issue</li></ul></li></ul></li><li><p>心理状态/身体健康<br>* 在围绕心理状态来陈述的分论点时，尽量详细的描述感受，使得分论点丰满。<br>* 身体健康难以写具体，通常不作为单独的分论点。  </p></li><li><p>教育<br>相关语料：  </p><ul><li>textbook of history teaching  </li><li>lay a foundation for future career  </li></ul></li><li><p>文化<br>相关语料：  </p><ul><li>extinction of cultrual identity</li><li>cultrual conflict</li><li>ideology 意识形态</li></ul></li><li><p>环境<br>相关语料：  </p><ul><li>waste emission 尾气排放</li><li>contamination n.污染</li><li>green house effects 温室效应</li><li>acid rain 酸雨</li><li>haze n. 雾霾</li><li>ozone layer hole 臭氧层空洞</li></ul></li><li><p>权益<br>*权益一般比较难写，通常写生存权和隐私权即可。<br>相关语料：  </p><ul><li>deprive the living rights</li><li>invade/violet the private privacy</li></ul></li></ul><h3 id="确定结构"><a href="#确定结构" class="headerlink" title="确定结构"></a>确定结构</h3><p>根据立场来确定结构，如果观点不是绝对的(比如：Mostly/Partially)，可以首先写让步段，部分认同，再反驳让步的观点。  </p><h3 id="构思范例"><a href="#构思范例" class="headerlink" title="构思范例"></a>构思范例</h3><p>例： Some people think the media should stop reporting on details of crime. To what extent do you agree or disagress？  </p><ol><li>对题干中的概述词进行细化  </li></ol><ul><li>details<ul><li>identification of victim/motivation/criminal</li><li>location/time/modus operandi(M.O)</li><li>scenes</li></ul></li></ul><ol><li>对细化后每一个项目进行讨论。  </li></ol><ul><li>scenes  <ul><li>The report of cruel scenes may traumatise audiences even causing massive social panic.（心理健康）  </li></ul></li><li>identification of victim and criminal  <ul><li>Covering the identification of victims and crimininals may violet the privacy leading to the further damage to the victims family and in most cases are misleading.  </li></ul></li><li>location/time/modus operandi(M.O)<ul><li>The report of modus operandi in detail should be bannd to prevent from the copy-cats who may imitate the crimes threteaning to the public security. Meanwhile, it is harmful for teens without the ability of distingushing right from wrong to read the report of modus operandi.  </li><li>There is a importantce of reporting the locations and time of crimes to force the government to invest more on security configurations and reinforce the public awareness of crimes so as to protect themselves.</li></ul></li></ul><p>例：Should children begin learning a foreign language as soon as they start school?  </p><ul><li><p>分析<br> Should:  </p><ol><li>it’s widely admitted that school-beginning is the golden age for language learning because the language-learning part in brain is the most active during this time.</li><li>Young children are not occupied with too much things during this period.</li><li>The culture can also be brought while leanring ,which helps them to explore the word.</li><li>They will have a good start for the future study.</li></ol></li><li><p>例文<br>  As the improvement of the globalization, coorperation and communication across the sea are more important than any stage of the history. For every qualified citizen, not only is mastering a foreign language to meet requirements but also viewed as an essential competence. Nowadays, people increasingly attach great importance to the education on foreign language , a growing number of primary schools are now teaching foreign languages in the first semester. From where I stand, it’s a beneficial practice without doubt.</p><p>  With the higher degree of globalization, transnational cooperation and communication have become<br>  more crucial than ever. For each qualified modern citizen, mastering a foreign language is morc than a<br>  necessity, but rather a requisite ability Nowadays, intensified emphasis has been laid upon foreign<br>  language education. An increasing number of primary schools begin to teach a foreign language.<br>In the very first semester. In my opinion, this is undoubtedly a beneficial practice. </p></li></ul><h2 id="开头段"><a href="#开头段" class="headerlink" title="开头段"></a>开头段</h2><h3 id="开头段结构"><a href="#开头段结构" class="headerlink" title="开头段结构"></a>开头段结构</h3><p>背景句（事实引入）+改写题干（不是直接抄写题干）+个人立场  </p><h3 id="导入部分（背景句）"><a href="#导入部分（背景句）" class="headerlink" title="导入部分（背景句）"></a>导入部分（背景句）</h3><p>在写作时背景导入如果没有想出来可以忽略。<br>导入部分要有逻辑衔接。<br>在事实引入部分和“引发了热烈的讨论”两句之间的逻辑要紧密。<br>逻辑必须要完整。  </p><ul><li><p>功能(模板)句法<br>常用模板句：<br>Nowadays, … is  playing an role in … when…<br>Thanks to….,… is becoming increasingly  important.<br>Recent years have witnessed that…<br>The way we consider… is heavily influenced by….<br>With the development of…, is becoming increasingly…  </p><p> e.g.：Today, we live is heavily influenced by the modern technology.Recent years have witnessed the development of modern technology.</p></li><li><p>论据提前法<br>在正文中不需要详细拓展的论据，作为开头的引入。<br>e.g.: With the increasing air pollution, the use of transportation tools, such as airplanes, is definitely responsible for it. （环境污染为文章其中的一个论点）Therefore, some people think the use of aircrafts is not practical and causes many problems thus should be reduced. In my opinion, it’s necessary to do so.  </p><p> We can often people living nearby the airport always complain about the noise made by the airplane. Therefore…  </p><p> It’s widely agreed that not only the flight ticket but also the trip to back and from the airport are expensive. Therefore..  </p></li><li><p>场景表述法<br>用相关的具体场景引出主题。<br>e.g.：<br>  Have you ever been late for the date with friends because of the poor traffic? Have you ever felt irritable on the way to work during the rush hour on Monday morning?(用事实说明) Actually these situations are happening everyday,driving every city dweller crazy.</p><p>  When the new lives coming into the world, what makes the unexperienced parents headache most is how to take care of babies. To settle the problem, the parenting course gains increasingly popularity nowadays. However, it also bring up to many issues. For instance, the classes actually are not adapt to all the babies. So some people think the parenting course should be reduced. And I’m deeply agree that.  </p></li></ul><h3 id="题干改写"><a href="#题干改写" class="headerlink" title="题干改写"></a>题干改写</h3><p>改写方法：<br>替换同义词 改写语态 名词性从句互换（主谓宾&lt;-&gt;主系表）<br>注意不要逐字逐句的改写，一种简单的改写方法是将其翻译为中文后改写为英语。<br>语料：  </p><ul><li>The relative improtance of… and …/whether…or… is a frequenct discussed topic of discussion when…</li><li>The focus of this essay is to illustrate the causes and explore some relevant and feasible measures to combat this situation.</li></ul><p>e.g.：<br>例题：Some people claim that the use of  tobacco has caused severe social problems thus should be banned.To what extent do you agree or disagree?<br>改写: A point held by many people is that serious social problems have been triggered by smoking and it should be forbidden.  </p><h4 id="表达观点"><a href="#表达观点" class="headerlink" title="表达观点"></a>表达观点</h4><p>引入观点的句子：  </p><ul><li>In my opinion</li><li>as far as I am concerned</li><li>from my point of view</li><li>from my own perspective </li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">同意</th><th style="text-align:center">反对</th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th></tr></thead><tbody><tr><td style="text-align:center">advocate <br> support <br> embrace <br> endorse <br> be of the same mind with <br> do not reserve any approval of <br> see more reasonsi n the latter</td><td style="text-align:center">oppose <br> be fail to agree with <br> in dispute with <br> mey perspective contradicts <br> the opinion can not deat much analysis <br> frown on/upon <br> cannot hold water <br> be acceptable but not recommendable <br> cause a few raised eyebrows</td><td style="text-align:center">advantages <br> benefits <br> upsides <br> strengths <br> merits</td><td style="text-align:center">disadvantages <br> drawbacks <br> downsides <br> weakness <br> demerits</td></tr></tbody></table></div><h2 id="中间段展开"><a href="#中间段展开" class="headerlink" title="中间段展开"></a>中间段展开</h2><p>中间段主要是提出分论点并论证各分论点。论证需要消除理由和论点的逻辑断层，解释为什么可以支持论点，表明理由是合理的。观点和理由是因果关系，观点和理由之间需要用论据做逻辑衔接。<br>中间段的作用是把理由分层叙述，让读者充分理解论点是合理的过程。  </p><h3 id="首句"><a href="#首句" class="headerlink" title="首句"></a>首句</h3><p>每一段的首句应当提出分论点，其后的句子进行进一步的论述和证明。  </p><h3 id="论证方法"><a href="#论证方法" class="headerlink" title="论证方法"></a>论证方法</h3><h4 id="道理论证"><a href="#道理论证" class="headerlink" title="道理论证"></a>道理论证</h4><p>进一步解释中心句。  </p><ul><li><p>语料：  </p><ul><li>To be more precise</li><li>In other words  </li><li>That is…  </li></ul></li><li><p>进一步解释可以从:what/who/when/where/how/why这几个方面思考。<br>例如：<br>题干：Governments have spent too much money on scientific research. To what extent do you agree or disagree?<br>分论点：Outer space exploration, for example, have consumed a large government expenditure.（中心句）<br>To be more precise, rich counries （WHO） put considerable investments on developmenting technology and manufacturing equipment for astronomy (HOW) to search possible resources (WHY) in the space only catering for domestic demands of their countries.</p></li><li>从因果关系进行进一步解释<br>原因一边表示前提，而结果一边会说明好处或者坏处。<br>例如：<br>In primery education, the law education should be compulsory. （中心句） As the primery students are the group who are innocent and do not have the ability to<br>distingush right from wrong, they are supposed to learn the knowledge of law to rose their awareness of self-defence.<br>The govenment should raise the public awareness of environmental preservation, thereby promoting sustainable development and creating a more livable environment.<br>表示原因和结果的连接词：  </li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">原因</th><th style="text-align:center">结果</th></tr></thead><tbody><tr><td style="text-align:center">because <br> as <br> for <br> since <br> ascribed/assoicated with <br> due to/owing to</td><td style="text-align:center">as a consequence/result <br> therefore <br> thus <br> hence <br> thereby doing</td></tr></tbody></table></div><h4 id="举例论证"><a href="#举例论证" class="headerlink" title="举例论证"></a>举例论证</h4><p>举出例子解释中心句。需要注意，例子应该具有代表性，尽量不要选择人物的例子。<br>常见的举例方法是以小见大：从大类中选择一个具有代表性的事物说明。<br>语料：  </p><ul><li>for instance/example</li><li>to illustrate</li><li>take…for instance</li><li>a case in point is that…</li><li>more specifically</li><li>especially</li><li>the upsides/downsides/advantages/benefits/disadvantages of…</li><li>a typical example can be found in…</li><li>such as（前面的词是上义词，后面的例举是下义词）</li></ul><p>例如：<br>The Asian countries are getting westernized at a staggering rate.（中心句） <u>Take China for example</u>, when youngsters go to the movies, it is common for them to choose Hollywood blockbusters over domestic films.<br>To begin with, it is really helpful for university students to be taught some job-related skills that have already become a major focus of higher education.（中心句） <u>A typical example can be found in</u> the effort to develop their interpersonal skills now required by a growing number of companies as one of the most essential qualities of any job candidate.  </p><div class="note note-info">            <p>如上面的例句，写作时可以尽量使用动词非谓语形式作为后置定语对名词进行修饰，以扩展句子。<br>扩展句子的三种方式：  </p><ul><li>特定句式：例如强调句</li><li>后置定语从句： 例如 which 引导的状语从句  </li><li>动词非谓语形式作为后置定语  </li></ul>          </div><h4 id="对比论证"><a href="#对比论证" class="headerlink" title="对比论证"></a>对比论证</h4><p>通过对比反衬事物的优点，而对照突出差别。<br>对比论证时需要注意避免词汇重复。<br>语料：  </p><ul><li>likewise</li><li>on the other hand</li><li>conversly</li><li>in constrast/by constrast：两个对象，前后形成相反的情形</li><li>on the contrary：一个对象，否定前者陈述，并且提出更进一步的特性</li><li>while</li><li>wherearas</li><li>similarly</li></ul><div class="note note-warning">            <p>特别注意in constrast/by constrast和on the contrary的区别。</p><ul><li>in constrast/by constrast：两个对象，前后形成相反的情形</li><li>on the contrary：一个对象，否定前者陈述，并且提出更进一步的特性</li></ul><p>e.g.: Watching Television cannot improve children’s study efficiency. on the contrary, the advertisements and programms could enable kids to be distracted/make distractions.  </p>          </div><h5 id="避免重复的方法"><a href="#避免重复的方法" class="headerlink" title="避免重复的方法"></a>避免重复的方法</h5><ul><li>利用上下义解释进行替换<br>例如：<br>Generally speaking, buying over a dozen household equipment intended for daily use may be beneficial at home from cooking to entertainment. Microwave oven, for instance, allows housewives to cook rapidly <u>with the turn of a dial（convenient 的下义）</u>, and this convenience provides more options in daily life than in the past. Likewise, rice cooker can <u> simplifty the cooking process</u> by <u>reducing the number of steps</u> between people and their meal at having appliances, the more other work they are capable of doing, including just watching television in the comfort of home after a heavy day from work.  </li><li>利用同义词、近义词替换<br>【find it difficult, struggle at, achieve the comparable levels】<br>例如：<br>题干： Governments should accept equal number of males and females in each major. To what extent do you agree or disagree?<br>a. The acceptance of university is supposed to focus on students’ accdemic performance, or scores, which is considered as the layout of personal abilities instead of gender differences (中心句). For instance, males may struggle at studying the majors such as education or administration rather than engineering. Similarly, it is not suprised that female students may find it is hard to achieve the comparable levels of comprehension and analysis when attending courses like calculus or signals and systems due to the gaps of patterns of thinking. Thus the perspective of persuiting the same acdemic achievements omitting the gender differences is biased and nature differences brought by gender should be respected properly.<br>b. The acceptance/admission/enrollment of males and females in each major should depend on their overall abilities and academic performance, <em>instead of unrealistic gender quota</em>. <em>In most cases</em>, it is rare to see male students choose liberal art or education since they are often in lack of verbal skills or patience to become qualified teachers. <em>Similarly</em>, females are usually not good at engineering or physics due to their inborn/inherent features, <em>thus</em> having difficulty in reaching a comparable level as males. Therefore, it is reasonable for universities to respect their separate academic pursuit according to their natural talent.  </li><li>替换词性  </li><li>使用肯定词替换否定词<br>e.g. gap year ↔ entrance university immediately  </li></ul><h3 id="假设论证"><a href="#假设论证" class="headerlink" title="假设论证"></a>假设论证</h3><p>语料：  </p><ul><li>if</li><li>suppose/assume</li><li>providing that/on condition that</li><li>when/once</li></ul><p>需要注意使用虚拟语气时，注意时态降级（be-&gt;was/were, will-&gt;would）  </p><p>例文：<br>Then, since the transportation system is the lifeline of a country’s economic activities, its paralysis would lead to the disintegration of the economy, either industry, farming or day life. Supposing that all the means of transportation were halted for lack of oil, factories with insufficient raw materials would have to close, workers would be out of work, and ripe farm crops would have to stay in the fields at the mercy of rain and storms. People would try to store food and the price of all commodities would go up.</p><h4 id="让步"><a href="#让步" class="headerlink" title="让步"></a>让步</h4><p>姑且承认相反观点的合理性，再加以反驳。<br>如果让步和反驳写在一段，那么让步和反驳的分论点需要相同。<br>如果让步单独成段，需要有明显的连接词以展示文章观点。<br>语料：  </p><ul><li>although/though/in spite of the fact that…  </li><li>as is granted/admittedly…</li><li>opponents would argue that…  </li></ul><p>例文：<br><u>As is granted</u>, saving money offers people a sense of security in case of emergency. <u>However</u>, people tend to believe that wise investment can get more benefits.  </p><div class="note note-warning">            <p>特别地，在雅思写作考试中不建议使用引用论证。  </p>          </div><h2 id="结尾段"><a href="#结尾段" class="headerlink" title="结尾段"></a>结尾段</h2><p>结尾段需要陈述所有的分论点，并总结全文。如果篇幅不够，还需要延伸拓展。  </p><ul><li>不要重复前面的文字  </li><li>不要出现新观点  </li></ul><h3 id="结尾段替换"><a href="#结尾段替换" class="headerlink" title="结尾段替换"></a>结尾段替换</h3><ul><li>使用倾向性动词表示观点<br>正面：<br>prove/encourage/support/enable/assist/help/drive<br>负面：<br>lead to/prevent/hinder/threaten/pose a threat to  </li></ul><p>例文：<br>In conclusion, my view is that taking a year off allows young people to have <u>a broader view of life（分论点1）</u> and <u>better perosonal resources to draw on（分论点2）</u>.  </p><h3 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h3><p>进一步说明受益对象的好处，或者受害者的坏处。<br>例文：<br>Students with these practical experiences are usually the most effective and motivated ones.  </p><h2 id="写作要点"><a href="#写作要点" class="headerlink" title="写作要点"></a>写作要点</h2><h3 id="正式用语"><a href="#正式用语" class="headerlink" title="正式用语"></a>正式用语</h3><p>题目：<br>Some people have argued that we should not make heroic efforts to preserve the natural habitats of endangered plants and animals when doing so would conflict with human interests. To what extent do you agree or disagree?<br>例文：<br>If <em>you look at it that way</em>,  true that humans and animals have conflicting interests. People have always exploited animals for food and clothing, and farmers have brought <em>bigger and bigger</em> areas of land under cultivation. <em>But should we keep on doing this?</em><br>In regions of the world where the population is growing and there <em>aren’t enough</em> resources, the conflict between humans and animals is really <em>bad</em>. If you go to Africa, for example, <em>you can see large</em> natural reserves alongside, really poor human settlements.<em>I love the idea of elephants and lions live in the wild</em>, but often <em>it’s</em> the poor farmer living nearby who’s got to pay the cost in terms of land and<br>lost earnings.  </p><p>学术写作中需要注意的几个写作要点：  </p><ul><li>不要使用not/is/are的缩写形式</li><li>回避第一、第二、第三人称<ul><li>使用被动语态</li><li>使用 the public\teenagers等等具体的名词指代</li></ul></li><li>规避口语化用词：比如really/biger and biger/love等等<ul><li>really → extremely/seriously等等具体的副词</li></ul></li><li>避免问句和感叹句、不恰当的标点<ul><li>问句可以改为”whether”作为主语的句子</li></ul></li><li>避免使用习语</li></ul><h3 id="规避用语"><a href="#规避用语" class="headerlink" title="规避用语"></a>规避用语</h3><ol><li>with the development of→because of/做主语</li><li>In today’s society/in contemporary society/nowadays…→直接写现象、信息</li><li>it is a issue people heatedly debate that…/highly controversial issue that ….</li><li>broaden one’s horizon(建议：a broader view of life/become open-minded)</li><li>as is known to us all, …(建议：in most cases)</li><li>Every coin has two sides./As the saying goes…</li><li>last but not (the) least(建议：besides/additionally)</li><li>in a nutshell(建议：in conclusion、To conclusion)</li><li>nowadays 前置并且后面没有今昔对比</li></ol><h2 id="范文学习方法"><a href="#范文学习方法" class="headerlink" title="范文学习方法"></a>范文学习方法</h2><p>关注范文的三个点：  </p><ul><li>行文结构和论证方法</li><li>用词：连接词和生僻表达 </li></ul><p>然后模仿范文进行仿写。  </p><p>例文：<br>However, reaching the conclusion that other functions such as giving access to knowledge for its own sake, are no longer important is biased.(中心句) For hundreds of years, <u> especially in the west </u> , the undergraduate education is, indeed a liberal education, which means the undergraduates learn a wide range of curriculums <u>such as</u> psychology, economics, politics that have no direct relations to jobs. <u>The upsides of this are that </u> it firstly enables students to become open-minded and help them lay a solid theoritical foundation, then they will be able to choose the most appropriate field based on their own interests for further studies.  </p><p>文章结构：  </p><ul><li>the conculusion that knowledge for its own sake is not important is biased:<ul><li>examples<ul><li>especially in west</li><li>liberal education</li><li>curriculum: psychology/ecnomies/politics</li></ul></li><li>benefitis:<ul><li>open-minded</li><li>lay the fundamentals</li><li>choose the territories</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>雅思笔记</category>
      
      <category>雅思写作</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Part 2</title>
    <link href="/2022/02/10/%E9%9B%85%E6%80%9D/%E9%9B%85%E6%80%9D%E5%8F%A3%E8%AF%AD/Part2/"/>
    <url>/2022/02/10/%E9%9B%85%E6%80%9D/%E9%9B%85%E6%80%9D%E5%8F%A3%E8%AF%AD/Part2/</url>
    
    <content type="html"><![CDATA[<h1 id="Part-2"><a href="#Part-2" class="headerlink" title="Part 2"></a>Part 2</h1><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><ul><li>Part 2的内容通常都是要求描述一段个人的经历  </li><li>每个话题回答两分钟左右  </li><li>Part 2 需要展示语法的多样性，尽量做正确的同义替换  </li></ul><h2 id="回答技巧"><a href="#回答技巧" class="headerlink" title="回答技巧"></a>回答技巧</h2><p>Part2的问题可以分为两类：<br>描述人或者描述物<br>Part 2中可以将题目作为聊天的开始，后面可以改变话题的方向。因此，两类问题都可以转变成对某个经历的描述。  </p><ul><li>扣题<br>可以使用“It reminds me of my experience of…which… during…”对题目进行同义替换，并扣题。   </li><li>描述经历<br>描述经历可以从时间、原因、人物、地点展开叙述。<br>描述过程中尽量使用连接词，连接词可以使对话更加流利、体现交流感。<br>描述过程的时候可以并列列举。  </li></ul><div class="note note-info">            <p>连接词包括：连接词、口头词、交互词<br>口头词：basically,I mean…, Okay?, you know, right?, honestly, well, actually<br>结构连接词： because, so, therefore, as, plus, apart from that, further to that, besides, on top of that<br>交互词： 自问自答(why I find it…)、强调感受(It is amazing that…/What really made me happy is that…)<br>假设： Picture/imagine/suppose/assume that…  </p>          </div><ul><li>拓展<br>可以从“From that moment on…”描述事件之后的事情。  </li></ul>]]></content>
    
    
    <categories>
      
      <category>雅思笔记</category>
      
      <category>雅思口语</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Part 1</title>
    <link href="/2022/02/10/%E9%9B%85%E6%80%9D/%E9%9B%85%E6%80%9D%E5%8F%A3%E8%AF%AD/Part1/"/>
    <url>/2022/02/10/%E9%9B%85%E6%80%9D/%E9%9B%85%E6%80%9D%E5%8F%A3%E8%AF%AD/Part1/</url>
    
    <content type="html"><![CDATA[<h1 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h1><h2 id="Part1-必考话题"><a href="#Part1-必考话题" class="headerlink" title="Part1 必考话题"></a>Part1 必考话题</h2><h3 id="study"><a href="#study" class="headerlink" title="study"></a>study</h3><ul><li>what subjects are you studying?<br>I’m majored in<strong>, which means I’ve got a lot to do with</strong>, for instance: subtopic1,2,3,4… and etc.  </li><li>why did you choose those subjects?  </li><li>is it very interesting?</li><li>do you prefer to study in the mornings or in the afternoon?</li><li>what technology do you use when you study?</li><li>are you looking forward to working?</li></ul><h4 id="积累"><a href="#积累" class="headerlink" title="积累"></a>积累</h4><ul><li>fill my preferencescoordinated to this major 填志愿</li><li>dicpline 学科</li><li>get left behind 掉队</li><li>keep up with 跟上</li><li>burgeoning world 迅速发展的社会</li><li>practical experence 实习</li><li>it dosen’t appeal to me that much. 对我不感兴趣</li><li>offence 违法行为</li><li>burn the midnight oil 熬夜</li><li>procrastinator 拖延症患者</li><li>vicious cycle 恶性循环</li><li>sync 同步</li><li>further education 深造</li><li>step into the workforce 步入社会</li><li>consolidate 巩固</li><li>survive, strive to thrive 努力奋斗</li><li>put bread on the table/make ends meet 维持生计</li><li>breek even 收支平衡</li><li>rat race 内卷</li><li>superficial 肤浅的</li><li>dive deeper into it 深入了解</li><li>employable and competitive </li><li>in a rut 千篇一律</li><li>promotion 升职</li><li>decent 体面的</li></ul><h3 id="hometown"><a href="#hometown" class="headerlink" title="hometown"></a>hometown</h3><ul><li>please describe your hometown?<br>location: south western<br>population: with the population over 20 million residents<br>climate:<br>cusine/culture: </li><li>where is your hometown?</li><li>is it a big city or small city? </li><li>what do you like most about your city?</li><li>is there anything you dislike about your city?  </li></ul><h4 id="词汇"><a href="#词汇" class="headerlink" title="词汇"></a>词汇</h4><ul><li>metropolis/motropolitan 大都市</li><li>born and raise 土生土长</li><li>subtropical monsoon climate 亚热带季风气候</li><li>humid 潮湿的 </li><li>overcast 阴天  </li><li>comprehensive 全面的</li><li>dogs in the sichuan bark to the sun because it’s rare to be seen.  </li><li>swltering 闷热</li><li>chic 时髦</li><li>influencers 网红</li><li>sipping tea 喝茶</li><li>perfectly blends traditional lifestyle with/into modern culture. 传统生活方式和现代文化的融合</li><li>there are plenty of things chengdu has to offer.</li><li>mouthwatering 垂涎的</li><li>laid back 安逸  </li><li>slow paced 慢节奏</li><li>numbing 麻</li><li>umami 鲜</li><li>fragrant 香</li><li>appetising 有食欲的</li><li>skewers 烧烤</li><li>kebabs 肉串</li><li>known for the land of abundance 天府之国</li></ul><h3 id="accomadation"><a href="#accomadation" class="headerlink" title="accomadation"></a>accomadation</h3><ul><li>please discribe your room you live in?<ul><li>大小： spacious or tiny</li><li>人数： shared with 3 other people</li><li>时间</li><li>人员</li><li>类型： 4 loft beds/double-deck beds</li></ul></li><li>please discribe your accommodation you live in?</li><li>who do you live with?</li><li>which room deose your family spend most of time in?</li><li>what do you usually do in your room?</li><li>what kinds of accomadation would you like to living in future?</li></ul><h4 id="词汇-1"><a href="#词汇-1" class="headerlink" title="词汇"></a>词汇</h4><ul><li>the accomodation is allocated/ arrange by the school.</li><li>balcony 阳台</li><li>suite 套房</li><li>aircon 空</li><li>wardrobe 衣柜</li><li>linens 床单、被套、枕套</li><li>shelf 书架</li><li>accessories 周边</li><li>floating shelfs 隔板</li><li>curtain 窗帘</li><li>blind 遮光帘</li><li>insulation 隔音</li><li>messy 杂乱的</li><li>sophisticated 精致的</li><li>nordic 北欧的</li><li>simplisitic and minimalistic 极简</li><li>preserve 保护/保存</li><li>warm and inviting 温暖的</li><li>livedin furniture 老旧家具</li><li>warm wood tone 暖木色</li><li>plain colour 简洁的色调</li><li>accent colour 点缀色</li><li>touch 点缀</li><li>house 独栋屋</li><li>apartment 公寓楼</li><li>cuddle （像小孩一样抱着）</li><li>genre 种类</li><li>biography 传记</li><li>novel 小说</li><li>equipped with smart homekit 智能家居</li><li>futuristic 未来感</li></ul><h2 id="Part-1-随机话题"><a href="#Part-1-随机话题" class="headerlink" title="Part 1 随机话题"></a>Part 1 随机话题</h2><h3 id="记忆"><a href="#记忆" class="headerlink" title="记忆"></a>记忆</h3><ul><li>why do some people have good memories?  </li><li>why do some people rely on cellphones to memorise things?<br>nature and nurture:<br>genetic reason<br>recite or memorise<br>raise my eyebrow<br>over exaggerated<br>someone have experienced the repetitive and systematic training which can enhanced.<br>handy, easy to carry around<br>unlimited storange<br>laziness drives the evolution of technology<br>organized 有计划的<br>schedule<br>spontaneous 随性的  </li></ul><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><p>延展话题的技巧：  </p><ul><li>并列的话题</li><li>举例</li><li>引用 “according to a research, as far as I know”</li><li>进一步解释</li><li>对比</li><li>在问到不感兴趣的话题时，可以用I would like to rather than 将话题引走</li></ul>]]></content>
    
    
    <categories>
      
      <category>雅思笔记</category>
      
      <category>雅思口语</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>阅读方法</title>
    <link href="/2022/02/09/%E9%9B%85%E6%80%9D/%E9%9B%85%E6%80%9D%E9%98%85%E8%AF%BB/%E9%98%85%E8%AF%BB%E6%96%B9%E6%B3%95/"/>
    <url>/2022/02/09/%E9%9B%85%E6%80%9D/%E9%9B%85%E6%80%9D%E9%98%85%E8%AF%BB/%E9%98%85%E8%AF%BB%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="阅读方法"><a href="#阅读方法" class="headerlink" title="阅读方法"></a>阅读方法</h1><h2 id="结构阅读法"><a href="#结构阅读法" class="headerlink" title="结构阅读法"></a>结构阅读法</h2><h3 id="方法步骤"><a href="#方法步骤" class="headerlink" title="方法步骤"></a>方法步骤</h3><h4 id="1-读标题和副标题，判断文体"><a href="#1-读标题和副标题，判断文体" class="headerlink" title="1. 读标题和副标题，判断文体"></a>1. 读标题和副标题，判断文体</h4><p>说明文和议论文：段意会出现在段首或者段末。<br>记叙文： 阅读时抓住时间线。  </p><h4 id="2-段落略读"><a href="#2-段落略读" class="headerlink" title="2. 段落略读"></a>2. 段落略读</h4><p>短段落：全部读完<br>长段落：读段落的前两句，抓住段落的情感倾向和低频词。<br>段落中复杂的句子提取主干。  </p><h4 id="3-细节定位"><a href="#3-细节定位" class="headerlink" title="3. 细节定位"></a>3. 细节定位</h4><ul><li>勾画题干定位词<br>题目中的定位词能够帮助在文章中找到对应的的段落，定位词包括：  <ul><li>专有词：人名、数字、时间和专有名词</li><li>低频词：在文章中出现频率低的词</li><li>限定词和抽象名词<br>此外题干中的介词也可以帮助定位：  </li></ul></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">时间</th><th style="text-align:center">空间关系</th></tr></thead><tbody><tr><td style="text-align:center">in</td><td style="text-align:center">时间段</td><td style="text-align:center">包含关系，大地点</td></tr><tr><td style="text-align:center">on</td><td style="text-align:center">具体日期</td><td style="text-align:center">表面接触</td></tr><tr><td style="text-align:center">at</td><td style="text-align:center">时间点</td><td style="text-align:center">小地点</td></tr></tbody></table></div><ul><li><p>扫读文本寻找定位词所在关键句<br>根据题目本身定位词寻找准确的段落句，并阅读该句的前后两句。<br>首段和尾段如果不长，需要读完。  </p></li><li><p>精读关键句<br>需要注意，关键句的前后两句也需要读完。如果不明白关键句的含义，如后面有例子，需要读完例子。  </p></li></ul><h2 id="平行阅读法"><a href="#平行阅读法" class="headerlink" title="平行阅读法"></a>平行阅读法</h2><p>对于有标题匹配的阅读题文字，通常采用平行阅读法。</p><ol><li>略读首段选择一个标题。  </li><li>看除了标题匹配的其他题目中关键词是否在这一段中出现，如果有，就直接做本段相关的所有题目。  </li></ol><h2 id="同义词替换"><a href="#同义词替换" class="headerlink" title="同义词替换"></a>同义词替换</h2><p>阅读中的非专有词定位词往往不会以原词出现，在文章中会有与之对应的同义词。<br>同义词替换类型包括:  </p><ul><li>同义词替换：比如amazing和suprizing</li><li>词性转换</li><li>上下义词替换<br>即将某些列举使用表示其类型的词语替代。  </li><li>逆否改写<br>以“双重否定表示肯定”将句子的逆否表述改写，常见于选择题和匹配题中。  </li></ul>]]></content>
    
    
    <categories>
      
      <category>雅思笔记</category>
      
      <category>雅思阅读</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>词汇积累</title>
    <link href="/2022/02/09/%E9%9B%85%E6%80%9D/%E8%AF%8D%E6%B1%87/"/>
    <url>/2022/02/09/%E9%9B%85%E6%80%9D/%E8%AF%8D%E6%B1%87/</url>
    
    <content type="html"><![CDATA[<h1 id="词汇积累"><a href="#词汇积累" class="headerlink" title="词汇积累"></a>词汇积累</h1><ul><li>husband v.节俭使用</li><li>speculate v. 投机倒把</li><li>healthwise adj. 健康的</li><li>intimidating adj. （由于压力大而感到）可怕的</li><li>dive into 了解</li><li>comprehensive adj. 综合性的</li><li>trump v. 胜过</li><li>dull and dry 枯燥乏味</li><li>authoritative adj. 权威性的</li><li>instrumental adj.（工具性的）起作用的  </li><li>sleek adj. 平整的</li><li>detrimental adj. 有害的</li><li>hone v. 打磨</li><li>edge n. 优势</li><li>key opinion influencor(KOI) n. 网红</li><li>go viral 走红</li><li>paparrazi n. 狗仔队</li><li>stands n. 路边摊  </li><li>mental labour 脑力劳动</li><li>manual labour 体力劳动</li><li>be attached/tied to 依恋</li><li>aesthetic adj. 美学的</li><li>artistic adj. 艺术的</li><li>be detrimental to 对…有害  </li><li>diabetes n. 支气管炎</li><li>contamination n.污染（pollution的同义替换）</li><li>trauma n. 创伤  </li><li>be informed about 了解</li><li>flawless adj. 完美的</li><li>dictate v. 支配/决定  </li><li>be susceptible to 对…敏感/容易受到…影响  </li><li>prone to 倾向于/特别容易做…  </li><li>ability of distingushing right from wrong 辨别是非的能力</li><li>for one’s own sake 为…本身/以…为目的</li><li>biased adj. 片面的、有偏见的</li><li>liberal adj. 自由主义的</li><li>liberal education 通识教育</li><li>a wide range of 各种</li><li>upsides/downsides 好处/坏处</li><li>be aquainted with… 对…熟悉</li><li>at the mercy of… 任凭…支配</li><li>paralysis n. 瘫痪</li><li>perosonal resources 人脉</li><li>Chronologically adv. 以时间顺序来看</li><li>double/triple/quadruple v. 变成两/三/四倍  </li><li>livestock n. 家畜</li><li>halt v. 停止</li><li>subtle adj. 微妙的/精巧的</li><li>deficiency n. 缺乏/缺陷</li><li>vulnerable adj. 脆弱的/易受影响的</li><li>plausible    adj. 貌似合理的/花言巧语的</li><li>mosaic n. 马赛克</li><li>scrutiny n. 仔细检查</li><li>realign v. 统治</li><li>dispute n. 争论</li><li>radical adj. 激进的</li></ul>]]></content>
    
    
    <categories>
      
      <category>雅思笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>匹配题</title>
    <link href="/2022/01/28/%E9%9B%85%E6%80%9D/%E9%9B%85%E6%80%9D%E9%98%85%E8%AF%BB/%E9%9B%85%E6%80%9D%E5%8C%B9%E9%85%8D%E9%A2%98/"/>
    <url>/2022/01/28/%E9%9B%85%E6%80%9D/%E9%9B%85%E6%80%9D%E9%98%85%E8%AF%BB/%E9%9B%85%E6%80%9D%E5%8C%B9%E9%85%8D%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="匹配题"><a href="#匹配题" class="headerlink" title="匹配题"></a>匹配题</h1><p>雅思阅读中匹配题占比很大，要求将对应的描述和目标进行匹配。<br>题目构成为：  </p><ul><li>题目说明</li><li>选项集合和题目集合</li></ul><h2 id="特征匹配"><a href="#特征匹配" class="headerlink" title="特征匹配"></a>特征匹配</h2><p>匹配题中题目中出现的定位词基本上不会被改写，通常为时间、人名、国家与事件、观点、事实的匹配。  </p><h3 id="重点句"><a href="#重点句" class="headerlink" title="重点句"></a>重点句</h3><ul><li>引号内的句子</li><li>表示声明/认为/支持等动词的句子</li></ul><h3 id="做题步骤"><a href="#做题步骤" class="headerlink" title="做题步骤"></a>做题步骤</h3><ul><li>找专有名词：一般直接以匹配的专有名词作为定位词，在文章中找到提到的位置，注意找全。    </li><li>勾画题干：在题干的描述中找到描述的定位词，这些词通常会被同义替换。  </li><li>读原文：只需要读有定位词的原文部分。  </li><li>配选项  </li></ul><h3 id="做题方法"><a href="#做题方法" class="headerlink" title="做题方法"></a>做题方法</h3><p>在文章中一个人名出现多次时，第二次出现时文章中不会给出全名或者使用人称代词。<br>做题时应当先做文章中提出观点少的人名再做观点多的人名的匹配。  </p><p>特征词首次出现的时是顺序的。<br>特殊词中间出现时，如果两个特征词都出现在同一个观点，大概率这个观点不会被考察。<br>可以优先做信息少的定位词部分。<br>特殊词有干扰信息。  </p><h4 id="复选"><a href="#复选" class="headerlink" title="复选"></a>复选</h4><p>题目中出现NB时，代表可能至少有一个选项可以重复选。<br>在实际做题中基本上有一个选项会被使用两次。  </p><h2 id="标题匹配"><a href="#标题匹配" class="headerlink" title="标题匹配"></a>标题匹配</h2><h3 id="题型特征"><a href="#题型特征" class="headerlink" title="题型特征"></a>题型特征</h3><p>纸笔考试中题目在文章之前。<br>通常选项为总结段意的短语，数量会大于段落的数量。<br>关键词一般会进行同义替换。  </p><div class="note note-warning">            <p>标题的选项需要对文章的段落有概括性。  </p>          </div><h3 id="做题流程"><a href="#做题流程" class="headerlink" title="做题流程"></a>做题流程</h3><h4 id="1-理解选项"><a href="#1-理解选项" class="headerlink" title="1. 理解选项"></a>1. 理解选项</h4><ul><li>找出关键词<br>注意关键词前的修饰、限定和以及关键名词单复数（比如：an explaination）</li><li>关注否定词  </li><li>理解情感倾向<br>抓住段落的情感倾向（比如:advantages/critism）  </li><li>预测段内容<br>根据表述预测段内可能会讲述哪些内容</li><li>区分相似选项<br>相似的选项通常有两种：描述对象相似和描述内容相似，要注意区分不同点  </li><li>关注程度词<br>警惕绝对性的表述   </li><li>关注逻辑词（and）<br>选项中（and）前后的内容都被描述才能作为标题</li></ul><h4 id="2-略读段落，抓段落大意"><a href="#2-略读段落，抓段落大意" class="headerlink" title="2. 略读段落，抓段落大意"></a>2. 略读段落，抓段落大意</h4><p>如果首段和尾段不长，精读首段和尾段。<br>阅读过程中可以省略修饰部分和插入语，直接提取每句话的主干。<br><strong>特别关注的句子</strong>  </p><ul><li>问句<br>通常是自问自答，问句之后通常紧跟中心句。  </li><li>副词开头的句子<br>副词表示作者的情感倾向，是出题的重点，副词开头的句子需要特别关注。  </li><li>转折表达<br>关注段落中出现的转折表达：  <ul><li>如果前三句有转折词，这几句为中心句。 </li><li>如果长段落中间或者末尾出现转折，需要仔细比对是否只是对比论证，没有改变话题方向。  </li></ul></li></ul><div class="note note-info">            <p>转折词：however/yet/on the other hand<br>让步转折：Inspite of/despite<br>事件转折：until（事件的发展在前后发生了转变）  </p>          </div><h3 id="重点结构和句型"><a href="#重点结构和句型" class="headerlink" title="重点结构和句型"></a>重点结构和句型</h3><h4 id="中心词"><a href="#中心词" class="headerlink" title="中心词"></a>中心词</h4><p>段落中出现的高频词，极有可能是在标题中不会被替换的词。  </p><h4 id="主旨句"><a href="#主旨句" class="headerlink" title="主旨句"></a>主旨句</h4><p>转折句，议论文的观点句常常是能够表达段意的主旨句。<br>通常是段落中最后一个观点句（believe/claim/argue/believe）、含有序数词的句子（First）、段位的总结句。  </p><h4 id="强调结构"><a href="#强调结构" class="headerlink" title="强调结构"></a>强调结构</h4><p>比如倒装句，副词开头的句子，或者是标准的强调句结构(It is that)。<br>还要关注自带强调意义的词（note/emphasize/important/notice）。  </p><h4 id="情感倾向"><a href="#情感倾向" class="headerlink" title="情感倾向"></a>情感倾向</h4><p>包涵正面词或者负面词的结构和句子，这些有情感倾向的词通常是形容词。  </p><h3 id="句间关系"><a href="#句间关系" class="headerlink" title="句间关系"></a>句间关系</h3><h4 id="同向类型"><a href="#同向类型" class="headerlink" title="同向类型"></a>同向类型</h4><p>同向：举例、并列、递进、因果、指代、解释、列举、类比、排序<br>同向的句子可以跳读。  </p><h4 id="反向类型"><a href="#反向类型" class="headerlink" title="反向类型"></a>反向类型</h4><p>让步句、转折、对比、矛盾（paradoxically/surprisingly/ironically）。<br>此外，普遍的观点（traditionally/most people think）后容易出现反向的事实。  </p><h2 id="句子匹配"><a href="#句子匹配" class="headerlink" title="句子匹配"></a>句子匹配</h2><p>句子匹配题中将句子的前半句和后半句进行匹配。<br>句子匹配中题文是顺序出题的。  </p><h3 id="做题方法-1"><a href="#做题方法-1" class="headerlink" title="做题方法"></a>做题方法</h3><ul><li>题干中可能会出现专有词，专有名词直接作为定位词进行定位。<strong>应当先做有明显定位词的题目，再根据顺序出题的规律卡出其他题目的定位词。</strong>    </li><li>关注匹配信息中表示情感倾向的词（innovative/damage）和否定表达。  </li><li>可以对选项进行分类，比如原因归一类，结果归一类。但是通常选项的类别都比较一致。  </li></ul><h2 id="段落信息匹配"><a href="#段落信息匹配" class="headerlink" title="段落信息匹配"></a>段落信息匹配</h2><p>出题时通常要求找出包含题干内容的段落。题干大多是短语。<br>如果有NB时某一个选项会多选一次。<br>题干中的定位词一般不会原词出现。  </p><h3 id="预测工具"><a href="#预测工具" class="headerlink" title="预测工具"></a>预测工具</h3><ul><li>标题/副标题：预测文章文体和发展逻辑<ul><li>记叙文：时间线</li><li>议论文：背景-论点-论证-总结</li><li>说明文：背景/问题-方法-结论-应用</li></ul></li><li>题干信息词：预测描述对象、描述量和逻辑<br>题干中的信息词指能够描述段落用途的名词短语。信息词和其单复数会暗示寻找的对象类型（比如：A country/The figure/The day）。<br>常见的信息词有：<br>Differnece/description/explaination/reference/example/⋆number&lt;涉及数字&gt;/⋆location&lt;容易出现专有名词&gt;/⋆prediction&lt;一般在文末&gt;/⋆overview<br>但是做题时不需要花太多精力在分析信息词上。    </li><li>定位词：预测匹配的文段</li></ul><h3 id="做题方法-2"><a href="#做题方法-2" class="headerlink" title="做题方法"></a>做题方法</h3><ul><li>使用结构阅读法快速浏览文章，找出文章的基本框架。  </li><li>审题，关注题干中的信息词和定位词。  </li><li>匹配每一段的主题和信息做题。  </li><li>如果时间充裕，再核对细节。  </li></ul>]]></content>
    
    
    <categories>
      
      <category>雅思笔记</category>
      
      <category>雅思阅读</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>阅读选择题</title>
    <link href="/2022/01/28/%E9%9B%85%E6%80%9D/%E9%9B%85%E6%80%9D%E9%98%85%E8%AF%BB/%E9%80%89%E6%8B%A9%E9%A2%98/"/>
    <url>/2022/01/28/%E9%9B%85%E6%80%9D/%E9%9B%85%E6%80%9D%E9%98%85%E8%AF%BB/%E9%80%89%E6%8B%A9%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="雅思选择题"><a href="#雅思选择题" class="headerlink" title="雅思选择题"></a>雅思选择题</h1><h2 id="题型特征"><a href="#题型特征" class="headerlink" title="题型特征"></a>题型特征</h2><p>选择题出题的概率在雅思阅读考试中占比不高，但是逐年增高。<br>选择题通常有4选1的单选题，5选2等等多选题。<br>单选题出现频率大于多选题。<br>选择题通常是题文同序的，且通常一段一题（长段落除外）  </p><h3 id="题干完整度"><a href="#题干完整度" class="headerlink" title="题干完整度"></a>题干完整度</h3><p>题干不完整，待选项合理补充<br>如果题干没有定位词，可以通过卡上下题定位，或者选项找定位词。<br>相似度越高的选项越有可能表述出现问题。<br>题干完整，按疑问词定位阅读方向。  </p><h4 id="定位方式"><a href="#定位方式" class="headerlink" title="定位方式"></a>定位方式</h4><ul><li>优先通过题干信息找</li><li>如果题干中没有定位词，从选项中寻找</li><li>注意避免通过词汇找正确答案</li></ul><h2 id="单项选择"><a href="#单项选择" class="headerlink" title="单项选择"></a>单项选择</h2><h3 id="错误选项类型"><a href="#错误选项类型" class="headerlink" title="错误选项类型"></a>错误选项类型</h3><ul><li>答非所问<br>选项是文章中的同义替换，但是无法回答问题。  </li><li>以偏概全<br>用局部过度地推导全局，经常会出现绝对词。  </li><li>逻辑混乱<br>选项内容中产生了不存在的逻辑关系。  </li><li>无中生有<br>捏造文中没有的信息。  </li><li>内容矛盾<br>题干描述与文中描述的内容相悖。  </li></ul><h3 id="考察点类型"><a href="#考察点类型" class="headerlink" title="考察点类型"></a>考察点类型</h3><ul><li>事实<br>考察细节信息。需要通过定位词查找信息。  </li><li>例子<br>why the writer mention to…?，问例子的使用目的。<br>例子题考察例子支撑的论点句，需要<strong>查看文章中例子前后出现的总结句。</strong><br>句中有指代时向前看。<br>单一论点如果没有办法判定答案的话，也可以看后面的例子进行理解。  </li><li>主旨<br>make a point/suggest/claim: the author suggest that…<br>主旨类问题通常考察推段落主旨观点的归纳。<br>回顾前面寻找段落主旨的方法解题。<br>段落主旨句常在段落第一句、第二句或者末尾句。  </li></ul><h2 id="多项选择"><a href="#多项选择" class="headerlink" title="多项选择"></a>多项选择</h2><p>题型特征  </p><ul><li>顺序出题  </li><li>答案可能跨段落出现  </li><li>主要考察事实细节  </li></ul><h3 id="做题步骤"><a href="#做题步骤" class="headerlink" title="做题步骤"></a>做题步骤</h3><ul><li>审题，划关键词  </li><li>利用题干关键词定位区间，如果选项特别多，需要从选项中找定位词</li><li>分析原文句子</li><li>识别原文答案句</li></ul><h3 id="复选题"><a href="#复选题" class="headerlink" title="复选题"></a>复选题</h3><p>NB： 可能至少有一个选项可以重复选。<br>基本上有一个选项会被使用两次。<br>不止一个人名出现多次。<br>第二次出现时文章中不会给出全名或者使用人称代词。<br>先做观点少的再做观点多的。  </p>]]></content>
    
    
    <categories>
      
      <category>雅思笔记</category>
      
      <category>雅思阅读</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>听力简述和题型</title>
    <link href="/2022/01/27/%E9%9B%85%E6%80%9D/%E9%9B%85%E6%80%9D%E5%90%AC%E5%8A%9B/%E9%9B%85%E6%80%9D%E5%90%AC%E5%8A%9B%E4%BB%8B%E7%BB%8D/"/>
    <url>/2022/01/27/%E9%9B%85%E6%80%9D/%E9%9B%85%E6%80%9D%E5%90%AC%E5%8A%9B/%E9%9B%85%E6%80%9D%E5%90%AC%E5%8A%9B%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="听力简述和题型"><a href="#听力简述和题型" class="headerlink" title="听力简述和题型"></a>听力简述和题型</h1><h2 id="听力考试介绍"><a href="#听力考试介绍" class="headerlink" title="听力考试介绍"></a>听力考试介绍</h2><p>听力考试基本情况<br>在中国大陆平均一个雅思账号考过3.4次。<br>在中国大陆的雅思考试中听力为雅思的第一科目。<br>总分7:前10%，总分7.5：前4%。中国大陆：平均分5.56，听力平均分5.69。  </p><ul><li>每段录音播放一遍，无例题。  </li><li>听力考试分为4个part，每个Part会有少量时间（大约每道题4秒）进行读题，结束后有半分钟时间检查。  </li><li>听力考试时间总共40分钟（笔试），笔试考试有10分钟誊写到答题纸上，字迹清晰。机考仅有两分钟时间确认答案。  </li><li>拼写错误会扣分，但是大小写除外。  </li><li>口音以英式英语为主，但是会有澳大利亚、印度、高地（苏格兰口音）、美式、西班牙口音，大约占比20%。  </li><li>听力6.5分需要作对27-29个正确答案，7分30-32个正确答案，7.5分33-34个正确答案。  </li><li>“Now turn to part one”之后才能打开试卷。  </li></ul><h2 id="做题策略"><a href="#做题策略" class="headerlink" title="做题策略"></a>做题策略</h2><p>在每一个part听力结束后，会有30s的时间检查，这段时间的利用分布为：  </p><ul><li>Part 1 后 30s 看选择题</li><li>Part 2 后 30s 看选择题</li><li>Part 3 后 30s 看Part 4的笔记题</li></ul>]]></content>
    
    
    <categories>
      
      <category>雅思笔记</category>
      
      <category>雅思听力</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Part A：图表描述题</title>
    <link href="/2022/01/26/%E9%9B%85%E6%80%9D/%E9%9B%85%E6%80%9D%E5%86%99%E4%BD%9C/%E9%9B%85%E6%80%9D%E5%B0%8F%E4%BD%9C%E6%96%87/"/>
    <url>/2022/01/26/%E9%9B%85%E6%80%9D/%E9%9B%85%E6%80%9D%E5%86%99%E4%BD%9C/%E9%9B%85%E6%80%9D%E5%B0%8F%E4%BD%9C%E6%96%87/</url>
    
    <content type="html"><![CDATA[<h1 id="Part-A：图表描述题"><a href="#Part-A：图表描述题" class="headerlink" title="Part A：图表描述题"></a>Part A：图表描述题</h1><h2 id="写作标准"><a href="#写作标准" class="headerlink" title="写作标准"></a>写作标准</h2><p>TR:  </p><ol><li>完成所有的任务<br>总结主要特征（主要特征：折线图的趋势，起点终点拐点，适当的数据需要被引用以说明趋势。）、对比不同项目之间的差异。  </li><li>概述段（Overview⋆）<br>概述段描述总体趋势、差异、阶段。  </li><li>关键信息  </li></ol><p>CC：  </p><ol><li>逻辑连贯（逻辑连接词），有明确的写作逻辑顺序  </li><li>指代（Referencing）⋆</li></ol><p>LR/GRA：  </p><ol><li>每一句/每一段话中尽量使用到不同的复杂结构。  </li></ol><p>重点：<br>引用具体数据/概述段  </p><h2 id="题目类型"><a href="#题目类型" class="headerlink" title="题目类型"></a>题目类型</h2><p>图表类型：line graph（折线） pie chart（饼图） bar chart（条形统计图）<br>table（表格） /  flow chart（流程图） maps（地图）  </p><h3 id="按图形类别来分"><a href="#按图形类别来分" class="headerlink" title="按图形类别来分"></a>按图形类别来分</h3><ul><li><p>数据图<br>line graph（折线） pie chart（饼图） bar chart（条形统计图）<br>table（表格）  </p></li><li><p>图像（diagram）<br>flow chart（流程图） maps（地图）</p></li></ul><h3 id="按图表状态来分"><a href="#按图表状态来分" class="headerlink" title="按图表状态来分"></a>按图表状态来分</h3><ul><li>动态图<br>表现（时间）变化（比如：波士顿房价-时间图）<br>描述趋势时的原则：同一类型，不同时间。<br>需要适度进行同一时间点内项目之间的大小比较。  </li><li>静态图<br>表现数据对比和差异<br>比较原则：控制变量  </li><li>组合图<br>同静态图和动态图和组合（需要在两张图之间体现变化，并且每张图内部的类别需要进行比较）<br>在给出图特别多时，应当识别所有图描述的统计类别，简化图表的数量，再进行分析。  </li></ul><h2 id="审题"><a href="#审题" class="headerlink" title="审题"></a>审题</h2><p>审题分为读题、分要点、分段。  </p><h3 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h3><p>题目的开头和表头给出了话题和单位。<br>坐标轴给出了语法要求：横轴中如果是时间轴，则需要使用过去式进行描述。  </p><h3 id="描述要点"><a href="#描述要点" class="headerlink" title="描述要点"></a>描述要点</h3><h4 id="动态图"><a href="#动态图" class="headerlink" title="动态图"></a>动态图</h4><ul><li>趋势（需要引用一些数据点说明趋势: 起点、终点、拐点）  </li><li>线与线之间的交点（主要描述反超关系）  </li><li>数据之间的排名，差距，进行内部比较。  </li></ul><p>通常的动态图只需要集中描述起点位置的占比，再描述时间变化趋势即可。<br>如果动态图只给出了两个时间点，在写作时更应当描述大小关系。可行的方法是先描述起点的占比大小，再描述动态趋势，最后描述终点的占比。  </p><h4 id="静态图"><a href="#静态图" class="headerlink" title="静态图"></a>静态图</h4><ul><li>重要数值：最大、最小值、第二大（有需要才进行描述）  </li><li>数据的比较关系：差距、相似、相同  </li><li>特殊数值（如果给出才谈及）：均值、总量  </li></ul><div class="note note-info">            <p>可以利用倍数描述两个数据之间差距。  </p>          </div><h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><p>主要特征分段一般分为2-3段。<br>段落结构可以是“总（介绍）-总（概述）-分（要点）”，也可以是“总（介绍）-分（要点）-总（概述）”，推荐前者。  </p><h4 id="动态图-1"><a href="#动态图-1" class="headerlink" title="动态图"></a>动态图</h4><p>在分要点中，常用的分段依据：</p><ul><li>利用趋势进行分类，比如：  <ul><li>是否出现转折</li><li>只关注起点和终点：数据上升还是下降？</li></ul></li><li>利用变化幅度分类  </li><li>利用时间阶段进行分类<br>定点和交点可以作为分阶段的依据  </li><li>利用项目类别来分类（比如私人交通：car,bicycle和公共交通：train,bus）  </li></ul><h4 id="静态图-1"><a href="#静态图-1" class="headerlink" title="静态图"></a>静态图</h4><ul><li>按表头（横表头/纵表头）进行分段  </li><li>利用项目类别来分类  </li><li>按数据体量进行分类<br>将相似的数据体量进行分类：<br>整体数据量偏大的部分和整体数据量偏小的部分。<br>最大值相似的部分和最小值相似的部分。<br>指标差异相似的部分。（比如指标A&gt;B的分一组，B&gt;A的分一组）<br>差异程度相似的部分（比如好的很好，差的很差的分一组）<br>平均值相似的部分。<br>写作的时候更容易阐述数据明显的关系。  </li></ul><h2 id="词汇"><a href="#词汇" class="headerlink" title="词汇"></a>词汇</h2><h3 id="动态图的相关词汇"><a href="#动态图的相关词汇" class="headerlink" title="动态图的相关词汇"></a>动态图的相关词汇</h3><h4 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h4><div class="note note-warning">            <p>下述所有描述趋势的名词都是可数的（e.g. experience a increase）<br>下述所有的动词都没有被动语态  </p>          </div><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">动词（不规则过去式/名词形式）</th></tr></thead><tbody><tr><td style="text-align:center">增加</td><td style="text-align:center">increase/on the increase <br> jump <br> grow(grew/growth) <br> rise(rose) <br> show upward trend <br> climb <br> ascend(ascent)</td></tr><tr><td style="text-align:center">激增 <br> *不能加副词修饰</td><td style="text-align:center">skyrocket <br> soar <br> rocket</td></tr><tr><td style="text-align:center">减少</td><td style="text-align:center">fall(fell) <br> show a downward trend <br> decrease <br> decline <br> drop(dropped) <br> dip(dipped) <br> descend(descent) <br> reduce(reduction)</td></tr><tr><td style="text-align:center">骤降</td><td style="text-align:center">plumment <br> plunge</td></tr><tr><td style="text-align:center">稳定</td><td style="text-align:center">remain stable <br> level off/out（在变化之后出现了持平状态）<br> stay steady</td></tr><tr><td style="text-align:center">波动</td><td style="text-align:center">experience rises and falls <br> fluctuate(fluctuation)</td></tr><tr><td style="text-align:center">超过</td><td style="text-align:center">exceed <br> overtake(overtook)/take over <br> pass</td></tr></tbody></table></div><div class="note note-info">            <p>英语词汇等级分类:A1到C2，逐级增加<br>写作中推荐使用B2,C1级别的词汇  </p>          </div><h4 id="程度副词"><a href="#程度副词" class="headerlink" title="程度副词"></a>程度副词</h4><div class="table-container"><table><thead><tr><th style="text-align:center">意义</th><th style="text-align:center">表达（不规则形容词）</th><th style="text-align:center">意义</th><th style="text-align:center">表达（不规则形容词）</th></tr></thead><tbody><tr><td style="text-align:center">剧烈地</td><td style="text-align:center">considerably(considerable) <br> drastically(drastic) <br> hugely <br> dramatically(dramatic) <br> significantly <br> largely <br> abruptly</td><td style="text-align:center">快速地</td><td style="text-align:center">rapidly <br> sharply <br> quickly</td></tr><tr><td style="text-align:center">轻微地</td><td style="text-align:center">a little <br> smally <br> moderately <br> slowly <br> slightly <br> modestly <br> marginal</td><td style="text-align:center">稳定地</td><td style="text-align:center">consistently <br> steadily(steady) <br> gradually</td></tr></tbody></table></div><h4 id="介词"><a href="#介词" class="headerlink" title="介词"></a>介词</h4><ul><li>from…to… 从..到</li><li>by 差值，变化了，前为动词</li><li>of 差值，变化了，前为名词</li></ul><h3 id="静态图的相关词汇"><a href="#静态图的相关词汇" class="headerlink" title="静态图的相关词汇"></a>静态图的相关词汇</h3><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">动词</th></tr></thead><tbody><tr><td style="text-align:center">最大</td><td style="text-align:center">top the list <br> dominate <br> more than the others <br> the largest</td></tr><tr><td style="text-align:center">最小</td><td style="text-align:center">the least popular <br> insigificant</td></tr><tr><td style="text-align:center">第二</td><td style="text-align:center">come second <br> followed by…</td></tr><tr><td style="text-align:center">区间</td><td style="text-align:center">cluster between…and.. <br> range from… to…</td></tr><tr><td style="text-align:center">倍数</td><td style="text-align:center">a quarter <br> twice <br> double <br> triple</td></tr><tr><td style="text-align:center">相似</td><td style="text-align:center">similar <br> be matched by <br> be equal to</td></tr><tr><td style="text-align:center">占比 <br>*占比的主语不能是百分比</td><td style="text-align:center">make up <br> account for <br> represent <br> constitute</td></tr></tbody></table></div><h4 id="数据读取"><a href="#数据读取" class="headerlink" title="数据读取"></a>数据读取</h4><ul><li>at + 数据<br>at前面必须要有对应的数据<br>e.g. the longest route of all cities at 394km.</li><li>（数据）<br>e.g. the length of railway system(200km) is..</li><li>数据放主语位置<br>e.g. 20000 resitants have been surfured this catastrophy.  </li><li>with 数据+名词+从句<br>e.g. with 200 people engaging in the event.  </li><li>使用where/when引导的非限定性定语从句<br>e.g. The biggest cost emerged in the infrustrure construction, where the average cost is 2 million dollors per year.<br>e.g. The sales amount of coffee reached its summit in 2006, when the average cost is 200$.  </li></ul><h2 id="句式"><a href="#句式" class="headerlink" title="句式"></a>句式</h2><h3 id="句式结构变换"><a href="#句式结构变换" class="headerlink" title="句式结构变换"></a>句式结构变换</h3><p>句式变换的要点是变换句子的主语，使用不同的谓语动词进行连接。<br>可以做句式变换的主语名词来自于题干和图表中的名词。<br>适度使用指代（it/they/this figure）<br>常见的主语及其谓语动词搭配如下所示：  </p><h4 id="数据概念"><a href="#数据概念" class="headerlink" title="数据概念"></a><strong>数据概念</strong></h4><ul><li>数量<br>e.g. the amount of pizza consumed held the top position/ranked the 2nd position during the period of..  </li><li>题目中动词的名词化<br>e.g. consumed → consumption of increase  </li></ul><p>变化有关的动词/rank/hold the top position/record  </p><div class="note note-info">            <p>数据概念使用高低进行描述。<br>类别概念使用大小进行描述。    </p>          </div><h4 id="数据特征"><a href="#数据特征" class="headerlink" title="数据特征"></a><strong>数据特征</strong></h4><ul><li>趋势<br>e.g. increase → an increase can be observed/occured  </li><li>顶点/拐点/转折<br>e.g. the changes occures  </li><li>差距<br>e.g. the difference can be witnessed that..  </li></ul><p>和发生有关的动词，观察和记录的被动形：<br>be observed/ be witnessed/ happen/ occur/ there be</p><h4 id="类别概念"><a href="#类别概念" class="headerlink" title="类别概念"></a><strong>类别概念</strong></h4><ul><li>类型<br>e.g. pizza shared/enjoyed the high popularity among Australian teenagers  </li><li>图表阐述的对象<br>e.g. Australian teenagers → Australian teenagers intended to/prefered to  </li></ul><p>相关的动词即可：<br>prefer/intend/enjoy/share/gained/show/display/exhibit  </p><h4 id="地点和时间"><a href="#地点和时间" class="headerlink" title="地点和时间"></a><strong>地点和时间</strong></h4><ul><li>时间<br>e.g. the time/the period from witnessed/documented/recorded the variation of…  </li><li>地点  </li></ul><p>见证、经历相关的动词：witness/experience/see/document/record  </p><h2 id="写作结构"><a href="#写作结构" class="headerlink" title="写作结构"></a>写作结构</h2><h3 id="开头段和介绍段"><a href="#开头段和介绍段" class="headerlink" title="开头段和介绍段"></a>开头段和介绍段</h3><h4 id="介绍段"><a href="#介绍段" class="headerlink" title="介绍段"></a>介绍段</h4><p>小作文的开头通常需要介绍图表的基本情况，主要的技巧是题干改写。<br>题干改写的方法有三种：  </p><ol><li>同义词转换  </li><li>词性和语态的改变  </li><li>抽象名词具体化/上下义词改变  </li></ol><p>e.g.<br>例题：The graph shows that the comsuption of fish and some different kinds of meat in an European coutry between 1979 and 2004.<br>改写：The graph illustrates how much fish and meets were consumed per person per week in an European coutry from 1979 to 2004.<br>例题： The bar chart below shows the participation rate of boys and girls in different sports in Australia in 2010.<br>改写： The graph illustrates/displays/compares the percentage of teenagers based on/in terms of/according to gender participating in diverse sports in Australia in 2010.  </p><h3 id="概述-总结段"><a href="#概述-总结段" class="headerlink" title="概述/总结段"></a>概述/总结段</h3><p>概述段需要写出类别的主要趋势（比如有一项上升，两项下降）。在多图题中应当尽量联系主体段中分组描述的图表。描述大类的趋势。  </p><h4 id="连词"><a href="#连词" class="headerlink" title="连词"></a>连词</h4><p>概述段相关的连词：  </p><ul><li>总括性：in general/overall</li><li>对比： while/whereas/whilst</li></ul><h3 id="主体段"><a href="#主体段" class="headerlink" title="主体段"></a>主体段</h3><p>在动态图中选取某些特殊的时间点（起始点、拐点、终止点）静态比较数据。<br>分组详述各项趋势，并且在每一段第一句表明出分组依据。<br>在每一段内部，也需要再进行分组，以体现出段落的逻辑性，并且需要详略得当，通常着重写变化/占比最大的项，其它项可以略写。  </p><h4 id="段内结构"><a href="#段内结构" class="headerlink" title="段内结构"></a>段内结构</h4><h5 id="开头句"><a href="#开头句" class="headerlink" title="开头句"></a>开头句</h5><p>段内的开头句式有如下几种，用于进行总括。<br>It can be observed/identifity that…<br>We can see immediately…<br>It is noticeable that…<br>What is worth mentioning is that..   </p><h5 id="比较内容"><a href="#比较内容" class="headerlink" title="比较内容"></a>比较内容</h5><p>在比较时尽量不要反复使用同一个动词，在进行同义替换时需要注意动宾搭配是否合适。  </p><p>比较的方法有如下几种：  </p><ul><li>描述差距（huge gap/slight difference）  </li><li>描述倍数（twice）  </li><li>直接使用比较级（More than）  </li></ul><p>引用数据的方式：<a href="#数据读取">跳转</a>  </p>]]></content>
    
    
    <categories>
      
      <category>雅思笔记</category>
      
      <category>雅思写作</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>雅思写作概述</title>
    <link href="/2022/01/26/%E9%9B%85%E6%80%9D/%E9%9B%85%E6%80%9D%E5%86%99%E4%BD%9C/%E9%9B%85%E6%80%9D%E5%86%99%E4%BD%9C/"/>
    <url>/2022/01/26/%E9%9B%85%E6%80%9D/%E9%9B%85%E6%80%9D%E5%86%99%E4%BD%9C/%E9%9B%85%E6%80%9D%E5%86%99%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="雅思写作概述"><a href="#雅思写作概述" class="headerlink" title="雅思写作概述"></a>雅思写作概述</h1><h2 id="雅思写作介绍"><a href="#雅思写作介绍" class="headerlink" title="雅思写作介绍"></a>雅思写作介绍</h2><p>大陆考试的平均分：5.5  </p><ul><li><p>小作文（20 min）<br>图文转换 150+ words（170-180词） 评分占1/3<br>在纸笔考试时尽量写到翻面<br>不要发表自己的观点，原因分析等等。<br>任务要求：<br>总结图表，比较图表中的主要信息。<br>比较中应当包含目标的相同点和不同点。  </p></li><li><p>大作文（40 min）<br>议论文 250+ words 评分占2/3<br>在纸笔考试时尽量写到翻面后的（1/3-1/2）<br>需要明确给出立场（有且仅有一个）、原因（应当有多个）、并且应当有多个例子支撑。  </p></li></ul><p>不用写标题。<br>单词中美式单词和英式单词写法不要混淆。<br>先写简单的，如果两个题都比较难，先写大作文。  </p><h2 id="评分标准"><a href="#评分标准" class="headerlink" title="评分标准"></a>评分标准</h2><ul><li>Task response（TR）：完成全部任务  </li><li>Coherence and cohension（CC）：流畅——段落结构恰当，连接词  </li><li>Lexical resource（LR）：词汇量，词汇的丰富运用，同义词反复出现时要替换（比如：reputation，status，frame）  </li><li>Grammar range and accuracy（GRA）：语法多样性和准确度  </li></ul><p>其他评分标准  </p><ul><li>Underlength：低于最低字数线</li><li>Penalty ：考场惩罚</li><li>Words ：词数</li><li>Off topic：跑题</li><li>Memorised ：套作</li><li>Ilegible ：书写难以辨认</li></ul><h4 id="7分写作标准"><a href="#7分写作标准" class="headerlink" title="7分写作标准"></a>7分写作标准</h4><ul><li>TR：1.满足所有任务 2.有明确的立场 3.展开立场和有论点支持</li><li>CC:  1.有逻辑连贯（逻辑词）2.每段的段旨清楚</li><li>LR：1.词汇充分灵活 2.有非常用词汇 3.允许高级词汇出现错误</li><li>GRA：1.复杂丰富的语法结构 2.语法无错误 3.大部分语句没有错误</li></ul>]]></content>
    
    
    <categories>
      
      <category>雅思笔记</category>
      
      <category>雅思写作</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>口语考试简介</title>
    <link href="/2022/01/25/%E9%9B%85%E6%80%9D/%E9%9B%85%E6%80%9D%E5%8F%A3%E8%AF%AD/%E9%9B%85%E6%80%9D%E5%8F%A3%E8%AF%AD/"/>
    <url>/2022/01/25/%E9%9B%85%E6%80%9D/%E9%9B%85%E6%80%9D%E5%8F%A3%E8%AF%AD/%E9%9B%85%E6%80%9D%E5%8F%A3%E8%AF%AD/</url>
    
    <content type="html"><![CDATA[<h1 id="口语考试简介"><a href="#口语考试简介" class="headerlink" title="口语考试简介"></a>口语考试简介</h1><h2 id="雅思口语考试规则"><a href="#雅思口语考试规则" class="headerlink" title="雅思口语考试规则"></a>雅思口语考试规则</h2><p>中国考生通常的口语得分为5.5。<br>雅思口语考试的考察点：<br>WILLINGNESS AND ABILITY OF HAVING A CONVERSATION.<br>因此，在口语考试中可以提出和考官观点相悖的观点。<br>尽量延展话题，尤其是对话题没有任何了解的情况下，体现“CONVERSATION”。  </p><p>时长：11-16分钟<br>考试分为三部分：  </p><ul><li>Part 1：询问身份 4-4.5min  </li><li>Part 2：抽题回答，所有的问题都会公布在题库中。 3min  </li><li>Part 3：考官即兴发挥，针对part3的回答进行深入。 4min  </li></ul><h3 id="原题库"><a href="#原题库" class="headerlink" title="原题库"></a>原题库</h3><p>part 1 和 part 2 的问题会来自公开的题库。<br>题库每年会更换三次。<br>持续时间： 1-4月   5-8月   9-12月 （不要1，5，9上半月报考）。<br>大于30%的题目会更换，题库中有100个话题左右。  </p><h3 id="考试流程"><a href="#考试流程" class="headerlink" title="考试流程"></a>考试流程</h3><p>在part1之前， 面试官会询问姓名和身份（student/work）。  </p><h4 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h4><p>在part1， 面试官通常会询问三个话题，其中一个问题来自于常见话题：  </p><ul><li>study/work（考官基于面试者的身份选择话题）  <ul><li>what subjects are you studying? (major/program/subject).</li></ul></li><li>hometown<ul><li>please describe your hometown a bit.</li></ul></li><li>accommondation/home<ul><li>please describe the room you living.  </li></ul></li></ul><p>对每一个话题，每个问题尝试回答20秒。尽量尝试一直流畅地说，直到考官打断当前的谈话。<br>另一个问题的常见话题来自于题库：比如daily rountine, car。目前题库中part1的随机话题中可供选择的有31个话题。<br>另一个问题来自生活，比如hobbies</p><h4 id="Part-2"><a href="#Part-2" class="headerlink" title="Part 2"></a>Part 2</h4><p>在part2，其中有1分钟的准备时间（提供铅笔和草稿纸）,有1-2分钟的时间回答问题（尽量说到2分钟）。<br>考官会从题库中抽出题库中的一道题并给出问题（例如：something you cannot live without not a computer or phone, you should say what it is, how often you use it, where you get it from, explain why you cannot live without it.）<br>【you should say】是设置的辅助，没有必要严格遵守，只需要围绕话题即可。<br>问题通常要求描述：描述的对象分为两类：  </p><ul><li>person/item<br>in terms of this question, I’d like to take about <strong> who/which _</strong>.</li><li>occassion/time/place<br>in terms of this question, it reminds me of my experience of <strong>_ during which __</strong>.</li></ul><p>当季题库大概有50个话题左右。<br>练习的方式为串题：近似的话题共用同一个事情。<br>尽量结合个人经历。  </p><h4 id="Part-3"><a href="#Part-3" class="headerlink" title="Part 3"></a>Part 3</h4><p>part3决定口语评分的上限，part3会问到4-5个问题，每个问题尽量作答1分钟。<br>part3与社会问题和公共相关，具有讨论性，经常与part2问题中的关键词相关。<br>part3 通常有5种提问角度：  </p><ul><li>why【常见】  </li><li>what【常见】  </li><li>opinion【常见】  </li><li>pros and cons（优劣性）  </li><li>difference<br>part3中的观点必须要合理，可以适当引用（真假不重要，重要的是自圆其说）。  </li></ul><div class="note note-info">            <p>如何练习：  </p><ol><li>简单的词汇、流利地表达。  </li><li>提升好的短语。（量化：part1中20s的回答中有2个左右好的短语，part2 2分钟的回答中有8个，part3：1分钟的回答中有4个左右好的短语。）  </li><li>使用从句和不同的时态。  </li><li>发音正确，表现出轻松聊天一样（使用强调和适度的停顿，加入一些停顿句）。  </li></ol>          </div><p>问题没有听清楚可以请求重复，不会扣分。  </p><h3 id="评分标准"><a href="#评分标准" class="headerlink" title="评分标准"></a>评分标准</h3><p>评分标准：<br>0分： 完全没有体现<br>1分： 很少体现<br>2分： 体现了一些<br>3分： 完全体现</p><h4 id="流利连贯"><a href="#流利连贯" class="headerlink" title="流利连贯"></a>流利连贯</h4><ul><li>避免沉默和犹豫  </li><li>表达详尽   </li><li>使用连接词、适当的语法连接观点和举例  </li></ul><h4 id="词汇量"><a href="#词汇量" class="headerlink" title="词汇量"></a>词汇量</h4><ul><li>广泛的词汇  </li><li>成语（idioms）和正确的词语搭配【theidioms.com】  </li><li>改述和同义替换  </li></ul><h4 id="语法和准确性"><a href="#语法和准确性" class="headerlink" title="语法和准确性"></a>语法和准确性</h4><ul><li>多样的语法结构（从句）</li><li>时态多样</li><li>避免语法错误（三单、指代、过去式）</li></ul><h4 id="发音"><a href="#发音" class="headerlink" title="发音"></a>发音</h4><ul><li>词语发音正确</li><li>发音的连贯性</li><li>抑扬顿挫</li></ul>]]></content>
    
    
    <categories>
      
      <category>雅思笔记</category>
      
      <category>雅思口语</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>遗传编程（GP）导论</title>
    <link href="/2022/01/13/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/%E9%81%97%E4%BC%A0%E7%BC%96%E7%A8%8B%E5%AF%BC%E8%AE%BA/"/>
    <url>/2022/01/13/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/%E9%81%97%E4%BC%A0%E7%BC%96%E7%A8%8B%E5%AF%BC%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="遗传编程导论"><a href="#遗传编程导论" class="headerlink" title="遗传编程导论"></a>遗传编程导论</h1><blockquote><p><em>Gennetic Programming</em>.,John R. Koza,Riccardo Poli,Search Methodologies—Introductory Tutorials in Optimization and Decision Support Techniques, 2005.<br><em>Visualization of Evolutionary Process in Genetic Programming</em>.,Wongsiriprasert, Chatchawan &amp; Chongstitvatana, Prabhas &amp; Prasitjutrakul, Somchai, 1998.<br><em>the home page of Genetic Programming Inc.</em>., Genetic Programming Inc.,<a href="http://www.genetic-programming.com/">http://www.genetic-programming.com/</a>, 2007.</p></blockquote><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>遗传编程（Gennetic Progamming）是一种针对复杂目标问题，基于对需求高层级下的描述，使用计算机描述自动给出的最优解的算法。<br>具体而言，遗传编程通过应用类似于自然界基因遗传的规律，对一组程序（Programs）进行筛选和迭代，最终生成对目标问题解决效果最好的程序。  </p><h3 id="个体的描述和表达"><a href="#个体的描述和表达" class="headerlink" title="个体的描述和表达"></a>个体的描述和表达</h3><p>与遗传算法不同的是，遗传编程中不再像遗传算法那样使用固定长度的字符串（Strings）和线性结构来描述一个个体。而是通过程序（Program）和树形结构（称为语法树，Syntax trees）来编码可能的系统解决方法。  </p><div class="note note-info">            <p>遗传编程中，一个程序可以理解为是可以被符号化和流程化的一个类（item），它可以是一个特征，也可以是目标问题的一种解决问题的策略。  </p>          </div><p>这样编码方式使得对个体的描述能够更加准确，同时进行遗传操作时对个体的变化也更大。<br>比如：  </p><script type="math/tex; mode=display">max(x*x,x+3*y)</script><p>可以被树形化为：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220113114716.png width=80%>  </p><p>如上图所示，语法树由众多的节点（nodes）和节点之间的连接（links）组成，一个程序可以由语法树来描述其成分和执行流程，一个节点表示一个操作，在数学中可以理解为运算符，而连接可以表示某个节点与操作对象的对应关系，在数学中可以理解为运算数（Operand）。一个基本的语法树包括如下的成分：  </p><ul><li>根（root）<br>最顶层的节点，表示程序的最外部操作。  </li><li>函数（function）<br>语法树中内部的节点。每一个函数对应的子树称作分支（brunch）。  </li><li>端点（terminal）<br>语法树中非操作符的成分，比如不相关的变量，常数等等，是树的结束。  </li></ul><p>每一个语法树分支的类型和分支的数量称为语法树/程序的结构（architecture）。  </p><p>在遗传编程中更习惯用前缀表示法（profix-notation expression）来表达一个数学运算，前缀表示法中所有的运算符都前置以强调运算符，这样的表示也更接近语法树结构。比如$max(x<em>x,x+3</em>y)$可以表示为：  </p><script type="math/tex; mode=display">max(*xx)(+*3y)</script><h2 id="运行前的准备"><a href="#运行前的准备" class="headerlink" title="运行前的准备"></a>运行前的准备</h2><p>在运行遗传编程之前，程序的设计者应当准备如下步骤：  </p><ol><li>对目标问题，要决定目标问题每一个分支的端点，端点可以是独立变量、无变量数学运算、或者是随机常数等等，这些都以一个集合的形式给出。  </li><li>确定每一个分支的函数，同样也以一个函数集对其指定。  </li><li>确定适应度函数，即如何评估个体的优劣。  </li><li>确定运行时的参数和调试、诊断参数。  </li><li>确定何时终止程序运行的标准。  </li></ol><h3 id="搜索空间的确定"><a href="#搜索空间的确定" class="headerlink" title="搜索空间的确定"></a>搜索空间的确定</h3><p>第一步和第二步为遗传编程的运行确定了搜索空间，遗传编程将在这个空间内对特定的目标种群进行搜索。对于不同类型的目标问题，端点和函数有所不同。有时甚至函数并不是数学运算符，也有可能是目标问题中其他的可以被符号化、结构化和流程化的表达。通常，函数是通过对目标进行分解而得到的。但无论如何设置函数，<strong>函数集必须满足完备性，即函数集中的函数可以包括目标问题中所有可能的操作。</strong><br><div class="note note-info">            <p>例如，如果目标是让扫地机器人在有障碍的房间中能够顺利的清扫房间。那么执行的函数集中应当包括：转向、前进、清扫、停止等等。<br>如果目标问题是对模拟电路进行自动综合（Synthesis），那么函数集应该能够让遗传编程程序自动的从电路器件库中选择器件进行创建，函数集可以是含有电阻、电容、电感、运算放大器等等的器件库。  </p>          </div></p><h3 id="适应度函数"><a href="#适应度函数" class="headerlink" title="适应度函数"></a>适应度函数</h3><p>同样的，第三步中的适应度函数（fitness function）也与目标问题有关，适应度函数的主要功能是评估和量化种群中每个个体的优劣程度。在遗传算法领域，个体的“优劣”通常指个体对实现目标问题的贡献程度。适应度评估是遗传编程中将对目标问题高层级的需求转义进遗传编程程序中的最基本的机制。  </p><h3 id="运行控制"><a href="#运行控制" class="headerlink" title="运行控制"></a>运行控制</h3><p>第四步和第五步都是用于控制遗传编程程序的运行，第四步中为遗传编程指定一些参数，比如：种群大小、允许的个体（即程序）的最大大小（端点和函数的最大个数）、以及个体发生遗传操作（复制、交叉、突变等）的概率等等。<br>第五步则指定了遗传编程何时终止，数学上表征为何时收敛。可以通过指定个体的适应度达到某个阈值，或者是最大的运行代数来确定遗传编程何时终止。这些参数的设定都在“怎样算成功解决目标问题”这个大的背景问题下设定。  </p><h2 id="遗传编程的运行"><a href="#遗传编程的运行" class="headerlink" title="遗传编程的运行"></a>遗传编程的运行</h2><p>遗传编程的运行从随机初始化个体形成初始种群开始，个体通过适应度函数对其量化评估，得到个体的适应度后，基于适应度，有概率地挑选个体进行遗传操作，生成下一代种群。整个运行的流程图如下所示。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220114180854.png width=100%>  </p><div class="note note-info">            <p>与遗传算法不同的是，遗传编程中的遗传操作是并行执行，而遗传算法中的遗传操作是串行执行的。并行执行可以使得原本优秀的亲代性状尽可能的被保存。  </p>          </div><p>和遗传算法一样，遗传编程也是一种通用的解决问题的策略、不对某一个或是某一类问题进行特化（problem-independent）。</p><h3 id="初始化个体"><a href="#初始化个体" class="headerlink" title="初始化个体"></a>初始化个体</h3><p>从函数集和节点集中随机挑选一些组成个体，并形成初始种群（第0代种群）。<br>初始种群中的个体通常是通过递归产生一个程序树，该树由随机选择的原始函数和终端组成。通常初始个体的大小设置为运行准备一节中所设置的最大大小。<br>初始化个体的常用方法有两种： “Full” 和 “Grow”。  </p><h4 id="Full-Initialization"><a href="#Full-Initialization" class="headerlink" title="Full Initialization"></a>Full Initialization</h4><p>Full 初始化的方法的步骤是：  </p><ol><li>确定语法树的最大深度，即子树的最高层级。</li><li>从函数集中随机选择一些运算符，构建子树。  </li><li>当达到最大深度时，从端点的集合中选择一些变量或者常数作为端点。<br>通过Full初始化方法，每一个个体只会在最深一层出现端点。  </li></ol><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220114213939.png width=60%></p><h4 id="Grow-Initialization"><a href="#Grow-Initialization" class="headerlink" title="Grow Initialization"></a>Grow Initialization</h4><p>Grow初始化方法的步骤是：  </p><ol><li>确定语法树的最大深度，即子树的最高层级。</li><li>从函数集和端点集中同时随机选择一些运算符和运算数，构建子树，直到达到语法树的最大深度。  </li></ol><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220114214126.png width=60%></p><p>通过这样的随机生成方法，初始种群中会出现不同大小和形状的个体。<br>用grow策略生长得到的语法树往往不对称，而且普遍会比用户设置的最大深度浅一些；在变量的数量远大于函数的数量时，这种情况更明显。<br>下图动态展示了full和grow初始化：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/creation.gif width=50%>  </p><p>这两种的随机初始化方法是对搜索空间的盲选。在python的遗传编程库gplearn中默认采用的是一半一半（half-half）的策略：一半的公式树用grow策略生成，另一半用full策略生成，以创造种群多样性。  </p><blockquote><p>gplearn: <a href="https://gplearn.readthedocs.io/en/stable/">https://gplearn.readthedocs.io/en/stable/</a></p></blockquote><h3 id="个体评估"><a href="#个体评估" class="headerlink" title="个体评估"></a>个体评估</h3><h4 id="个体的编译"><a href="#个体的编译" class="headerlink" title="个体的编译"></a>个体的编译</h4><p>当随机种群生成后，遗传编程进行迭代，并基于前一代个体筛选和变异生成下一代个体。每一次迭代的第一步是用适应度函数评估每一个个体，得到每个个体的适应度。评估过程需要多次运行当前种群中的每一个个体。常见的程序运行策略包括离线编译、在线编译、链接、虚拟机编译、解释等等。具体而言，需要将每个个体的树形结构转义为运算式后，在运算其结果，带入适应度函数中得到对应的个体适应度。<br>对树形结构的解释（interpretation）是一种一边编译一边运行的策略，解释遵循当且仅当这个函数下面的所有量都是已知的情况下，这个函数才会被运行。下图所示了一棵语法树在$x=-1$时的解释流程。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220115101701.png width=50%><br>这种运行策略可以节省每一个个体的运行时间，加快评估速度。  </p><h4 id="适应度评估"><a href="#适应度评估" class="headerlink" title="适应度评估"></a>适应度评估</h4><p>对个体的适应度的评估依据于问题目标，比如个体的适应度可以是运行时间、运行中发生的错误数、计算资源消耗、或者是识别目标时的准确率等等。<br>个体也可以从多个维度去评价，并应用不同的适应度函数得到多个适应度结果。通常如果评测个体的指标有很多个，有必要对评测的指标进行降维操作。<br>许多问题中，每个个体的表现还与程序的输入、初始条件和运行环境有关，这些影响个体表现的因素称为适应度场合（fitness cases），每个个体在不同的场合下可能会有不同的适应度。  </p><h3 id="遗传操作"><a href="#遗传操作" class="headerlink" title="遗传操作"></a>遗传操作</h3><p>经过随机盲选得出的初始种群的个体适应度通常都不高，因此需要通过遗传操作（genetic operations）在搜索空间（searching space）内从这些初始个体周围开始寻找新的适应度更高的个体。<br>基于自然界的达尔文生物进化理论，遗传操作包括复制/繁殖（reproduction）、交叉（crossover）、突变（mutation），以及遗传算法中没有的结构转换（architecture-altering）。通过遗传操作产生的个体（称为后代）被移入下一代种群。<br>遗传编程基于个体的适应度，有概率的对个体进行这些遗传操作。通常个体的适应度越高，个体被选中进行遗传操作的概率就更高，这暗示了遗传编程将更倾向于在高适应度个体的周围去搜索搜索空间中的其他个体。通常选择个体进行遗传操作的算法有轮盘赌算法和锦标赛算法，这些算法都不是贪心算法，即是从全局而非当前的局部最优来考虑优化问题。这种非贪心的特性能够保证遗传编程/遗传算法不会陷入局部最优解。<br><div class="note note-info">            <p>贪心算法<br>在对问题求解时，总是做出在当前看来是最好的选择。即不从整体最优上加以考虑，贪心算法所做出的仅是在某种意义上的局部最优解。  </p>          </div></p><h4 id="交叉"><a href="#交叉" class="headerlink" title="交叉"></a>交叉</h4><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220115130723.png width=50%>  </p><p>交叉的步骤是：<br>基于概率$p_c$和适应度从当前种群中选择两个个体，随机的选择两个个体某一位置上的一个连接或者结点作为交叉点，然后交换两个体交叉点以下的子树。<br>通常选择函数作为交叉点的概率要远高于端点作为交叉点的概率（比如90%的概率选择一个函数，10%的概率选择端点。），这是因为选择函数作为交叉点时，交叉对个体的影响更大，遗传编程在搜索空间中单次搜索的范围更广。</p><h4 id="突变"><a href="#突变" class="headerlink" title="突变"></a>突变</h4><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220115130749.png width=50%>  </p><p>突变的步骤是：<br>基于概率$p_m$和适应度从当前种群中选择一个个体，并随机在这个个体内选择一个突变点，突变点下的子树被一个随机生成的子树替代（相当于与这个随机生成的子树发生交叉）。  </p><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p>基于概率$p_r$和适应度从当前种群中选择一个个体，并复制到下一代种群中。  </p><h4 id="结构转换"><a href="#结构转换" class="headerlink" title="结构转换"></a>结构转换</h4><p>结构转换会在之后的节中详述，在此不做叙述。  </p><p>遗传操作执行结束后，后代组成的下一代种群会替代当前的种群，并再次进行“评估-选择-遗传操作”这样的迭代流程。直到遗传编程的运行达到一开始设定的终止条件。<br>由于初始种群中的每个程序是可运行的有效程序，遗传操作不会改变其有效性，因此后代也是有效的，可以说明通过遗传编程生成的最终程序是有效的。  </p><h2 id="遗传编程的运行案例"><a href="#遗传编程的运行案例" class="headerlink" title="遗传编程的运行案例"></a>遗传编程的运行案例</h2><p>这一节将举例说明遗传编程是如何通过遗传操作解决目标问题的。目标问题为自动的生成一个程序使得其在$x ∈ [-1,1]$区间内生成的值满足函数$x^2+x+1$。这种试图发现某种隐藏的数学公式，以此利用特征变量预测目标变量的问题称之为符号回归（symbolic regression）类问题。  </p><h3 id="搜索空间确定和参数设置"><a href="#搜索空间确定和参数设置" class="headerlink" title="搜索空间确定和参数设置"></a>搜索空间确定和参数设置</h3><p>对于这个问题，在遗传编程的准备阶段，端点集由随机常数和变量$x$构成：  </p><script type="math/tex; mode=display">T=\{X,ℜ\}</script><p>其中的$ℜ$表示一个随机数，人为地设置其范围为$ℜ∈[-5.0,5.0]$。<br>接下来指定遗传编程的函数集，可以将函数集设置为四则运算即可：  </p><script type="math/tex; mode=display">F=\{+,-,×,\%\}</script><div class="note note-info">            <p>为了避免运行错误，指定了$ℜ÷0=1$。  </p>          </div><p>初始种群中的每一个个体都将从端点集和函数集中生成。生成之后的个体需要用适应度函数对其评估，在这个问题中，适应度函数可以通过当前个体$\hat{y}$与目标函数$y_e=x^2+x+1$在$x ∈ [-1,1]$上的值的差距来衡量。定义这个问题中的适应度函数为：  </p><script type="math/tex; mode=display">f(i)=∫_{-1}^1|\hat{y_i}-y_e|dx</script><p>对于这个适应度函数而言，个体的适应度越小代表与目标函数的差距越小，个体表现更加“优秀”。<br>接下来应当决定运行参数，为了简化解释，此处设定每一代中仅存在四个个体（但是实际上每一代的个体数量往往是成千或者百万级别的）并设置各遗传操作发生的概率，通常情况下设置<strong>交叉的概率为90%，繁殖的概率为8%，突变的概率为1%，结构变换的概率为1%。</strong><br><div class="note note-info">            <p>GP通过交叉对搜索空间进行查找，因此交叉的概率应当比较大，才能保证搜索空间中的个体尽可能被搜索完全。<br>繁殖的概率比较低暗示了环境压力较大，选择比较严苛。<br>突变和结构变换的随机性会带来负面效应，因此应当尽量保持在非常低的水平</p>          </div><br>最后设置运行的终止条件，对于回归问题通常可以设置个体与目标之间的差值低于某一水平时终止运行。在这个例子中设定当出现适应度小于0.01的个体时，遗传编程终止运行。   </p><h3 id="初始种群生成和个体评估"><a href="#初始种群生成和个体评估" class="headerlink" title="初始种群生成和个体评估"></a>初始种群生成和个体评估</h3><p>初始种群从搜索空间中随机挑选得到，这个例子中随机生成的初始种群中的四个个体如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220115142521.png width=60%>  </p><p>通过解释，这四个个体表示为：$x+1$、$x^2+1$、$2$和$x$。<br>将这四个个体$\hat{y}$分别带入适应度函数中，可以计算得出四个个体的适应度为0.67、1.0、1.67和2.67，可视化表示如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220115143355.png width=70%><br>可以发现前两个个体(a)、(b)的适应度更低（或者说更“好”），在这个例子中意味着这两个个体更接近与目标，它们有更高的概率被选择做遗传操作。   </p><h3 id="遗传操作-1"><a href="#遗传操作-1" class="headerlink" title="遗传操作"></a>遗传操作</h3><h4 id="复制-1"><a href="#复制-1" class="headerlink" title="复制"></a>复制</h4><p>由于个体(a)适应度最好，它更有高概率被选择。此处假设它被选择出来进行复制操作，它被复制到下一代种群中。即它在下一代被保留。  </p><h4 id="突变-1"><a href="#突变-1" class="headerlink" title="突变"></a>突变</h4><p>假设个体(c)的某个点位发生了突变，其下面的子树会被一个随机生成的子树替代，如图所示。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220115144408.png width=50%><br>可以发现，原本适应度不佳的个体(c)通过突变后，其适应度可能会有所好转。<strong>除了在运行快要收敛时对现有种群施加扰动、改善算法的运行情况外</strong>，<strong>突变还能够有概率地改善适应度不加的个体的适应度，在搜索空间中调整在这些点附近的查找方向。</strong>  </p><h4 id="交叉-1"><a href="#交叉-1" class="headerlink" title="交叉"></a>交叉</h4><p>前两个个体(a)、(b)的适应度更好，更有高概率被选择配对进行交叉操作，假设(a)(b)个体发生如下图所示的交叉：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220115145005.png width=60%>  </p><p>可以发现，个体(a)和个体(b)中各自都有一部分贴近于目标函数（称为各自的优良性状），<strong>通过交叉，两个亲本的优良性状更容易被结合，从而生成更加贴近目标的后代。</strong>  </p><h3 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h3><p>通过遗传操作后的后代如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220115145739.png width=60%><br>可以发现，个体(d)的适应度已经为0，达到了预先设定的终止条件，遗传编程停止运行。  </p><h2 id="遗传编程的高级特性"><a href="#遗传编程的高级特性" class="headerlink" title="遗传编程的高级特性"></a>遗传编程的高级特性</h2><p>除了可以通过上述简单的例子表现出来的遗传编程的选择机制之外，遗传编程还拥有许多高级特性，在此进行简单介绍。  </p><h3 id="强类型"><a href="#强类型" class="headerlink" title="强类型"></a>强类型</h3><p>强类型（Strong type）指的是程序中表达的任何对象所从属的类型都必须能在编译时刻确定。<br>强类型是针对类型检查的严格程度而言的，它指任何变量在使用的时候必须要指定这个变量的类型，而且在程序的运行过程中这个变量只能存储这个类型的数据。因此，对于强类型语言，一个变量不经过强制转换，它永远是这个数据类型，不允许隐式的类型转换（例如Python中变量的数据类型取决于赋值而并非事先声明）。<br>上面的例子中，端点集和函数集并不是非常严格地指定了数据类型（比如上面的例子中端点集可以是常数，也可以是随机变量，函数也没有严格地指定输入的数据类型）。但是大部分问题对程序的要求都需要指定程序输入和输出的数据类型：比如在扫地机器人的例子中，函数“旋转”的输入一定是一个角度值，而“前进”的输入一定是一个距离。<br>将强类型语法应用于遗传编程中，用于限制树的结构和构成方式。在强类型的遗传编程随机过程中，如果一个下层节点的输出类型和它连接的一个上层节点输入类型不一致，那么存在这种连接的树会被丢弃。<br>在生成初始个体时，应该使所有的初始个体都满足强类型语法，并且要使得所有的遗传操作也要满足强类型语法的条件，这样最终筛选出来的个体也会是强类型的。  </p><h3 id="自动定义函数"><a href="#自动定义函数" class="headerlink" title="自动定义函数"></a>自动定义函数</h3><p>像人类编程的程序中会编写子函数一样，遗传编程会利用问题对称性、规律性和模块性的特点，将个体之间结构、形状相似的部分自动定义为若干个小模块/子程序，称为自动定义函数（Automatically defined function，ADF），这些模块允许在重用时其输入的变量根据问题的不同而变化。<br><div class="note note-info">            <p>通常ADF的端点集和函数集与主程序的端点集和函数集有所不同。  </p>          </div></p><p>自动定义函数会随着与主程序一起动态演化，并且可以在进化过程的同时被调用和递归调用。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220119143133.png width=70%><br>自动定义函数机制使得遗传编程能参数化重用和分层调用某一个模块，减小进化过程的回归压力，降低计算量。在问题层面上，自动定义函数机制能够将问题分解为若干个模块、简化问题的解决流程。随着问题的复杂程度上升，自动定义函数机制可以明显的减缓计算量和个体大小的上升，实验表明，在复杂问题中应用这样的机制简化计算是非常有效的。  </p><h3 id="程序的结构和结构转换操作"><a href="#程序的结构和结构转换操作" class="headerlink" title="程序的结构和结构转换操作"></a>程序的结构和结构转换操作</h3><h4 id="程序的结构"><a href="#程序的结构" class="headerlink" title="程序的结构"></a>程序的结构</h4><p>在遗传编程中，个体/程序的结构（architecture）包括：  </p><ul><li>分支的总数量</li><li>分支的类型（比如有自动定义函数分支，自动定义迭代分支，自动定义循环分支，解决生成分支）  </li><li>每个分支中端点/声明的数量</li><li>分支的层级</li></ul><h4 id="结构转换-1"><a href="#结构转换-1" class="headerlink" title="结构转换"></a>结构转换</h4><p>在遗传编程中，如何找到目标个体的结构也是一个问题。结构转换操作（architecture-altering operations）提供了一种方法：在遗传编程运行期间动态地向单个程序添加和删除子程序和其他类型的分支并添加或删除它们的参数。结构变换是针对一种程序结构的遗传操作，迭代运行结构变换后可以给出一个符合目标比较好的程序结构。由于结构变换本身具有破坏性，通常结构变换发生的概率很小，只有0.5%-1%。<br>有如下的几种常见的结构变换操作，如下表所示：  </p><div class="table-container"><table><thead><tr><th style="text-align:center">操作类型</th><th style="text-align:left">说明</th><th style="text-align:center">图示</th></tr></thead><tbody><tr><td style="text-align:center">子程序复制 <br> subroutine duplication</td><td style="text-align:left">复制单个程序中预先存在的子程序，并为其副本指定新名称，并将预先存在的调用到该子程序的树复制为两部分。<br>此操作通过扩展整个程序中子程序的层次结构来改变整个个体的结构。与自然界中的基因复制一样，这种操作在第一次发生时保留了语义。这两个子例程通常在稍后发散，有时产生专门化。</td><td style="text-align:center"><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/branch-dup2.gif></td></tr><tr><td style="text-align:center">子程序删除 <br> subroutine deletion</td><td style="text-align:left">删除一个子程序分支</td><td style="text-align:center"><img src = http://www.genetic-programming.com/branch-delete.gif></td></tr><tr><td style="text-align:center">子程序创建 <br> subroutine creation</td><td style="text-align:left">使用主结果生成分支的一部分创建新的子例程，从而通过在主程序和新的子程序之间创建分层引用深化整个程序中引用的分层。子程序创建操作还可以从现有子程序的一部分创建一个新的子程序，通过在先前存在的子例程和新的子程序之间创建一个层次引用以及一个更深更复杂的整体层次结构，进一步深化引用的层次结构。</td><td style="text-align:center"><img src = http://www.genetic-programming.com/branch-create2.gif></td></tr><tr><td style="text-align:center">参数复制 <br> argument duplication</td><td style="text-align:left">复制子程序的一个参数，随机划分对它的内部引用，并通过调整对子例程的所有调用来保留整个程序语义。此操作放大了子例程操作的子空间的维数</td><td style="text-align:center"><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/arg-dup2.gif></td></tr><tr><td style="text-align:center">参数删除 <br> argument deletion</td><td style="text-align:left">删除某个子程序下的参数</td><td style="text-align:center"><img src=http://www.genetic-programming.com/arg-delete.gif></td></tr></tbody></table></div><p>总而言之，结构转换提供了一种寻找目标个体结构的方法，其优点是能够随着主进化过程一同动态变换。<br>除了结构转换外，寻找目标个体结构的方式还有：  </p><ul><li>人为设置程序的结构<br>这种方法是一种静态设置的方法，适合在能够通过经验判断目标结构、目标结构比较简单时使用，可以节省计算量。  </li><li>使用遗传编程进化出合适的目标结构<br>这种方法需要像上述运行流程一样首先随机生成若干个结构，应用迭代和筛选选择出合适的目标结构，相比于结构转换操作，这种方法的计算量较大，但是产生的目标结构可能更为贴切。  </li></ul><h2 id="遗传编程的理论分析"><a href="#遗传编程的理论分析" class="headerlink" title="遗传编程的理论分析"></a>遗传编程的理论分析</h2><p>遗传编程的的本质是一种在程序组成的搜索空间内搜索目标问题最优解的搜索方法。在最初阶段，遗传编程会从搜索空间中随机的几个点（即初始种群）开始搜索，这些个体中优于平均水平的个体会通过遗传操作在它们的周围搜索更优秀的个体，随着遗传编程的进行，这些随机分布的点会朝着某一方向移动，最终聚拢。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220115130107.png width=80%>  </p><p>不过在高维和复杂的搜索空间中去可视化这样的过程从而探究遗传编程的运行机理不太可行，另外一种探究遗传编程的运行机理的方式是在相同条件下运行数次遗传算法，观察运行结果，通过经验和分析运行过程中的一些参数变化得出结论。这种方法很容易出错，因为遗传编程系统是一个复杂的自适应系统，有无数个自由度。因此，任何少量的统计描述符都可能只能捕捉到这样一个系统复杂性的一小部分。<br>由Holland提出的模式理论（schema theory）是另一种可行的解决方法，模式理论可以基于上一代种群的信息，推演出现有种群中某个特定个体的进化性质。<br>在遗传编程中，模式是一种含有通配符（don’t care）的树，通配符可以是一些函数或者端点。一个特定的模式可以代表所有的与这个模式形状结构相同、大小相同、非通配符节点也相同的一类个体，一个模式代表了一个子种群（sub-population）。<br>比如模式$H=(*x(+y*))$可以表示：$(+x(+yx))$,$(+x(+yy)),(\%x(+yx))$等等个体。<br>令$α(H,t)$表示模式$H$在$t$代的进化采样率，即在$t$代中模式$H$中的个体得到进化的概率，即$t+1$代种群中有模式$H$中的个体数目与$t+1$代种群中的总个体数目之比,$α(H,t)=p(H,t+1)$。假设进化过程中只有复制和单点交叉发生，那么$t$代个体中含有$H$的概率分为两部分：$H$中的个体被复制到下一代的概率和现有种中交叉产生的后代在$H$中的概率：  </p><script type="math/tex; mode=display">α(H,t)=P_r[\text{via repoduction}]+P_r[\text{via crossover}]</script><p>设每个个体发生复制的概率为$p_r$，发生交叉的概率为$p_c$，$p_c+p_r=1$:  </p><script type="math/tex; mode=display">α(H,t)=p_rP_r[\text{via repoduction}]+p_cP_r[\text{via crossover}]</script><p>对于前项，选择$H$中的个体发生复制的概率为：  </p><script type="math/tex; mode=display">P_r[\text{via repoduction}]=p(H,t)=P(H,t)\frac{f(H,t)}{\overline{f}}</script><p>其中$P(H,t)$表示从第$t$种选择一个来自$H$的个体的概率，$\frac{f(H,t)}{\overline{f}}$表示均值归一化后的$H$的平均适应度。<br>对于第二项，选择两个个体，它们的形状为$k$,$l$，已知形状$k$和$l$在交叉点$i$和$j$被选择时，发生交叉后的个体会落入模式$H$，那么通过交叉产生个体落入$H$的概率分解为两步：  </p><ul><li>从所有配对的亲本中选择出形状$k$和形状$l$，这个概率记为$P_r[k,l]$。  </li><li>在形状$k$中选择出交叉点$i$，在形状$l$中选择出交叉点$j$，这个概率记为$P_r[i,j|k,l]$。<br>根据条件概率公式，有选择形状$k$,$l$且选择出交叉点$i$，$j$的概率为：  <script type="math/tex; mode=display">P_r[i,j,k,l]=P_r[i,j|k,l]×P_r[k,l]</script><script type="math/tex; mode=display">P_r[\text{via crossover}]=∑_{k,l}∑_{i,j}P_r[i,j,k,l]</script>假设形状相同的个体中的每个交叉点被选到的概率是相同的，在形状$k$中选择出交叉点$i$，在形状$l$中选择出交叉点$j$均为其形状中含有的节点数分之一：  <script type="math/tex; mode=display">P_r[i,j|k,l]=\frac{1}{nodes_k}×\frac{1}{nodes_l}</script>对于$P_r[k,l]$，为了简化计算，假设两个树中一个树的某个节点上方满足在$H$内的个体的结构，另一个树的下方满足在$H$内的个体的结构，那么：  <script type="math/tex; mode=display">P_r[k,l]=P_r[k]×P_r[l]</script>$P_r[k]$和$P_r[l]$分别表示从$t$代中选择这两种形状的个体的概率：<br>$P_r[k]=p(k,t)$,$P_r[l]=p(l,t)$。  <script type="math/tex; mode=display">P_r[k,l]=p(k,t)×p(l,t)</script></li></ul><p>进而可以给出理论上$H$的采样率下界：  </p><script type="math/tex; mode=display">α(H,t)=p(H,t)+∑_{k,l}∑_{i,j}\left[\frac{1}{nodes_k}×\frac{1}{nodes_l}×p(k,t)×p(l,t)\right]</script><p>通过采样率下界，可以估计子种群$H$经过遗传操作，下一代中个体在子种群$H$中的数目的期望为：  </p><script type="math/tex; mode=display">E[M(H,t+1)]=M(H,t)α(H,t)</script><p>由于$p()=P()\frac{f()}{\overline{f}}$，可以发现整个采样率$α$的表达式与子种群$H,k,l$的采样率及其适应度有关：子种群$H,k,l$的适应度$\frac{f(H,t)}{\overline{f}}$，$\frac{f(k,t)}{\overline{f}}$，$\frac{f(l,t)}{\overline{f}}$的适应度越高，$H$的采样率$α$就越高，进而可以推出：<strong>随着遗传编程的运行，每一代种群中适应度高的子种群越倾向于被保留，采样率逐步升高。</strong> 理论上，在经过若干次进化后，种群中的所有个体都将是搜索空间中适应度较高的个体。  </p>]]></content>
    
    
    <categories>
      
      <category>遗传算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数字信号处理-知识点总结</title>
    <link href="/2021/12/28/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    <url>/2021/12/28/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="数字信号处理-知识点总结"><a href="#数字信号处理-知识点总结" class="headerlink" title="数字信号处理-知识点总结"></a>数字信号处理-知识点总结</h1><h2 id="离散信号和系统的性质"><a href="#离散信号和系统的性质" class="headerlink" title="离散信号和系统的性质"></a>离散信号和系统的性质</h2><h3 id="线性"><a href="#线性" class="headerlink" title="线性"></a>线性</h3><p>对于系统$H$，有$y_1[n]=H[x_1[n]]$,$y_2[n]=H[x_2[n]]$，如果：</p><script type="math/tex; mode=display">H[A_1x_1[n]+A_2x_2[n]]=A_1y_1[n]+A_2y_2[n]</script><p>称系统是线性的。  </p><h3 id="时不变"><a href="#时不变" class="headerlink" title="时不变"></a>时不变</h3><p>对于系统$H$，有$y[n]=H[x[n]]$，如果：  </p><script type="math/tex; mode=display">H[x[n-τ]]=y[n-τ]</script><p>称系统是时不变的。  </p><h3 id="稳定"><a href="#稳定" class="headerlink" title="稳定"></a>稳定</h3><p>对于系统$H$，如果系统输入有界$x[n]&lt;∞$，系统输出$y[n]&lt;∞$，称系统是稳定的。  </p><h3 id="因果"><a href="#因果" class="headerlink" title="因果"></a>因果</h3><p>对于系统$H$，如果系统输出$y[n]$不与未来系统的输入$x[n+m],m∈Z^*$有关，称系统是因果的。  </p><h3 id="周期性"><a href="#周期性" class="headerlink" title="周期性"></a>周期性</h3><p>如果序列满足：  </p><script type="math/tex; mode=display">x[n+N]=x[n]</script><p>那么序列是周期的。<br>对于正弦序列$x[n]=Acos(\omega_0n+φ)$，如果：</p><script type="math/tex; mode=display">N=\frac{2πk}{ω_0},k=0,1,2...,N-1</script><p>能找到$k$使得$N$是一个整数，那么这个正弦序列是周期的。  </p><h3 id="共轭对称和共轭反对称"><a href="#共轭对称和共轭反对称" class="headerlink" title="共轭对称和共轭反对称"></a>共轭对称和共轭反对称</h3><p>对于某个序列中的每一项$x[n]$可以拆解为实部和虚部的形式：$x[n]=x_r[n]+jx_i[n]$:<br>如果另一个序列的每一项满足：</p><script type="math/tex; mode=display">x_e^*[n]=x_r[n]-jx_i[n]</script><p>称序列$x_e^*[n]$是序列$x[n]$的共轭对称序列。  </p><p>如果另一个序列$x_o^*[n]$的每一项满足：  </p><script type="math/tex; mode=display">x_o^*[n]=-(x_r[n]-jx_i[n])</script><p>称序列$x_o^*[n]$是序列$x[n]$的共轭反对称序列。  </p><h2 id="离散时间域分析方法"><a href="#离散时间域分析方法" class="headerlink" title="离散时间域分析方法"></a>离散时间域分析方法</h2><h3 id="离散时间傅里叶变换"><a href="#离散时间傅里叶变换" class="headerlink" title="离散时间傅里叶变换"></a>离散时间傅里叶变换</h3><p>一个信号可以被分解为系数与本征函数的线性组合:  </p><script type="math/tex; mode=display">x[n]=∑w[n]E[n]</script><p>其中$E[n]$为本征函数。<br>离散时间傅里叶变换（DTFT）的物理意义是一个离散序列$x[n]$可以表示为无数个指数序列的线性组合，这个线性组合的系数为其离散时间傅里叶变换的结果：  </p><script type="math/tex; mode=display">x[n]=\frac{1}{2π}∫_{-π}^πX(e^{jω})e^{jωn}dω</script><script type="math/tex; mode=display">X(e^{jω})=∑x[n]e^{-jωn}</script><p>直接计算离散时间傅里叶变换的两种方法：  </p><ul><li>递推法，适用于出现系统反馈$y[n-m]$时。  </li><li>通项定义法，根据定义写出通项表达式，使用等比数列求和后用欧拉公式进行化简。  </li></ul><h4 id="线性卷积"><a href="#线性卷积" class="headerlink" title="线性卷积"></a><strong>线性卷积</strong></h4><p>两个序列的线性卷积表示为：  </p><script type="math/tex; mode=display">x[n]*y[n]=∑_{m}x[m]y[m-n]</script><p>当其中一个输入为$x[n]=e^{jωn}$时，线性卷积的结果是另一个输入的离散时间傅里叶变化结果$Y(e^{jω})$。  </p><h5 id="线性卷积的时域计算方法"><a href="#线性卷积的时域计算方法" class="headerlink" title="线性卷积的时域计算方法"></a><strong>线性卷积的时域计算方法</strong></h5><p>时域计算两个有限长度序列的线性卷积的方法为不进位乘法，方法为：<br>两个序列的末尾（最右边）对齐，做竖式乘法，其每一位的结果不进位，得到线性卷积后的结果。<br>结果中$n=0$一项的位置由第一个序列中最右边距离$n=0$的位置$N_1$与第二个序列中最右边距离$n=0$的位置$N_2$确定，结果中$n=0$一项的位置为从右往左数第$N_1+N_2-1$项。  </p><h3 id="Z变换"><a href="#Z变换" class="headerlink" title="Z变换"></a>Z变换</h3><script type="math/tex; mode=display">X_r(e^{jω})=∑x[n]r^{-n}e^{-jωn}=∑x[n](re^{jω})^{-n}</script><p>将：$re^{jω}$简记为$z$，得到Z变换的变换公式：  </p><script type="math/tex; mode=display">X(z)=∑x[n]z^{-n}</script><p>常用的两个序列的Z变换：  </p><script type="math/tex; mode=display">δ[n]↔1,Aδ[n-n_0]↔Az^{-n_0}</script><script type="math/tex; mode=display">a(b)^nu[n]↔\frac{a}{z-b}</script><h4 id="Z变换的收敛域"><a href="#Z变换的收敛域" class="headerlink" title="Z变换的收敛域"></a>Z变换的收敛域</h4><p>Z反变换的结果会根据Z变换收敛域的不同而不同。序列特征和对应Z变换的收敛域如下表所示：  </p><div class="table-container"><table><thead><tr><th style="text-align:center">序列类型</th><th style="text-align:center">收敛域</th><th style="text-align:center">图示</th></tr></thead><tbody><tr><td style="text-align:center">右边序列：$x[n]=a^nu[n]$</td><td style="text-align:center">$‖z‖&gt;‖a‖$</td><td style="text-align:center"><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211001142544.png width=50%></td></tr><tr><td style="text-align:center">左边序列：$x[n]=-a^nu[-n-1]$</td><td style="text-align:center">$‖z‖&lt;‖a‖$</td><td style="text-align:center"><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211001142726.png width=50%></td></tr><tr><td style="text-align:center">双边序列:$x[n]=a^nu[n]-b^nu[-n-1]$</td><td style="text-align:center">$‖a‖&lt;‖z‖&lt;‖b‖$</td><td style="text-align:center"><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211001142950.png width=50%></td></tr></tbody></table></div><p>收敛域对应系统的性质：  </p><ul><li><strong>右边序列对应系统因果</strong>。</li><li><strong>系统稳定时，收敛域应当包括单位圆</strong>。</li></ul><h4 id="Z反变换"><a href="#Z反变换" class="headerlink" title="Z反变换"></a>Z反变换</h4><p>通常，Z反变换使用部分分式法来求解，基本步骤是：  </p><ol><li>对分母做因式分解，找到极点。  </li><li>根据因式分解结果将整个式子拆分为多个分数相加的形式，并找到零点。  </li><li>进行反变换。  </li></ol><p>反变换时需要根据$z-a_i$的正负对Z变换的收敛域进行讨论:  </p><ul><li>当$|z|&lt;(a_i)_{min}$时，根据极点对应序列形式（收敛特性一小节中提到的表格），该项对应的指数序列为左边序列$-A_i(a_i)^nu[-n-1]$。</li><li>当$|z|&gt;(a_i)_{max}$时，根据极点对应序列形式，该项对应的指数序列为右边序列$A_i(a_i)^nu[n]$。</li><li>当$a_{min}&lt;|z|&lt;a_{max}$时，根据极点对应序列形式，该项对应的指数序列为双边序列。</li></ul><div class="note note-warning">            <p>需要注意左边序列每一项前面的符号为负：$-A_i(a_i)^nu[-n-1]$  </p>          </div><h3 id="离散傅里叶变换-离散傅里叶级数"><a href="#离散傅里叶变换-离散傅里叶级数" class="headerlink" title="离散傅里叶变换/离散傅里叶级数"></a>离散傅里叶变换/离散傅里叶级数</h3><p>N点离散傅里叶变换定义为：  </p><script type="math/tex; mode=display">X[k]=∑_{n=0}^{N-1}x[n]e^{-j\frac{2π}{N}kn}</script><p>反变换为：  </p><script type="math/tex; mode=display">x[n]=\frac{1}{N}∑_{k=0}^{N-1}X[k]e^{j\frac{2π}{N}kn},0≤n≤N-1</script><p>离散傅里叶级数则是当变换对象为周期序列$\tilde{x}[n]$时的离散傅里叶变换结果。相当于取周期序列$\tilde{x}[n]$的主值序列进行离散傅里叶变换后进行周期延拓。<br>计算时需要注意：<br>当$N$大于序列长度时，使用0对$x[n]$进行填充。<br>当$N$小于序列长度时则会发生混叠（Alising）。长度为$L$的序列$x[n]$发生混叠的过程表示为：  </p><script type="math/tex; mode=display">\begin{aligned}x[0],x[1],...,&x[N],...,x[L-2],x[L-1]\\    &⇓\\x[0]+x[N],x[1]+&x[N+1],...,x[N-1]+x[2N-1]\end{aligned}</script><p>简单来说就是把超出$N$的序列部分截断，与原序列从$x[0]$开始对位叠加。  </p><p>直接计算离散傅里叶变换的两种方法：  </p><ul><li>递推法，适用于出现系统反馈时。  </li><li>通项定义法，根据定义写出通项表达式，使用等比数列求和后用欧拉公式进行化简。  </li></ul><div class="note note-info">            <p>离散傅里叶变换计算中可能会用到的重要公式：  </p><ul><li>等比数列求和公式：<br>对于公比为$q$,长度为$n$的等比数列，其和为：  <script type="math/tex; mode=display">\frac{a_1(1-q^n)}{1-q}</script></li><li>欧拉公式：  <script type="math/tex; mode=display">cosx=\frac{1}{2}(e^{-jx}+e^{jx})</script><script type="math/tex; mode=display">sinx=\frac{1}{2j}(e^{jx}-e^{-jx})</script></li></ul>          </div><div class="note note-info">            <p>$x[n]=e^{jω_0n}$具有周期性：  </p><script type="math/tex; mode=display">x[n]=e^{jω_0n}=e^{j(ω_0+2πk)n}=x[n+N]</script><p>复指数序列$x[n]$具有周期性，称$N$为其周期。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/A5EC68750987DF38D05E1771EF035FF2.png width=50%></p>          </div><h4 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h4><p>$x[n]$的N点左移$m$的循环移位结果为$x[(n+m)modN]$。<br>$(n+m)modN$运算的含义是取序列的$0-N$部分以$N$为周期进行延拓，延拓后的序列向左平移$m$个单位，取现在序列$0-N$的结果。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211016144821.png width=50%>  </p><h4 id="循环卷积和周期卷积"><a href="#循环卷积和周期卷积" class="headerlink" title="循环卷积和周期卷积"></a>循环卷积和周期卷积</h4><p>定义两个序列非周期序列的$N$点$x[n]$、$y[n]$循环卷积/圆周卷积（Circular shift）为：  </p><script type="math/tex; mode=display">x[n]⊗_Ny[n]=∑_{m=0}^{N-1}x[m]y[(n-m)mod(N)]</script><p>同样地，当$N$大于两个序列的长度时，直接将两个序列的长度用0填充到长度$N$，再进行循环卷积。<br>当$N$小于两个序列的长度时，循环卷积时则会发生混叠。<br>$x[n]$和$y[n]$具有相同的序列长度，两个序列长度如果不相同，使用0进行补齐。<br>其物理意义是将其中一个序列反转（称为反褶）后，进行$N$点循环时移$m$次，与原序列线性卷积的结果。  </p><p>在频域上，循环卷积对应两个序列DFT的乘积：  </p><script type="math/tex; mode=display">x[n]⊗y[n]↔X[k]Y[k]</script><h5 id="圆周卷积的时域计算方法"><a href="#圆周卷积的时域计算方法" class="headerlink" title="圆周卷积的时域计算方法"></a><strong>圆周卷积的时域计算方法</strong></h5><p>圆周卷积在时域上可以通过矩阵快速计算：  </p><script type="math/tex; mode=display">x[n]⊗y[n]=\left[\begin{matrix}    z[0] \\    z[1] \\    ...\\    z[N-2] \\    z[N-1]\end{matrix}\right]=\left[\begin{matrix}    y[0] & y[N-1] & ...& y[2] & y[1]\\    y[1] & y[0] & ...& y[3] & y[2]\\    ...&...&...&...&...\\    y[N-2] & y[N-1] & ...& y[0] & y[N-1]\\    y[N-1] & y[N-2] & ...& y[1] & y[0]\\\end{matrix}\right]\left[\begin{matrix}    x[0] \\    x[1] \\    ...\\    x[N-2] \\    x[N-1]\end{matrix}\right]</script><p>可以发现矩阵$Y$内部每一列的元素在进行周期性的位置轮换。  </p><p>周期卷积则是将两个同周期的周期序列$\tilde{x_1}[n]$、$\tilde{x_2}[n]$的主值序列进行循环卷积后进行周期延拓的计算。  </p><h3 id="离散时间傅里叶变换、Z变换、离散傅里叶变换的关系"><a href="#离散时间傅里叶变换、Z变换、离散傅里叶变换的关系" class="headerlink" title="离散时间傅里叶变换、Z变换、离散傅里叶变换的关系"></a>离散时间傅里叶变换、Z变换、离散傅里叶变换的关系</h3><p>周期序列$\tilde{x}[n]$做傅里叶级数分析后一周期内（$0≤n≤N-1$）的结果与$x[n]$做离散傅里叶变换的结果完全一致。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211016143431.png width=50%></p><p>可以发现：<strong>离散傅里叶级数是对离散时间傅里叶变换的结果进行采样，而一周期内的采样结果则为离散傅里叶变换的结果。</strong><br>对于Z变换，$z=re^{jω}$，如果选择$r=1$，那么Z变换将退化为离散时间傅里叶变换：  </p><script type="math/tex; mode=display">X(e^{jω})=X(z)|_{z=e^{jω}}</script><p>因此，Z域单位圆上的任意一点表示$e^{jω}$。<br>而离散傅里叶变换是对离散时间傅里叶变换一周期内的采样，因此离散傅里叶变换是在Z域单位圆上的均匀采样。  </p><h4 id="线性卷积、循环卷积、周期卷积的关系"><a href="#线性卷积、循环卷积、周期卷积的关系" class="headerlink" title="线性卷积、循环卷积、周期卷积的关系"></a>线性卷积、循环卷积、周期卷积的关系</h4><p><strong>当循环卷积的点数大于$2L-1$（即线性卷积的长度）时，其结果与线性卷积（$x[n]*y[n]$）完全相同。</strong><br>如果$\tilde{x_1}[n]$、$\tilde{x_2}[n]$分别对应是$x_1[n]$、$x_2[n]$以周期为$N$的延拓，有：  </p><script type="math/tex; mode=display">(x_1[n]⊗_Nx_2[n])R_N=\tilde{x_1}[n]\tilde{⊗}_N\tilde{x_2}[n]</script><p>$R_N$表示以周期为$N$的延拓。<br>即<strong>在周期卷积对象的主值序列是循环卷积对象时，$N$点循环卷积是$N$点周期卷积的主值序列。</strong></p><h3 id="快速傅里叶变换"><a href="#快速傅里叶变换" class="headerlink" title="快速傅里叶变换"></a>快速傅里叶变换</h3><p>快速傅里叶变换是计算离散傅里叶变换的一种近似计算方式。只有在序列长度为$2^n$时才能够使用。<br>快速傅里叶变换的结构基于蝶形运算：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211222132037.png width=70%><br>对于$N=2^m$，需要$m$级次蝶形结构的运算。  </p><p>快速傅里叶变换的步骤是：  </p><ol><li>做比特镜像反转，即1点FFT。  </li><li>对$i$级，其$x[n]$和$x[n+i]$配对，使用蝶形结构进行运算。  </li><li>重复上述过程，直到达到对应的级，完成$N$点FFT的计算。</li></ol><p>如果序列长度为$N$，其计算量为：  </p><script type="math/tex; mode=display">N+\frac{N}{2}log_2N</script><p>一个8点快速傅里叶变换结构如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211030144723.png width=80%></p><h2 id="系统的表示方法"><a href="#系统的表示方法" class="headerlink" title="系统的表示方法"></a>系统的表示方法</h2><p>对于一个离散系统，其差分方程为：  </p><script type="math/tex; mode=display">∑_{k=0}^Na_ky[n-k]=∑_{k=0}^Mb_kx[n-k],a_0≠0,b_0≠0</script><h3 id="系统的单位采样响应-系统的冲激响应"><a href="#系统的单位采样响应-系统的冲激响应" class="headerlink" title="系统的单位采样响应/系统的冲激响应"></a>系统的单位采样响应/系统的冲激响应</h3><p>系统的单位采样响应指输入为$δ[n]$时候的系统输出$h[n]$。通常可以带入$x[n]=δ[n]$到差分方程递归运算得到。也可以通过对系统的频率响应求Z反变换得到。<br>系统输出可以表示为：  </p><script type="math/tex; mode=display">y[n]=x[n]*h[n]</script><h3 id="系统的频率响应-转换方程"><a href="#系统的频率响应-转换方程" class="headerlink" title="系统的频率响应/转换方程"></a>系统的频率响应/转换方程</h3><p>当系统的输入$x[n]=e^{jωn}$时：  </p><script type="math/tex; mode=display">y[n]=e^{jωn}∑h[k]e^{-jωk}</script><p>$∑h[k]e^{-jωk}$正好对应其离散时间傅里叶变换$H(e^{jω})$，称为其频率响应。<br>频率响应可以通过观察差分方程快速写出：  </p><script type="math/tex; mode=display">H(e^{jω})=\frac{∑b_ke^{-jωk}}{∑a_ke^{-jωk}}</script><p>带入$z=e^{jω}$，得到其Z域下的表现称为转换方程：  </p><script type="math/tex; mode=display">H(z)=\frac{∑b_kz^{-k}}{∑a_kz^{-k}}</script><p>也可以通过对$h[n]$求离散时间傅里叶变换得到。<br>由于Z域的收敛域可以不同，一个转换方程/差分方程可以对应多个冲激响应。但是只有当系统因果时，才能具备离散时间傅里叶变换的条件。<br>因此，只有系统的冲激响应$h[n]$和系统的频率响应$H(e^{jω})$可以确定唯一的系统。</p><h3 id="系统的幅频响应和相频响应"><a href="#系统的幅频响应和相频响应" class="headerlink" title="系统的幅频响应和相频响应"></a>系统的幅频响应和相频响应</h3><p>系统的频率响应也可以写作：  </p><script type="math/tex; mode=display">H(e^{jω})=|H(e^{jω})|e^{-j∠H(e^{jω})}</script><p>$|H(e^{jω})|$是系统的幅度值-频率响应（Magnitude-frequency response）简称幅频响应或者幅度值响应。$∠H(e^{jω})$是系统的相位-频率响应，简称相频响应或相位响应。<br>系统的幅度相应和相位响应的求法为：<br>将系统频率响应改为对应的Z域方程，找到系统的零点和极点，在Z域上作图。然后连接单位圆上的任意一点，求解零点/极点与该点构成向量（称为零向量和极向量）的模和角度。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211228164840.png width=50%></p><ul><li>系统方程的模长/幅度值(Magnitude)：  <script type="math/tex; mode=display">|H(e^{jω})|=\frac{Π零向量的模长}{Π极向量的模长}</script>即系统方程频率响应$H(e^{jω})$的幅度值-频率响应，简称幅频响应。  </li><li>系统方程的相位：  <script type="math/tex; mode=display">∠H(e^{jω})=∑零向量的角度-∑极向量的角度</script>即系统方程频率响应$H(e^{jω})$的相位-频率响应，简称相频响应。</li></ul><div class="note note-info">            <p>正弦信号通过系统<br>如果正弦信号为$Acos(ω_0t+θ_0)$，通过系统$H(e^{jω})=|H(e^{jω})|e^{-j∠H(e^{jω})}$后的表达式为：  </p><script type="math/tex; mode=display">A|H(e^{jω_0})|cos(ω_0t+θ_0+∠H(e^{jω_0}))</script>          </div><h3 id="FIR系统和IIR系统"><a href="#FIR系统和IIR系统" class="headerlink" title="FIR系统和IIR系统"></a>FIR系统和IIR系统</h3><p>对Z域转换方程做Z反变换：  </p><script type="math/tex; mode=display">h[n]=∑_{r=0}^{M-N}B_rδ[n-r]+∑_{k=1}^NA_k(d_k)^nu[n]</script><p>由于$u[n]$是一个无限长度的序列，因此系统的冲激响应也是无限长度的，称这样的系统为无限冲激响应系统（IIR System）。<br>当$N=0$时，差分方程左边只含有$y[n]$，系统方程的当前输出只由输入$x$决定，系统不含有反馈，此时系统方程为：  </p><script type="math/tex; mode=display">h[n]=∑_{r=0}^{M}B_rδ[n-r]</script><p>由于$δ[n-r]$长度有限，整个系统的冲激响应的长度是有限的，称这样的系统为有限冲激响应系统（FIR System）。  </p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">N</th><th style="text-align:center">差分方程左侧</th><th style="text-align:center">有无反馈</th><th style="text-align:center">冲激响应长度</th></tr></thead><tbody><tr><td style="text-align:center">IIR</td><td style="text-align:center">N&gt;0</td><td style="text-align:center">含有$y[n-k]$</td><td style="text-align:center">有</td><td style="text-align:center">无限</td></tr><tr><td style="text-align:center">FIR</td><td style="text-align:center">N=0</td><td style="text-align:center">只有$y[n]$</td><td style="text-align:center">无</td><td style="text-align:center">有限</td></tr></tbody></table></div><h2 id="滤波器设计"><a href="#滤波器设计" class="headerlink" title="滤波器设计"></a>滤波器设计</h2><h3 id="滤波器的理论结构"><a href="#滤波器的理论结构" class="headerlink" title="滤波器的理论结构"></a>滤波器的理论结构</h3><p>对于FIR滤波器，滤波器的理论结构如下表所示：  </p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">基于的系统表示</th><th style="text-align:center">图示</th></tr></thead><tbody><tr><td style="text-align:center">直接型</td><td style="text-align:center">$y[n]=∑_kh[k]x[n-k]$</td><td style="text-align:center"><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211125161657.png width=50%></td></tr><tr><td style="text-align:center">级联型</td><td style="text-align:center">$Y(z)=G∏_{k=1}^{M_s}(b_{0k}+b_{1k}z^{-1}+b_{2k}z^{-2})X(z)$</td><td style="text-align:center"><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211125170748.png width=50%></td></tr></tbody></table></div><p>对于IIR滤波器，滤波器的理论结构类型如下表所示：  </p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">基于的系统表示</th><th style="text-align:center">图示</th></tr></thead><tbody><tr><td style="text-align:center">直接型</td><td style="text-align:center">$y[n]=v[n]+∑_{k=1}^Na_ky[n-k]$ <br> $v[n]=∑_{k=0}^Mb_kx[n-k]$</td><td style="text-align:center"><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211127131242.png width=50%></td></tr><tr><td style="text-align:center">标准型</td><td style="text-align:center">$H(Z)=\frac{Y(Z)}{W(Z)}\frac{W(Z)}{X(Z)}$ <br> $x[n]=∑_iA_iw[n-i]$ <br> $y[n]=∑_iB_iw[n-i]$</td><td style="text-align:center"><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211127135151.png width=50%></td></tr><tr><td style="text-align:center">级联型</td><td style="text-align:center">$H(z)=G∏_{k=1}^{N_s}\frac{(z_k-z^{-i})}{(p_k-z^{-i})}=G∏_{k=1}^{N_s}H_i(z)$</td><td style="text-align:center"><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211127141419.png width=50%></td></tr><tr><td style="text-align:center">并联型</td><td style="text-align:center">$H(z)=∑_{k=0}^{N_p}C_kz^{-k}+∑_{k=1}^{N_s}\frac{e_{0k}+e_{1k}z^{-1}}{1-a_{1k}z^{-1}-a_{2k}z^{-2}}$</td><td style="text-align:center"><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211127143607.png width=50%></td></tr></tbody></table></div><h3 id="FIR滤波器设计的加窗法"><a href="#FIR滤波器设计的加窗法" class="headerlink" title="FIR滤波器设计的加窗法"></a>FIR滤波器设计的加窗法</h3><p>加窗法的实现依赖于理想低通滤波器，理想低通滤波器的冲激响应为：  </p><script type="math/tex; mode=display">h[n]=\frac{sin(ω_cn)}{πn}</script><p>其中$ω_c$表示其截止频率。  </p><ol><li>设置滤波器的长度$L=2N+1$，并在理想低通滤波器冲激响应上截取$L$个采样点。为了满足线性相位滤波器的条件，通常使用以$h[0]$为对称轴的奇数$L$个序列。定义滤波器的阶数$M$为滤波器序列长度减一：<script type="math/tex; mode=display">M=L-1</script>此时的序列为$\{h[-N],h[-N+1],..,\underset{n=0}{h[0]},..,h[N-1],h[N]\}$,是一个非因果序列。</li><li>对截取的序列做时移以满足系统的因果性，时移量为$α=\frac{L-1}{2}$，称为滤波器的<strong>群时延</strong>(Group delay)。<br>此时的序列为：$\{\underset{n=0}{h[-N]},h[-N+1],..,h[0],..,h[N-1],h[N]\}$</li><li>为了使得滤波器性能更好，还需要对产生的序列进行赋权，产生赋权序列的函数称为窗函数（Window function），赋权的操作为：<script type="math/tex; mode=display">fl[n]=h_d[n]×w[n]</script>其中$h_d[n]$为截取和时移之后的理想低通滤波器序列，$w[n]$由窗函数产生。  </li></ol><div class="note note-warning">            <p>需要注意的是，窗函数的阶数比序列阶数高2，再截掉窗函数序列两端的0后，与理想低通滤波器序列相乘。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211230151430.png width=70%>  </p>          </div><h4 id="窗函数"><a href="#窗函数" class="headerlink" title="窗函数"></a>窗函数</h4><div class="table-container"><table><thead><tr><th style="text-align:center">窗函数类型</th><th style="text-align:center">表达式</th><th style="text-align:center">$e_p=20lgδ$</th><th style="text-align:center">过渡带带宽</th></tr></thead><tbody><tr><td style="text-align:center">三角窗</td><td style="text-align:center">$\begin{cases}\frac{2}{M}n,0≤n≤\frac{M}{2}\\ 2-\frac{2}{M}n,\frac{M}{2}≤n≤M \end{cases}$</td><td style="text-align:center">-25</td><td style="text-align:center">$\frac{2.37π}{M}$</td></tr><tr><td style="text-align:center">汉宁窗</td><td style="text-align:center">$0.5-0.5cos(\frac{2πn}{M})$</td><td style="text-align:center">-44</td><td style="text-align:center">$\frac{5.01π}{M}$</td></tr><tr><td style="text-align:center">海明窗</td><td style="text-align:center">$0.54-0.46cos(\frac{2πn}{M})$</td><td style="text-align:center">-53</td><td style="text-align:center">$\frac{6.27π}{M}$</td></tr><tr><td style="text-align:center">布莱克曼窗</td><td style="text-align:center">$0.42-0.5cos(\frac{2πn}{M})+0.08cos(\frac{4πn}{M})$</td><td style="text-align:center">-74</td><td style="text-align:center">$\frac{9.19π}{M}$</td></tr></tbody></table></div><h3 id="IIR滤波器设计"><a href="#IIR滤波器设计" class="headerlink" title="IIR滤波器设计"></a>IIR滤波器设计</h3><h4 id="模拟滤波器"><a href="#模拟滤波器" class="headerlink" title="模拟滤波器"></a>模拟滤波器</h4><p>定义其通带波纹$R_p$为：  </p><script type="math/tex; mode=display">R_p|_{dB}=-10lg|H_a(jΩ_p)|^2=-10lg\frac{1}{1+ɛ^2}</script><p>止带衰减$A_s$为：  </p><script type="math/tex; mode=display">A_s=-10lg|H_a(jΩ_s)|^2=-10lg\frac{1}{A^2}</script><h4 id="模拟滤波器类型"><a href="#模拟滤波器类型" class="headerlink" title="模拟滤波器类型"></a>模拟滤波器类型</h4><ul><li>巴特沃斯滤波器<br>巴特沃斯滤波器的频率响应：  <script type="math/tex; mode=display">|H(e^{jω})|^2=\frac{1}{1+(\frac{Ω}{Ω_c})^{2N}}</script></li><li><p>切比雪夫滤波器<br>切比雪夫I型滤波器的频率响应：  </p><script type="math/tex; mode=display">|H(e^{jω})|^2=\frac{1}{1+ɛ^2T_N^2(\frac{Ω}{Ω_c})}</script><p>$T_N(x)$为N阶切比雪夫多项式：  </p><script type="math/tex; mode=display">T_N(x)=\begin{cases}  cos(Narccos(x)),0≤x≤1\\  cosh(Narccosh(x)),1≤x≤∞\end{cases}</script><blockquote><p>$cosh(x)=\frac{e^x+e^{-x}}{2}$   </p></blockquote><script type="math/tex; mode=display">ɛ=\sqrt{10^{0.1R_p}-1}</script></li></ul><h4 id="模数转换-冲激响应不变"><a href="#模数转换-冲激响应不变" class="headerlink" title="模数转换-冲激响应不变"></a>模数转换-冲激响应不变</h4><p>脉冲响应不变的映射律：  </p><script type="math/tex; mode=display">h[n]=Th_c(nT)</script><p>脉冲响应不变法的流程：  </p><ol><li>根据设计要求的通带截止频率和止带截止频率将数字角频率还原为模拟角频率：$Ω_p=\frac{ω_p}{T},Ω_s=\frac{ω_s}{T}$。  </li><li>设计出对应的模拟滤波器。  </li><li>求出模拟滤波器的频率响应：$H_c(s)=∑_{k=1}^N\frac{A_k}{s-s_k}$。</li><li>根据映射律：$H(z)=∑\frac{A_k}{1-e^{s_kT}z^{-1}}$，得到数字滤波器的频率响应。  </li></ol><div class="note note-info">            <p>由于其所有的极点在s域以$Ω_c$为半径的圆上均匀分布，因此极点可以根据下图快速求得：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220102213033.png width=60%>  </p><p>可以求得：  </p><script type="math/tex; mode=display">s_k=Ω_ccos(\frac{π}{N}k)-jΩ_csin(\frac{π}{N}k)</script>          </div><h4 id="模数转换-双线性转换"><a href="#模数转换-双线性转换" class="headerlink" title="模数转换-双线性转换"></a>模数转换-双线性转换</h4><p>双线性转换的映射律：  </p><script type="math/tex; mode=display">s=\frac{2}{T}\frac{1-z^{-1}}{1+z^{-1}}</script><p>其模拟角频率与数字角频率之间的关系是：  </p><script type="math/tex; mode=display">Ω=\frac{2}{T}tan\frac{ω}{2}</script><h2 id="MATLAB程序设计基础"><a href="#MATLAB程序设计基础" class="headerlink" title="MATLAB程序设计基础"></a>MATLAB程序设计基础</h2><h3 id="绘制频率响应"><a href="#绘制频率响应" class="headerlink" title="绘制频率响应"></a>绘制频率响应</h3><p>给定系统冲激响应$h[n]$下，绘制其频率响应需要注意的是：  </p><ul><li>需要对$h[n]$进行周期延拓，方法是使用<code>zeros(1,L)</code>创建一个长度为L的全0向量用<code>x=[x,zeros(1,L)]</code>对其填充。  </li><li>使用<code>fft()</code>函数求其FFT结果。<code>abs()</code>求结果的绝对值得到幅频响应，<code>angle()</code>求FFT结果的相频响应。  </li><li>横轴应当为<code>[0:(N+L)]*2*pi/(N+L+1)</code>使得0-2π内每一格的长度为$\frac{2π}{N+L+1}$ （因为<code>0:(N+L)</code>有N+L+1个数）  </li></ul><p>下面的示例程序展示了如何绘制$h[n]=Sa(0.1(n-50)),0≤n≤100$的幅频和相频响应曲线：<br><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs M">N<span class="hljs-built_in">=</span><span class="hljs-number">100</span>; <span class="hljs-comment">%100点FFT</span><br>n<span class="hljs-built_in">=</span><span class="hljs-number">0</span>:N;<br>x<span class="hljs-built_in">=</span>sinc(<span class="hljs-number">0.1</span>*(n-<span class="hljs-number">50</span>));<br>x<span class="hljs-built_in">=</span>[x,zeros(<span class="hljs-number">1</span>,<span class="hljs-number">1000</span>)]; <span class="hljs-comment">%对x周期延拓到长度为1000</span><br>X<span class="hljs-built_in">=</span>fft(x); <span class="hljs-comment">%求其FFT/DFS结果（Amplitude Response）</span><br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br>w<span class="hljs-built_in">=</span>[<span class="hljs-number">0</span>:(N+<span class="hljs-number">1000</span>)]*<span class="hljs-number">2</span>*pi/(N+<span class="hljs-number">1001</span>);<span class="hljs-comment">%横轴，每一格表示2π/(N+1001)</span><br>plot(w./pi,abs(X));  <span class="hljs-comment">%取绝对值求幅频响应（Magnitude Response）并作π归一化</span><br>title(<span class="hljs-string">&#x27;Magnitude Response&#x27;</span>);<br>axis ([<span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">12</span>]);<br>xlabel(<span class="hljs-string">&#x27;\omega/\pi&#x27;</span>);<br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>plot(w./pi,angle(X)); <span class="hljs-comment">% angle(X)表示求其相频响应</span><br>title(<span class="hljs-string">&#x27;Phase Response&#x27;</span>);<br>axis ([<span class="hljs-number">0</span> <span class="hljs-number">2</span> -<span class="hljs-number">4</span> <span class="hljs-number">4</span>]);<br>xlabel(<span class="hljs-string">&#x27;\omega/\pi&#x27;</span>);<br></code></pre></td></tr></table></figure><br>给定系统Z域下的转换方程$H(z)=\frac{∑b_kz^{-k}}{∑a_kz^{-k}}$时，可以使用<code>[H,w]=freqz(b,a,n)</code>返回其频率响应<code>H</code>和对应的π归一化的角频率横轴<code>w</code>，其中<code>a</code>是$∑a_kz^{-k}$由高次幂到低次幂排列时的系数向量，其中<code>b</code>是$∑b_kz^{-k}$由高次幂到低次幂排列时的系数向量，<code>n</code>为计算时所指定的N点FFT的点数，缺省值为512。<br>如下的例程中给出了如何绘制$H(z)=\frac{1-0.5z^{-1}}{1-2z^{-1}+z^{-2}}$的频率响应图：<br><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs m">b<span class="hljs-built_in">=</span>[<span class="hljs-number">1</span>,-<span class="hljs-number">0.5</span>];<br>a<span class="hljs-built_in">=</span>[<span class="hljs-number">1</span>,-<span class="hljs-number">2</span>,<span class="hljs-number">1</span>];<br>[H,w]<span class="hljs-built_in">=</span>freqz(b,a); <br>plot(w,abs(X));  <span class="hljs-comment">%取绝对值求幅频响应（Magnitude Response）</span><br>title(<span class="hljs-string">&#x27;Magnitude Response&#x27;</span>);<br>plot(w,angle(X)); <span class="hljs-comment">% angle(X)表示求其相频响应</span><br>title(<span class="hljs-string">&#x27;Phase Response&#x27;</span>);<br></code></pre></td></tr></table></figure></p><h3 id="卷积函数"><a href="#卷积函数" class="headerlink" title="卷积函数"></a>卷积函数</h3><p>线性卷积计算使用命令<code>conv(x,y)</code>得到。<br>周期卷积计算可以使用命令<code>toeplitz(x,y)</code>得到，其中x,y为两个周期序列的主值序列向量，两个向量长度相同。 当两向量长度不等时，使用0进行填充。  </p><h3 id="滤波器设计-1"><a href="#滤波器设计-1" class="headerlink" title="滤波器设计"></a>滤波器设计</h3><p>MATLAB中，可以使用<code>fir1()</code>函数来进行加窗法的程序设计，其具体表达为：<br><code>fir1(order,omega_c,filtertype,windowtype,&quot;noscale/scale&quot;)</code><br>其中<code>order</code>表示滤波器的阶数；<code>omega_c</code>是π归一化后的滤波器截止频率；<code>filtertype</code>表示设计的滤波器类型，缺省值为低通滤波器<code>&quot;low&quot;</code>；<code>windowtype</code>表示使用的窗函数，缺省值为海宁窗；<code>&quot;noscale/scale&quot;</code>表示是否需要归一化。<br>其中常见的窗函数有：  </p><ul><li><code>boxcar(l)</code>：矩形窗  </li><li><code>hann(l)</code>：海宁窗  </li><li><code>kaiser(l,beta)</code>：凯撒窗<br><strong>l 表示的是滤波器的序列长度，注意与滤波器的阶数作区分。</strong>  </li></ul><p><code>fir1()</code>函数会返回滤波器的冲激响应序列，返回的冲激序列使用<code>[H_f,w]=freqz(h)</code>返回其幅度-频率响应<code>H_f</code>和角频率轴<code>w</code>。<br>其幅度值-频率响应可以通过求其绝对值<code>abs(H_f)</code>得到，相频响应可以通过<code>angle(H_f)</code>得到。<br>下面的例程展示了如何用MATLAB绘制一个序列长度为7，截止频率为0.5π的理想低通滤波器：<br><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs M">h <span class="hljs-built_in">=</span> fir1(<span class="hljs-number">6</span>, <span class="hljs-number">0.5</span>, <span class="hljs-string">&quot;low&quot;</span>,boxcar(<span class="hljs-number">7</span>),<span class="hljs-string">&quot;noscale&quot;</span>); <span class="hljs-comment">% generate the filter</span><br>[hf,w] <span class="hljs-built_in">=</span> freqz(h); <span class="hljs-comment">% 频率响应</span><br>figure(<span class="hljs-number">1</span>);<br>plot(w/pi,abs(hf)); <span class="hljs-comment">% 幅频响应</span><br>xlabel(<span class="hljs-string">&quot;\omega / \pi&quot;</span>)<br>title(<span class="hljs-string">&quot;Magnitude response&quot;</span>);<br>figure(<span class="hljs-number">2</span>);<br>plot(w/pi,angle(hf)); <span class="hljs-comment">% 相频响应</span><br>xlabel(<span class="hljs-string">&quot;\omega / \pi&quot;</span>);<br>title(<span class="hljs-string">&quot;Phase response&quot;</span>);<br></code></pre></td></tr></table></figure><br>下面例程用于生成一个序列长度131，截止频率0.5π，β=4.966的凯撒窗低通滤波器，例程如下：<br><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs M"><span class="hljs-comment">% 生成一个序列长度131，截止频率0.5π，β=4.966的凯撒窗滤波器</span><br>h <span class="hljs-built_in">=</span> fir1(<span class="hljs-number">130</span>, <span class="hljs-number">0.5</span>, <span class="hljs-string">&quot;low&quot;</span>,kaiser(<span class="hljs-number">131</span>,<span class="hljs-number">4.966</span>),<span class="hljs-string">&quot;noscale&quot;</span>); <br>[hf,w] <span class="hljs-built_in">=</span> freqz(h); <span class="hljs-comment">% 幅度-频率响应</span><br>figure(<span class="hljs-number">1</span>);<br>plot(w/pi,abs(hf)); <span class="hljs-comment">% 幅度值-频率响应</span><br>xlabel(<span class="hljs-string">&quot;\omega / \pi&quot;</span>)<br>title(<span class="hljs-string">&quot;Magnitude response&quot;</span>);<br>figure(<span class="hljs-number">2</span>);<br>plot(w/pi,angle(hf)); <span class="hljs-comment">% 相频响应</span><br>xlabel(<span class="hljs-string">&quot;\omega / \pi&quot;</span>);<br>title(<span class="hljs-string">&quot;Phase response&quot;</span>);<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>数字信号处理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>电子系统-知识点总结</title>
    <link href="/2021/12/26/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%AD%90%E7%B3%BB%E7%BB%9F/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <url>/2021/12/26/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%AD%90%E7%B3%BB%E7%BB%9F/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="电子系统-知识点总结"><a href="#电子系统-知识点总结" class="headerlink" title="电子系统-知识点总结"></a>电子系统-知识点总结</h1><h2 id="晶体管电路部分"><a href="#晶体管电路部分" class="headerlink" title="晶体管电路部分"></a>晶体管电路部分</h2><h3 id="晶体管的直流分析"><a href="#晶体管的直流分析" class="headerlink" title="晶体管的直流分析"></a>晶体管的直流分析</h3><p>晶体管的直流分析普遍从$i_b$入手，利用三极电流之间的关系：$i_c=βi_b=αi_e$,$i_c≈i_e$来求得整个电路各部分的值。  </p><h4 id="负载线"><a href="#负载线" class="headerlink" title="负载线"></a>负载线</h4><p>直流负载线是用来探究$V_{CE}$和$I_C$关系的直线：  </p><script type="math/tex; mode=display">V_{CE}=V_{CC}-I_CR_C</script><script type="math/tex; mode=display">I_C=-\frac{1}{R_C}V_{CE}+\frac{V_{CC}}{R_C}</script><p>知道$I_S=\frac{V_{CC}}{R_C}$，即负载线的截距；和$V_{CE}|_{max}=V_{CC}$，即直线与x轴的交点，就能确定晶体管电路的负载线。  </p><h3 id="晶体管的交流分析"><a href="#晶体管的交流分析" class="headerlink" title="晶体管的交流分析"></a>晶体管的交流分析</h3><p>由于电路中耦合电容的存在，因此交流分析和直流分析可以分别对同一个晶体管电路使用。基本步骤是：  </p><ol><li>只看直流，确定电路中的$I_E$、$I_C$、$I_B$。  </li><li>将所有的直流电压源全部视为接地，直流电流源/电流镜电路全部视为短路，并根据发射极是否有额外的电阻画出电路的小信号模型。  <div class="note note-info">            <p>发射极有额外的电阻$R_e$:T模型<br>没有额外的电阻：π模型<br>两个晶体管发射极相连:T模型</p>          </div></li><li>根据直流分析中的$I_E$、$I_C$、$I_B$，确定小信号模型中的$r_e$、$r_π$、$g_m$和$R_0$(厄利效应的等效电阻)。  </li><li>一般而言，从基极开始分析，求出$i_b$后利用$i_c=βi_b$转到集电极分析。得到输出电压。  </li></ol><h4 id="输入阻抗和输出阻抗"><a href="#输入阻抗和输出阻抗" class="headerlink" title="输入阻抗和输出阻抗"></a>输入阻抗和输出阻抗</h4><p>晶体管电路的输入阻抗和输出阻抗都是指的晶体管本身的阻抗，<strong>分析时应当去掉电路中的全部负载</strong>（如输出端电阻$R_L$、输入端电阻$R_{sig}$）。<br>其次，在T模型中分析输入阻抗时，应当把发射极上的全部电阻通过等效$(β+1)(r_e+R_e)$转到基极。<br>输入阻抗和输出阻抗的基本判断方法是当$v_{in}=0$时，从晶体管的输入端口和输出端口看到的电阻。  </p><h3 id="基本的两个双晶体管电路"><a href="#基本的两个双晶体管电路" class="headerlink" title="基本的两个双晶体管电路"></a>基本的两个双晶体管电路</h3><h4 id="电流镜"><a href="#电流镜" class="headerlink" title="电流镜"></a>电流镜</h4><p>电流镜的分析从晶体管的集电极入手，将基极电流用$I_B=\frac{I_C}{β}$表达后求出$I_{REF}$与$I_C$的关系。<br>集电极电压/基极电压需要利用$V_C=V_B=V_{BE}+V_E$求解，再求出$I_C$。<br>电流镜的输出电流与输入电流的关系为：  </p><script type="math/tex; mode=display">I_{o}=area × I_{REF}</script><p>$area$是pn结的面积比。  </p><h4 id="差分对"><a href="#差分对" class="headerlink" title="差分对"></a>差分对</h4><p>对于差分放大电路，求其差分增益，其分析思路有两个：  </p><ul><li>$A_d=\frac{v_{od}}{v_{id}}\frac{v_{id}}{v_{sig_d}}$<br>这是一种“两边一起看”的分析思路，$\frac{v_{od}}{v_{id}}$可以通过晶体管内部输出端电阻和输入端电阻之比$\frac{R_{od}}{R_{id}}$得到。$\frac{v_{id}}{v_{sig_d}}$通过分析基极的分压情况得到。  </li><li>对每个晶体管分开来看<br>通过对基极的分析得到$i_b$，利用$i_c=βi_b$的关系转入集电极分析，用$v_{sig1}$表达$v_{o1}$。最后用$v_{od}=v_{o1}-v_{o2}$求得含有$v_{sigd}$的表达式，移动表达式即可得到差分增益。  </li></ul><h3 id="其他交流分析中用到的重要概念"><a href="#其他交流分析中用到的重要概念" class="headerlink" title="其他交流分析中用到的重要概念"></a>其他交流分析中用到的重要概念</h3><ul><li>差分输入<br>交流分析下$i_C=I_Se^{\frac{V_{BE}}{V_T}}$。<br>在差分放大器电路中可以利用$V_{BE}=V_B-V_E$分别带入两晶体管电路，两式相比可以求得差分输入。  </li><li>晶体管的开环增益<br>开环增益指的晶体管输出端口和输入端口的电压之比：$A_{ol}=\frac{v_{o}}{v_{i}}$。  </li><li>晶体管电路的差分增益<br>差分增益指差分电路中差分电路的输出信号之差与输入信号之差的比：$A_d=\frac{v_{od}}{v_{sigd}}$。  </li><li>共模增益和共模抑制比<br>共模增益指的当输入信号相同，但是两个$R_C$不同引起输出信号不同时的差分增益。<br> 定义共模增益为差分电压和输入电压之比：  <script type="math/tex; mode=display">A_{cm}=\frac{v_{od}}{v_{icm}}=-\frac{αΔR_C}{r_e+2R_{EE}}</script>定义共模抑制比为其差分增益与共模增益之比：  <script type="math/tex; mode=display">CMRR=\frac{A_d}{A_{cm}}</script></li></ul><h3 id="放大电路的频率响应"><a href="#放大电路的频率响应" class="headerlink" title="放大电路的频率响应"></a>放大电路的频率响应</h3><p>由于完整的放大电路中存在耦合电容，当输入的电压信号频率较低时，这些电容的容抗无法在电路分析中忽略，因此放大电路的增益在输入信号为低频信号时有所损失。<br>下图表示了晶体管放大电路的频率响应特性曲线：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211201134850.png width=80%></p><div class="note note-info">            <p>集成放大器中（比如第10讲的多级放大电路）不存在电容，因此其性能不会受到输入信号中低频分量的影响。但是高频时晶体管内部的类似电容的表现特性也会使得其性能在高频时存在损失。  </p>          </div><h2 id="集成放大器电路部分"><a href="#集成放大器电路部分" class="headerlink" title="集成放大器电路部分"></a>集成放大器电路部分</h2><h3 id="运算放大器的参数特性"><a href="#运算放大器的参数特性" class="headerlink" title="运算放大器的参数特性"></a>运算放大器的参数特性</h3><h4 id="增益带宽积（GBP）"><a href="#增益带宽积（GBP）" class="headerlink" title="增益带宽积（GBP）"></a>增益带宽积（GBP）</h4><p>频率响应图中某时刻下的增益和带宽的乘积。  </p><script type="math/tex; mode=display">GBP=Gain × Bandwidth</script><h4 id="共模抑制比"><a href="#共模抑制比" class="headerlink" title="共模抑制比"></a>共模抑制比</h4><p>运算放大器的共模增益将放大直流噪声。共模抑制比（Common Mode Rejection Ratio，CMRR），定义为差模增益与共模增益的比值:  </p><script type="math/tex; mode=display">CMRR=\frac{A_d}{A_{cm}}</script><script type="math/tex; mode=display">CMRR(dB)=20lg\frac{A_d}{A_{cm}}</script><h4 id="压摆率"><a href="#压摆率" class="headerlink" title="压摆率"></a>压摆率</h4><p>理想的运算放大器在输入电压接入运算放大器的同时就会立即有稳定的输出电压，然而实际的运算放大器由于内部电容充电过程的存在，需要经过一小段时间才能达到稳定输出电压$V_o$，达到稳定输出电压的最大速率称为<strong>压摆率</strong>或电压转换速率（Slew Rate）。  </p><script type="math/tex; mode=display">S.R.=\frac{dV_o}{dt}|_{max}</script><p>输入信号为频率$f$的正弦交流电时：</p><script type="math/tex; mode=display">S.R.=2πAf</script><p>可以得到运算放大器所支持的某峰值下的最大信号频率（全功率带宽）为：  </p><script type="math/tex; mode=display">f_{max}=\frac{S.R.}{2πA}</script><h4 id="泄露和补偿"><a href="#泄露和补偿" class="headerlink" title="泄露和补偿"></a>泄露和补偿</h4><p>在真实的放大器中，输入端$V_+$和$V_-$之间是有电流的，这个电流称为泄露电流，在反相放大器中这个电流会流向$V_+$的接地端。泄露电流的存在会造成假设$V_+=V_-$不成立，因此在运算放大器的内部需要添加一个补偿电容来对$V_+$和$V_-$的电压进行补偿。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210916113332.png width=50%><br>同时在接地端需要额外增加一个补偿电阻以减小泄露电流的影响。在集成化的仪用放大器中，有两个pin：offset用于额外连接一个变阻器，调节补偿电阻的大小。  </p><h3 id="反馈放大器电路"><a href="#反馈放大器电路" class="headerlink" title="反馈放大器电路"></a>反馈放大器电路</h3><h4 id="反馈放大器的类型"><a href="#反馈放大器的类型" class="headerlink" title="反馈放大器的类型"></a>反馈放大器的类型</h4><ul><li><p>反相放大器<br>信号从反相输入端输入，其增益为：  </p><script type="math/tex; mode=display">\frac{V_{out}}{V_{sig}}=-\frac{R_f}{R_i}</script></li><li><p>同相放大器<br>信号从同相输入端输入，其增益为：  </p><script type="math/tex; mode=display">\frac{V_{out}}{V_{sig}}=1+\frac{R_f}{R_i}</script></li></ul><p>反馈放大器电路的分析原则：  </p><ul><li>有多个输入的情况下，将其他输入暂时视为接地，单独分析每一个输入对输出电压的影响。在分析每一个输入时：  <ul><li>需要关注放大器端口的输入电压。  </li><li>利用理想放大器同相输入端口和反相输入端口电压相等，建立关于电流的方程。  </li></ul></li><li>利用叠加定理，求和求解即可。  </li></ul><h4 id="反馈放大器的频率响应"><a href="#反馈放大器的频率响应" class="headerlink" title="反馈放大器的频率响应"></a>反馈放大器的频率响应</h4><p>反馈放大器的频率响应如图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211229211532.png width=50%></p><p>反馈放大器的开环带宽和闭环带宽之间存在着如下关系：  </p><script type="math/tex; mode=display">B_{cl}=\frac{B_{ol}}{A_v}</script><p>其中$A_v$是运算放大器的电压增益。  </p><h4 id="反馈电路的类型"><a href="#反馈电路的类型" class="headerlink" title="反馈电路的类型"></a>反馈电路的类型</h4><p>最简单的判断电路属于哪种反馈类型的方式为看电路中反馈部分两端是否存在额外的接地电阻，如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211014152437.png width=80%>  </p><p>注意反馈电路的类型名称是先写出输出端（sensing）的反馈类型，再写出输入端（mixer）的反馈类型。  </p><h3 id="滤波器电路"><a href="#滤波器电路" class="headerlink" title="滤波器电路"></a>滤波器电路</h3><p>基本的滤波器有高通，低通两种类型，其截止频率都为：  </p><script type="math/tex; mode=display">f_c=\frac{1}{2πRC}</script><p>对于多级高通/低通滤波器，其截止频率为：  </p><script type="math/tex; mode=display">f_c=\frac{1}{2π\sqrt[n]{∏_iR_iC_i}}</script><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">电路图</th><th style="text-align:center">被测目标</th><th style="text-align:center">截止频率</th><th style="text-align:center">下降/上升斜率</th><th style="text-align:center">达到截止频率时的相移</th></tr></thead><tbody><tr><td style="text-align:center">一阶低通滤波器</td><td style="text-align:center"><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211001134003.png width=60%></td><td style="text-align:center">C</td><td style="text-align:center">$\frac{1}{2πRC}$</td><td style="text-align:center">-20dB</td><td style="text-align:center">-45°</td></tr><tr><td style="text-align:center">一阶高通滤波器</td><td style="text-align:center"><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211008150418.png width=50%></td><td style="text-align:center">R</td><td style="text-align:center">$\frac{1}{2πRC}$</td><td style="text-align:center">20dB</td><td style="text-align:center">45°</td></tr><tr><td style="text-align:center">二阶低通滤波器</td><td style="text-align:center"><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211008145038.png width=50%></td><td style="text-align:center">C</td><td style="text-align:center">$\frac{1}{2π√(R_1R_2C_1C_2)}$</td><td style="text-align:center">-40dB</td><td style="text-align:center">-90°</td></tr><tr><td style="text-align:center">二阶高通滤波器</td><td style="text-align:center"><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211008150715.png width=50%></td><td style="text-align:center">R</td><td style="text-align:center">$\frac{1}{2π√(R_1R_2C_1C_2)}$</td><td style="text-align:center">40dB</td><td style="text-align:center">90°</td></tr><tr><td style="text-align:center">带通滤波器</td><td style="text-align:center"><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211008145829.png width=50%></td><td style="text-align:center">R、C</td><td style="text-align:center">$f_r=\frac{1}{2π√(R_1R_2C_1C_2)}$ <br> $f_H=\frac{1}{2πR_1C_1}$ <br> $f_L=\frac{1}{2πR_2C_2}$</td><td style="text-align:center"><br> 20dB <br>-20dB</td><td style="text-align:center">0° <br> 90° <br> -90°</td></tr></tbody></table></div><p>分析滤波器电路的方法：  </p><ol><li>模拟电路中输入信号为高频输入信号或者低频输入信号时的情况，通过电容“隔直流，通交流”的特性，分析电路中每个电容的开闭对输出的影响，以此来判断是高通滤波器还是低通滤波器。  </li><li>对每个电容单独分析，判断其截止频率。  </li><li>如果为有源滤波器，还需要对放大电路分析其增益。<br>放大电路部分和滤波器电路部分相互隔离，其中的电阻阻值互不影响。  </li></ol><h4 id="滤波器的频率响应"><a href="#滤波器的频率响应" class="headerlink" title="滤波器的频率响应"></a>滤波器的频率响应</h4><p>滤波器的频率响应图中应当关注：  </p><ul><li>最大增益$A_m$</li><li>-3dB处，对应截止频率。  </li></ul><p>需要注意的是带通滤波器的频率响应图中，较低的截止频率对应的是高通滤波器部分的截止频率，较高的截止频率对应的是低通滤波器部分的截止频率。  </p><h3 id="振荡器电路"><a href="#振荡器电路" class="headerlink" title="振荡器电路"></a>振荡器电路</h3><p>满足稳定振荡的两个条件：  </p><ul><li>$|GH|=1$.  </li><li>相移为0°</li></ul><p>有两种策略来实现稳定的振荡器：文氏电桥振荡电路和相移振荡器。  </p><h4 id="文氏电桥振荡器"><a href="#文氏电桥振荡器" class="headerlink" title="文氏电桥振荡器"></a>文氏电桥振荡器</h4><p>文氏电桥电路图如下，这是一个带通滤波器：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211017140810.png width=50%>  </p><p>其在输入信号为中心响应频率时可以满足相移为0°的条件：</p><script type="math/tex; mode=display">f_r=\frac{1}{2π\sqrt{R_1R_2C_1C_2}}=\frac{1}{2πRC},R_1=R_2=R,C_1=C_2=C</script><p>电桥电路输出到放大器的同相输入端，以确保相移为0°，产生稳定的振荡。<br>同相输入端的电阻需要满足：  </p><script type="math/tex; mode=display">1+\frac{R_f}{R_{in}}>3</script><p>才能够确保$|GH|=1$。<br>同时放大器的反相输入端可视为一个反相放大器，以负反馈确保电路输出稳定。  </p><h4 id="相移振荡器"><a href="#相移振荡器" class="headerlink" title="相移振荡器"></a>相移振荡器</h4><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211017150508.png width=50%>  </p><p>相移器通过高通滤波器的并联实现，根据高通滤波器的频率响应关系和相移公式可知，每个相移器的相移为：  </p><script type="math/tex; mode=display">Δφ=arctan\frac{X_c}{R}</script><p>通过调整电路中RC的值即可使其在输入信号频率$f_r$固定的情况下产生特定的相移。<br>当高通滤波器并联时，要使相移平均到高通滤波器，有如下公式：  </p><script type="math/tex; mode=display">f_r=\frac{1}{2πRC\sqrt{2N}}</script><p>其中$N$代表高通滤波器的个数，它与相移之间满足如下关系:</p><script type="math/tex; mode=display">Δφ=\frac{N}{180°}</script><p>需要注意的是，$N$的值越大，所需要的器件越多，同时由于每个高通滤波器在$f_r$处的增益都小于0，对所连接的运算放大器电压增益的要求也更高：运算放大器的电压增益需要大于所有高通滤波器在$f_r$的增益之和，该电路才能正常工作。通常认为<strong>$A_v≥29$</strong>。  </p><h3 id="555定时器"><a href="#555定时器" class="headerlink" title="555定时器"></a>555定时器</h3><p>55定时器是一种利用电容器充放电性质的电路元件，它可以通过直流电压输出稳定的方波。其元件内部结构如图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211022201421.png width=80%>  </p><p>其中的NPN晶体管作用类似于开关。上方三个$5kΩ$的分压器将输入电压$V_{cc}$分割成$\frac{2}{3}V_{cc}$和$\frac{1}{3}V_{cc}$并分别送入比较器2、1。其中比较器2将$\frac{2}{3}V_{cc}$与外接电压Threshold进行比较，比较器1将$\frac{1}{3}V_{cc}$与外接电压Trigger进行比较，以控制SR触发器的输入。<br>同时，555定时器还支持使用ControlVoltage替代$\frac{2}{3}V_{cc}$作为比较电压。SR触发器的输出为Ouput和Reset。<br>555定时器有三种工作状态（电路连接方式）：非稳态、单稳态和多稳态，这三种连接分别可以产生三种不同的方波波形。  </p><h4 id="非稳态模式"><a href="#非稳态模式" class="headerlink" title="非稳态模式"></a>非稳态模式</h4><p>非稳态模式(Astable)下555定时器的连接图如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211022210029.png width=80%></p><p>如图，VCC分别作为内部和外部电路的电压源，外部电路是一个基本的RC电路。而外部电路的输出端与Threshold和Trigger连接，从而起到自我触发的效果。<br>开始时电容器充电，当$Threshold&gt;\frac{2}{3}V_{cc}$时，SR触发器输入逻辑为：$R=1,S=0$，输出为低电平，同时由于$\overline{Q}=1$，NPN晶体管被导通，电容器开始放电。<br>当$Threshold&lt;\frac{2}{3}V_{cc}$时，SR触发器输入逻辑为：$R=0,S=1$，输出为高电平，同时由于$\overline{Q}=0$，NPN晶体管关断，电容器充电。<br>此后，由于Threshold/Trigger电压的变化，电容器会不断地进行充放电，从而在输出端产生稳定的高低电平方波，而电容器处产生稳定的锯齿波三角波，且周期占空比与输出的方波信号完全相同:<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211022210401.png width=50%>  </p><p>可以发现锯齿波/三角波的上下限为$\frac{2}{3}V_{CC}$(或者ControlVoltage)和$\frac{1}{3}V_{CC}$。  </p><p>在电路连接时往往还会增加另一个电容$C_2$以提高电路的稳定性。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211104164835.png width=50%>  </p><h4 id="有关计算"><a href="#有关计算" class="headerlink" title="有关计算"></a>有关计算</h4><p>在电容器充电过程，电流实际上流过了外部的两个电阻$R_1、R_2$，因此充电过程的时间常数：$τ_1=(R_1+R_2)C_1$。<br>放电过程中电流只流过了$R_2$,因此放电过程的时间常数：$τ_2=R_2C_1$。<br>根据数学推导得到充电时间：   </p><script type="math/tex; mode=display">t_{char}=ln2(R_1+R_2)C_1</script><p>放电时间：  </p><script type="math/tex; mode=display">t_{Discr}=ln2R_2C_1</script><p>周期：  </p><script type="math/tex; mode=display">T=t_{char}+t_{Discr}=ln2(R_1+2R_2)C_1</script><p>振荡频率：  </p><script type="math/tex; mode=display">f_r=\frac{1}{T}=\frac{1.44}{(R_1+2R_2)C_1}</script><p>定义输出波形一周期内的高电平出现时间占整个周期时间的比例为占空比，有：  </p><script type="math/tex; mode=display">Duty Cyecle=\frac{R_1+R_2}{R_1+2R_2}× 100\%</script><p><strong>因此，非稳态的555定时器输出的方波可以通过改变$R_1$和$R_2$的值改变占空比。</strong><br>可以发现这种基本的非稳态555振荡器配置的问题在于占空比，因为电阻$R_2$的存在使得占空比永远大于50%。<br>换句话说，该电路不能使输出“ON”时间短于“OFF”时间，因为$(R_1 + R_2)C$ 总是大于$R_1C$的值。  </p><blockquote><p>当$R_2$远大于$R_1$时，$Duty Cyecle=50\%$。  </p></blockquote><p><strong>$V_{Control}$对输出波形的影响</strong>：<br>充放电时间中的参数$ln2$实际上是由$\frac{1}{3}V_{CC}$和$\frac{2}{3}V_{CC}$进行决定的：  </p><script type="math/tex; mode=display">Const=ln\frac{V_{CC}-0.5V_{Control}}{V_{CC}-V_{Control}}</script><p>当$V_{CC}=15V,V_{Control}=\frac{2}{3}V_{CC}$时，$Const=ln2$。<br>如果Pin5：Control-Voltage接入直流电压，则$V_{Control}≠\frac{2}{3}V_{CC}$。<br>此时产生的三角波的上下限应该为：$\frac{1}{3}V_{CC}-V_{Control}$。<br>输出的方波周期发生变化，高电平和低电平的持续时间同比例增加或者减小，占空比仍然保持不变。  </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>电子系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数字系统设计-知识点总结</title>
    <link href="/2021/12/24/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%B7%A5%E7%A8%8B/%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    <url>/2021/12/24/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%B7%A5%E7%A8%8B/%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="数字系统设计-知识点总结"><a href="#数字系统设计-知识点总结" class="headerlink" title="数字系统设计-知识点总结"></a>数字系统设计-知识点总结</h1><blockquote><p>本文是BUL EE2634 Digital Systems Design and Reliability Engineering 数字系统部分的知识点总结。<br>本节授课教师：Dr.Ruiheng Wu（武瑞恒）  </p></blockquote><h2 id="逻辑门的晶体管实现"><a href="#逻辑门的晶体管实现" class="headerlink" title="逻辑门的晶体管实现"></a>逻辑门的晶体管实现</h2><p>晶体管在数字电路中用做开关，实现数字逻辑。有两种最基本的晶体管：NMOS和PMOS。<br>对于NMOS，如果栅极处于高电平，那么晶体管导通，如果处于低电平，晶体管关断。<br>PMOS的行为和NMOS完全相反，在电路符号中栅极处多了一个∘。<br>CMOS晶体管电路是使用PMOS和NMOS的混合电路，其优点在于相比于PMOS和NMOS电路，CMOS在表达数字逻辑“0”或“1”时电路中只有电压的变化，始终没有任何电流的变化，因此理论下在表达过程中不会有任何的功率损失。此外还有高阻抗，匹配功率范围广的优势。因此CMOS被广泛运用。  </p><h3 id="传输门"><a href="#传输门" class="headerlink" title="传输门"></a>传输门</h3><p>传输门由一个PMOS和一个NMOS组成，其作用相当于一个开关，电路表示如下图所示：当控制信号$s=0$时，电路开路，输出$f=0$。当控制信号$s=1$时，电路闭合，$f=x$。  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211225200724.png width=20%><br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211225200944.png width=25%>  </p><h3 id="逻辑门的晶体管数量"><a href="#逻辑门的晶体管数量" class="headerlink" title="逻辑门的晶体管数量"></a>逻辑门的晶体管数量</h3><p>实现各逻辑门所含晶体管数量如下表所示：  </p><div class="table-container"><table><thead><tr><th style="text-align:center">逻辑门</th><th style="text-align:center">NOT</th><th style="text-align:center">2NAND</th><th style="text-align:center">2NOR</th><th style="text-align:center">2AND</th><th style="text-align:center">2OR</th><th style="text-align:center">传输门</th></tr></thead><tbody><tr><td style="text-align:center">晶体管数量</td><td style="text-align:center">2</td><td style="text-align:center">4</td><td style="text-align:center">4</td><td style="text-align:center">6</td><td style="text-align:center">6</td><td style="text-align:center">2</td></tr></tbody></table></div><p>对于CMOS电路而言，每增加一个输入，就会分别增加一个PMOS和NMOS，因此$n$个输入的NAND或者NOR门需要的晶体管数目为：  </p><script type="math/tex; mode=display">\#transistors=2n</script><p>AND门和OR门是在NAND和NOR的基础上增加一个NOT门，NOT含有两个晶体管，因此$n$个输入的AND或者OR门需要的晶体管数目为：  </p><script type="math/tex; mode=display">\#transistors=2n+2</script><h2 id="系统的逻辑表达"><a href="#系统的逻辑表达" class="headerlink" title="系统的逻辑表达"></a>系统的逻辑表达</h2><p>系统的逻辑表达式有两种：SOP（Sum of Product）和POS（Product of Sum）。  SOP可以用全部用NAND门表达:   </p><script type="math/tex; mode=display">A.B+C.D=\overline{(\overline{A}.\overline{B}).(\overline{C}.\overline{D})}</script><p>POS可以全部用NOR门表达:   </p><script type="math/tex; mode=display">(A+B).(C+D)=\overline{\overline{A+B}+\overline{C+D}}</script><h2 id="减少成本的方式-化简数字电路的方式"><a href="#减少成本的方式-化简数字电路的方式" class="headerlink" title="减少成本的方式/化简数字电路的方式"></a>减少成本的方式/化简数字电路的方式</h2><p>数字系统设计中最核心的实现是减少系统设计的成本（Cost），数字电路的成本可以用门成本表示：  </p><script type="math/tex; mode=display">Cost=\#inputs+\#gates</script><p>其中$inputs$指电路中所有门的输入数，$gates$是电路中所有逻辑门的数量。需要注意的是，只有在“非”逻辑下方有非逻辑时（比如：$\overline{A+\overline{A}B}$），才将NOT门及其输入计入$gates$和$inputs$。  </p><h3 id="逻辑运算律化简"><a href="#逻辑运算律化简" class="headerlink" title="逻辑运算律化简"></a>逻辑运算律化简</h3><p>通过逻辑运算律进行化简，几个重要的逻辑运算律：  </p><ul><li>吸收律：<br>$A+AB=A$<br>$A(A+B)=A$</li><li>德摩根律：<br>$\overline{AB}=\overline{A}+\overline{B}$<br>$\overline{A+B}=\overline{A}.\overline{B}$  </li></ul><h3 id="卡诺图化简"><a href="#卡诺图化简" class="headerlink" title="卡诺图化简"></a>卡诺图化简</h3><ul><li>SOP圈“1”，“1→x”</li><li>POS圈“0”，“0→x”</li><li>每个圈中的蕴含项个数只能为$2^n$</li><li>尽可能圈住最多的蕴含项</li><li>四个边视为相邻，四个角视为相邻</li><li>如果一个圈里面所有的蕴含项都在其他圈中出现，这个圈可以被取消</li><li>通配符“d”可以被圈住</li><li>一个电路多个输出时，对多个输出分别画卡诺图，多张卡诺图中圈的位置尽可能相同。  </li></ul><div class="note note-info">            <p>如果题目中的设计目标是“最小成本”，那么做完卡诺图化简后还需要提取公因项化简。<br>如果题目中的设计目标是“最简SOP/POS”，那么做完卡诺图化简后即可。  </p>          </div><h2 id="逻辑电路元件"><a href="#逻辑电路元件" class="headerlink" title="逻辑电路元件"></a>逻辑电路元件</h2><h3 id="加法器"><a href="#加法器" class="headerlink" title="加法器"></a>加法器</h3><p>半加器为不含进位的加法器，全加器相比于半加器有另一个输出用于表示进位。<br>加法器可以通过列出真值表，对进位（carry）和和（sum）分别用卡诺图化简即可。<br>第$i+1$位的进位表示为：  </p><script type="math/tex; mode=display">c_{i+1}=x_iy_i+x_ic_i+y_ic_i</script><p>第$i$位的和表示为：  </p><script type="math/tex; mode=display">s_i=x_i⊕y_i⊕c_i</script><p>如果将加法器的其中一个输入和一个控制信号与异或门连接，就能将这个输入在控制信号为0时转为二补码，实现两个输入的减法。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211225225637.png width=50%></p><h3 id="多路复用器"><a href="#多路复用器" class="headerlink" title="多路复用器"></a>多路复用器</h3><p>多路复用器是一种通过控制信号，实现从多个输入信号中选择一个信号输出的数字电路器件。当输入信号为从00..0到11..1的不同组合时，多路复用器会对应输出其结果，利用这一特性可以让多路复用器实现逻辑表达式。  </p><h3 id="解码器·编码器"><a href="#解码器·编码器" class="headerlink" title="解码器·编码器"></a>解码器·编码器</h3><p>解码器是一种输入$n$个比特，返回对应的$2^n$个比特值的电路器件。编码器的行为和解码器相反，输入$2^n$个比特，返回$n$个比特的器件。<br>对于解码器，当$En=1$时，输入$w_1w_0$为特定的比特组合时，输出端对应的输出为1，其余输出为0.其真值表如下：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211227140215.png width=50%>  </p><p>编码器的行为和解码器完全相反：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211227140437.png width=50%></p><h3 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h3><p>比较器在一个电路中可以实现对两个输入信号$A$,$B$的比较，并用布尔值返回其比较结果。比较器有三个输出结果：$AeqB,AgtB,AleB$，$A$和$B$满足哪一个关系，比较器对应的输出结果就是1。  </p><ul><li><p>$AeqB$<br>判断A和B是否相等的简单思路是利用XOR门的特性逐位比较每一个比特是否相同，但是XOR门在相同时输出结果为0，因此最后还需要取反才能得到每一位正确的比较结果。每一个比特位的比较可以表示为：  </p><script type="math/tex; mode=display">i_k=\overline{a_k⊕b_k}</script><p>当所有位都相同时，$AeqB=1$：</p><script type="math/tex; mode=display">AeqB=i_ni_{n-1}...i_1i_0</script></li><li><p>$AgtB$<br>在每一个比特位上，只有$a_i=1$，$b_i=0$时才能判断在该位上$a_i&gt;b_i$。$AgtB$表示为：  </p><script type="math/tex; mode=display">AgtB=a_n\overline{b_n}+i_na_{n-1}\overline{b_{n-1}}+i_ni_{n-1}a_{n-2}\overline{b_{n-2}}+...+∏_{i=1}^ni_ka_0\overline{b_0}</script></li><li><p>$AleB$<br>当A既不大于B，也不等于B时，其结果为$A&lt;B$:</p><script type="math/tex; mode=display">AleB=\overline{AgtB+AeqB}</script></li></ul><h2 id="逻辑电路的实现方式"><a href="#逻辑电路的实现方式" class="headerlink" title="逻辑电路的实现方式"></a>逻辑电路的实现方式</h2><h3 id="CMOS电路"><a href="#CMOS电路" class="headerlink" title="CMOS电路"></a>CMOS电路</h3><p>CMOS电路由两部分构成：上拉和下拉电路。<br>上拉电路由PMOS管组成，电路上端接$V_{dd}$，当一条回路上的PMOS全部导通时，对应的输出为1。<br>下拉电路由PMOS管组成，电路下端接地，当一条回路上的PMOS全部导通时，对应的逻辑输出为0。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211225194842.png width=50%>  </p><p>使用CMOS电路实现逻辑表达式的思想是：  </p><ul><li>逻辑表达式中的每一项对应电路中的一条支路。  </li><li>对于每一项，AND逻辑用串联电路构建，OR逻辑用并联电路实现。  </li><li>对于上拉电路，应当用POS表达$f$。</li><li>对于下拉电路，应当对上拉电路的表达式取反$\overline{f}$，用德摩根律化简。  </li></ul><h3 id="多路复用器电路"><a href="#多路复用器电路" class="headerlink" title="多路复用器电路"></a>多路复用器电路</h3><p>从逻辑表达式实现多路复用器电路的过程：  </p><ol><li>看输入信号的数量，并选取其中一些输入信号的作为控制信号。<br>控制信号的数量满足：  <script type="math/tex; mode=display">2^{控制信号的数量} ≥ 剩余输入信号的数量</script></li><li>利用香农展开，从逻辑表达式中提取出一个控制信号，并将逻辑表达式写作如下形式：  <script type="math/tex; mode=display">f(w_1,w_2,..,w_n)=\overline{w_1}f(0,w_2,...,w_n)+w_1f(1,w_2,...,w_n)</script></li><li>再从$f(0,w_2,…,w_n)$和$f(1,w_2,…,w_n)$使用相同的方法提取出第二个控制信号，重复直到所有的控制信号都被提取。  </li></ol><h4 id="移位器（Shifter）电路"><a href="#移位器（Shifter）电路" class="headerlink" title="移位器（Shifter）电路"></a>移位器（Shifter）电路</h4><p>移位器设计的关键是写出不同的控制信号对应的每一位上的输出，列表。然后竖着看表，根据每一位输出在不同控制信号下对应的输出，对这个输出用多路复用器搭建电路。重复直到每一个输出都用一个对应的多路复用器电路表达，然后将相同的输入连接到一起即可。  </p><h3 id="解码器电路"><a href="#解码器电路" class="headerlink" title="解码器电路"></a>解码器电路</h3><p>SOP可以直接用解码器电路表达，如果在SOP中最小项$i=1$，那么解码器电路中的$y_i$需要被输出，解码器中所有的$y_i$用OR门相连，剩下的输出端口不需要输出。  </p><h3 id="查找表（LUT）电路"><a href="#查找表（LUT）电路" class="headerlink" title="查找表（LUT）电路"></a>查找表（LUT）电路</h3><p>单级的查找表只需要写明输入信号，并在寄存器图标上填入真值表的输出即可。<br>多级的查找表电路需要利用香农展开，提取变量作为控制信号后，对括号内的项构建查找表电路，再使用输出和控制信号构建下一级的查找表电路。  </p><h3 id="可编程逻辑阵列（PLA）和可编程阵列逻辑（PAL）"><a href="#可编程逻辑阵列（PLA）和可编程阵列逻辑（PAL）" class="headerlink" title="可编程逻辑阵列（PLA）和可编程阵列逻辑（PAL）"></a>可编程逻辑阵列（PLA）和可编程阵列逻辑（PAL）</h3><p>可编程逻辑阵列（PLA）和可编程阵列逻辑（PAL）中逻辑门的输入端存在可编程开关，因此可以通过控制开关的开闭来实现不同的布尔函数。<br>可编程逻辑阵列（PLA）实现的是先AND，再OR的SOP逻辑，例子如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211225195501.png width=50%><br>在可编程逻辑中，电路中的“×”代表此处是连接的。  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211225195620.png width=50%></p><p>在PLA当中，电路中OR门所在的区域（称为OR平面）是固定好的，不可以被编程。  </p><p>可编程开关的劣势：  </p><ul><li>影响运行速度</li><li>占据大量空间</li><li>增加功耗</li></ul><h3 id="门阵列"><a href="#门阵列" class="headerlink" title="门阵列"></a>门阵列</h3><p>门阵列中，阵列外围是输入或者输出端口，其内部为位置固定的NAND门或者NOR门的阵列，可通过将端口和逻辑门连接实现对应的NAND-only或NOR-only的布尔表达式。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211225200257.png width=50%>  </p><h2 id="锁存器和触发器"><a href="#锁存器和触发器" class="headerlink" title="锁存器和触发器"></a>锁存器和触发器</h2><p>锁存器（Latch）是一类有记忆功能的数字电路器件。触发器在锁存器的基础上被构建出来。  </p><h3 id="RS锁存器"><a href="#RS锁存器" class="headerlink" title="RS锁存器"></a>RS锁存器</h3><p>RS锁存器的电路结构和真值表如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211227144607.png width=50%>  </p><p>其表现归纳为：“<strong>只有SR处于不同值时，对应输出为1</strong>”。<br>SR锁存器的问题是当$S=1,R=1$时，$Q_a=1,Q_b=1$，如果此时设置$S=0，R=0$时，触发器的输出$Q_a=0,Q_b=0$，并作为下一次的输入，此时$Q_a=1,Q_b=1$，接下来，锁存器将处于不断的0-1跳变当中。  </p><h3 id="D锁存器"><a href="#D锁存器" class="headerlink" title="D锁存器"></a>D锁存器</h3><p>RS锁存器存在跳变的解决办法是使用一个输入D来代替原来的RS两个输入端口，并使用一个NOT门让D输入的一条支路的逻辑值反转，对于整个电路而言，就永远不可能出现SR值相同的情况，进而无法出现跳变。此外，D锁存器加入了时钟信号clk，使得当时钟信号为0时，锁存器当永久保存当前的输出状态，直到时钟信号变为1。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211227151048.png width=50%><br>其真值表为：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211227151112.png width=50%></p><h2 id="主从D触发器"><a href="#主从D触发器" class="headerlink" title="主从D触发器"></a>主从D触发器</h2><p>主从D触发器能够保留一个时钟的信息，其结构如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211227151301.png width=50%><br>D触发器的真值表为：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211227154837.png width=50%></p><p>D触发器的行为规则是：  </p><ul><li><strong>在clk=1的时刻，其输出随着D的变换而变化</strong>。  </li><li><strong>在clk=0的时刻，其输出保留之前的状态</strong>。  </li></ul><p>D触发器的触发规则有上升沿触发、下降沿触发，不同的触发方式对于同一个输入信号，其结果可能是不同的：  </p><ul><li>对于D锁存器/主从D触发器，其在clk=1的时刻与D完全同步变化。在clk=0的时刻，其输出保留之前的状态  </li><li>对于上升沿D触发器，其始终保留在clk=1的上升沿前最后一个D，直到下一个clk=1的上升沿出现。  </li><li>对于下升沿D触发器，其始终保留在clk=1的下降沿前最后一个D。直到下一个clk=1的下降沿出现。  </li></ul><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211227152645.png width=70%>  </p><h3 id="T触发器"><a href="#T触发器" class="headerlink" title="T触发器"></a>T触发器</h3><p>T触发器的结构如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211227152859.png width=70%><br>T触发器的真值表为：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211227154618.png width=50%></p><p>其clk=1的时间中，其行为为：<br><strong>T=1时发生比特反转，T=0时保留原来的比特。</strong></p><h3 id="JK触发器"><a href="#JK触发器" class="headerlink" title="JK触发器"></a>JK触发器</h3><p>JK触发器是SR触发器和D触发器的变形，其结构为：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211227155154.png width=50%>  </p><p>JK触发器的真值表为：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211227155746.png width=50%>  </p><p>其行为可以描述为：  </p><ul><li><strong>JK=1时，输出$\overline{Q}$。JK=0时，输出$Q$。</strong>  </li><li><strong>J代表set，仅$J=1$时，$Q$强制为1。</strong>  </li><li><strong>K代表reset，仅$K=1$时，$Q$强制为0。</strong></li></ul><h2 id="VHDL程序基础"><a href="#VHDL程序基础" class="headerlink" title="VHDL程序基础"></a>VHDL程序基础</h2><p>VHDL是一种用于描述逻辑电路的程序，程序的基本结构由用于声明输入和输出端口的ENTITY和用于描述逻辑电路功能的ARCHITECTURE组成。<br>ENTITY的写法如下例程所示，这段例程program1声明了$x_1$，$x_2$，$x_3$是输入变量，其数据类型为<code>STD_Logic</code>(standard logic，此处的数据类型也可以是<code>BIT</code>)，并指定输出端口为$f$：<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vhdl"><span class="hljs-keyword">ENTITY</span> program1 <span class="hljs-keyword">IS</span><br>  <span class="hljs-keyword">PORT</span>(x1,x2,x3 : <span class="hljs-keyword">IN</span> <span class="hljs-built_in">STD_Logic</span>;<br>       f : <span class="hljs-keyword">OUT</span> <span class="hljs-built_in">STD_Logic</span>;);<br><span class="hljs-keyword">END</span> program1 ;<br></code></pre></td></tr></table></figure><br>在声明变量之后，用布尔运算式描述逻辑电路的功能，注意，VHDL中<code>&lt;=</code>表示赋值。<br>下面的例程中展示了program1是如何实现$f=x_1x_2+\overline{x_2}x_3$的：<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vhdl"><span class="hljs-keyword">ARCHITECTURE</span> LogicFunc <span class="hljs-keyword">OF</span> program1 <span class="hljs-keyword">IS</span><br><span class="hljs-keyword">Begin</span><br>  f&lt;= (x1 <span class="hljs-keyword">AND</span> x2) <span class="hljs-keyword">OR</span> (<span class="hljs-keyword">NOT</span> x2 <span class="hljs-keyword">AND</span> x3);<br><span class="hljs-keyword">END</span> LogicFunc;<br></code></pre></td></tr></table></figure><br>LogicFunc是这段结构的名字，可以自定义命名。<br>在VHDL中，逻辑运算是没有优先级的，需要通过给定括号<code>()</code>来制定优先级。  </p><p>此外，VHDL语言中还支持使用分支结构来表达：<br>分支结构中使用<code>WHITH</code>声明控制变量，使用<code>WHEN &#39;bit&#39;</code>和<code>WHEN OTHERS</code>来指定控制信号为对应比特值<code>bit</code>时和其他时候的对应的情况。<br>需要注意最后一种情况对应的一定是<code>WHEN OTHERS</code>以排除可能出现的所有不稳定值。<br>比如下面例程所示的2-1多路复用器，当输入信号$s=0$时，$f=w_1$，$s=1$时，$f=w_2$。<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vhdl"><span class="hljs-keyword">LIBRARY</span> ieee;<br><span class="hljs-keyword">USE</span> ieee.std_logic_1164.<span class="hljs-keyword">all</span>;<br><br><span class="hljs-keyword">ENTITY</span> mux2to1 <span class="hljs-keyword">IS</span><br>  <span class="hljs-keyword">PORT</span>(w0,w1,s <span class="hljs-keyword">IN</span> <span class="hljs-built_in">STD_logic</span><br>       f <span class="hljs-keyword">OUT</span> <span class="hljs-built_in">STD_logic</span>);<br><span class="hljs-keyword">END</span> mux2to1;<br><br><span class="hljs-keyword">ARCHITECTURE</span> behavior <span class="hljs-keyword">OF</span> mux2t01 <span class="hljs-keyword">IS</span><br><span class="hljs-keyword">BEGIN</span><br> <span class="hljs-keyword">WITH</span> s <span class="hljs-keyword">SELECT</span><br>   f&lt;=w1 <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;0&#x27;</span>;<br>   f&lt;=w0 <span class="hljs-keyword">WHEN</span> <span class="hljs-keyword">OTHERS</span>;<br><span class="hljs-keyword">END</span> behavior;<br></code></pre></td></tr></table></figure><br>除了<code>STD_logic</code>和<code>BIT</code>之外，VHDL还支持<code>STD_logic_vector()</code>这样的逻辑向量表达，有升序：<code>STD_logic_vector(m TO n)</code>表示从m 到 n的比特值组成的向量，和降序：<code>STD_logic_vector(n DOWNTO m)</code>两种。字节长度在ACHITECURE中指定。<br>比如下面例程所示的2-4解码器：<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs vhdl"><span class="hljs-keyword">LIBRARY</span> ieee;<br><span class="hljs-keyword">USE</span> ieee.std_logic_1164.<span class="hljs-keyword">all</span>;<br><br><span class="hljs-keyword">ENTITY</span> dec2to4 <span class="hljs-keyword">IS</span><br>  <span class="hljs-keyword">PORT</span>(<br>    w : <span class="hljs-keyword">IN</span> <span class="hljs-built_in">STD_logic_vector</span>(<span class="hljs-number">1</span> <span class="hljs-keyword">DOWNTO</span> <span class="hljs-number">0</span>);<br>    En : <span class="hljs-keyword">IN</span> <span class="hljs-built_in">STD_logic</span>;<br>    y : <span class="hljs-keyword">OUT</span> <span class="hljs-built_in">STD_LOGIC_VECTOR</span>(<span class="hljs-number">0</span> <span class="hljs-keyword">TO</span> <span class="hljs-number">3</span>);<br>  )<br><span class="hljs-keyword">END</span> dec2to4;<br><br>ARCHITECUTURE behavior <span class="hljs-keyword">OF</span> dec2t04 <span class="hljs-keyword">IS</span><br> <span class="hljs-keyword">SIGNAL</span> Enw: <span class="hljs-built_in">STD_logic_vector</span>(<span class="hljs-number">2</span> <span class="hljs-keyword">DOWNTO</span> <span class="hljs-number">0</span>);<br> <span class="hljs-keyword">BEGIN</span><br>  Enw &lt;= En <span class="hljs-keyword">AND</span> w;<br>  <span class="hljs-keyword">WITH</span> Enw <span class="hljs-keyword">SELECT</span><br>    y &lt;= <span class="hljs-string">&quot;1000&quot;</span> <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&quot;100&quot;</span>,<br>         <span class="hljs-string">&quot;0100&quot;</span> <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&quot;101&quot;</span>,<br>         <span class="hljs-string">&quot;0010&quot;</span> <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&quot;110&quot;</span>,<br>         <span class="hljs-string">&quot;0000&quot;</span> <span class="hljs-keyword">WHEN</span> <span class="hljs-keyword">OTHERS</span>;<br><span class="hljs-keyword">END</span> behavior;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>数字系统与可靠性工程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>11. IIR滤波器设计方法</title>
    <link href="/2021/12/22/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/11.%20IIR%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%AE%BE%E8%AE%A1/"/>
    <url>/2021/12/22/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/11.%20IIR%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="IIR滤波器设计方法"><a href="#IIR滤波器设计方法" class="headerlink" title="IIR滤波器设计方法"></a>IIR滤波器设计方法</h1><p>IIR系统的频率响应：  </p><script type="math/tex; mode=display">H(z)=\frac{∑_{k=0}^Mb_kz^{-k}}{∑_{k=0}^Na_kz^{-k}}</script><p>IIR滤波器设计的基本思路是通过对模拟滤波器进行参数调整，再通过数字采样将模拟滤波器转换为数字滤波器。  </p><h2 id="模拟滤波器原型"><a href="#模拟滤波器原型" class="headerlink" title="模拟滤波器原型"></a>模拟滤波器原型</h2><p>IIR滤波器设计的两种基本原型是巴特沃斯低通滤波器和切比雪夫低通滤波器，两种滤波器的幅频特性都不含有相位信息，因此IIR滤波器的相位不可控。<br>这两种滤波器的幅频特性如图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211222150601.png width=60%>  </p><p>其幅度的模的平方与频率的关系表示为：  </p><script type="math/tex; mode=display">\frac{1}{1+ɛ^2}≤|H_a(jΩ)|^2≤1,|Ω|≤Ω_p</script><script type="math/tex; mode=display">0≤|H_a(jΩ)|^2≤\frac{1}{A^2},|Ω|≥Ω_s</script><p>其中$ɛ$称为通带波纹系数，$Ω_p$是通带截止频率，$A$是止带衰减系数，$Ω_s$是止带截止频率。<br>在通带截止频率时：  </p><script type="math/tex; mode=display">|H_a(jΩ)|^2=\frac{1}{1+ɛ^2}</script><p>在止带截止频率时：  </p><script type="math/tex; mode=display">|H_a(jΩ)|^2=\frac{1}{A^2}</script><p>定义其通带波纹$R_p$为：  </p><script type="math/tex; mode=display">R_p|_{dB}=-10lg|H_a(jΩ_p)|^2=-10lg\frac{1}{1+ɛ^2}</script><p>止带衰减$A_s$为：  </p><script type="math/tex; mode=display">A_s=-10lg|H_a(jΩ_s)|^2=-10lg\frac{1}{A^2}</script><h3 id="巴特沃斯滤波器"><a href="#巴特沃斯滤波器" class="headerlink" title="巴特沃斯滤波器"></a>巴特沃斯滤波器</h3><p>巴特沃斯滤波器的特点是在通带和止带都没有波纹，但是过渡带相对较大。巴特沃斯滤波器的幅频响应表示为：  </p><script type="math/tex; mode=display">|H_a(jΩ)|^2=\frac{1}{1+(\frac{Ω}{Ω_c})^{2N}}</script><p>其中$N$称为巴特沃斯滤波器的阶数，$ω_c$为其截止频率，知道这两个参数便可以确定一个巴特沃斯滤波器。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211222151800.png width=50%><br>从图中可以发现，阶数越高，巴特沃斯滤波器的过渡带宽越窄，$N→∞$时成为理想低通滤波器。同时，无论任何阶数，其截止频率下$|H_a(jΩ_c)|^2=\frac{1}{2}$。  </p><h4 id="巴特沃斯滤波器的s域分析"><a href="#巴特沃斯滤波器的s域分析" class="headerlink" title="巴特沃斯滤波器的s域分析"></a>巴特沃斯滤波器的s域分析</h4><p>在s域下，由拉普拉斯变换中定义$Ω=\frac{s}{j}$，其幅频响应可以写作：</p><script type="math/tex; mode=display">\begin{aligned}    |H_a(jΩ)|^2&=H_a(s)H_a(-s) \\    &=\frac{1}{1+(\frac{s}{jΩ_c})^{2N}}\\    &=\frac{(jΩ_c)^{2N}}{(jΩ_c)^{2N}+s^{2N}}\end{aligned}</script><p>求得极点为：</p><script type="math/tex; mode=display">p_k=Ω_ce^{j\frac{kπ}{N}},k=0,1,...,2N-1</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211222153348.png width=50%>  </p><div class="note note-info">            <p>即在幅频响应中令$Ω=\frac{s}{j}$，带入后得到$|H_a(jΩ)|^2=\frac{1}{1+(\frac{s}{jΩ_c})^{2N}}=H(s)H(-s)$，令下方为0后得到的$1+(\frac{s}{jΩ_c})^{2N}=0$的方程解。  </p>          </div><p>可以发现<strong>2N个极点均匀的分布在半径为$Ω_C$的圆上，由于只有s域左半部分表示稳定一同，因此只选取位于s域左半部分的极点构建滤波器。</strong>  </p><div class="note note-info">            <p>由于其所有的极点在s域以$Ω_c$为半径的圆上均匀分布，因此极点可以根据下图快速求得：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220102213033.png width=60%>  </p><p>可以求得：  </p><script type="math/tex; mode=display">s_k=Ω_ccos(\frac{π}{N}k)-jΩ_csin(\frac{π}{N}k)</script>          </div><p>巴特沃斯滤波器的幅频响应在s域上表示为：  </p><script type="math/tex; mode=display">H_a(s)=\frac{Ω_c^N}{\prod(s-p_k)}</script><h4 id="巴特沃斯滤波器设计"><a href="#巴特沃斯滤波器设计" class="headerlink" title="巴特沃斯滤波器设计"></a>巴特沃斯滤波器设计</h4><p>如果设计要求为指定的通带和止带截止频率，以及通带和止带的波纹：<br>根据$R_p=-10lg|H_a(jΩ_p)|$，$A_s=-10-10lg|H_a(jΩ_s)|$，有：  </p><script type="math/tex; mode=display">R_p=-10lg\frac{1}{1+(\frac{Ω_p}{Ω_c})^{2N}}</script><script type="math/tex; mode=display">A_s=-10lg\frac{1}{1+(\frac{Ω_s}{Ω_c})^{2N}}</script><p>两式相比可以得到：  </p><script type="math/tex; mode=display">N=\frac{lg[\frac{10^{R_p/10}-1}{10^{A_s/10}-1}]}{2lg(\frac{\omega_p}{\omega_s})}</script><p>向上取整。<br>根据$R_p$、$A_s$的表达式可以得到两个截止频率，截止频率$Ω_c$应当为这两式得出结果区间内的某个值：  </p><script type="math/tex; mode=display">Ω_c=(\frac{Ω_p}{\sqrt[2N]{10^{R_p/10}-1}},\frac{Ω_s}{\sqrt[2N]{10^{A_s/10}-1}})</script><h3 id="切比雪夫滤波器"><a href="#切比雪夫滤波器" class="headerlink" title="切比雪夫滤波器"></a>切比雪夫滤波器</h3><p>根据通带或止带存在波纹将切比雪夫滤波器分为两类：  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211222201955.png width=50%>  </p><h4 id="I型切比雪夫滤波器"><a href="#I型切比雪夫滤波器" class="headerlink" title="I型切比雪夫滤波器"></a>I型切比雪夫滤波器</h4><p>I型切比雪夫滤波器的通带存在波纹，其频率响应为：  </p><script type="math/tex; mode=display">|H_a(jΩ)|^2=\frac{1}{1+ɛ^2T_N^2(\frac{Ω}{Ω_c})}</script><p>$T_N(x)$为N阶切比雪夫多项式：  </p><script type="math/tex; mode=display">T_N(x)=\begin{cases}    cos(Narccos(x)),0≤x≤1\\    cosh(Narccosh(x)),1≤x≤∞\end{cases}</script><blockquote><p>$cosh(x)=\frac{e^x+e^{-x}}{2}$   </p></blockquote><h4 id="切比雪夫I型滤波器的s域分析"><a href="#切比雪夫I型滤波器的s域分析" class="headerlink" title="切比雪夫I型滤波器的s域分析"></a>切比雪夫I型滤波器的s域分析</h4><p>根据对s的定义：  </p><script type="math/tex; mode=display">H_a(s)H_a(-s)=\frac{1}{1+ɛ^2T^2_N(\frac{s}{jΩ_c})}</script><p>极点可以表示为：$p_k=σ_k+jΩ_k$  </p><script type="math/tex; mode=display">Ω_k=(bΩ_c)sin[\frac{π}{2}+\frac{(2k+1)π}{2N}]</script><script type="math/tex; mode=display">σ_k=(aΩ_c)cos[\frac{π}{2}+\frac{(2k+1)π}{2N}]</script><p>$a=\frac{1}{2}(\sqrt[n]{α}-\sqrt[n]\frac{1}{α}))$，$b=\frac{1}{2}(\sqrt[n]{α}+\sqrt[n]\frac{1}{α})$，$α=\frac{1}{ɛ}+\sqrt{1+\frac{1}{ɛ^2}}$.  </p><div class="note note-info">            <p>即在幅频响应中令$Ω=\frac{s}{j}$，带入后得到$|H_a(jΩ)|^2=\frac{1}{1+ɛ^2T_N^2(\frac{s}{jΩ_c})}$，令下方为0后得到的$1+ɛ^2T_N^2(\frac{s}{jΩ_c})=0$的方程解。  </p>          </div><h4 id="切比雪夫I型滤波器设计"><a href="#切比雪夫I型滤波器设计" class="headerlink" title="切比雪夫I型滤波器设计"></a>切比雪夫I型滤波器设计</h4><p>根据$R_p$的定义，有$Ω_c=Ω_p$时，</p><script type="math/tex; mode=display">ɛ=\sqrt{10^{0.1R_p}-1}</script><p>滤波器的阶数为：  </p><script type="math/tex; mode=display">N=\frac{lg[g+\sqrt{g^2-1}]}{lg[\frac{Ω_s}{Ω_c}+\sqrt{(\frac{Ω_s}{Ω_c})^2-1}]}</script><p>其中：$g=\sqrt{\frac{A^2-1}{ɛ^2}}$  </p><h3 id="切比雪夫II型滤波器"><a href="#切比雪夫II型滤波器" class="headerlink" title="切比雪夫II型滤波器"></a>切比雪夫II型滤波器</h3><p>切比雪夫II型滤波器在止带上有波纹，其系统幅频响应为：  </p><script type="math/tex; mode=display">|H_a(jΩ)|^2=\frac{1}{1+\left[ɛ^2T_N^2(\frac{Ω}{Ω_c})\right]^{-1}}</script><p>其余设计思路与切比雪夫I型滤波器相同。  </p><h2 id="模拟-数字滤波器转换"><a href="#模拟-数字滤波器转换" class="headerlink" title="模拟/数字滤波器转换"></a>模拟/数字滤波器转换</h2><h3 id="脉冲响应不变法"><a href="#脉冲响应不变法" class="headerlink" title="脉冲响应不变法"></a>脉冲响应不变法</h3><p>脉冲响应不变法的基本思路是在模拟滤波器的时域表达上等距采样，生成数字滤波器的序列。在脉冲响应不变法中，数字角频率和模拟角频率之间的关系是线性的：$Ω=\frac{ω}{T}$  </p><script type="math/tex; mode=display">h[n]=Th_c(nT)</script><p>如果模拟滤波器$h_c$的频率响应：  </p><script type="math/tex; mode=display">H_c(s)=∑_{k=1}^N\frac{A_k}{s-s_k}</script><p>在时域上：  </p><script type="math/tex; mode=display">h_c(t)=∑_{k=1}^NA_ke^{s_kt},t≥0</script><p>对其采样：  </p><script type="math/tex; mode=display">\begin{aligned}h[n]=&Th_c(nT)\\    =&\sum_{k=1}^NTA_ke^{s_knT}u[n]\\    =&\sum_{k=1}^NTA_k(e^{s_kT})^nu[n]\end{aligned}</script><p>对其做Z变换，得到对应的数字滤波器的频率响应：  </p><script type="math/tex; mode=display">H(z)=∑_{k=1}^N\frac{TA_k}{1-e^{s_kT}z^{-1}}</script><p>脉冲响应不变是一种一对多的映射：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211222212251.png width=50%><br>在采样的过程中，由于一对多的映射关系，采样信号会在频谱上发生混叠。  </p><p>脉冲响应不变法的流程：  </p><ol><li>根据设计要求的通带截止频率和止带截止频率将数字角频率还原为模拟角频率：$Ω_p=\frac{ω_p}{T},Ω_s=\frac{ω_s}{T}$。  </li><li>设计出对应的模拟滤波器。  </li><li>求出模拟滤波器的频率响应：$H_c(s)=∑_{k=1}^N\frac{A_k}{s-s_k}$。</li><li>根据映射律：$H(z)=∑\frac{A_k}{1-e^{s_kT}z^{-1}}$，得到数字滤波器的频率响应。  </li></ol><h3 id="双线性法"><a href="#双线性法" class="headerlink" title="双线性法"></a>双线性法</h3><p>双线性法的映射律为：  </p><script type="math/tex; mode=display">s=\frac{2}{T}\frac{1-z^{-1}}{1+z^{-1}}</script><p>因此:  </p><script type="math/tex; mode=display">H(z)=H_a(\frac{2}{T}\frac{1-z^{-1}}{1+z^{-1}})</script><p>这是一种一对一的映射律，因此不会发生混叠。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211223165306.png width=50%>  </p><p>在这种映射律下，其数字角频率和模拟角频率之间的关系是非线性的：</p><script type="math/tex; mode=display">Ω=\frac{2}{T}tan\frac{ω}{2}</script><p>其频率响应表示为：  </p><script type="math/tex; mode=display">|H(e^{jω})|^2=\frac{1}{1+(\frac{tan(ω/2)}{tan(ω_c/2)})^N}</script><h2 id="其他类型的IIR滤波器设计"><a href="#其他类型的IIR滤波器设计" class="headerlink" title="其他类型的IIR滤波器设计*"></a>其他类型的IIR滤波器设计*</h2><p>在模拟域中，滤波器类型的转换是线性的，但是在经过模数转换后，数字滤波器的类型转换是非线性的。<br>简单来说，IIR滤波器的类型转换通过映射律将低通滤波器频率响应的$z^{-1}$重新映射，进而得到其他类型的IIR滤波器的频率响应。  </p><script type="math/tex; mode=display">z^{-1}=G(z^{-1})</script><script type="math/tex; mode=display">H(z)=H_{LP}(z)|_{z^{-1}=G(z^{-1})}</script><p>并且映射律需要满足：$|z^{-1}|=|G(z^{-1})|=1$。  </p><p>常见的映射律如下表所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211223165920.png width=80%></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>数字信号处理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>可靠性工程-知识点总结</title>
    <link href="/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%B7%A5%E7%A8%8B/%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%B7%A5%E7%A8%8B/"/>
    <url>/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%B7%A5%E7%A8%8B/%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%B7%A5%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="可靠性工程-知识点总结"><a href="#可靠性工程-知识点总结" class="headerlink" title="可靠性工程-知识点总结"></a>可靠性工程-知识点总结</h1><blockquote><p>本文是BUL EE2634 Digital Systems Design and Reliability Engineering 可靠性工程部分的知识点总结。<br>本节授课教师：Dr.Chungsing Lai（赖俊升）</p></blockquote><h2 id="可靠性工程的衡量指标"><a href="#可靠性工程的衡量指标" class="headerlink" title="可靠性工程的衡量指标"></a>可靠性工程的衡量指标</h2><blockquote><p>可靠性术语-德州仪器：<a href="https://www.ti.com.cn/zh-cn/support-quality/reliability/reliability-terminology.html">https://www.ti.com.cn/zh-cn/support-quality/reliability/reliability-terminology.html</a></p></blockquote><p>产品质量、性能和可靠性是可靠性工程的三个重要因素。此外产品的可维护性，可用性等指标也与可靠性工程有关。  </p><h3 id="质量"><a href="#质量" class="headerlink" title="质量"></a>质量</h3><p>产品或者服务的质量（Quality）可以定义为：<strong>产品或服务满足用户给定需求的全部功能和特性的能力。</strong><br>产品的质量与制造产品时所用的主要材料和工艺（craftsmanship）有关。  </p><blockquote><p>有如下的因素可以影响产品对目标值的实现度，即产品质量：  </p><ul><li>生产噪声：在制造过程中因为制造差异和缺陷而导致的产品个体差异。  </li><li>内部噪声：在使用过程中产品某些性质的改变，比如磨损，生锈等等。  </li><li>外部噪声：环境因素（比如温度、湿度、尘埃等等）和用户的使用方法。  </li></ul></blockquote><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>产品的性能(Performance)通常用<strong>产品执行其预期功能的程度</strong>来衡量。  </p><h3 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h3><p>可靠性(Reliability)通常<strong>表征产品未来的性能</strong>，是一个随机变量。它的定义需要由性能条件，环境条件，时间范围对其限制。<br>某个产品或系统的可靠性可以定义为<strong>在特定时间内，在生命周期条件下能够如期表现其性能的能力。</strong>   </p><div class="note note-info">            <p>生命周期条件指产品在整个生命周期（生产、运输、储存、使用）中能够正常运行的环境条件。  </p>          </div><h4 id="衡量产品可靠性的因素"><a href="#衡量产品可靠性的因素" class="headerlink" title="衡量产品可靠性的因素"></a>衡量产品可靠性的因素</h4><p>对同一个产品，其可靠性并不是唯一的。某个产品的可靠性主要依据四个因素进行衡量和定义：  </p><ul><li>对“预期功能”的定义</li><li>对“产品期望性能”（Satisfactory performance）的定义</li><li>使用条件和环境条件</li><li>时间</li></ul><h4 id="可靠性与产品生命周期"><a href="#可靠性与产品生命周期" class="headerlink" title="可靠性与产品生命周期"></a>可靠性与产品生命周期</h4><p>整个产品的生命周期中都会涉及到有关可靠性的活动:<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211220162651.png width=50%><br>在整个产品生命周期中的投入方式有两种假设：一种是在产品周期的前期对可靠性的投入较大，那么在后期就可以对产品的可靠性投入较少。如果在产品周期的前期对对可靠性的投入较少，那么在生命周期的后期由于产品出问题的概率较大，因此在后期对可靠性的投入（比如售后和维修支出）需要较多，两种假设可以用下图表示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211220163225.png width=50%>  </p><h4 id="可靠性失效的后果"><a href="#可靠性失效的后果" class="headerlink" title="可靠性失效的后果"></a>可靠性失效的后果</h4><p>对于不同的产品和失效方式，产品可靠性失效的后果可能影响不大，也可能导致灾难性的后果。常见的失效后果包括：</p><ul><li>财产损失</li><li>人员伤亡</li><li>无形成本损失</li><li>公信力损失</li><li>…</li></ul><h3 id="可维护性（Maintainability）"><a href="#可维护性（Maintainability）" class="headerlink" title="可维护性（Maintainability）"></a>可维护性（Maintainability）</h3><p>产品的可维护性定义为：<strong>在规定的使用条件下，使用规定的程序和资源进行维护时，产品能够通过维修恢复到能够履行其所需功能的状态的能力。</strong></p><h4 id="维护的类别"><a href="#维护的类别" class="headerlink" title="维护的类别"></a>维护的类别</h4><ul><li>修复性维护（Corrective Maintenance）<br>故障发生后对产品进行的维护，是一种事后维护。  </li><li>预防性维护（Preventive Maintenance）<br>每隔一段时间或按照规定的标准进行的维护，目的是减少发生失效的概率。  </li><li>预测性维护（Predictive Based Maintenance）<br>是以状态为依据(Condition Based)的维护，在机器运行时，对它的主要（或需要）部位进行定期（或连续）的状态监测和故障诊断，判定产品所处的状态，预测产品状态未来的发展趋势，依据产品的状态发展趋势和可能的故障模式，预先制定预测性维护计划，确定机器应该修理的时间、内容、方式和必需的技术和物资支持。  </li></ul><h4 id="维护的衡量指标"><a href="#维护的衡量指标" class="headerlink" title="维护的衡量指标"></a>维护的衡量指标</h4><p>可维护性通过修复所需要的时间间隔进行衡量。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211220194310.png width=50%></p><ul><li><p>MTTR（Mean Time To Repair）<br>平均维护所需时间，是系统的宕机时间（Downtime）。  </p><blockquote><p>宕机时间又指系统因为干扰而不能正常工作的时间。  </p></blockquote><script type="math/tex; mode=display">MTTR=\frac{总维护时间}{维护次数}</script></li><li><p>MTTF（Mean Time To Faliure）<br>平均故障时间，指系统维修好后到下一次出现故障的平均时间，是系统的正常工作/上线时间（Uptime）。  </p><blockquote><p>上线时间又指系统正常工作的时间。  </p></blockquote></li><li><p>MTBF（Mean Time Between Failures）<br>平均故障间隔时间，指两次故障发生的平均间隔时间，是系统的工作时间。<br>三者满足如下关系：  </p><script type="math/tex; mode=display">MTBF=MTTR+MTTF</script></li><li>可用性<br>定义可用性（Availability）为系统的上线时间与系统总工作时间之比：  <script type="math/tex; mode=display">A=\frac{MTTR}{MTBF}=\frac{MTTR}{MTTF+MTTR}</script>对于不可修复性系统而言，系统一旦宕机，不可修复：$A=\frac{MTTR}{MTTR}=1$。  </li></ul><h2 id="可靠性工程的统计分析"><a href="#可靠性工程的统计分析" class="headerlink" title="可靠性工程的统计分析"></a>可靠性工程的统计分析</h2><h3 id="质量、性能和可靠性的统计定义"><a href="#质量、性能和可靠性的统计定义" class="headerlink" title="质量、性能和可靠性的统计定义"></a>质量、性能和可靠性的统计定义</h3><p>产品的可靠性估计量可以通过在某时刻$t$下采样得到，具体而言：<br>产品的可靠性估计量可以用某时刻$t$下采样中的良品数量与样品总数之比进行表示：  </p><script type="math/tex; mode=display">\hat{R(t)}=\frac{n_s(t)}{n_0}=1-\hat{F(t)}</script><p>其中$\hat{F(t)}=\frac{n_f}{n_0}$表示失效率(Failure rate)的估计量，定义与可靠性相反。<br>如果失效率的概率密度函数用$f(t)$表示，那么失效率的概率积累函数为：  </p><script type="math/tex; mode=display">F(t)=\int_0^tf(τ)dτ</script><p>其物理意义是在$t$时刻下失效产品占产品总数的比例。  </p><div class="note note-info">            <p>失效率的概率密度函数必须满足全域积分为1($∫f(t)dt=1$)的条件。  </p>          </div><div class="note note-info">            <p>$B_α$表示：$F(B_α)=\frac{α}{100}$  </p>          </div><p>那么可靠性的概率积累函数表示为：  </p><script type="math/tex; mode=display">R(t)=1-F(t)=\int_t^∞f(τ)dτ</script><p>其物理意义是在$t$时刻下存留产品（未失效）占产品总数的比例。<br><div class="note note-info">            <p>已知$t_1$时刻下的可靠性$R(t,t_1)$，在$t$时刻（$t&gt;t_1$）的可靠性$R(t,t_1)$:  </p><script type="math/tex; mode=display">R(t,t_1)=\frac{R(t+t_1)}{R(t_1)}</script>          </div></p><h3 id="风险率"><a href="#风险率" class="headerlink" title="风险率"></a>风险率</h3><p>风险率（Hazard Rate）是某一时刻$t$下，单位时间失效产品数与存留产品数之比。风险率可以理解为某一时刻下的失效率，表示为：  </p><script type="math/tex; mode=display">h(t)=\frac{f(t)}{R(t)}</script><p>风险率可以用一段时间失效产品数与存留产品数之比除以时间估计：  </p><script type="math/tex; mode=display">\hat{h}(t)=\frac{N_f}{N_0Δt}</script><p>风险率是产品失效的相对表征，因此风险率与样本数量大小无关。<br>可靠性和风险率的关系为：  </p><script type="math/tex; mode=display">R(t)=e^{-\int_0^th(τ)dτ}</script><h4 id="澡盆曲线-寿命特性曲线"><a href="#澡盆曲线-寿命特性曲线" class="headerlink" title="澡盆曲线/寿命特性曲线"></a>澡盆曲线/寿命特性曲线</h4><p>理想的产品风险率曲线应当如下图所示，称为澡盆曲线/寿命特性曲线。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211220170344.png width=50%>  </p><p>澡盆曲线对应的可靠性曲线如图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211220171138.png width=50%></p><p>如图，一般把产品从投产起至严重磨损后的全过程划分为三个时期，即初期故障期、偶发故障期与磨损故障期。  </p><ul><li><p>初期故障期(Infant Mortality Period)<br>产品在投产后的一段时间内，一些可靠性较差的产品会立即失效，因此初期故障期产品总体的风险率很高，随时间逐步下降。  </p><blockquote><p>某些厂家会在出厂后增加一段“腐蚀期”以筛选出可靠性较差的产品，再投入销售。  </p></blockquote></li><li><p>偶发故障期（Useful Life Period）<br>在用户使用的前期和中期，产品比较稳定，不容易出现失效，在此期间的风险率较低。  </p></li><li><p>磨损故障期（Wear-out Period）<br>在用户使用末期，产品随着时间和使用次数的增加而磨损，出现失效的概率大幅度增加。可以采取维护或者更换的方式延长产品总体的可靠性。  </p></li></ul><h3 id="可修复性的统计定义"><a href="#可修复性的统计定义" class="headerlink" title="可修复性的统计定义"></a>可修复性的统计定义</h3><p>可修复性可以表示为失效率的统计均值：  </p><script type="math/tex; mode=display">MTTF=\int_0^∞tf(t)dt=\int_0^∞R(t)dt</script><h3 id="离散分布特征"><a href="#离散分布特征" class="headerlink" title="离散分布特征"></a>离散分布特征</h3><p>可靠性可以看做是未来的系统质量，可以用随机变量表示。<br>离散分布有伯努利分布、二项分布和泊松分布。  </p><div class="table-container"><table><thead><tr><th style="text-align:center">分布类型</th><th style="text-align:center">概率密度/积累分布函数</th><th style="text-align:center">期望</th><th style="text-align:center">方差</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">伯努利分布</td><td style="text-align:center">$f(k)=p^kq^{1-k}$</td><td style="text-align:center">$μ=p$</td><td style="text-align:center">$σ^2=p(1-p)$</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">二项分布</td><td style="text-align:center">$f(k)=C_k^mp^kq^{m-k}$ <br> $F(k)=∑_{i=0}^kC_i^mp^iq^{(m-i)}$</td><td style="text-align:center">$μ=mp$</td><td style="text-align:center">$σ^2=mp(1-p)$</td><td style="text-align:center">$m$：所有可能事件数</td></tr><tr><td style="text-align:center">泊松分布</td><td style="text-align:center">$f(k)=\frac{μ^k}{k!}e^{-μ}$</td><td style="text-align:center">$μ=mp$</td><td style="text-align:center">$σ^2=mp$</td><td style="text-align:center">$m$：所有可能事件数</td></tr></tbody></table></div><h3 id="连续分布特征"><a href="#连续分布特征" class="headerlink" title="连续分布特征"></a>连续分布特征</h3><h4 id="威布尔分布（Weibull-Distribution）"><a href="#威布尔分布（Weibull-Distribution）" class="headerlink" title="威布尔分布（Weibull Distribution）"></a><strong>威布尔分布（Weibull Distribution）</strong></h4><p>威布尔分布是最常见的一种用于拟合风险率的曲线，其概率密度函数为：  </p><script type="math/tex; mode=display">f(t)=βη^{-β}(t-γ)^{β-1}e^{-(\frac{t-γ}{η})^β}</script><p>其中，$β&gt;0$是形状参数，$η&gt;0$是放大尺度，$γ$是时移尺度，通常等于0。  </p><script type="math/tex; mode=display">R(t)=∫_t^∞f(t)dt=e^{-(\frac{t-γ}{η})^β}</script><p>其均值为：</p><script type="math/tex; mode=display">ηΓ(1+\frac{1}{β})</script><p>其方差为：  </p><script type="math/tex; mode=display">η^2\left(Γ(1+\frac{2}{β})-Γ^2(1+\frac{1}{β}))\right)</script><h4 id="指数分布（Exponential-Distribution）"><a href="#指数分布（Exponential-Distribution）" class="headerlink" title="指数分布（Exponential Distribution）"></a><strong>指数分布（Exponential Distribution）</strong></h4><p>指数分布是威布尔分布在$β=1$，$γ=0$ 时的特殊情况：   </p><script type="math/tex; mode=display">f(t)=λ_0e^{-λ_0t},λ_0=\frac{1}{η},t≥0</script><p>其均值为$\frac{1}{λ_0}$，方差为$(\frac{1}{λ_0})^2$。<br>可靠性表示为：  </p><script type="math/tex; mode=display">R(t)=e^{-λ_0t}</script><p>风险率表示为：  </p><script type="math/tex; mode=display">h(t)=λ_0</script><h4 id="正态分布（Gaussian-Normal-Distribution）和对数正态分布（Log-normal-Distribution）"><a href="#正态分布（Gaussian-Normal-Distribution）和对数正态分布（Log-normal-Distribution）" class="headerlink" title="正态分布（Gaussian/Normal Distribution）和对数正态分布（Log-normal Distribution）"></a><strong>正态分布（Gaussian/Normal Distribution）和对数正态分布（Log-normal Distribution）</strong></h4><p>正态分布的概率密度函数为：  </p><script type="math/tex; mode=display">f(t)=\frac{1}{\sqrt{2π}σ}e^{-\frac{(t-μ)^2}{2σ^2}}</script><p>当$μ=0,σ^2=1$时退化为标准正态分布：  </p><script type="math/tex; mode=display">ϕ(t)=\frac{1}{\sqrt{2π}}e^{-\frac{t^2}{2}}</script><p>任何均值为$μ$，方差为$σ^2$的正态分布都可以转化为标准正态分布，来求概率积累函数：  </p><script type="math/tex; mode=display">F(t)=Φ(\frac{t-μ}{σ})</script><script type="math/tex; mode=display">f(t)=\frac{ϕ(\frac{t-μ}{σ})}{σ}</script><p>标准正态分布是一个以1对称的函数：  </p><script type="math/tex; mode=display">Φ(-z)=1-Φ(z)</script><p>其中$Φ(\frac{t-μ}{σ})$可以在标准正态分布表中找到对应的值。  </p><p>对数正态分布中，$t:=lnt$，其余性质与正态分布完全相同。<br>其均值为；$MTTF=e^{μ+\frac{σ^2}{2}}$。<br>风险率表示为：  </p><script type="math/tex; mode=display">h(t)=\frac{ϕ(\frac{lnt-μ}{σ})}{σtR(t)}</script><h4 id="伽玛分布（Gamma-Distribution）"><a href="#伽玛分布（Gamma-Distribution）" class="headerlink" title="伽玛分布（Gamma Distribution）"></a><strong>伽玛分布（Gamma Distribution）</strong></h4><p>伽玛分布的概率密度函数*：  </p><script type="math/tex; mode=display">f(t)=\frac{λ^η}{Γ(η)}t^{η-1}e^{-λt}</script><p>其中$η$是其形状参数，$λ$是尺度参数，$Γ(η)$由伽马函数通过查表得到，伽马函数满足：  </p><script type="math/tex; mode=display">Γ(n+1)=nΓ(n),n>0</script><h2 id="可靠性分析数据和数据来源"><a href="#可靠性分析数据和数据来源" class="headerlink" title="可靠性分析数据和数据来源"></a>可靠性分析数据和数据来源</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="技术数据"><a href="#技术数据" class="headerlink" title="技术数据"></a>技术数据</h4><p>数据中指定了通道、子系统、各部分的工作原理。</p><h4 id="操作数据"><a href="#操作数据" class="headerlink" title="操作数据"></a>操作数据</h4><p>数据中指定了操作模式、操作环境和操作条件。  </p><h4 id="可靠性数据"><a href="#可靠性数据" class="headerlink" title="可靠性数据"></a>可靠性数据</h4><p>数据中给出了失效率，MTTF，或者是其他能够估计可靠性的数据。<br>可靠性数据包括如下五类：  </p><ul><li>泛用性数据（Generic Data）<br>由各种组织收集并公开的数据。<br>这些数据的时效性可能较低，当新环境/功能/操作条件引入时，这些数据可能准确率不高，因此需要对未注册数据进行处理。<br>处理的方法是用已知的未注册数据中的失效率$λ_B$中根据现有所有影响因子$δ_i$赋权后得到当前的失效率$λ_p$:  <script type="math/tex; mode=display">λ_P=λ_B\sum_{i=1}^kw_iσ_i</script>其中$σ_i$是影响失效率的影响因子（比如温度、湿度、测试时长等等），$w_i$是影响因子对应的权重，表示每个影响因子的对失效率的相对影响能力，并对其归一化：$∑w_i=1$。  </li><li>制造商数据<br>由制造商提供的数据，包括实验室测试，失效或者失效率估计等等。  </li><li>用户数据<br>通过特定用户收集的数据。  </li><li>专家判断<br>基于专家观点和经验提出的数据，可在在刚开始运行系统/新功能时可分析数据量不多的情况下使用。  </li></ul><h4 id="测试和维护数据"><a href="#测试和维护数据" class="headerlink" title="测试和维护数据"></a>测试和维护数据</h4><p>与维护和测试相关的数据，比如观察时间，平均维修时间等等。  </p><p>这四类数据对于可靠性分析的作用如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211221160311.png width=50%></p><h3 id="删失（Censoring）"><a href="#删失（Censoring）" class="headerlink" title="删失（Censoring）"></a>删失（Censoring）</h3><p>删失数据是指在观察或试验中,由于人力或其他原因未能观察到目标事件发生，因而得到的数据。  </p><h3 id="6σ原则"><a href="#6σ原则" class="headerlink" title="6σ原则"></a>6σ原则</h3><p>6σ原则是一种经管流程，通过持续的流程改进来提高业务的最低水准。<br>6σ原则的目的是将零缺陷(Zero-defects)管理流程应用于组织中的每一个流程/产品当中。  </p><h2 id="生命周期档案"><a href="#生命周期档案" class="headerlink" title="生命周期档案"></a>生命周期档案</h2><p>产品的生命周期档案（Life-cycle loads）中包括了商品在生命周期的每一个阶段中可能影响产品生命周期的因素。  </p><h3 id="产品的生命周期"><a href="#产品的生命周期" class="headerlink" title="产品的生命周期"></a>产品的生命周期</h3><p>产品的生命周期包括：<br>制造和装配、测试、修改（Rework）、仓储、运输、运行、维修（Repair）、维护（Maintenance）。  </p><h3 id="生命周期负荷"><a href="#生命周期负荷" class="headerlink" title="生命周期负荷"></a>生命周期负荷</h3><p>生命周期负荷（Life-cycle loads）指能够影响产品生命周期的因素，通常分为五大类：  </p><ul><li>热学负荷（Thermal）：如温度区间、温度周期、温度梯度等。</li><li>力学负荷（Mechanical）：如压力、震动、声级（Acoustic level）等。 </li><li>化学负荷（Chemical）： 如臭氧浓度（Ozone）、惰性（Inert）环境、污染（contamination）等。  </li><li>物理学负荷（Physical）：如辐射、磁场干扰、纬度等。  </li><li>运行负荷（Operational）：如热耗、功率、电流、电压等。  </li></ul><h3 id="常见的生命周期负荷对产品的影响"><a href="#常见的生命周期负荷对产品的影响" class="headerlink" title="常见的生命周期负荷对产品的影响"></a>常见的生命周期负荷对产品的影响</h3><ul><li>温度  <ol><li>改变产品材料的性质。</li><li>改变化学反应（如腐蚀、生锈）的速率。</li></ol></li><li>震动  <ol><li>导致产品发生线性或非线性的移动。  </li><li>导致由于产品运动而造成的额外的机械能耗散或存储。  </li></ol></li><li>太阳辐射  <ol><li>对产品有紫外线和其他可能造成产品破坏的射线辐射。  </li><li>使产品和环境温度上升。  </li></ol></li><li>电磁辐射  </li><li>化学品和化学因素  <ol><li>使材料腐蚀（corrode）和变质（deteriorate）。  </li><li>由于生物化学反应，产品容易发生老化和生物（比如细菌）附着。  </li></ol></li><li>尘埃  <ol><li>进入机械结构中损伤产品结构。  </li><li>覆盖在元器件表面，影响其散热。  <blockquote><p>防范措施分为主动（通风、使用风扇或者空气净化器）和被动（植树）两种。  </p></blockquote></li></ol></li><li>电压  <ol><li>过高的电压导致产品过载、金属熔化、断路和断路。  </li><li>长期高电压导致产品氧化（Oxide breakdown）。</li></ol></li></ul><h3 id="量化估计生命周期负荷的方法"><a href="#量化估计生命周期负荷的方法" class="headerlink" title="量化估计生命周期负荷的方法"></a>量化估计生命周期负荷的方法</h3><p>在可靠性分析中，生命周期负荷需要被量化估计，具体的方法包括：  </p><ol><li>市场调研/查找标准数据  </li><li>监测生命周期负荷  </li><li>试验记录/失效记录/售后记录  </li><li>相同零部件的历史量化数据  </li></ol><h2 id="可靠性试验"><a href="#可靠性试验" class="headerlink" title="可靠性试验"></a>可靠性试验</h2><p>可靠性试验（Reliability Testing）的目的是：  </p><ol><li>确定安全使用期限。  </li><li>确认产品规格是否符合预期。   </li><li>确定产品的失效模式。  </li><li>测试某一部件或系统超出标准使用范围时的运行稳定性。  </li></ol><h3 id="完整寿命试验"><a href="#完整寿命试验" class="headerlink" title="完整寿命试验"></a>完整寿命试验</h3><p>完整寿命试验（Full-life Testing）将产品在其整个生命周期种对其施加预测好的正常使用下的应力（Stress），观察产品在整个寿命周期中的变化。其缺点是这样的寿命测试需要持续相当长的时间，甚至需要24小时/7天全天候持续运行测试。  </p><h3 id="加速寿命试验"><a href="#加速寿命试验" class="headerlink" title="加速寿命试验"></a>加速寿命试验</h3><p>加速寿命试验（Accelerated Life Testing,ALT）是一种决定产品寿命终止期限（end-of-life）和预测其失效模式的方法。其在短时间内通过增加应力来模拟产品在生命周期中受到的磨损情况，以预测在正常工作条件或储存条件下的可靠性。<br>加速寿命试验会增加产品在整个生命周期的风险率，但不改变受试产品在整个生命周期的失效分布。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211224100933.png width=50%>  </p><p>加速寿命实验的前提条件是测试前需要对产品的失效机制（Failure Mechanisms）有足够的了解，并且测试目的是明确的探究指定因素对产品寿命的影响。  </p><h4 id="失效机制"><a href="#失效机制" class="headerlink" title="失效机制"></a>失效机制</h4><p>失效机制是力学、化学、电学等条件导致故障的过程。潜在的失效机制是根据失效模式和原因、载荷和材料确定的。通常，失效机制分为“磨损”（Wearout）和“过载”（Overstress）两类。  </p><ul><li>磨损<br>磨损是指应力长时间积累对产品造成的损坏。  </li><li>过载<br>过载是指单一的，超出了材料承受限制的应力对产品造成的损坏。  </li></ul><h3 id="环境应力筛选"><a href="#环境应力筛选" class="headerlink" title="环境应力筛选"></a>环境应力筛选</h3><p>环境应力筛选(Environmental Stress Screening,ESS)是为发现和排除不良产品和防止出现早期失效，在环境应力下所做的一系列试验。它的意义就是筛选产品，把通过不能用常规检验或试验的方法查出的缺陷，暴露出来。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211224101617.png width=50%>  </p><h3 id="电磁兼容试验"><a href="#电磁兼容试验" class="headerlink" title="电磁兼容试验"></a>电磁兼容试验</h3><p>电磁兼容性 (Electro-Magnetic Compatibility,EMC) 是指产品在它本身的电磁环境中，能够正常工作且不会产生让其它在此环境中的设备难以忍受的电磁干扰的性质。<br>电磁兼容试验（Electromagnetic Compatibility Screening Testing,EMC Testing）的目的是为了测试产品的这一性质。<br>常见的电磁兼容试验项目包括：辐射骚扰测试（Radiated Emission）和传导骚扰测试（Conducted Emission）等等。  </p><h2 id="失效分析方法"><a href="#失效分析方法" class="headerlink" title="失效分析方法"></a>失效分析方法</h2><h3 id="故障树"><a href="#故障树" class="headerlink" title="故障树"></a>故障树</h3><p>系统中的每一个部分的失效和整个系统失效之间的关系可以用布尔运算表达。故障树（Faulty tree）通过树形结构表示这一布尔运算式。基本的树形结构表达如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211224104412.png width=40%>  </p><p>对于和事件，其发生概率为：  </p><script type="math/tex; mode=display">P(I)=P(A)+P(B)-P(A)P(B)</script><p>对于积事件，其发生概率为：  </p><script type="math/tex; mode=display">P(I)=P(A)P(B)</script><p>需要注意的是，这样的树形结构中的下层结构中所有子部分的失效率之和应当为1。  </p><p>故障树的基本分析思路是：  </p><ol><li>从下向上分析，从最低层级的子树分析，写出子树的布尔运算式。  </li><li>分析高层级的树，写出其布尔运算式，并将子树的布尔运算式带入。  </li><li>使用运算律化简整个系统的布尔运算式。  </li></ol><h3 id="可靠性框图"><a href="#可靠性框图" class="headerlink" title="可靠性框图"></a>可靠性框图</h3><p>可靠性框图是另一种表达系统中的每一个部分的失效和整个系统失效之间的关系的方法，其在系统框图中加入了每个部分的可靠性概率（即正常工作的概率）。<br>基本的系统结构有并联和串联两种。<br>对于串联系统，系统正常工作的条件是每个部分都能够正常工作，每个部分正常工作的概率为$P_{i|R}$，$P_{i|R}$表示部分$i$的可靠性概率，因此串联系统的可靠性概率为：  </p><script type="math/tex; mode=display">P_R=∏_i P_{i|R}</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211224105659.png width=50%>  </p><p>对于并联系统，系统正常工作的条件是每个部分都能够正常工作，即每个部分都不会发生失效，每个部分发生失效的概率为$P_{i|f}=1-P_{i|R}$，整个并联系统的失效概率为$P_f=∏_i1-P_{i|R}$，根据$1-P_f=P_R$，整个系统的可靠性概率为：  </p><script type="math/tex; mode=display">P_R=1-\left(∏_i1-P_{i|R}\right)</script>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>数字系统与可靠性工程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>10. FIR滤波器设计方法</title>
    <link href="/2021/12/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/10.%20FIR%20%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/"/>
    <url>/2021/12/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/10.%20FIR%20%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="FIR滤波器设计方法"><a href="#FIR滤波器设计方法" class="headerlink" title="FIR滤波器设计方法"></a>FIR滤波器设计方法</h1><p>在实际的滤波器设计中，需要通过各种各样的方法来近似理想滤波器的幅度值响应，从而近似实现理想滤波器的功能。  </p><h2 id="加窗法"><a href="#加窗法" class="headerlink" title="加窗法"></a>加窗法</h2><p>加窗法（Windowing）基于离散时间傅里叶变换（DTFT）进行设计，其基本思想是由于理想滤波器的带宽是无限长的，通过截取理想滤波器系统冲激响应的一段序列，并用窗函数序列加权来替代整个理想滤波器的波形。  </p><h3 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h3><p>加窗法的实现依赖于理想低通滤波器，理想低通滤波器的冲激响应为：  </p><script type="math/tex; mode=display">h[n]=\frac{sin(ω_cn)}{πn}</script><p>其中$ω_c$表示其截止频率。  </p><ol><li>设置滤波器的长度$L=2N+1$，并在理想低通滤波器冲激响应上截取$L$个采样点。为了满足线性相位滤波器的条件，通常使用以$h[0]$为对称轴的奇数$L$个序列。定义滤波器的阶数$M$为滤波器序列长度减一：<script type="math/tex; mode=display">M=L-1</script>此时的序列为$\{h[-N],h[-N+1],..,\underset{n=0}{h[0]},..,h[N-1],h[N]\}$,是一个非因果序列。</li><li>对截取的序列做时移以满足系统的因果性，时移量为$α=\frac{L-1}{2}$，称为滤波器的<strong>群时延</strong>(Group delay)。<br>此时的序列为：$\{\underset{n=0}{h[-N]},h[-N+1],..,h[0],..,h[N-1],h[N]\}$</li><li>为了使得滤波器性能更好，还需要对产生的序列进行赋权，产生赋权序列的函数称为窗函数（Window function），赋权的操作为：<script type="math/tex; mode=display">fl[n]=h_d[n]×w[n]</script>其中$h_d[n]$为截取和时移之后的理想低通滤波器序列，$w[n]$由窗函数产生，对于矩形窗：$w[n]=1$，之后会对窗函数做更加详细的介绍。  </li></ol><div class="note note-warning">            <p>需要注意的是，窗函数的阶数比序列阶数高2，再截掉窗函数序列两端的0后，与理想低通滤波器序列相乘。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211230151430.png width=70%>  </p>          </div><h3 id="加窗法的频谱分析·滤波器波形的影响因素"><a href="#加窗法的频谱分析·滤波器波形的影响因素" class="headerlink" title="加窗法的频谱分析·滤波器波形的影响因素"></a>加窗法的频谱分析·滤波器波形的影响因素</h3><p>在频域中，赋权表示为实际滤波器$h_d[n]$的频率响应与窗函数频率响应的周期卷积：  </p><script type="math/tex; mode=display">fl(e^{jω})=H_d(e^{jω}) \tilde{⊕} W(e^{jω})</script><p>在频域中$H_d(e^{jω})$是一个门函数，对矩形窗，$W(e^{jω})$是采样函数。<br>两者周期卷积的过程如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/image171.gif width=70%><br>两者的卷积结果如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/R-C.2b3573a9858b6fa5a41359616773035c width=70%>  </p><h4 id="波纹"><a href="#波纹" class="headerlink" title="波纹"></a>波纹</h4><p>可以发现，由于窗函数旁瓣在频域上的振荡，使得卷积后的频率响应中在通带和止带都出现了振荡，称为滤波器的波纹(Ripple)。同时可以发现，波纹在周期卷积过程中的形成只和窗函数频谱的主瓣和旁瓣的相对幅值有关，定义峰值旁瓣比(PSLR，peak side lobe ratio) 表示dB化后的主瓣相邻旁瓣幅值和主瓣幅值之比：</p><script type="math/tex; mode=display">r_p|dB=20lg(\frac{A_{sidelope}}{A_{mainlope}})</script><p>可以发现，<strong>窗函数频谱中峰值旁瓣比越小，波纹的振荡就越小。</strong>  </p><h4 id="过渡带带宽"><a href="#过渡带带宽" class="headerlink" title="过渡带带宽"></a>过渡带带宽</h4><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211215141238.png width=50%></p><p>由上图可以看出，<strong>采样点的个数和过渡带带宽成反比关系。</strong><br>并且，过渡带带宽为主瓣带宽。<br>增大采样点的个数（实际设计中增大抽头数$N$），其过渡带会减小。  </p><h4 id="吉布斯效应"><a href="#吉布斯效应" class="headerlink" title="吉布斯效应"></a>吉布斯效应</h4><p>同时，<strong>增大抽头数$N$还会改变波纹的密度，抽头数增多，其波纹密度增大</strong><br>，但是每个波纹的幅值并不会改变，这个效应称为吉布斯效应。<br><strong>吉布斯效应可以通过设计窗函数时让窗函数的时域表达平缓的由1减小到0来消除。</strong>  </p><h4 id="宽容度"><a href="#宽容度" class="headerlink" title="宽容度"></a>宽容度</h4><p>上述影响因素都是基于幅度值-频率响应得出的，定义滤波器的幅度-频率响应为：  </p><script type="math/tex; mode=display">A_e(e^{jω})=H_e(e^{jω}) \tilde{⊕} W_e(e^{jω})</script><p>对于第一类FIR滤波器(序列对称，长度为奇数)，有：  </p><script type="math/tex; mode=display">A_e(e^{jω})=H(e^{jω})e^{-jαω}</script><p>$H$和$W$为原始滤波器和窗函数的幅度-频率响应。<br>低通滤波器的幅度响应图如下：  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211215145524.png width=50%>  </p><p>定义波纹偏离1或0的最大幅值为滤波器的宽容度(Tolerance)$δ$，上下波纹的宽容度相同。峰值近似误差（Peak approximation error）用dB表示波纹的宽容度：  </p><script type="math/tex; mode=display">e_p=20lgδ</script><h3 id="常见窗函数"><a href="#常见窗函数" class="headerlink" title="常见窗函数"></a>常见窗函数</h3><h4 id="矩形窗"><a href="#矩形窗" class="headerlink" title="矩形窗"></a>矩形窗</h4><p>矩形窗函数：</p><script type="math/tex; mode=display">w[n]=\begin{cases}    1, 0 ≤n≤N-1\\    0, otherwise\end{cases}</script><p>矩形窗函数的峰值旁瓣比：$r_p=-13dB$<br>主瓣宽度$Δω_m=\frac{4π}{N}$<br>由于矩形窗从1到0的变化过快，因此难以消除吉布斯效应。  </p><h4 id="三角窗"><a href="#三角窗" class="headerlink" title="三角窗"></a>三角窗</h4><p>三角窗函数：  </p><script type="math/tex; mode=display">w[n]=\begin{cases}    \frac{2n}{M}, 0≤n≤\\    2-\frac{2n}{M}, \frac{M}{2}≤n≤M\\    0, otherwise\end{cases}</script><p>矩形窗函数的峰值旁瓣比：$r_p=-27dB$<br>主瓣宽度$Δω_m=\frac{8π}{N}$  </p><h4 id="汉宁窗（Hanning）"><a href="#汉宁窗（Hanning）" class="headerlink" title="汉宁窗（Hanning）"></a>汉宁窗（Hanning）</h4><p>汉宁窗函数：  </p><script type="math/tex; mode=display">w[n]=0.5-0.5cos(\frac{2πn}{M}),0≤n≤M</script><p>矩形窗函数的峰值旁瓣比：$r_p=-31dB$<br>主瓣宽度$Δω_m=\frac{8π}{N}$  </p><h4 id="汉明窗（Hamming）"><a href="#汉明窗（Hamming）" class="headerlink" title="汉明窗（Hamming）"></a>汉明窗（Hamming）</h4><p>汉宁窗函数：  </p><script type="math/tex; mode=display">w[n]=0.54-0.46cos(\frac{2πn}{M}),0≤n≤M</script><p>矩形窗函数的峰值旁瓣比：$r_p=-41dB$<br>主瓣宽度$Δω_m=\frac{8π}{N}$  </p><h4 id="布莱克曼窗（Blackman）"><a href="#布莱克曼窗（Blackman）" class="headerlink" title="布莱克曼窗（Blackman）"></a>布莱克曼窗（Blackman）</h4><p>布莱克曼窗函数：  </p><script type="math/tex; mode=display">w[n]=0.42-0.5cos(\frac{2πn}{M})+0.08cos(\frac{4πn}{M}),0≤n≤M</script><p>矩形窗函数的峰值旁瓣比：$r_p=-57dB$<br>主瓣宽度$Δω_m=\frac{12π}{N}$  </p><h4 id="凯撒窗"><a href="#凯撒窗" class="headerlink" title="凯撒窗"></a>凯撒窗</h4><p>凯撒窗函数：  </p><script type="math/tex; mode=display">w[n]=\begin{cases}    \frac{I_0[β(1-[\frac{n-α}{α}]^2)^{\frac{1}{2}}]}{I_0(β)},0≤n≤M\\    0, otherwise\end{cases}</script><p>凯撒窗的过渡带带宽由凯撒窗的阶数和宽容度决定：  </p><script type="math/tex; mode=display">M=\frac{-e_p-8}{2.285Δω}</script><p>宽容度由形状参数决定：  </p><script type="math/tex; mode=display">β=\begin{cases}    0.1102(-e_p-8.7),-e_p>50\\    0.5842(-e_p-21)^{0.4}+0.07886(-e_p-21),21≤-e_p≤50\\    0, -e_p<21\end{cases}</script><p>凯撒窗可以通过控制阶数和形状参数$β$来控制宽容度和过渡带带宽。<br>对于给定宽容度和过渡带带宽的设计要求，应用凯撒窗函数设计滤波器的步骤：  </p><ol><li>根据宽容度$δ$计算出$e_p$  </li><li>根据$e_p$计算出$β$。  </li><li>根据$e_p$和过渡带带宽计算出凯撒窗的阶数。  </li></ol><h3 id="高通和带通、带阻滤波器设计"><a href="#高通和带通、带阻滤波器设计" class="headerlink" title="高通和带通、带阻滤波器设计"></a>高通和带通、带阻滤波器设计</h3><p>高通和带通、带阻滤波器的频率响应都可以通过对低通滤波器频率响应加以一定的数学变换得到。  </p><h4 id="高通滤波器"><a href="#高通滤波器" class="headerlink" title="高通滤波器"></a>高通滤波器</h4><p>高通滤波器的频率响应可以表示为1-低通滤波器：  </p><script type="math/tex; mode=display">H_{HP}(e^{jω})=1-H_{LP}(e^{jω})</script><p>对应时域冲激响应表示为：  </p><script type="math/tex; mode=display">h[n]=δ[n]-\frac{sin(ω_cπ(n-α))}{πn}</script><h4 id="带通滤波器"><a href="#带通滤波器" class="headerlink" title="带通滤波器"></a>带通滤波器</h4><p>带通滤波器的频率响应可以表示为两个截止频率不同的低通滤波器频率响应相减：  </p><script type="math/tex; mode=display">H_{BP}(e^{jω})=H_{LP1}(e^{jω})-H_{LP2}(e^{jω})</script><p>对应时域冲激响应表示为：  </p><script type="math/tex; mode=display">h[n]=\frac{sin(ω_{ca}π(n-α))}{πn}-\frac{sin(ω_{cb}π(n-α))}{πn}</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211218185227.png width=50%></p><h4 id="带阻滤波器"><a href="#带阻滤波器" class="headerlink" title="带阻滤波器"></a>带阻滤波器</h4><p>带阻滤波器的频率响应可以表示为1-带通滤波器的频率响应。  </p><script type="math/tex; mode=display">H_{HP}(e^{jω})=1-H_{LP}(e^{jω})</script><p>对应时域冲激响应表示为：  </p><script type="math/tex; mode=display">h[n]=δ[n]-\left(\frac{sin(ω_{ca}π(n-α))}{πn}-\frac{sin(ω_{cb}π(n-α))}{πn}\right)</script><h3 id="使用MATLAB进行滤波器设计"><a href="#使用MATLAB进行滤波器设计" class="headerlink" title="使用MATLAB进行滤波器设计"></a>使用MATLAB进行滤波器设计</h3><p>MATLAB中，可以使用<code>fir1()</code>函数来进行加窗法的程序设计，其具体表达为：<br><code>fir1(order,omega_c,filtertype,windowtype,&quot;noscale/scale&quot;)</code><br>其中<code>order</code>表示滤波器的阶数；<code>omega_c</code>是π归一化后的滤波器截止频率；<code>filtertype</code>表示设计的滤波器类型，缺省值为低通滤波器<code>&quot;low&quot;</code>；<code>windowtype</code>表示使用的窗函数，缺省值为海宁窗；<code>&quot;noscale/scale&quot;</code>表示是否需要归一化。<br>其中常见的窗函数有：  </p><ul><li><code>boxcar(l)</code>：矩形窗  </li><li><code>hann(l)</code>：海宁窗  </li><li><code>kaiser(l,beta)</code>：凯撒窗<br><strong>l 表示的是滤波器的序列长度，注意与滤波器的阶数作区分。</strong>  </li></ul><p><code>fir1()</code>函数会返回滤波器的冲激响应序列，返回的冲激序列使用<code>[H_f,w]=freqz(h)</code>返回其幅度-频率响应<code>H_f</code>和角频率轴<code>w</code>。<br>其幅度值-频率响应可以通过求其绝对值<code>abs(H_f)</code>得到，相频响应可以通过<code>angle(H_f)</code>得到。<br>下面的例程展示了如何用MATLAB绘制一个序列长度为7，截止频率为0.5π的理想低通滤波器：<br><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs M">h <span class="hljs-built_in">=</span> fir1(<span class="hljs-number">6</span>, <span class="hljs-number">0.5</span>, <span class="hljs-string">&quot;low&quot;</span>,boxcar(<span class="hljs-number">7</span>),<span class="hljs-string">&quot;noscale&quot;</span>); <span class="hljs-comment">% generate the filter</span><br>[hf,w] <span class="hljs-built_in">=</span> freqz(h); <span class="hljs-comment">% 频率响应</span><br>figure(<span class="hljs-number">1</span>);<br>plot(w/pi,abs(hf)); <span class="hljs-comment">% 幅频响应</span><br>xlabel(<span class="hljs-string">&quot;\omega / \pi&quot;</span>)<br>title(<span class="hljs-string">&quot;Magnitude response&quot;</span>);<br>figure(<span class="hljs-number">2</span>);<br>plot(w/pi,angle(hf)); <span class="hljs-comment">% 相频响应</span><br>xlabel(<span class="hljs-string">&quot;\omega / \pi&quot;</span>);<br>title(<span class="hljs-string">&quot;Phase response&quot;</span>);<br></code></pre></td></tr></table></figure><br>下面例程用于生成一个序列长度131，截止频率0.5π，β=4.966的凯撒窗低通滤波器，例程如下：<br><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs M"><span class="hljs-comment">% 生成一个序列长度131，截止频率0.5π，β=4.966的凯撒窗滤波器</span><br>h <span class="hljs-built_in">=</span> fir1(<span class="hljs-number">130</span>, <span class="hljs-number">0.5</span>, <span class="hljs-string">&quot;low&quot;</span>,kaiser(<span class="hljs-number">131</span>,<span class="hljs-number">4.966</span>),<span class="hljs-string">&quot;noscale&quot;</span>); <br>[hf,w] <span class="hljs-built_in">=</span> freqz(h); <span class="hljs-comment">% 幅度-频率响应</span><br>figure(<span class="hljs-number">1</span>);<br>plot(w/pi,abs(hf)); <span class="hljs-comment">% 幅度值-频率响应</span><br>xlabel(<span class="hljs-string">&quot;\omega / \pi&quot;</span>)<br>title(<span class="hljs-string">&quot;Magnitude response&quot;</span>);<br>figure(<span class="hljs-number">2</span>);<br>plot(w/pi,angle(hf)); <span class="hljs-comment">% 相频响应</span><br>xlabel(<span class="hljs-string">&quot;\omega / \pi&quot;</span>);<br>title(<span class="hljs-string">&quot;Phase response&quot;</span>);<br></code></pre></td></tr></table></figure></p><h2 id="频率采样法"><a href="#频率采样法" class="headerlink" title="频率采样法*"></a>频率采样法*</h2><p>频率采样法的核心思想是滤波器的冲激响应$h[n]$的离散傅里叶变换的本质是对其频率响应$H(e^{jω})$进行采样。采样后通过在每个采样点之间插值，来近似拟合滤波器的频率响应。<br>因此，对于给定的理想滤波器频率响应$H(e^{jω})$，其对应的离散傅里叶变换应当为：  </p><script type="math/tex; mode=display">H(e^{jω})|_{ω=\frac{2πk}{N}}=H[k]</script><p>$H(e^{jω})$中$\frac{N-1}{2}$的序列通过采样生成后做对称生成后半部分的序列，以满足滤波器的线性相位特性。<br>最后，对整个序列做群时延$α=\frac{N-1}{2}$以满足因果性。即可生成实际的滤波器序列。  </p><h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法*"></a>优化方法*</h2><p>相当多的通信调制方法中对于滤波器的波纹要求很高，因此需要对滤波器函数做进一步的优化，优化的基本思想是对滤波器的波纹进行赋权，权值函数为$w_{rp}[n]$，使得滤波器在频域上的表现更加接近于理想滤波器。<br>定义滤波器优化方法的损失函数为：  </p><script type="math/tex; mode=display">ɛ^2=\frac{1}{2π}∫_{-π}^π|W_{rp}(e^{jω})\left(H_d(e^{jω})-H(e^{jω})\right)|^2dω</script><p>其中，$H_d(e^{jω})$是实际设计的滤波器的频率响应，$H(e^{jω})$对应理想滤波器的频率响应。<br>基本上所有的优化方法的思路都是寻找损失函数取得最小值时所对应的权重$W_{rp}$。<br>常见的优化算法有：帕克斯-麦克莱伦算法（Parks–McClellan algorithm）或者梯度下降算法（Gredient Desent），都是寻找全局最小值问题的常用方法，在此不做过多介绍。  </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>数字信号处理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>通信原理-知识点总结</title>
    <link href="/2021/12/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <url>/2021/12/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="通信原理-知识点总结"><a href="#通信原理-知识点总结" class="headerlink" title="通信原理-知识点总结"></a>通信原理-知识点总结</h1><h2 id="信息和通信系统参数"><a href="#信息和通信系统参数" class="headerlink" title="信息和通信系统参数"></a>信息和通信系统参数</h2><h3 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h3><p>信息量：</p><script type="math/tex; mode=display">I=log_a\frac{1}{P(x)}=-log_aP(x)</script><p>信息熵：</p><script type="math/tex; mode=display">H=∑_{i=1}^MP(x_i)\log_2\frac{1}{P(x_i)}=∑_{i=1}^MP(x_i)I_i</script><h3 id="通信系统的重要参数"><a href="#通信系统的重要参数" class="headerlink" title="通信系统的重要参数"></a>通信系统的重要参数</h3><h4 id="有效性指标"><a href="#有效性指标" class="headerlink" title="有效性指标"></a>有效性指标</h4><p>传输速率：  </p><script type="math/tex; mode=display">R_b=R_Blog_2M</script><p>$R_b$是比特率，$R_B$是符号速率。  </p><div class="note note-info">            <p>记忆方法：通常一个符号对应多个字节，因此符号速率是小于比特率的。  </p>          </div><p>频谱效率:  </p><script type="math/tex; mode=display">η=\frac{R_B}{B}</script><h4 id="可靠性指标"><a href="#可靠性指标" class="headerlink" title="可靠性指标"></a>可靠性指标</h4><p>误码率：<br>即原本信息为“1”判决后为“0”的概率和原本信息为“0”判决后为“1”的概率之和。  </p><script type="math/tex; mode=display">P_e=P(0|1)+P(1|0)</script><p>信噪比：<br>信噪比表示为信号的功率与噪声的功率之比：  </p><script type="math/tex; mode=display">SNR=\frac{P_S}{P_N}</script><p>香农容量：<br>在误码率为0的情况下，信息系统的理论最大速率$R_b$称为香农容量，即带宽利用率与系统带宽相乘。  </p><script type="math/tex; mode=display">C=Blog_2(1+SNR)=η_bB</script><h3 id="通信系统的两次编码"><a href="#通信系统的两次编码" class="headerlink" title="通信系统的两次编码"></a>通信系统的两次编码</h3><p>信源编码（Source Encoding）：提升有效性<br>信道编码（Channel Encoding）： 提升可靠性  </p><h2 id="信号的数学和统计特性"><a href="#信号的数学和统计特性" class="headerlink" title="信号的数学和统计特性"></a>信号的数学和统计特性</h2><h3 id="信号的数学特性"><a href="#信号的数学特性" class="headerlink" title="信号的数学特性"></a>信号的数学特性</h3><p>如果信号可以表示为$S(t)$:<br>直流信号是信号在一周期内的平均值：  </p><script type="math/tex; mode=display">S_{dc}=\lim_{T→∞}\int_{-\frac{T}{2}}^{\frac{T}{2}}S(t)dt</script><div class="note note-info">            <p>定义时间均值函数：</p><script type="math/tex; mode=display">\overline{f(t)}=\lim_{T→∞}\frac{1}{T}∫_{-\frac{T}{2}}^\frac{T}{2}f(t)dt</script><p><strong>当$f(t)$是一个周期函数时，其时间均值为0。</strong></p>          </div><p>其功率信号是其平方的时间均值：  </p><script type="math/tex; mode=display">P=\lim_{T→∞}\frac{1}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}}|S(t)|^2dt</script><p>功率信号也可以表示为其功率谱密度函数$P_f(t)$的积分:  </p><script type="math/tex; mode=display">P=\frac{1}{2π}∫_{-π}^πP_f(ω)dω</script><p>其功率谱函数可以由维纳——辛钦定理得到：<br>功率信号的自相关函数和功率谱密度函数为傅里叶变换对。  </p><script type="math/tex; mode=display">P_f(t)=∫R_S(t)e^{-jωt}dt</script><h3 id="随机过程的统计特征"><a href="#随机过程的统计特征" class="headerlink" title="随机过程的统计特征"></a>随机过程的统计特征</h3><ul><li>期望<script type="math/tex; mode=display">E_ξ(t)=∫ξ(t)f_1(x,t)dt</script>其中$ξ(t)$是含有随机变量$x$的随机过程，$f_1(x,t)$是$x$的概率密度函数。</li><li>方差<script type="math/tex; mode=display">D_ξ(t)=E(ξ^2(t))-[E_ξ(t)]^2</script>随机过程的方差表示随机过程值围绕期望的摆动幅度。  </li><li>自相关函数<script type="math/tex; mode=display">R(t,t+τ)=E[ξ(t)ξ(t+τ)]=∫f_1(t)ξ(t)ξ(t+τ)dt</script></li></ul><h3 id="两种特殊的随机过程"><a href="#两种特殊的随机过程" class="headerlink" title="两种特殊的随机过程"></a>两种特殊的随机过程</h3><ul><li>平稳随机过程<ol><li>期望是一个常数。</li><li>自相关函数只与τ有关。  </li></ol></li><li>遍历性随机过程<br>遍历随机过程最大的特点是过程中的任意一个随机变量$x(t)$的在时间上的统计特性和这个随机过程$ξ(t)$的统计特性相等。  <ol><li>计算过程中任意一个随机变量的期望：$E(x)=∫xf(t)dt$  </li><li>计算随机过程的时间均值：$\lim_{T→∞}\frac{1}{T}∫_{-T/2}^{T/2}f(t)dt$  </li><li>证明两者相等  </li></ol></li></ul><h3 id="功率信号的统计性质"><a href="#功率信号的统计性质" class="headerlink" title="功率信号的统计性质"></a>功率信号的统计性质</h3><p>在通信系统中，功率信号是一个宽平稳随机过程，下面使用自相关函数研究其性质。  </p><blockquote><p>此处自变量为τ（如平均功率为τ=0）</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">功率信号</th><th style="text-align:center">自相关函数</th><th style="text-align:center">注解</th></tr></thead><tbody><tr><td style="text-align:center">平均功率</td><td style="text-align:center">$R(0)=E(ξ^2(t))$</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">直流功率</td><td style="text-align:center">$R(∞)=E^2(ξ(t))$</td><td style="text-align:center">当τ→∞时，表示为两个不相关信号的自相关函数</td></tr><tr><td style="text-align:center">交流功率</td><td style="text-align:center">$R(0)-R(∞)=σ^2$</td><td style="text-align:center">平均功率=交流功率+直流功率</td></tr></tbody></table></div><div class="note note-info">            <p>求解平均功率的方式：  </p><ol><li>$R(0)$</li><li>$E(ξ^2(t))$</li><li>谱密度函数的积分<ul><li>对于角频率谱密度函数：$\frac{1}{2π}∫P_ξ(ω)dω$</li><li>对于频率密度函数：$∫P_ξ(f)df$</li></ul></li></ol>          </div><h3 id="随机过程通过线性系统"><a href="#随机过程通过线性系统" class="headerlink" title="随机过程通过线性系统"></a>随机过程通过线性系统</h3><p><strong>如果线性系统的输入信号是一个平稳随机过程，那么输出信号也必然是一个平稳随机过程。</strong><br>假定线性系统的频域方程为$H(ω)$，有如下结论：  </p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">输入过程</th><th style="text-align:center">输出过程</th></tr></thead><tbody><tr><td style="text-align:center">分布类型</td><td style="text-align:center">平稳随机过程</td><td style="text-align:center">平稳随机过程</td></tr><tr><td style="text-align:center">均值</td><td style="text-align:center">$a$</td><td style="text-align:center">$aH(0)$</td></tr><tr><td style="text-align:center">功率谱密度</td><td style="text-align:center">$P(ω)$</td><td style="text-align:center">$\lvert H(ω) \rvert ^2P(ω)$</td></tr></tbody></table></div><h2 id="高斯白噪声"><a href="#高斯白噪声" class="headerlink" title="高斯白噪声"></a>高斯白噪声</h2><p>高斯白噪声指信号的<strong>功率谱密度函数在频域内符合均匀分布</strong>、<strong>概率密度函数符合高斯分布的噪声</strong>。高斯白噪声是一种可加性噪声。    </p><h3 id="高斯白噪声的统计特性"><a href="#高斯白噪声的统计特性" class="headerlink" title="高斯白噪声的统计特性"></a>高斯白噪声的统计特性</h3><p>均值：$E_ξ(ω)=0$<br>方差：$D_ξ(ω)=0$<br>自相关函数：$R_n(τ)=\frac{n_0}{2}δ(τ)$  </p><h3 id="高斯白噪声通过滤波器"><a href="#高斯白噪声通过滤波器" class="headerlink" title="高斯白噪声通过滤波器"></a>高斯白噪声通过滤波器</h3><p>通过低通滤波器：<br>平均功率：即频谱的面积，$n_0B$<br>自相关函数：$\frac{n_0}{2}G_{2B}(ω)↔R(τ)=\frac{n_0τ}{2}Sa(\frac{Bτ}{2}),B=ω_c$  </p><p>通过带通滤波器：<br>平均功率：即频谱的面积，$n_0B$<br>自相关函数：$R_n(τ)=\frac{n_0B}{4π}Sa(\frac{Bτ}{2})cos(ω_0τ)$。  </p><h3 id="波形成分及其统计特性"><a href="#波形成分及其统计特性" class="headerlink" title="波形成分及其统计特性"></a>波形成分及其统计特性</h3><p>窄带高斯白噪声的谱密度函数可以以包络相位形式和同相正交形式表现：  </p><ul><li>包络相位<script type="math/tex; mode=display">n_0(t)=a(t)cos[ω_ct+φ(t)]</script>其中$a(t)$为<strong>随机包络函数，服从瑞利分布(Rayleigh Distribution)</strong>；$φ(t)$为<strong>随机相位函数，服从均匀分布(Uniform Distribution)。</strong></li><li>同相正交<script type="math/tex; mode=display">n_0(t)=n_ccosω_ct-n_s(t)sinω_ct</script>同相分量和正交分量的统计特性：<br><strong>一个均值为0的窄带平稳高斯过程，其同相分量和正交分量也是平稳高斯过程，且均值为0，方差和原信号相同。</strong>  </li></ul><h3 id="高斯白噪声通过低通滤波器"><a href="#高斯白噪声通过低通滤波器" class="headerlink" title="高斯白噪声通过低通滤波器"></a>高斯白噪声通过低通滤波器</h3><p>设低通滤波器的带宽为$B$:<br>此时的平均功率可以由谱密度函数的面积表示：  </p><script type="math/tex; mode=display">\overline{N(t)}=\frac{n_0}{2}×2B=n_0B</script><p>其自相关函数可以通过傅里叶变换来获得：  </p><script type="math/tex; mode=display">R_n(τ)=\frac{n_0B}{2π}Sa(Bτ)</script><h2 id="模拟传输系统"><a href="#模拟传输系统" class="headerlink" title="模拟传输系统"></a>模拟传输系统</h2><h3 id="调制的目的"><a href="#调制的目的" class="headerlink" title="调制的目的"></a>调制的目的</h3><p>使用调制的目的有三个：  </p><ol><li>由于天线与传输信号的波长之间存在匹配关系，通常天线的尺寸在$\frac{λ}{10}$到$\frac{λ}{4}$之间，经过调制的信号波长会变小，因此对应的传输天线的尺寸会对应减小以便于传输。  </li><li>调制使得多频复用称为可能，多个基带信号可以与不同的载波结合，实现同时传输多个基带信号。  </li><li>扩展信号带宽，提高系统抗干扰能力。  </li></ol><h3 id="线性调制方法"><a href="#线性调制方法" class="headerlink" title="线性调制方法"></a>线性调制方法</h3><p>线性调制后，不会有新的频率成分产生。因此线性调制只能在受调参量为幅度时使用。<br>线性调制的方法分为：调幅（AM），双边带调制（DSB），单边带调制（SSB），残留边带调制（VSB）。这几种线性调制方法简图如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211222195912.png width=70%>  </p><ul><li>AM： 输入信号加上直流分量后与载波相乘。  </li><li>DSB： 输入信号直接与载波相乘。  </li><li>SSB/VSB： 输入信号与载波相乘后通过低通滤波器。  </li></ul><p>线性调制的参数：  </p><div class="table-container"><table><thead><tr><th style="text-align:center">线性调制方法</th><th style="text-align:center">输出表达式</th><th style="text-align:center">带宽</th><th style="text-align:center">调制后功率$P_{TX}$</th><th style="text-align:center">调制端噪声</th><th style="text-align:center">无衰减下的输入信噪比$SNR_i$</th></tr></thead><tbody><tr><td style="text-align:center">调幅(AM)</td><td style="text-align:center">$S_{AM}=(A_0+m(t))cosω_ct$</td><td style="text-align:center">$2f_H$</td><td style="text-align:center">$\frac{A_0^2}{2}+\frac{\overline{m^2(t)}}{2}$</td><td style="text-align:center">$2n_0f_H$</td><td style="text-align:center">$\frac{A_o^2+\overline{m^2(t)}}{4n_0f_H}$</td></tr><tr><td style="text-align:center">双边带调制(DSB)</td><td style="text-align:center">$S_{DSB}=m(t)cosω_ct$</td><td style="text-align:center">$2f_H$</td><td style="text-align:center">$\frac{\overline{m^2(t)}}{2}$</td><td style="text-align:center">$2n_0f_H$</td><td style="text-align:center">$\frac{\overline{m^2(t)}}{4n_0f_H}$</td></tr><tr><td style="text-align:center">单边带调制(SSB) <br> 残留边带调制(VSB)</td><td style="text-align:center">$S_{SSB}=\frac{1}{2} m(t)cosω_ct∓\frac{1}{2}\hat{m(t)}sinω_ct$ <br> $\hat{m(t)}$ 表示$m(t)$ 相移 $-\frac{π}{2}$ 的结果 <br> 即希尔伯特变换 <br> 保留上边带为“-”，下边带为“+”</td><td style="text-align:center">$f_H$</td><td style="text-align:center">$\frac{\overline{m^2(t)}}{4}$</td><td style="text-align:center">$n_0f_H$</td><td style="text-align:center">$\frac{\overline{m^2(t)}}{4n_0f_H}$</td></tr></tbody></table></div><p>线性调制的解调方法分为两类：相干解调和非相干解调，两者的简图如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211218213249.png width=50%></p><ul><li>相干解调： 在解调端调制信号与一个同频同相的载波相乘。  </li><li>非相干解调： 通过低通滤波器消除高频分量后直接得到包络线波形。  </li></ul><p>线性解调的参数：  </p><ul><li>相干解调之后，噪声功率只有原来的$\frac{1}{4}$。  </li><li>非相干解调之后，噪声功率与原来相同。  </li></ul><p>信噪比增益：  </p><script type="math/tex; mode=display">G=\frac{SNR_o}{SNR_i}</script><p>即解调端的信噪比与调制端的信噪比之比。  </p><div class="table-container"><table><thead><tr><th style="text-align:center">线性调制方法</th><th style="text-align:center">输出信号</th><th style="text-align:center">解调后功率</th><th style="text-align:center">解调后噪声</th><th style="text-align:center">输出信噪比$SNR_o$</th><th style="text-align:center">信噪比增益</th></tr></thead><tbody><tr><td style="text-align:center">调幅</td><td style="text-align:center">$\frac{1}{2}m(t)$</td><td style="text-align:center">$\frac{1}{4}\overline{m^2(t)}_{co}$ <br> $\overline{m^2(t)}_{noc}$</td><td style="text-align:center">$\frac{n_0f_H}{2}_{co}$ <br> ${2n_0f_H}_{noc}$</td><td style="text-align:center">$\frac{\overline{m^2(t)}}{2n_0f_H}_{co}$ <br> $\frac{\overline{m^2(t)}}{2n_0f_H}_{noc}$</td><td style="text-align:center">$\frac{2\overline{m^2(t)}}{A_0^2+\overline{m^2(t)}}≤\frac{2}{3}$</td></tr><tr><td style="text-align:center">双边带调制</td><td style="text-align:center">$\frac{1}{2}m(t)$</td><td style="text-align:center">$\frac{1}{4}\overline{m^2(t)}$</td><td style="text-align:center">$\frac{n_0f_H}{2}$</td><td style="text-align:center">$\frac{\overline{m^2(t)}}{2n_0f_H}$</td><td style="text-align:center">$2$</td></tr><tr><td style="text-align:center">单边带调制</td><td style="text-align:center">$\frac{1}{4}m(t)$</td><td style="text-align:center">$\frac{1}{16}\overline{m^2(t)}$</td><td style="text-align:center">$\frac{n_0f_H}{4}$</td><td style="text-align:center">$\frac{\overline{m^2(t)}}{4n_0f_H}$</td><td style="text-align:center">$1$</td></tr></tbody></table></div><h3 id="调幅指数"><a href="#调幅指数" class="headerlink" title="调幅指数"></a>调幅指数</h3><p>由于对标准调幅的解调实质上是求得其包络线函数，在波形图上观察，当$m(t)&lt;A_0$时，波形图的上下包络线会发生重叠从而无法还原之前的包络线函数，导致失真。<br>因此要求:  </p><script type="math/tex; mode=display">|m(t)|_{max}≤A_0</script><p>定义调幅指数$β_{AM}$反映$|m(t)|_{max}$与$A_0$的关系：  </p><script type="math/tex; mode=display">β_{AM}=\frac{|m(t)|_{max}}{A_0}</script><ul><li>$β_{AM}&lt;1$： 正常调幅</li><li>$β_{AM}=1$： 满调幅</li><li>$β_{AM}&gt;1$： 过调幅</li></ul><h3 id="调制效率"><a href="#调制效率" class="headerlink" title="调制效率"></a>调制效率</h3><p>由于载波不携带任何信息，定义调制效率为边带功率（$P_s=\frac{\overline{m^2(t)}}{2}$）与总功率（$P_s+P_c=\frac{\overline{m^2(t)}}{2}+\frac{A^2_0}{2}$）之比以反映调制时信息的占比：  </p><script type="math/tex; mode=display">η=\frac{P_s}{P_s+P_c}</script><h3 id="信道衰减·输入信噪比"><a href="#信道衰减·输入信噪比" class="headerlink" title="信道衰减·输入信噪比"></a>信道衰减·输入信噪比</h3><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211211154702.png width=80%>  </p><p>经过线性调制后的信号通过发射机(TX)发送，进入信道，在信道中由于干扰和噪声，导致信号功率出现损失，使得接收机(RX)接收的信号功率与发射机发射的信号功率不同，定义信道中的衰减（ATU）为发射机发射功率与接收机接收功率之比：  </p><script type="math/tex; mode=display">ATU|dB=10lg\frac{P_{TX}}{P_{RX}}</script><p>因此，在解调模块处，接收机接收到的功率可以表示为：  </p><script type="math/tex; mode=display">P_{TX}=P_{RX} × ATU=P_{AM/DSB/SSB}</script><p><strong>在这个过程中，假设噪声通过信道时不会发生任何改变，噪声的功率仍然与基带信号中的噪声功率相同。</strong>  </p><p>定义输入信噪比($SNR_i$)为<strong>输入进解调模块的信噪比</strong>：  </p><script type="math/tex; mode=display">SNR_i=\frac{S_i}{N_i}</script><p>其中，$S_i=P_{RX}=P_{AM/DSB/SSB} / ATU$。<br>$N_i=N_{modulation}=n_0B$。  </p><h3 id="非线性调制方法"><a href="#非线性调制方法" class="headerlink" title="非线性调制方法*"></a>非线性调制方法*</h3><h4 id="调相"><a href="#调相" class="headerlink" title="调相"></a>调相</h4><p>调相后的波形：  </p><script type="math/tex; mode=display">\begin{aligned}    S_{PM}(t)=&Acos(ω_ct+K_pm(t))\\    =&Acos(ω_ct+K_pA_mcosω_mt)\end{aligned}</script><p>其中$K_p=ϕ(t)/m(t)$为相位敏感度，$m_p=K_pA_m$称为调相指数。<br>最大相偏：$K_pA_m$  </p><h4 id="调频"><a href="#调频" class="headerlink" title="调频*"></a>调频*</h4><p>调频后的波形：  </p><script type="math/tex; mode=display">\begin{aligned}    S_{FM}(t)=&Acos(ω_ct+K_f∫m(t)dt)\\    &=Acos(ω_ct+\frac{K_fA_m}{ω_m}sinω_mt)\end{aligned}</script><p>其中$K_fm(t)=\frac{d}{dt}ϕ(t)$，$K_f$为频率敏感度；$m_f=\frac{K_fA_m}{ω_m}$称为调频指数。  </p><p>宽带下的调频特性：  </p><ul><li>带宽：$2(m_f+1)f_H$  </li><li>调制后功率：$\frac{A^2}{2}$</li><li>信噪比增益：$3m^2_f(m_f+1)$</li><li>最大频偏：$K_fA_m$</li></ul><h4 id="调幅和调频的关系"><a href="#调幅和调频的关系" class="headerlink" title="调幅和调频的关系"></a>调幅和调频的关系</h4><p>$m(t)$积分后的信号通过积分器后调相的结果是其调频结果。<br>$m(t)$微分后的信号通过微分器后调频的结果是其调相结果。  </p><h3 id="所有调制方法的性能对比"><a href="#所有调制方法的性能对比" class="headerlink" title="所有调制方法的性能对比"></a>所有调制方法的性能对比</h3><p><strong>可靠性</strong><br>解调端输入信号能量$S_i$相同的前提下，信噪比越大，可靠性越高。  </p><script type="math/tex; mode=display">AM＜DSB=SSB＜FM</script><p><strong>有效性</strong><br>带宽越大，有效性越低。  </p><script type="math/tex; mode=display">FM＜AM=DSB＜VSB＜SSB</script><h2 id="数字基带传输系统"><a href="#数字基带传输系统" class="headerlink" title="数字基带传输系统"></a>数字基带传输系统</h2><h3 id="模拟信号采样"><a href="#模拟信号采样" class="headerlink" title="模拟信号采样"></a>模拟信号采样</h3><p>对基带信号，最佳的采样频率为：  </p><script type="math/tex; mode=display">f_s=2f_H</script><p>对带通信号，最佳的采样频率为：  </p><script type="math/tex; mode=display">f_s=2B(1+\frac{M}{N})</script><p>其中$M$为$|\frac{f_H}{B}|$的小数部分，$N$为$|\frac{f_H}{B}|$的整数部分。  </p><h3 id="模拟信号的数字化方法：脉冲编码调制"><a href="#模拟信号的数字化方法：脉冲编码调制" class="headerlink" title="模拟信号的数字化方法：脉冲编码调制"></a>模拟信号的数字化方法：脉冲编码调制</h3><p>脉冲编码调制的格式为：  </p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">极性码</th><th style="text-align:center">段落码</th><th style="text-align:center">段内码</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center">$C_1$</td><td style="text-align:center">$C_2C_3C_4$</td><td style="text-align:center">$C_5C_6C_7C_8$</td></tr><tr><td style="text-align:center">意义</td><td style="text-align:center">极性</td><td style="text-align:center">对应8个段落</td><td style="text-align:center">对应每一个段落中的16个量化级</td></tr></tbody></table></div><p>PCM编码与数字化的13折A压缩律对应如下：  </p><div class="table-container"><table><thead><tr><th style="text-align:center">段落编号</th><th style="text-align:center">电平区间</th><th style="text-align:center">段落码</th><th style="text-align:center">量化间隔Δ</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">0-16</td><td style="text-align:center">000</td><td style="text-align:center">$1=2^0$</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">16-32</td><td style="text-align:center">001</td><td style="text-align:center">$1=2^0$</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">32-64</td><td style="text-align:center">010</td><td style="text-align:center">$2=2^1$</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">64-128</td><td style="text-align:center">011</td><td style="text-align:center">$4=2^2$</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">128-256</td><td style="text-align:center">100</td><td style="text-align:center">$8=2^3$</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">256-512</td><td style="text-align:center">101</td><td style="text-align:center">$16=2^4$</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">512-1024</td><td style="text-align:center">110</td><td style="text-align:center">$32=2^5$</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">1024-2048</td><td style="text-align:center">111</td><td style="text-align:center">$64=2^6$</td></tr></tbody></table></div><h4 id="脉冲调制编码过程"><a href="#脉冲调制编码过程" class="headerlink" title="脉冲调制编码过程"></a>脉冲调制编码过程</h4><p>量化后的电平值转化为脉冲调制编码的步骤为：  </p><ol><li><p>判断电平的正负，如果是正：$C_1=1$，如果为负，$C_1=0$。</p><blockquote><p>注意“1正0负”</p></blockquote></li><li><p>根据电平值和电平区间，判断电平落在了哪一个段落，决定段落码$C_2C_3C_4$。  </p></li><li>将电平值减去段落的起始值，与量化间隔相除，结果转化为8421码即为$C_5C_6C_7C_8$。  </li></ol><p>与量化间隔相除结果的余数部分无法通过编码表示，称为编码噪声$N_e$。  </p><h4 id="脉冲调制解码过程"><a href="#脉冲调制解码过程" class="headerlink" title="脉冲调制解码过程"></a>脉冲调制解码过程</h4><p>PCM编码在解码端首先会变成11位的自然二进制编码。<br>PCM编码转换为10进制后的结果与11位的自然二进制转换为10进制的结果相同。  </p><script type="math/tex; mode=display">I_{11-NBC}=I_{PCM}</script><p>因此PCM编码只需要转换为10进制，在开头补充0即可转换为11位NBC码。<br>由于PCM编码只考虑到了每个量化区间内的起始值$m_{i-1}$而并非量化电平$p_i$，在解码过程中需要补充每个量化段的半个量化区间$\frac{Δ_i}{2}$，由于最小的$\frac{Δ_1}{2}=0.5$，因此需要额外补充一个bit来弥补增加的精度，生成12位NBC码。<br>12位NBC的精度高于8位PCM编码，与PCM编码相比，12位NBC能额外表达一个当前量化段的一半的量化间隔，进而减少了量化噪声。<br>12位NBC可以通过在PCM转化为11位NBC码后，11位NBC码的最后一个“1”后增加一个“1”即可。  </p><script type="math/tex; mode=display">I_{12-NBC}=I_{PCM}+\frac{1}{2}Δ_i</script><p>因此，整个脉冲编码调制的量化噪声$N_q$为编码噪声减去$\frac{Δ_i}{2}$:</p><script type="math/tex; mode=display">N_q=N_e-\frac{Δ_i}{2}</script><h4 id="脉冲编码调制的性能"><a href="#脉冲编码调制的性能" class="headerlink" title="脉冲编码调制的性能"></a>脉冲编码调制的性能</h4><ul><li>传输速率<br>PCM的传输速率为：  <script type="math/tex; mode=display">R_B=f_s×log_2M×n</script>其中$f_s$为采样速率，$M$为比特数，A律13折PCM中$M=256$。$n$为信号的路数。  </li><li>信噪比<br>整个过程的信噪比表示为：  <script type="math/tex; mode=display">\frac{S_o}{N_o}_{PCM}=\frac{\overline{m^2(t)}}{N_q+N_e}</script>通过计算可以发现，当$m(t)$服从均匀分布时，量化信噪比表示为：  <script type="math/tex; mode=display">\frac{S}{N_q}=M^2</script></li></ul><h3 id="码型选择"><a href="#码型选择" class="headerlink" title="码型选择"></a>码型选择</h3><p>对每一帧而言，其中电平不为0的时间段（即信息传输的时间）称为符号持续时间$τ$（Symbol duration），定义占空比（Duty Cycle）表示符号持续时间和一个周期时间之比：  </p><script type="math/tex; mode=display">Duty.Cycle=\frac{τ}{T_s}×100\%</script><p>当$τ=T_s$时，表示一个周期内所有时间都在发送符号，称为归零码（RZ Code），$τ≠T_s$时，称为不归零码（NRZ Code）。  </p><div class="table-container"><table><thead><tr><th style="text-align:center">码型</th><th style="text-align:center">有无直流分量</th><th style="text-align:center">是否可以提取同步脉冲</th></tr></thead><tbody><tr><td style="text-align:center">单极性不归零码</td><td style="text-align:center">有</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">单极性归零码</td><td style="text-align:center">有</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">双极性不归零码</td><td style="text-align:center">无</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">双极性归零码</td><td style="text-align:center">无</td><td style="text-align:center">是<br>注：需要通过整流器</td></tr></tbody></table></div><p>双极性归零码虽然不能直接提取定时脉冲，但可以通过使用一个整流器转换为单极性归零码，从而提取出定时脉冲，且无直流分量。  </p><h4 id="HDB3-码"><a href="#HDB3-码" class="headerlink" title="HDB3 码"></a><strong>HDB<sub>3</sub> 码</strong></h4><p>HDB<sub>3</sub>的编码规则基本和AMI码相同，但相比于AMI码，其规定在连续三个0信号出现时加入一个破坏脉冲V以防止过长0信号导致定时脉冲难以提取的问题。HDB<sub>3</sub>码的编码规则如下：  </p><ol><li>给定一个初始符号以指定消息编码中起始1的极性，使用AMI编码方式对消息进行编码。<strong>起始1的极性与初始符号的极性相反。</strong>  </li><li>当有连续4个0信号出现时，第四个0信号改为破坏脉冲V，对破坏脉冲的极性有如下规定：<br>i）V的极性交替反转（高优先级）<br>ii）破坏脉冲的极性与前一个“1”或“V”的极性相同  </li><li><strong>在V的极性不满足条件2时</strong>，连0信号的第一个0变为补性码B’，B’的极性与其后一个V的极性相同。<strong>B’后的1全部反转极性</strong>。  </li><li>V和B’保留极性，并替换为“1”。  </li></ol><h4 id="曼彻斯特码"><a href="#曼彻斯特码" class="headerlink" title="曼彻斯特码"></a><strong>曼彻斯特码</strong></h4><h5 id="曼彻斯特码-双向码"><a href="#曼彻斯特码-双向码" class="headerlink" title="曼彻斯特码/双向码"></a><strong>曼彻斯特码/双向码</strong></h5><p>曼彻斯特码是一种双极性不归零码，其01编码为脉冲信号的上升沿和下降沿，巧妙地解决了长连0信号由于电平不发生变化而导致的定时脉冲提取困难的问题。其编码规则为：<br>脉冲波形在同步脉冲间隔周期50%时：  </p><ul><li>脉冲上升沿表示逻辑1  </li><li>脉冲下降沿表示逻辑0  </li></ul><p>例如：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211105205712.png width=70%>  </p><h6 id="差分曼彻斯特码"><a href="#差分曼彻斯特码" class="headerlink" title="差分曼彻斯特码"></a><strong>差分曼彻斯特码</strong></h6><p>差分曼彻斯特码的编码规则为：<br>脉冲间隔开始时：  </p><ul><li>脉冲电平不发生变化（无触发沿）表示逻辑1</li><li>脉冲电平发生变化（有触发沿）表示逻辑0</li></ul><p>例如：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211105210411.png width=70%>  </p><h3 id="波形选择"><a href="#波形选择" class="headerlink" title="波形选择"></a>波形选择</h3><p>对波形的选择标准要求频谱图上的主瓣（即信号的有用带宽）后杂波的带宽越小越好，换言之，频谱函数收敛速度越快越好。<br>在方波脉冲、三角脉冲、升余弦脉冲中，升余弦脉冲的收敛速度最快，意味着杂波的带宽通常比较小，因此在数字基带通信中常选择升余弦脉冲作为基带波形。<br>另外，对于归零码而言，符号持续时间越长，占用带宽越小。  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211105211419.png width=80%>  </p><h3 id="消除码间串扰的方式"><a href="#消除码间串扰的方式" class="headerlink" title="消除码间串扰的方式"></a>消除码间串扰的方式</h3><p>由于系统的带宽有限，单个字符信号的脉冲发生了失真，使得波形发生延展、含有拖尾，波形延展到其他码元时间间隔中时，会对其他字符的抽样产生干扰，称为码间串扰。码间串扰与系统的带宽有关，系统的带宽越小，字符脉冲的拖尾就会越长越严重，发生码间串扰的可能性越大。    </p><h4 id="无码间串扰的数学条件"><a href="#无码间串扰的数学条件" class="headerlink" title="无码间串扰的数学条件"></a>无码间串扰的数学条件</h4><p>在时域上表示为在抽样时间之外的其他采样时刻上对应波形的幅度为0。<br>在频域上满足奈奎斯特第一定律：<br>当且仅当系统的等效频谱在为一个在$±\frac{π}{T_s}$上的门函数时，这个系统可以满足没有码间串扰。<br>导出结论：  </p><ul><li>满足奈奎斯特第一定律时，频谱图的带宽称为奈奎斯特带宽$B_N$,$B_N=\frac{1}{2T_s}Hz$。  </li><li>奈奎斯特间隔为：$T_s=\frac{1}{2B_N}$。  </li><li>当采样周期为奈奎斯特间隔的整数倍（$T_s=\frac{Const}{2B_N}$）时，可以使得每次采样时信号拖尾的采样值都为0，系统无码间串扰。对应的数据传输速率为：$R_B=\frac{1}{nT_s}$。  </li><li>系统支持的最大的传输速率为$R_{B|max}=\frac{1}{T_s}=2B_N$，当且仅当： <script type="math/tex; mode=display">\frac{R_{B|max}}{R_B}=Const</script>时，系统无码间串扰。  </li><li>由频谱利用率$η=\frac{R_B}{B}$，系统最大的频谱利用率为$η=\frac{2B_N}{B_n}=2$。</li></ul><h4 id="理想低通滤波器"><a href="#理想低通滤波器" class="headerlink" title="理想低通滤波器"></a>理想低通滤波器</h4><p>理想低通滤波器的频谱正好是一个门函数：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211112173008.png width=60%>  </p><p>但是，可以从理想低通滤波器系统的频谱和波形图看出：理想低通滤波器有边界陡峭、难以实现、且时域中Sa函数收敛较慢的特点，因此考虑采用其他方法模拟等效理想低通滤波器的频谱。  </p><h4 id="滚降滤波器"><a href="#滚降滤波器" class="headerlink" title="滚降滤波器"></a>滚降滤波器</h4><p>滚降滤波器的基本思路是在理想低通滤波器频谱后加入一段奇对称的频谱，使得被剪切、时移、叠加后的等效频谱中奇对称的一半正好可以填充另一半，得到一个门函数的频谱，这种方法称为滚降。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211109153130.png width=30%><br>常常被选用的奇函数为反比例函数和升余弦函数（即余弦函数+常数）：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211109153809.png width=50%>  </p><p>设奇对称信号的带宽为$B_2$,那么滚降后的系统带宽为$B_N+B_2$。<br>滚降滤波器的系统方程可以表示为：</p><script type="math/tex; mode=display">H(ω)=\begin{cases}    Const, 0≤ω≤B_N\\    f(ω), B_N≤ω≤B_N+B_2\\    0,ω≥B_N+B_2\end{cases}</script><blockquote><p>根据系统方程可以将滚降系统的频谱分为：非滚降区、滚降区和截止区。  </p></blockquote><p>定义滚降系数$α=\frac{B_2}{B_N}$，那么系统带宽又可以写作：  </p><script type="math/tex; mode=display">B=(1+α)B_N,0≤α≤1</script><p>频谱利用效率为:$η=\frac{2}{1+α}$<br>系统所支持的无码间串扰的最大速率为:$R_{B|max}=2B_N$<br>可以发现，$α$越大，系统带宽就越大，系统有效性下降，但是从频谱图上来看，$α$越大，系统波形拖尾越小，可靠性上升。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211109154450.png width=50%>  </p><div class="table-container"><table><thead><tr><th style="text-align:center">系统类型</th><th style="text-align:center">$R_{Bmax}$</th><th style="text-align:center">$B$</th><th style="text-align:center">$η_{max}$</th></tr></thead><tbody><tr><td style="text-align:center">理想低通滤波器</td><td style="text-align:center">$2B_N$</td><td style="text-align:center">$B_N$</td><td style="text-align:center">$2$</td></tr><tr><td style="text-align:center">滚降滤波器</td><td style="text-align:center">$2B_N$</td><td style="text-align:center">$(1+α)B_N$</td><td style="text-align:center">$\frac{2}{1+α}$</td></tr><tr><td style="text-align:center">全滚降滤波器</td><td style="text-align:center">$2B_N$</td><td style="text-align:center">$2B_N$</td><td style="text-align:center">$1$</td></tr><tr><td style="text-align:center">部分响应系统</td><td style="text-align:center">$2B_N$</td><td style="text-align:center">$B_N$</td><td style="text-align:center">$2$</td></tr></tbody></table></div><h3 id="数字基带传输系统的抗噪性"><a href="#数字基带传输系统的抗噪性" class="headerlink" title="数字基带传输系统的抗噪性"></a>数字基带传输系统的抗噪性</h3><ul><li>使用单极性信号时数字基带传输系统的信噪比：<script type="math/tex; mode=display">SNR_u=\frac{A^2}{2σ^2}</script>误码率为：  <script type="math/tex; mode=display">P_e=\frac{1}{2}erfc(\frac{\sqrt{SNR_u}}{2})</script></li><li>使用双极性信号时数字基带传输系统的信噪比：<script type="math/tex; mode=display">SNR_b=\frac{A^2}{σ^2}</script>误码率为：  <script type="math/tex; mode=display">P_e=\frac{1}{2}erfc(\sqrt{\frac{SNR_b}{2}})</script></li></ul><h2 id="数字带通传输系统"><a href="#数字带通传输系统" class="headerlink" title="数字带通传输系统"></a>数字带通传输系统</h2><h3 id="ASK"><a href="#ASK" class="headerlink" title="ASK"></a>ASK</h3><h4 id="调制方式"><a href="#调制方式" class="headerlink" title="调制方式"></a>调制方式</h4><p>有波形时为1，无波形时为0。<br>输出波形表达式为：  </p><script type="math/tex; mode=display">S_{2ASK}(t)=\begin{cases}    cosω_ct,以概率P\\    0,以概率1-P\\\end{cases}</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211118090537.png width=60%>  </p><h4 id="解调方式"><a href="#解调方式" class="headerlink" title="解调方式"></a>解调方式</h4><ul><li><p>非相干解调<br>使用包络检波法：使用全波整流器输出信号的绝对值波形以去除极性，然后使用低通滤波器过滤高频分量，最终通过抽样判决器输出数字信号。  </p><div class="note note-info">            <p>注意在模拟信号的解调中，包络检波法不需要全波整流器去除极性，注意区分。  </p>          </div><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211122205159.png width=50%></p></li><li><p>相干解调<br>使用同频同相的载波与其相乘，通过低通滤波器。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211122205046.png width=50%>  </p></li></ul><h3 id="FSK"><a href="#FSK" class="headerlink" title="FSK"></a>FSK</h3><h4 id="调制方式-1"><a href="#调制方式-1" class="headerlink" title="调制方式"></a>调制方式</h4><p>FSK使用两个不同频率的载波$cos(ω_1t)$、$cos(ω_2t)$来表示数字信号“1”和“0”。<br>输出波形的表达式为：  </p><script type="math/tex; mode=display">S_{FSK}=[∑_na_ng(t-nT_s)]cos(ω_1t)+[∑_n\overline{a_n}g(t-nT_s)]cos(ω_2t)</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211122211340.png width=50%>  </p><h4 id="解调方式-1"><a href="#解调方式-1" class="headerlink" title="解调方式"></a>解调方式</h4><ul><li><p>非相干解调（包络检波法）<br>非相干解调的过程和相干解调基本相同，只不过每一路信号采用包络检波法取代与载波相乘。<br>由于仍然需要带通滤波器分别提取两路信号的频谱分量，因此非相干解调也只适用于$|f_1-f_2|≥2f_s$的情况。<br>抽样判决的过程和相干解调相同，也不需要设置判决门限。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211211202715.png width=50%></p></li><li><p>相干解调<br>在接收端，FSK信号$S_{2FSK}(t)$分为两路，各通过一个带通滤波器，只过滤出$f_1$或者$f_2$的频谱分量，每一路信号在通过带通滤波器之后与对应的同频同向的载波信号相乘去除极性，通过低通滤波器过滤掉高频分量后，送入抽样判决器进行判决。<br>只有在$f_1$和$f_2$的连续谱分量完全分离时，带通滤波器才能准确提取出对应频率的分量，因此相干解调只适用于$|f_1-f_2|≥2f_s$的情况。<br>抽样判决器的判决标准是两路信号在同一个码元周期$T_s$内的电平大小进行比较，哪路信号的电平高，则数字信号的值就为这一路所代表的逻辑值。因此，相干解调不需要设置判决门限。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211211202905.png width=50%></p></li><li><p>过零检波法<br>非相干解调和相干解调都只适用于$|f_1-f_2|≥2f_s$的情况，而过零检波法没有这样的条件限制。<br>过零检波法的原理是：在波形图上波形过0的次数越多代表码元周期内的频率越高，过零检波法的基本思路是用码元周期内平均幅度的大小来表示频率的高低。  </p><blockquote><p>方波脉冲信号的直流分量：$\frac{1}{T_s}∑τ_iA_i,τ_i$为周期内第$i$个方波脉冲的持续时间。  </p></blockquote></li></ul><p>过零检波法的具体过程是：FSK信号首先通过限制幅度将正弦波转变为方波，方波通过微分器后变为脉冲信号，经过整流器去除极性后，再用宽脉冲发生器依据脉冲信号重新生成无极性的方波信号。<br>方波信号会通过低通滤波器，低通滤波器只会允许低频分量（在此看做只有直流分量可以通过）通过滤波器，在单个码元周期中，方波脉冲的个数越多，代表其平均幅度越大，根据直流分量代表波形中的平均幅度可知，其直流分量也会更大。因此原波形中高频的部分通过低通滤波器之后的直流分量更大，低频部分通过低通滤波器后的直流分量更小。  </p><p>最后信号通过抽样判决器，抽样判决器的最佳判决门限为$\frac{a}{2}$。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211123133627.png width=50%>  </p><h3 id="PSK"><a href="#PSK" class="headerlink" title="PSK"></a>PSK</h3><h4 id="调制方式-2"><a href="#调制方式-2" class="headerlink" title="调制方式"></a>调制方式</h4><p>PSK使用两个反相的载波$Acos(ω_ct)$和$-Acos(ω_ct)$表示数字信号“1”和“0”。<br>PSK信号的波形可以表示为：</p><script type="math/tex; mode=display">S_{2PSK}(t)=∑_nb_ng(t-nT_s)cos(ω_ct)</script><p>$b_n$是$a_n$的双极性码表达。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211125133034.png width=50%>  </p><h4 id="解调方式-2"><a href="#解调方式-2" class="headerlink" title="解调方式"></a>解调方式</h4><ul><li><p>相干解调  </p><div class="note note-info">            <p>由于PSK信号通过全波整流器后各个码元周期内的信号完全相同，无法辨认“0”或“1”，因此PSK信号不能使用非相干解调，只能使用相干解调。  </p>          </div><p>在相干解调中，PSK信号通过带通滤波器后和同频同向的载波相乘，表示“-1”的波形与载波相乘，得到的波形会完全在小于0的一侧，表示“1”的波形与载波相乘，得到的波形会完全在大于0的一侧。信号通过低通滤波器消除高频分量后送入抽样判决器进行判别。抽样判决器的最佳判决门限为0。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211125141819.png width=60%></p></li></ul><h3 id="DPSK"><a href="#DPSK" class="headerlink" title="DPSK"></a>DPSK</h3><h4 id="调制方式-3"><a href="#调制方式-3" class="headerlink" title="调制方式"></a>调制方式</h4><p>传统的PSK在解调过程中需要依赖未调制载波$cosω_ct$的相位，如果载波相位发生反转，调制结果会随之发生反转，这种现象称为倒π现象。<br>为了解决倒π现象以及相位模糊（Phase ambiguity）问题，DPSK（相对相移键控）选择使用相对码来取代PSK中使用的绝对码，以使得解调结果不依赖$cosω_ct$的相位。<br>DPSK的具体做法是:假设$b_n$为$a_n$的差分码，有：</p><script type="math/tex; mode=display">b_n=a_n⊕b_{n-1}</script><p>即当前差分码$b_n$是前一个差分码$b_{n-1}$与当前绝对码$a_n$的模二加法（异或）结果。<br>再将差分码做PSK调制即可。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211125144556.png width=50%></p><h4 id="解调方式-3"><a href="#解调方式-3" class="headerlink" title="解调方式"></a>解调方式</h4><ul><li><p>相干解调<br>同PSK相干解调</p></li><li><p>差分解调<br>除了使用同频同相的载波与DPSK信号相乘外，还可以使用延时一个码元周期的原DPSK信号与自身信号相乘，两者都能够达到“表示-1的波形与载波相乘，得到的波形会完全在小于0的一侧，表示1的波形与载波相乘，得到的波形会完全在大于0的一侧。”的效果。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211125145153.png width=50%>  </p></li></ul><div class="note note-info">            <p>实际设计中往往采用差分解调，原因是差分解调中所使用的延时模块成本比相干解调中用于产生本地载波的振荡器成本更低。  </p>          </div><div class="table-container"><table><thead><tr><th style="text-align:center">调制方式</th><th style="text-align:center">受调信号的码型</th><th style="text-align:center">受调信号的带宽</th><th style="text-align:center">解调方法</th><th style="text-align:center">解调的最佳判决门限</th></tr></thead><tbody><tr><td style="text-align:center">ASK</td><td style="text-align:center">单极性码</td><td style="text-align:center">$2B_s$</td><td style="text-align:center">相干解调<br>包络检波法</td><td style="text-align:center">$\frac{a}{2}$</td></tr><tr><td style="text-align:center">FSK</td><td style="text-align:center">单极性码</td><td style="text-align:center">$\lvert f_1-f_2\rvert +2B_s$</td><td style="text-align:center">相干解调<br>包络检波法<br>过零检波法<br></td><td style="text-align:center">无<br>无<br>$\frac{a}{2}$</td></tr><tr><td style="text-align:center">PSK</td><td style="text-align:center">双极性码</td><td style="text-align:center">$2B_s$</td><td style="text-align:center">相干解调</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">DPSK</td><td style="text-align:center">双极性码</td><td style="text-align:center">$2B_s$</td><td style="text-align:center">相干解调<br>相位比较法</td><td style="text-align:center">0</td></tr></tbody></table></div><h3 id="数字调制方式的性能对比"><a href="#数字调制方式的性能对比" class="headerlink" title="数字调制方式的性能对比"></a>数字调制方式的性能对比</h3><ul><li>抗噪性  <script type="math/tex; mode=display">PSK>DPSK>FSK>ASK</script><script type="math/tex; mode=display">相干解调>非相干解调</script></li><li>信噪比<br>系统的误码率下降时，系统的信噪比上升。</li><li>有效性<br>ASK/PSK和DPSK的带宽相同，FSK的带宽大于前三者，因此FSK的频谱利用效率最低，有效性最差，其余三者相同：<script type="math/tex; mode=display">ASK=PSK=DPSK>FSK</script></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">调制方式</th><th style="text-align:center">受调信号的码型</th><th style="text-align:center">受调信号的带宽</th><th style="text-align:center">解调方法</th><th style="text-align:center">解调的最佳判决门限</th><th style="text-align:center">最大频谱利用效率</th><th style="text-align:center">误码率</th></tr></thead><tbody><tr><td style="text-align:center">ASK</td><td style="text-align:center">单极性码</td><td style="text-align:center">$2B_s$</td><td style="text-align:center">相干解调<br>包络检波法</td><td style="text-align:center">$\frac{a}{2}$</td><td style="text-align:center">$\frac{1}{2}$</td><td style="text-align:center">$\frac{1}{2}erfc(\frac{\sqrt{SNR}}{2})$<br> $\frac{1}{2}e^{-\frac{SNR}{4}}$</td></tr><tr><td style="text-align:center">FSK</td><td style="text-align:center">单极性码</td><td style="text-align:center">$\lvert f_1-f_2\rvert +2B_s$</td><td style="text-align:center">相干解调<br>包络检波法<br>过零检波法<br></td><td style="text-align:center">无<br>无<br>$\frac{a}{2}$</td><td style="text-align:center">$\frac{R_B}{\lvert f_1-f_2\rvert +2R_B}$</td><td style="text-align:center">$\frac{1}{2}erfc(\sqrt{\frac{SNR_{FSK}}{2}})$ <br> $\frac{1}{2}e^{-\frac{SNR_{FSK}}{2}}$</td></tr><tr><td style="text-align:center">PSK</td><td style="text-align:center">双极性码</td><td style="text-align:center">$2B_s$</td><td style="text-align:center">相干解调</td><td style="text-align:center">0</td><td style="text-align:center">$\frac{1}{2}$</td><td style="text-align:center">$\frac{1}{2}erfc(\sqrt{SNR_{PSK}})$</td></tr><tr><td style="text-align:center">DPSK</td><td style="text-align:center">双极性码</td><td style="text-align:center">$2B_s$</td><td style="text-align:center">相干解调<br>相位比较法</td><td style="text-align:center">0</td><td style="text-align:center">$\frac{1}{2}$</td><td style="text-align:center">$\frac{1}{2}e^{-SNR_{PSK}}$</td></tr></tbody></table></div><p>所有调制方法的信噪比均为： $SNR=\frac{\frac{a^2}{2}}{2n_0B_{S}}$。  </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>通信原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>加密测试</title>
    <link href="/2021/12/11/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/%E5%8A%A0%E5%AF%86%E6%B5%8B%E8%AF%95/"/>
    <url>/2021/12/11/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/%E5%8A%A0%E5%AF%86%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="b696930780540d0fa1ae5bc3c1a572081a146b069e9c264e675240d52985158d">c59abb579ab69a69cb0967c807bd10f7296a3381537944e6f5fbefbde11e41bdddaa6821533e42475329d89f4509f3cc06aef6051933480819ba61749ca8c821f73878687bb69e6ba721273c34e1a9ebf0f49ef0b86251aba5c38c6e5d8e95e97e20409c5d73131f80fee474320cf034ce361e5591a81df3bd9ed01afa5d56e5fabb591a74a1c0db949f1bafbb54e25d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">如果输入信号的带宽为fH，单边带调制后的带宽为：</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>技术杂谈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>半导体电路推导</title>
    <link href="/2021/12/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E8%B7%AF%E4%B8%8E%E5%99%A8%E4%BB%B6/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%85%83%E4%BB%B6%E6%8E%A8%E5%AF%BC/"/>
    <url>/2021/12/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E8%B7%AF%E4%B8%8E%E5%99%A8%E4%BB%B6/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%85%83%E4%BB%B6%E6%8E%A8%E5%AF%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="半导体电路推导"><a href="#半导体电路推导" class="headerlink" title="半导体电路推导"></a>半导体电路推导</h1><div class="row">    <embed src="https://l61012345.top/files/半导体元件部分推导.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>电路与器件</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>滤波器</title>
    <link href="/2021/12/10/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E8%B7%AF%E4%B8%8E%E5%99%A8%E4%BB%B6/%E6%BB%A4%E6%B3%A2%E5%99%A8/"/>
    <url>/2021/12/10/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E8%B7%AF%E4%B8%8E%E5%99%A8%E4%BB%B6/%E6%BB%A4%E6%B3%A2%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="滤波器"><a href="#滤波器" class="headerlink" title="滤波器"></a>滤波器</h1><h2 id="传输函数"><a href="#传输函数" class="headerlink" title="传输函数"></a>传输函数</h2><p>输出值与输入值的比值，以电压的形式来表示：</p><script type="math/tex; mode=display">T(s)=\frac{V_{out}}{V_{in}}</script><p>电容的值是随着频率的变化而变化的：</p><p>$τ=RC$, $ω=\frac{1}{τ}$</p><h2 id="低通滤波器"><a href="#低通滤波器" class="headerlink" title="低通滤波器"></a>低通滤波器</h2><p>传输函数：  </p><script type="math/tex; mode=display">T(Jω)=\frac{V_{out}}{V_{in}} =\frac{\frac{1}{S}C}{R+\frac{1}{S} C}</script><p>根据电容的位置，可以判断是高通还是低通。<br>低通滤波器的电容接在了输出端，如果电流的频率很底，输出端为开路，输出端电压=输入端电压，传输函数为1。<br>当频率增加到一定程度时，传输函数的值（$|T|dB$）比频率为0时的值低3dB（即下降0.707）时，可以认为传输函数的值开始下降。此时的频率为$\frac{1}{RC}$（称为低频截止频率）。<br>如果电流频率高，电容相当于短路，输出端短路，输出电压为0，所以能够阻断电压。  </p><h2 id="高通滤波器"><a href="#高通滤波器" class="headerlink" title="高通滤波器"></a>高通滤波器</h2><p>传输函数：  </p><script type="math/tex; mode=display">T(Jω)=\frac{V_{out}}{V_{in}} =\frac{s τ}{1+s τ}</script><p>电容的位置接在输入端和输出端之间，如果电流的频率很低，输出端为短路。如果电流的频率很高，电容相当于断路。<br>低通滤波器和高通滤波器的截止频率是相同的。  </p><h2 id="带通滤波器"><a href="#带通滤波器" class="headerlink" title="带通滤波器"></a>带通滤波器</h2><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211210231630.png width=50%>  </p><p>传输函数：  </p><script type="math/tex; mode=display">T(Jω)=\frac{V_{out}}{V_{in}} =−\frac{Kj 2πf}{1+\frac{j ω}{ω_1 }1+\frac{j ω}{ω_2 }}</script><p>如果要实现滤波器，必须要有一个电容或者电感。<br>$C_1$电流频率很低，$C_1$为开路，输入电压和放大器的反向输入端$（-）$被断开，放大器的输入信号为0.<br>$C_2$电流频率很高，$C_2$为短路，$R_2$为短路，运算放大器的输出端和反向输入端被短路，输出电压接地，输出电压为0.<br>输入电压的频率只能在$f_1=\frac{1}{2 πR_1 C_1 }$与$f_2=\frac{1}{2 πR_2 C_2 }$之间，才能够通过滤波器。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>电路与器件</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>电路分析方法</title>
    <link href="/2021/12/10/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E8%B7%AF%E4%B8%8E%E5%99%A8%E4%BB%B6/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/"/>
    <url>/2021/12/10/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E8%B7%AF%E4%B8%8E%E5%99%A8%E4%BB%B6/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="电路分析方法"><a href="#电路分析方法" class="headerlink" title="电路分析方法"></a>电路分析方法</h1><h2 id="网孔分析法"><a href="#网孔分析法" class="headerlink" title="网孔分析法"></a>网孔分析法</h2><p>方法要点：</p><ol><li>对于每一个环路设定顺时针或者逆时针的方向</li><li>根据电流的方向确定每部分电压的正负号</li><li>对每一个环路建立方程</li></ol><p>在含有独立电流源的条件下：</p><ol><li>先将电流源并联到最外面</li><li>忽略电流源先建立方程</li><li>再将电流源并入方程中分析</li></ol><h2 id="节点法"><a href="#节点法" class="headerlink" title="节点法"></a>节点法</h2><ol><li>确定一个0电势</li><li>选择一个节点</li><li>按照电流流动的方向是从电势高点流向电势低点，分析每一个支路的电流</li><li>分析电流的流向，建立一个完整的电流方程</li></ol><p>在含有独立电压源的条件下：</p><ol><li>将独立电压源视为短路</li><li>进行节点分析</li><li>再并入独立电压源</li></ol><h2 id="叠加法"><a href="#叠加法" class="headerlink" title="叠加法"></a>叠加法</h2><ol><li>将电压源视为短路，对仅含有电流源进行分析</li><li><p>将电流源视为断路，对仅含有电压源进行分析</p><blockquote><p>对每一个电流源和电压源都要进行这样的分析</p></blockquote></li><li><p>叠加每一个电压源/ 电流源的分析</p></li></ol><h2 id="戴维南定理"><a href="#戴维南定理" class="headerlink" title="戴维南定理"></a>戴维南定理</h2><ol><li>将电压源视为短路，电流源视为断路，从ab端看，计算戴维南等效电阻</li><li>还原电压源/ 电流源， ab断路，计算ab两端的电压</li><li>建立ab端外的等效电压源与电阻的串联电路</li></ol><h2 id="诺顿定理"><a href="#诺顿定理" class="headerlink" title="诺顿定理"></a>诺顿定理</h2><ol><li>将电压源视为短路，电流源视为断路，从ab端看，计算诺顿等效电阻</li><li>还原电压源/ 电流源， ab短路，计算流经ab的电流</li><li>建立ab端外的等效电流源与电阻的并联电路</li></ol><h2 id="最大功率传输定理"><a href="#最大功率传输定理" class="headerlink" title="最大功率传输定理"></a>最大功率传输定理</h2><p>当负载电阻值与内阻相等时，传输的功率最大  </p><h2 id="Y-Delta-形电路转换"><a href="#Y-Delta-形电路转换" class="headerlink" title="Y-Delta 形电路转换"></a>Y-Delta 形电路转换</h2><p>略</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>电路与器件</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>附录2：ASK/FSK/PSK/DPSK 解调过程及波形</title>
    <link href="/2021/12/10/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/ASKFSKPSK%E6%B3%A2%E5%BD%A2/"/>
    <url>/2021/12/10/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/ASKFSKPSK%E6%B3%A2%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="附录2：ASK-FSK-PSK-DPSK-解调过程及波形"><a href="#附录2：ASK-FSK-PSK-DPSK-解调过程及波形" class="headerlink" title="附录2：ASK/FSK/PSK/DPSK 解调过程及波形"></a>附录2：ASK/FSK/PSK/DPSK 解调过程及波形</h1><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/ADEE2386F972C3491EFCDCD3A625CC0A.png width=100%></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>通信原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>附录1：其他数学公式</title>
    <link href="/2021/12/10/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E5%8F%AF%E8%83%BD%E7%94%A8%E5%88%B0%E7%9A%84%E5%85%AC%E5%BC%8F/"/>
    <url>/2021/12/10/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E5%8F%AF%E8%83%BD%E7%94%A8%E5%88%B0%E7%9A%84%E5%85%AC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="附录1：-其他数学公式"><a href="#附录1：-其他数学公式" class="headerlink" title="附录1： 其他数学公式"></a>附录1： 其他数学公式</h1><h2 id="常用傅里叶变换对"><a href="#常用傅里叶变换对" class="headerlink" title="常用傅里叶变换对"></a>常用傅里叶变换对</h2><ul><li>调制定理<script type="math/tex; mode=display">f(t)cosω_ct↔\frac{1}{2}[F(ω+ω_c)+F(ω-ω_c)]</script></li><li>矩形脉冲的傅里叶变换<script type="math/tex; mode=display">G(t)=1,|t|≤\frac{τ}{2}↔τSa(\frac{ωτ}{2})</script></li><li>抽样函数的傅里叶变换<script type="math/tex; mode=display">Sa(ω_ct)↔\frac{π}{ω_c}G_{2ω_c}(ω)</script></li><li>斜坡函数的傅里叶变换<script type="math/tex; mode=display">1-\frac{|t|}{τ},|t|≤τ↔τSa^2(\frac{ωτ}{2})</script></li></ul><h2 id="积化和差公式"><a href="#积化和差公式" class="headerlink" title="积化和差公式"></a>积化和差公式</h2><script type="math/tex; mode=display">\cosα\cosβ=\frac{1}{2}[\cos(α+β)+\cos(α-β)]</script><script type="math/tex; mode=display">\sinα\sinβ=\frac{1}{2}[\cos(α-β)-\cos(α+β)]</script><script type="math/tex; mode=display">\sinα\cosβ=\frac{1}{2}[\sin(α+β)+\sin(α-β)]</script><script type="math/tex; mode=display">\cosα\sinβ=\frac{1}{2}[\sin(α+β)-\sin(α-β)]</script>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>通信原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>10. 双晶体管电路·多级放大电路</title>
    <link href="/2021/11/28/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%AD%90%E7%B3%BB%E7%BB%9F/10.%20IC_buildingblocks/"/>
    <url>/2021/11/28/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%AD%90%E7%B3%BB%E7%BB%9F/10.%20IC_buildingblocks/</url>
    
    <content type="html"><![CDATA[<h1 id="双晶体管电路"><a href="#双晶体管电路" class="headerlink" title="双晶体管电路"></a>双晶体管电路</h1><p>所有模拟电路都是通过使用数量非常有限的基本结构模块来构建的，因此，对这些简单模块的透彻了解对于深入了解更复杂的电路原理至关重要，这就是为什么将它们分别考虑并进行详细分析的原因。我们已经对单晶体管电路有了全面的了解，接下来我们将专注于电流镜和差分对的探讨，这些构成了所有模拟设计的基石。<br>基本的双晶体管配置有：电流镜(Current Mirror)和差分对(Difference Pair)两种。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211128134829.png width=50%>  </p><p>大部分模拟电路在集成电路设计中都可以通过数个多级的如上所示的两个基本电路而构成。  </p><blockquote><p>参考资料:<a href="https://www.icfedu.cn/archives/13594">https://www.icfedu.cn/archives/13594</a></p></blockquote><h2 id="电流镜"><a href="#电流镜" class="headerlink" title="电流镜"></a>电流镜</h2><p>电流镜电路的基本设计如图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211128134946.png width=40%>  </p><p>这个电路中，左边的晶体管$Q_1$将输入电流转为电压$V_{BE}$输出，右边的晶体管$Q_2$将$V_{BE}$视为输入，进而转为电流$I_O$输出。  </p><h3 id="电流分析"><a href="#电流分析" class="headerlink" title="电流分析"></a>电流分析</h3><p>对电流镜电路，假设图中AB两点间的电流为$2\frac{I_C}{β}$：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211128135641.png width=50%>  </p><p>那么可以发现：  </p><script type="math/tex; mode=display">I_{REF}=I_C+2\frac{I_C}{β}</script><script type="math/tex; mode=display">I_O=I_C</script><p>因此:  </p><script type="math/tex; mode=display">\frac{I_O}{I_{REF}}=\frac{1}{1+\frac{2}{β}}</script><p>当$β→∞$时，$\frac{I_O}{I_{REF}}→1$。<br>通常认为$I_O=I_{REF}$。  </p><h3 id="带基极电流补偿的电流镜"><a href="#带基极电流补偿的电流镜" class="headerlink" title="带基极电流补偿的电流镜"></a>带基极电流补偿的电流镜</h3><p>在电流镜电路中的AB两点增加一个晶体管：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211129204508.png width=50%>  </p><p>由于晶体管的存在，此时：  </p><script type="math/tex; mode=display">I_{REF}=I_C+I_{B3}</script><script type="math/tex; mode=display">I_{B3}=\frac{I_{E3}}{β+1}=\frac{2I_C}{β(β+1)}</script><p>因此：  </p><script type="math/tex; mode=display">I_O=I_{C}=\frac{I_{REF}}{1+\frac{2}{β(β+1)}}</script><p>相比于原来的电流镜电路，输出的电流大小对β的依赖性更低，更加稳定。  </p><h3 id="基本增益单元"><a href="#基本增益单元" class="headerlink" title="基本增益单元"></a>基本增益单元</h3><p>$I_{REF}$的产生方式有两种：第一种是通过给电压，使用电阻将电压转换为电流。另一种是直接给一个电流源。<br>在集成电路设计中第一种方法无法精准控制电流的大小，因此通常采用第二种方法来获得$I_{REF}$。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211130133505.png width=70%>  </p><p>在小信号模型中对其进行分析，其开环增益应该为：  </p><script type="math/tex; mode=display">A_{vo}=-g_mr_o</script><p><strong>电流镜在集成电路中可以为其他晶体管电路提供稳定的直流电流，在集成电路中常作为直流电流源使用。在小信号模型分析中，电流镜电路和直流电流源一样，被视为开路。</strong>  </p><h2 id="达灵顿对"><a href="#达灵顿对" class="headerlink" title="达灵顿对"></a>达灵顿对</h2><p>达灵顿对（Darlington pair）是由两个（甚至多个）双极性晶体管组成的复合结构，通过这样的结构，经第一个双极性晶体管放大的电流可以进一步被放大。这样的结构可以提供一个比其中任意一个双极性晶体管高得多的电流增益。在使用集成电流芯片的情况里，达灵顿晶体管可以使得芯片比使用两个分立晶体管元件占用更少的空间，因为两个晶体管可以共用一个集极。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211130134014.png width=30%>   </p><p>达灵顿对的电流增益可以表示为：  </p><script type="math/tex; mode=display">β=β_1×β_2</script><p>现在，达灵顿晶体管产品的典型电流增益可以达到1000甚至更高，因此只需要很小的基极电流就可以让晶体管导通。然而，这样高的电流增益也带来了一些缺点。<br>达灵顿对的问题在于通常$I_{B2}$非常小，因此$I_{E1}$很小，容易造成$I_{C1}$减小，影响$β_1$，使得$Q_1$进入截止工作状态而无法正常工作。  </p><blockquote><p>下图表示了$β$随$I_C$的变化曲线，可以发现如果$I_C$非常小的话，$β$无限趋近于0，晶体管进入截止状态。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211130141945.png width=50%>  </p></blockquote><p>解决方法是在$Q_1$的发射极区增加一个恒定的电流源，使$I_{E1}=I_{B2}+I$，以维持$I_{E1}$的电流水平，使$I_{C1}$不至于过小。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211130142236.png width=30%>  </p><h2 id="差分对"><a href="#差分对" class="headerlink" title="差分对"></a>差分对</h2><p>差分对是另一种常见于集成电路设计的基本结构，由于差分电路输出的结果是两个输入信号的差值，两个输入信号中携带的噪音在做差时很容易减小甚至是被除去，因此差分电路对于噪音和干扰的鲁棒性强，在集成电路中得到广泛的应用。<br>最基本的差分对结构如下图所示，差分对电路由两个完全相同的晶体管$Q_1$和$Q_2$组成。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211130142858.png width=50%>  </p><p>差分对电路中的两基极电压$v_{B1}$和$v_{B2}$用于设置两个晶体管状态处于放大模式或截止模式。$i_C$可以用电压$V_{CC}$加电阻$R_C$产生，也可以使用电流源直接产生。  </p><h3 id="差分对的正常模式"><a href="#差分对的正常模式" class="headerlink" title="差分对的正常模式"></a>差分对的正常模式</h3><p>当$v_{B1}=v_{B2}=V_{CM}$时，晶体管处于正常模式。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211130143312.png width=50%>  </p><p>在正常模式下，</p><script type="math/tex; mode=display">i_{E1}=i_{E2}=\frac{I}{2}</script><script type="math/tex; mode=display">V_{C1}=V_{C2}=V_{CC}-\frac{1}{2}αIR_C</script><p>可以发现，$Q_1$和$Q_2$均处于放大模式，此时输出的电压$V_{C1}$和$V_{C2}$与$V_{CM}$没有任何关系。  </p><h3 id="差分对的差分模式"><a href="#差分对的差分模式" class="headerlink" title="差分对的差分模式"></a>差分对的差分模式</h3><p><strong>当用于设置晶体管工作状态的$v_{B1}$和$v_{B2}$不相同时，$Q_1$和$Q_2$两个晶体管中一个晶体管处于正常模式，另一个晶体管处于截止模式。</strong><br>此时需要对两个晶体管的工作状态进行假设，然后观察两个晶体管的$V_{BE}≈0.7V$的条件是否成立，且是否与假设冲突，进而确定两个晶体管的工作状态。  </p><p>在差分模式下，其中处于截止状态的晶体管的输出电压：  </p><script type="math/tex; mode=display">V_{C}=V_{CC}</script><p>处于放大状态的晶体管的输出电压：  </p><script type="math/tex; mode=display">V_{C}=V_{CC}-αIR_C</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211130144602.png width=30%>  </p><h2 id="差分放大电路"><a href="#差分放大电路" class="headerlink" title="差分放大电路"></a>差分放大电路</h2><p>差分放大电路是利用差分对性质构成的放大电路，其输入电压为两个晶体管的基极电压信号，输出两个晶体管集电极电压的差值。  </p><h3 id="大信号模型"><a href="#大信号模型" class="headerlink" title="大信号模型"></a>大信号模型</h3><p>在大信号模型下，输入的电压信号既有交流信号，也有直流信号。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211130144839.png width=50%><br>此时：  </p><script type="math/tex; mode=display">i_{E1}=\frac{I_S}{α}e^{(v_{B1}-v_E)/V_T}</script><script type="math/tex; mode=display">i_{E2}=\frac{I_S}{α}e^{(v_{B2}-v_E)/V_T}</script><p>两式子相除：  </p><script type="math/tex; mode=display">\frac{i_{E1}}{i_{E2}}=e^{v_{id}/V_T}</script><p>其中$v_{id}$是输入电压信号的差值：$v_{id}=v_{B1}-v_{B2}$。<br>令$I=i_{E1}+i_{E2}$，等式两边同时加$1$以带入$I$，得到：  </p><script type="math/tex; mode=display">i_{E2}=\frac{I}{1+e^{v_{id}/V_T}}≈i_{C2}</script><script type="math/tex; mode=display">i_{E1}=\frac{I}{1+e^{-v_{id}/V_T}}≈i_{C1}</script><p>绘制出$i_C$关于$v_{id}$的图像，即差分放大电路的大信号模型特性曲线：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211130152811.png width=60%>  </p><p>在大信号模型中找到$v_{id}=0$（即$v_{B1}=v_{B2}=V_{CM}$）附近的线性区，在这个区域中，两个晶体管可以视作是在直流工作状态的放大模式下。  </p><h3 id="小信号模型"><a href="#小信号模型" class="headerlink" title="小信号模型"></a>小信号模型</h3><p>小信号模型基于大信号模型中的线性区域进行分析，根据大信号模型中得出的结论：  </p><script type="math/tex; mode=display">i_{C1}=\frac{αI}{1+e^{v_{-id}/V_T}}</script><script type="math/tex; mode=display">i_{C2}=\frac{αI}{1+e^{v_{id}/V_T}}</script><p>对于$i_{C1}$，分子分母同时乘以$e^{v_{id}/2V_T}$：  </p><script type="math/tex; mode=display">i_{C1}=\frac{αIe^{v_{id}/2V_T}}{e^{v_{id}/2V_T}+e^{v_{-id}/2V_T}},V_d<<2V_T</script><p>利用泰勒展开式展开，并保留前两项，化简得到：  </p><script type="math/tex; mode=display">i_{C1}=\frac{αI}{2}+\frac{αI}{2V_T}\frac{v_{id}}{2}</script><script type="math/tex; mode=display">i_{C1}=I_C+g_m\frac{v_{id}}{2}</script><p>由于$i_{C1}$由直流分量和交流分量组成，而$I_C$为纯粹的直流分量，因此$i_{C1}$的交流分量：  </p><script type="math/tex; mode=display">i_{c1}=g_m\frac{v_{id}}{2}</script><p>同理可得：  </p><script type="math/tex; mode=display">i_{c2}=-g_m\frac{v_{id}}{2}</script><h3 id="差分增益"><a href="#差分增益" class="headerlink" title="差分增益"></a>差分增益</h3><p>通过之前的分析可以得到两个输出电压：  </p><script type="math/tex; mode=display">v_{C1}=V_{CC}-I_CR_C-g_mR_C\frac{v_{id}}{2}</script><script type="math/tex; mode=display">v_{C2}=V_{CC}-I_CR_C+g_mR_C\frac{v_{id}}{2}</script><p>定义差分电路的差分增益为输出电压信号的差值和输入电压信号的差值$v_{id}$之比：  </p><script type="math/tex; mode=display">A_d=\frac{v_{C2}-v_{C1}}{v_{id}}=g_mR_C</script><h4 id="小信号模型的差分增益"><a href="#小信号模型的差分增益" class="headerlink" title="小信号模型的差分增益"></a>小信号模型的差分增益</h4><p>对两个晶体管在小信号模型下使用T模型进行分析：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211130154322.png width=50%>  </p><p>其输入电阻为：  </p><script type="math/tex; mode=display">R_{id}=\frac{v_{id}}{i_b}=2(β+1)r_e=2r_π</script><p>有:  </p><script type="math/tex; mode=display">i_e=\frac{v_{id}}{2r_e}≈i_c</script><script type="math/tex; mode=display">v_{c1}=-\frac{αv_{id}}{2r_e}R_C</script><script type="math/tex; mode=display">v_{c2}=\frac{αv_{id}}{2r_e}R_C</script><p>小信号模型下的差分增益：  </p><script type="math/tex; mode=display">A_d=\frac{v_{c2}-v_{c1}}{v_{id}}=\frac{2αR_C}{2r_e}≈\frac{R_C}{r_e}</script><h3 id="共模抑制比"><a href="#共模抑制比" class="headerlink" title="共模抑制比"></a>共模抑制比</h3><p>事实上，差分对的两个集电极区会有噪声和干扰，这些噪声和干扰最终归结于电路中$R_C$的阻值，因此在实际电路中，等效的两个$R_C$阻值并不完全相等，而是由细微的差异。<br>实际上差分对在正常模式下的两边的输出电压由于$R_C$细小的差异而不再相等：  </p><script type="math/tex; mode=display">v_{o1}=-\frac{αR_C}{r_e+2R_{EE}}v_{icm}</script><script type="math/tex; mode=display">v_{o2}=-\frac{α(R_C+ΔR_C)}{r_e+2R_{EE}}v_{icm}</script><p>此时整个电路相当于一个差分放大器，其在输出端存在一个差分电压：  </p><script type="math/tex; mode=display">v_{od}=v_{o2}-v_{o1}=-\frac{αΔR_C}{r_e+2R_{EE}}v_{icm}</script><p>定义共模增益为差分电压和输入电压之比：  </p><script type="math/tex; mode=display">A_{cm}=\frac{v_{od}}{v_{icm}}=-\frac{αΔR_C}{r_e+2R_{EE}}</script><p>定义共模抑制比为其差分增益与共模增益之比：  </p><script type="math/tex; mode=display">CMRR=\frac{A_d}{A_{cm}}</script><h2 id="多极放大器"><a href="#多极放大器" class="headerlink" title="多极放大器"></a>多极放大器</h2><p>为了尽可能的减少电阻、电容带来的不稳定性，在集成电路设计中通常使用多级的电流镜、差分对组成的电路实现电流信号的多级放大。<br>下图所示的是一个多级电流放大电路：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211201133023.png width=60%><br>在上图的电路中，<br>第一级由$Q_1$、$Q_2$、$Q_3$、$Q_9$ 四个晶体管组成。通过设置$V_{EE}$,在$Q_9$处产生$I_{REF}$。$I_{REF}$通过$Q_3$、$Q_9$ 组成的电流镜将电流信号传入$Q_1$、$Q_2$组成的差分对中，差分对将电流信号转换为电压信号，电压信号成为下一级差分对电路的输入信号。  </p><p>第二级由$Q_4$、$Q_5$、$Q_6$三个晶体管组成。上一级输出的电压信号作为$Q_4$、$Q_5$组成的差分对电路的输入电压（控制电压），同时$Q_6$对第一级的电流$I_{REF}$进行放大，并为$Q_4$、$Q_5$组成的差分对电路提供稳定的发射极电流$I_E$。差分对一端输出的电压信号传入下一级，为下一级的晶体管设置工作状态。  </p><p>第三级由$Q_7$组成，上一级差分对电路的输出电压为$Q_7$设置静态工作点，并通过$R_5$控制输入进下一级的电压信号的直流分量正好为0.7V。  </p><p>第四级由$Q_8$组成，通过$Q_8$基极和发射极之间的压降将上一级电压信号的直流分量完全消除，最终输出直流分量为0的交流电压信号。同时$R_6$将电压信号转为电流信号，可以发现，输出端的电流信号$I_o$正好是$I_{REF}$的十倍。  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211201134351.png width=70%>  </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>电子系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>09. 晶体管单级放大电路</title>
    <link href="/2021/11/28/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%AD%90%E7%B3%BB%E7%BB%9F/9.%20ICamplifier/"/>
    <url>/2021/11/28/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%AD%90%E7%B3%BB%E7%BB%9F/9.%20ICamplifier/</url>
    
    <content type="html"><![CDATA[<h1 id="晶体管单级放大电路"><a href="#晶体管单级放大电路" class="headerlink" title="晶体管单级放大电路"></a>晶体管单级放大电路</h1><p>集成电路中的运算放大器是由晶体管组成的，最基本的三种用晶体管构成的单级放大电路为：  </p><ul><li>共射极放大电路(Common Emitter)</li><li>共基极放大电路(Common Base)</li><li>共集极放大电路(Common Collector)  </li></ul><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211128140544.png width=60%>   </p><p>总体上来说，晶体管的哪个集被共用，电路中晶体管的哪个极就接地。<br>三种放大电路的特性不尽相同，用途也不相同，本节主要介绍这三种放大电路的电路分析和特性。  </p><h2 id="共射极（CE）放大电路"><a href="#共射极（CE）放大电路" class="headerlink" title="共射极（CE）放大电路"></a>共射极（CE）放大电路</h2><p>共射极放大电路如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211128140810.png width=50%></p><p>电压信号由基极输入、集电极输出。  </p><h3 id="π模型的电路分析"><a href="#π模型的电路分析" class="headerlink" title="π模型的电路分析"></a>π模型的电路分析</h3><p>当发射极没有额外的电阻时，因此使用π模型进行等效处理：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211128151846.png width=60%>  </p><p>在该电路中，放大电路部分（图中蓝色框）的输入电阻：  </p><script type="math/tex; mode=display">R_{in}=\frac{v_i}{i_b}=r_π</script><p>而$r_π=\frac{β}{g_m}$，$g_m=\frac{I_C}{V_T}$，通常来说放大电路内部的输入电阻较小，但是数量级仍然在几千欧姆。<br>当$v_{in}=0$（端口输入电压）时，从输出端看电路电阻，可以得到放大电路部分的输出电阻：  </p><script type="math/tex; mode=display">R_o=R_C</script><p>可见放大电路部分的输出电阻由$R_C$的阻值决定，通常$R_C$的阻值都比较大，数量级在几千欧姆左右。<br>放大器的电压增益就可以表示为：  </p><script type="math/tex; mode=display">A_v=\frac{v_o}{v_{sig}}</script><script type="math/tex; mode=display">v_o=-g_mv_π×R_C</script><script type="math/tex; mode=display">v_π=v_{sig}\frac{r_π}{r_π+R_{sig}}</script><script type="math/tex; mode=display">A_v=-g_m\frac{r_π}{r_π+R_{sig}}R_C</script><p>由于放大电路的开环增益与电压增益的关系为:$A_v=A_{vo}\frac{R_{in}}{R_{in}+R_{sig}}$，因此电路的开环增益表示为：  </p><script type="math/tex; mode=display">A_{vo}=-g_mR_C</script><h3 id="T模型电路分析"><a href="#T模型电路分析" class="headerlink" title="T模型电路分析"></a>T模型电路分析</h3><p>当发射极存在额外的电阻$R_e$时，采用T模型对电路进行分析：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211128160412.png width=50%>  </p><p>由于发射极接地，不便于电阻分析，因此采用电阻投射定理将发射极的电阻转到基极上进行计算。<br>那么输入电阻：  </p><script type="math/tex; mode=display">R_{in}=(r_e+R_e)(β+1)=r_π</script><p>输出电阻：  </p><script type="math/tex; mode=display">R_o=R_C</script><p>那么电压增益可以表示为：  </p><script type="math/tex; mode=display">A_v=\frac{v_o}{v_{sig}}</script><p>应用电阻投射定理将$R_{sig}$转到发射极以求出$i_e$：  </p><script type="math/tex; mode=display">i_e=\frac{v_{sig}}{(r_e+R_e)+\frac{R_{sig}}{β+1}}</script><script type="math/tex; mode=display">v_o=-i_cR_C=-αi_eR_C=-\frac{αv_{sig}R_C}{(r_e+R_e)+\frac{R_{sig}}{β+1}}</script><script type="math/tex; mode=display">A_v=-\frac{αR_C}{(r_e+R_e)+\frac{R_{sig}}{β+1}}</script><p>由$α=\frac{β}{\beta+1}$:  </p><script type="math/tex; mode=display">A_v=-β\frac{R_C}{(r_e+R_e)(β+1)+R_{sig}}</script><p>由$r_π=(r_e+R_e)(β+1)=\frac{β}{g_m}$:  </p><script type="math/tex; mode=display">A_v=-g_m\frac{r_π}{r_π+R_{sig}}R_C</script><p>电路的开环增益同样为：  </p><script type="math/tex; mode=display">A_{vo}=-g_mR_C</script><h3 id="共射极放大电路的特性"><a href="#共射极放大电路的特性" class="headerlink" title="共射极放大电路的特性"></a>共射极放大电路的特性</h3><p>由开环增益的表达式可以发现，输入电阻$R_{in}=r_π$增大，$g_m$下降，$|A_{vo}|$减小。根据反馈电路中对开环增益与稳定性的分析：<strong>开环增益越小，系统越稳定。</strong><br>因此，输入电阻应该尽量地大，而输出电阻$R_C$也应当尽量地小才能保证系统的稳定性。<br>在实际中，可以在输入端之前加入一个缓冲器/跟随器，以提高输入电阻的阻值。  </p><h2 id="共基极-CB-放大电路"><a href="#共基极-CB-放大电路" class="headerlink" title="共基极(CB)放大电路"></a>共基极(CB)放大电路</h2><p>共基极放大电路如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211128162524.png width=40%><br>电压信号$v_{sig}$在发射极作为输入信号，集电极处$R_C$上的电压作为输出电压。  </p><h3 id="T模型电路分析-1"><a href="#T模型电路分析-1" class="headerlink" title="T模型电路分析"></a>T模型电路分析</h3><p>由于发射极存在电阻，因此采用T模型进行分析：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211128162806.png width=50%>  </p><p>T模型中放大电路的输入电阻：  </p><script type="math/tex; mode=display">R_{in}=-\frac{v_i}{i_e}=r_e</script><p>由于$r_e=\frac{α}{g_m}$，因此放大电路内部的输入电阻比较小，在几十欧姆左右。  </p><p>假设输入电压为0，从输出端看电阻，则输出电阻为：  </p><script type="math/tex; mode=display">R_o=R_C</script><p>可见放大电路部分的输出电阻由$R_C$的阻值决定，通常$R_C$的阻值都比较大，数量级在几千欧姆左右。<br>则放大电路的电压增益表示为：  </p><script type="math/tex; mode=display">A_v=\frac{v_o}{v_{sig}}</script><script type="math/tex; mode=display">\begin{aligned}    v_o&=i_cR_C \\    &=-αi_eR_C \\    &=-α(-\frac{v_{sig}}{v_{sig}+r_e})R_C\\\end{aligned}</script><script type="math/tex; mode=display">A_v=\frac{v_o}{v_{sig}}=α\frac{R_C}{R_{sig}+r_e}</script><p>其开环增益：  </p><script type="math/tex; mode=display">A_{vo}=α</script><p>由于$α≈1$，因此共基极放大器的电压增益与晶体管电流增益$β$无关。同时$R_{sig}$、$R_C$的阻值常处于同一数量级，因此共基极放大电路的电压增益很小。  </p><h3 id="共基极放大电路的特性"><a href="#共基极放大电路的特性" class="headerlink" title="共基极放大电路的特性"></a>共基极放大电路的特性</h3><p>由于输入阻抗/阻值过于低，与理想放大器要求的“输入阻抗无穷大”矛盾，因此绝大多数情况下不适合作为放大电路工作。<br>但是，由于其开环增益相对独立，因此共基极放大电路不容易受到频率的影响，在高频部分表现较为稳定。<br>此外，其输入阻值的数量级正好和同轴线缆的阻值差不多，因此可以在使用同轴线缆的高频电路中使用，实现和线缆的阻抗匹配，以减小信号的能量反射损失。  </p><h2 id="共集极-CC-放大电路-发射极跟随器"><a href="#共集极-CC-放大电路-发射极跟随器" class="headerlink" title="共集极(CC)放大电路/发射极跟随器"></a>共集极(CC)放大电路/发射极跟随器</h2><p>共集极放大电路的结构如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211128170501.png width=40%>  </p><p>共集极以基极作为输入信号源，同时在发射极连接一个负载电阻$R_L$作为电路的输出。 </p><h3 id="T模型电路分析-2"><a href="#T模型电路分析-2" class="headerlink" title="T模型电路分析"></a>T模型电路分析</h3><p>由于发射极存在电阻，因此采用T模型进行分析：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211128173612.png width=40%>  </p><p>输入电阻：  </p><script type="math/tex; mode=display">i_b=\frac{v_i}{(β+1)(r_e+R_L)}</script><script type="math/tex; mode=display">R_{in}=(r_e+R_L)(1+β)</script><p>输出电阻：<br>如果端口输入电压$v_{in}=0$，那么从放大电路的输出端看电阻：  </p><script type="math/tex; mode=display">R_o=r_e</script><p>电路的电压增益为：  </p><script type="math/tex; mode=display">v_{in}=\frac{R_{in}}{R_{in}+R_{sig}}v_{sig}</script><script type="math/tex; mode=display">v_o=v_{in}\frac{R_L}{R_L+r_e}</script><p>其中$v_{in}$和$v_{o}$表示放大电路部分（对应晶体管）的输入电压和输出电压。  </p><script type="math/tex; mode=display">A_v=\frac{v_o}{v_{sig}}=\frac{R_L}{R_L+r_e}\frac{R_{in}}{R_{in}+R_{sig}}</script><p>带入$R_{in}$,得到：  </p><script type="math/tex; mode=display">\begin{aligned}    A_v&=\frac{R_L}{R_L+r_e}\frac{(r_e+R_L)(1+β)}{(r_e+R_L)(1+β)+R_{sig}}\\    &=\frac{(β+1)R_L}{(β+1)(r_e+R_L)+R_{sig}}\end{aligned}</script><p>电路的开环增益由$R_L→∞$给出：  </p><script type="math/tex; mode=display">A_{vo}=\lim_{R_L→∞}\frac{v_o}{v_{in}}=\lim_{R_L→∞}\frac{R_L}{R_L+r_e}=1</script><script type="math/tex; mode=display">A_{vo}=1</script><p>因此，电路的开环增益等于1。  </p><h3 id="共集极放大电路的特性"><a href="#共集极放大电路的特性" class="headerlink" title="共集极放大电路的特性"></a>共集极放大电路的特性</h3><p>共集极放大电路的开环增益恒等于1，因此在电路中常常作为缓冲器/跟随器使用。  </p><h2 id="完整的晶体管放大电路"><a href="#完整的晶体管放大电路" class="headerlink" title="完整的晶体管放大电路"></a>完整的晶体管放大电路</h2><p>上述的电路分析都是基于小信号模型，在小信号模型中只考虑的交流信号所带来的影响。现在回到大信号模型，同时考虑输入信号的直流分量。此时电路需要在晶体管的三极各设置一个耦合电容以隔绝直流的影响，其余部分保持不变。电路的特性和增益等交流分析的结论仍然适用。  </p><h3 id="完整的放大电路结构"><a href="#完整的放大电路结构" class="headerlink" title="完整的放大电路结构"></a>完整的放大电路结构</h3><ul><li>共发射极放大电路<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211128185514.png width=30%>  </li></ul><blockquote><p>图中发射极处的电容称为旁路电容（By-pass Capacitor）其作用是在高频交流信号输入时将与其并联的电阻短路。</p></blockquote><ul><li><p>共基极放大电路<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211128191118.png width=30%>  </p></li><li><p>共集极放大电路<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211128192601.png width=30%>  </p></li></ul><h3 id="放大电路的频率响应"><a href="#放大电路的频率响应" class="headerlink" title="放大电路的频率响应"></a>放大电路的频率响应</h3><p>由于完整的放大电路中存在电容，当输入的电压信号频率较低时，这些电容的容抗无法在电路分析中忽略，因此放大电路的增益在输入信号为低频信号时有所损失。<br>下图表示了晶体管放大电路的频率响应特性曲线：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211201134850.png width=80%></p><blockquote><p>集成放大器中（比如第10讲的多级放大电路）不存在电容，因此其性能不会受到输入信号中低频分量的影响。但是高频时晶体管内部的类似电容的表现特性也会使得其性能在高频时存在损失。  </p></blockquote><p>在低频输入下，电路中电容不再视为短路。整个电路的低频截止频率$f_L$可以是电路中的每一个电容的截止频率的线性叠加：  </p><script type="math/tex; mode=display">f_L=\frac{1}{2π}∑_i\frac{1}{C_iR_{Ci}}</script><p>其中$R_{Ci}$为单看其中一个电容，其他电容视为短路时，电容电阻构成的滤波器电路中的等效电阻。  </p><blockquote><p>求电路的低频截止频率：  </p><ol><li>单看其中一个电容，剩下电容视为短路。  </li><li>画出等效的滤波器电路模型，找到等效电阻。  </li><li>所有的电容对应的等效电阻都被找到，求每个电容的截止频率，再线性叠加。  </li></ol></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">放大电路类型</th><th style="text-align:center">$R_{in}$</th><th style="text-align:center">$R_{o}$</th><th style="text-align:center">$A_v$</th><th style="text-align:center">$A_{vo}$</th><th style="text-align:left">特性</th></tr></thead><tbody><tr><td style="text-align:center">CE</td><td style="text-align:center">$r_π$ <br> 越大越好</td><td style="text-align:center">$R_C$ <br> 越小越好</td><td style="text-align:center">$-g_m\frac{r_π}{r_π+R_{sig}}R_C$</td><td style="text-align:center">$-g_mR_C$</td><td style="text-align:left">内部的输入和输出阻值都在几千欧姆<br>相比之下输入阻值较小。</td></tr><tr><td style="text-align:center">CB</td><td style="text-align:center">$r_e$</td><td style="text-align:center">$R_C$</td><td style="text-align:center">$α\frac{R_C}{R_{sig}+r_e}$</td><td style="text-align:center">$α$</td><td style="text-align:left">输入阻值过小<br>电压增益很小<br>开环增益独立</td></tr><tr><td style="text-align:center">CC</td><td style="text-align:center">$(r_e+R_L)(1+β)$</td><td style="text-align:center">$r_e$</td><td style="text-align:center">$\frac{(β+1)R_L}{(β+1)(r_e+R_L)+R_{sig}}$</td><td style="text-align:center">$1$</td><td style="text-align:left">开环增益恒等于1</td></tr></tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>电子系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>13. 数字带通系统的抗噪性分析</title>
    <link href="/2021/11/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/13.%20%E6%95%B0%E5%AD%97%E5%B8%A6%E9%80%9A%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8A%97%E5%99%AA%E6%80%A7%E5%88%86%E6%9E%90/"/>
    <url>/2021/11/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/13.%20%E6%95%B0%E5%AD%97%E5%B8%A6%E9%80%9A%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8A%97%E5%99%AA%E6%80%A7%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="数字带通系统的抗噪性分析"><a href="#数字带通系统的抗噪性分析" class="headerlink" title="数字带通系统的抗噪性分析"></a>数字带通系统的抗噪性分析</h1><h2 id="ASK的抗噪性分析"><a href="#ASK的抗噪性分析" class="headerlink" title="ASK的抗噪性分析"></a>ASK的抗噪性分析</h2><p>在调制端，输入信号可以由ASK信号和窄带高斯白噪声组成：  </p><script type="math/tex; mode=display">y_i(t)=u_i(t)+n_i(t)</script><p>其中:$u_i(t)=\begin{cases}<br>    acosω_ct,表示“1”\\<br>    0, 表示“0”<br>\end{cases}$<br>输入噪声可以通过正交分解表示为: $n_i(t)=n_c(t)cosω_ct-n_s(t)sinω_ct$。  </p><p>那么通过带通滤波器后的信号：  </p><script type="math/tex; mode=display">y(t)=\begin{cases}    [a+n_c(t)]cosω_ct-n_ssinω_ct,\text{ 表示“1”}\\    n_c(t)cosω_ct-n_s(t)sinω_ct,\text{ 表示“0”}\end{cases}</script><h3 id="相干调制的误码率分析"><a href="#相干调制的误码率分析" class="headerlink" title="相干调制的误码率分析"></a>相干调制的误码率分析</h3><p>在相干调制中，信号与载波信号相乘得到：  </p><script type="math/tex; mode=display">z(t)=y(t)cosω_ct=\begin{cases}    [a+n_c(t)]cos^2ω_ct-n_ssinω_ctcosω_ct,\text{ 表示“1”}\\    n_c(t)cos^2ω_ct-n_s(t)sinω_ctcosω_ct,\text{ 表示“0”}\end{cases}</script><p>其中，由于低通滤波器只允许低频分量和直流分量通过，在无线传输中，一般认为载波频率很高，因此含有$t$的所有项无法通过滤波器，最终得到：  </p><script type="math/tex; mode=display">x(t)=\begin{cases}    \frac{1}{2}[a+n_c(t)],\text{ 表示“1”}\\    \frac{1}{2}n_c(t),\text{ 表示“0”}\end{cases}</script><p>其中幅值$\frac{1}{2}$可以通过放大器消除。<br>同数字基带系统的抗噪性分析，计算码元为“0”时判别为“1”的概率和码元为“1”时判别为“0”的概率，得到在$P(0)=P(1)=0.5$时的误码率：  </p><script type="math/tex; mode=display">P_e=\frac{1}{2}erfc(\frac{\sqrt{SNR}}{2})</script><h3 id="非相干信号的误码率分析"><a href="#非相干信号的误码率分析" class="headerlink" title="非相干信号的误码率分析"></a>非相干信号的误码率分析</h3><p>通过带通滤波器的信号进行包络检波：  </p><script type="math/tex; mode=display">V(t)=\begin{cases}    \sqrt{([a+n_c(t)]^2+n_s^2(t))},\text{ 表示“1”}\\    \sqrt{(n_c^2(t)+n_s^2(t))}, \text{ 表示“0”}\\\end{cases}</script><p>通过计算得到：  </p><script type="math/tex; mode=display">P_e=\frac{1}{2}e^{-\frac{SNR}{4}}=\frac{1}{2}e^{-\frac{SNR}{4}}</script><h3 id="ASK信号的信噪比"><a href="#ASK信号的信噪比" class="headerlink" title="ASK信号的信噪比"></a>ASK信号的信噪比</h3><p>对于ASK信号，信噪比为：  </p><script type="math/tex; mode=display">SNR_{ASK}=\frac{\frac{a^2}{2}}{n_0B_{ASK}}=\frac{\frac{a^2}{2}}{2n_0B_s}</script><h2 id="FSK的抗噪性分析"><a href="#FSK的抗噪性分析" class="headerlink" title="FSK的抗噪性分析"></a>FSK的抗噪性分析</h2><h3 id="FSK信号的误码率"><a href="#FSK信号的误码率" class="headerlink" title="FSK信号的误码率"></a>FSK信号的误码率</h3><p>FSK信号的误码率可以表示为：<br>采用相干解调时：  </p><script type="math/tex; mode=display">P_e=\frac{1}{2}erfc(\sqrt{\frac{SNR_{FSK}}{2}})</script><p>采用非相干解调时：  </p><script type="math/tex; mode=display">P_e=\frac{1}{2}e^{-\frac{SNR_{FSK}}{2}}</script><h3 id="FSK信号的信噪比"><a href="#FSK信号的信噪比" class="headerlink" title="FSK信号的信噪比"></a>FSK信号的信噪比</h3><p>FSK信号的解调过程实际上是两路信号做ASK解调，因此：  </p><script type="math/tex; mode=display">SNR_{FSK}=\frac{\frac{a^2}{2}}{n_0B_{ASK}}=\frac{\frac{a^2}{2}}{2n_0B_{S}}</script><h2 id="PSK信号的抗噪性分析"><a href="#PSK信号的抗噪性分析" class="headerlink" title="PSK信号的抗噪性分析"></a>PSK信号的抗噪性分析</h2><h3 id="PSK信号的误码率"><a href="#PSK信号的误码率" class="headerlink" title="PSK信号的误码率"></a>PSK信号的误码率</h3><p>PSK信号的误码率可以表示为：<br>采用相干解调时：  </p><script type="math/tex; mode=display">P_e=\frac{1}{2}erfc(\sqrt{SNR_{PSK}})</script><p>采用差分解调时：  </p><script type="math/tex; mode=display">P_e=\frac{1}{2}e^{-SNR_{PSK}}</script><h3 id="PSK信号的信噪比"><a href="#PSK信号的信噪比" class="headerlink" title="PSK信号的信噪比"></a>PSK信号的信噪比</h3><p>PSK信号的信噪比和ASK信号相同：  </p><script type="math/tex; mode=display">SNR_{PSK}=\frac{\frac{a^2}{2}}{n_0B_{PSK}}=\frac{\frac{a^2}{2}}{2n_0B_{S}}</script><h2 id="ASK-FSK-PSK抗噪性比较"><a href="#ASK-FSK-PSK抗噪性比较" class="headerlink" title="ASK/FSK/PSK抗噪性比较"></a>ASK/FSK/PSK抗噪性比较</h2><p>通过公式得出ASK/FSK/PSK抗噪性、采用相干/非相干解调方法时的抗噪性曲线：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211127160641.png width=60%>  </p><p>可以从上图总结出如下结论：  </p><ol><li>抗噪性：<strong>PSK&gt;DPSK&gt;FSK&gt;ASK</strong></li><li>抗噪性： <strong>相干解调&gt;非相干解调</strong>  </li><li>系统的误码率下降时，系统的信噪比上升。  </li></ol><p>此外，ASK/PSK和DPSK的带宽相同，FSK的带宽大于前三者，因此FSK的频谱利用效率最低。  </p><h3 id="使用MATLAB©绘制ASK-FSK-PSK的BER-SNR曲线"><a href="#使用MATLAB©绘制ASK-FSK-PSK的BER-SNR曲线" class="headerlink" title="使用MATLAB©绘制ASK/FSK/PSK的BER-SNR曲线"></a>使用MATLAB©绘制ASK/FSK/PSK的BER-SNR曲线</h3><p>使用<code>linspace()</code>函数创建一个从-10到30的等差数列，公差为10，用于描述分贝表示的SNR：<code>r_dB = linspace(-10,10,30);</code>，然后将SNR转换为数值描述： <code>r = 10.^(r_dB/10);</code>。<br>在MATLAB中使用<code>erfc()</code>函数即可得到互补误差函数在特定点下的输出。那么ASK/PSK/DPSK/FSK在相干解调/非相干解调下的误码率可以表示为：<br><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs M">ask_co <span class="hljs-built_in">=</span> <span class="hljs-number">0.5</span>.*erfc(sqrt(r)/<span class="hljs-number">2</span>);<br>ask_no <span class="hljs-built_in">=</span> <span class="hljs-number">0.5</span>.*exp(-r/<span class="hljs-number">4</span>);<br>fsk_co <span class="hljs-built_in">=</span> <span class="hljs-number">0.5</span>.*erfc(sqrt(r/<span class="hljs-number">2</span>));<br>fsk_no <span class="hljs-built_in">=</span> <span class="hljs-number">0.5</span>.*exp(-r/<span class="hljs-number">2</span>);<br>psk_co <span class="hljs-built_in">=</span> <span class="hljs-number">0.5</span>.*erfc(sqrt(r));<br>dpsk <span class="hljs-built_in">=</span> <span class="hljs-number">0.5</span>.*exp(-r);<br></code></pre></td></tr></table></figure><br>使用函数<code>semilogy()</code>绘制出y轴以10的次方表示的折线图。<br>完整的例程如下：<br><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs M">r_dB <span class="hljs-built_in">=</span> linspace(-<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,<span class="hljs-number">30</span>); <span class="hljs-comment">%创建SNR</span><br>r <span class="hljs-built_in">=</span> <span class="hljs-number">10</span>.^(r_dB/<span class="hljs-number">10</span>); <span class="hljs-comment">%转换为数值描述</span><br><br><span class="hljs-comment">% 表示BER</span><br>ask_co <span class="hljs-built_in">=</span> <span class="hljs-number">0.5</span>.*erfc(sqrt(r)/<span class="hljs-number">2</span>);<br>ask_no <span class="hljs-built_in">=</span> <span class="hljs-number">0.5</span>.*exp(-r/<span class="hljs-number">4</span>);<br>fsk_co <span class="hljs-built_in">=</span> <span class="hljs-number">0.5</span>.*erfc(sqrt(r/<span class="hljs-number">2</span>));<br>fsk_no <span class="hljs-built_in">=</span> <span class="hljs-number">0.5</span>.*exp(-r/<span class="hljs-number">2</span>);<br>psk_co <span class="hljs-built_in">=</span> <span class="hljs-number">0.5</span>.*erfc(sqrt(r));<br>dpsk <span class="hljs-built_in">=</span> <span class="hljs-number">0.5</span>.*exp(-r);<br><br><span class="hljs-comment">% 绘图</span><br>semilogy(r_dB,ask_co,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;DisplayName&#x27;</span>,<span class="hljs-string">&#x27;ASK coherent demodulation&#x27;</span>)<br>hold on<br>semilogy(r_dB,ask_no,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;DisplayName&#x27;</span>,<span class="hljs-string">&#x27;ASK none-coherent demodulation&#x27;</span>)<br>semilogy(r_dB,fsk_no,<span class="hljs-string">&#x27;g&#x27;</span>,<span class="hljs-string">&#x27;DisplayName&#x27;</span>,<span class="hljs-string">&#x27;FSK none-coherent demodulation&#x27;</span>)<br>semilogy(r_dB,fsk_co,<span class="hljs-string">&#x27;w&#x27;</span>,<span class="hljs-string">&#x27;DisplayName&#x27;</span>,<span class="hljs-string">&#x27;FSK coherent demodulation&#x27;</span>)<br>semilogy(r_dB,psk_co,<span class="hljs-string">&#x27;k&#x27;</span>,<span class="hljs-string">&#x27;DisplayName&#x27;</span>,<span class="hljs-string">&#x27;PSK coherent demodulation&#x27;</span>)<br>semilogy(r_dB,dpsk,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;DisplayName&#x27;</span>,<span class="hljs-string">&#x27;DPSK differential demodulation&#x27;</span>)<br>xlabel(<span class="hljs-string">&#x27;SNR(dB)&#x27;</span>)<br>ylabel(<span class="hljs-string">&#x27;BER&#x27;</span>)<br>grid on<br>hold off<br></code></pre></td></tr></table></figure></p><h2 id="总结：ASK-FSK-PSK的参数性能"><a href="#总结：ASK-FSK-PSK的参数性能" class="headerlink" title="总结：ASK/FSK/PSK的参数性能"></a>总结：ASK/FSK/PSK的参数性能</h2><p>ASK是一种应用最早的基本调制方式。其优点是设备简单，频带利用率较高；缺点是抗噪声性能差，并且对信道特性变化敏感，不易是抽样判决器工作在最佳判决门限状态。<br>FSK是数字通信中不可或缺的一种调制方式。其优点是抗干扰能力较强，不受信道参数变化的影响，因此FSK特别适合应用于衰落信道；缺点是占用频带较宽，尤其是MFSK，频带利用率较低。目前，调频体制主要应用于中，低速数据传输与接入中。<br>PSK和DPSK是一种高传输效率的调制方式，其抗噪声能力比ASK和FSK都强，且不易受信道特性变化的影响，因此在高、中速数据传输中得到了广泛的应用。绝对相移（PSK）在相干解调时存在载波相位模糊的问题，在实际中很少采用于直接传输，MDPSK应用更为广泛。  </p><div class="table-container"><table><thead><tr><th style="text-align:center">调制方式</th><th style="text-align:center">受调信号的码型</th><th style="text-align:center">受调信号的带宽</th><th style="text-align:center">解调方法</th><th style="text-align:center">解调的最佳判决门限</th><th style="text-align:center">最大频谱利用效率</th><th style="text-align:center">误码率</th></tr></thead><tbody><tr><td style="text-align:center">ASK</td><td style="text-align:center">单极性码</td><td style="text-align:center">$2B_s$</td><td style="text-align:center">相干解调<br>包络检波法</td><td style="text-align:center">$\frac{a}{2}$</td><td style="text-align:center">$\frac{1}{2}$</td><td style="text-align:center">$\frac{1}{2}erfc(\frac{\sqrt{SNR}}{2})$<br> $\frac{1}{2}e^{-\frac{SNR}{4}}$</td></tr><tr><td style="text-align:center">FSK</td><td style="text-align:center">单极性码</td><td style="text-align:center">$\lvert f_1-f_2\rvert +2B_s$</td><td style="text-align:center">相干解调<br>包络检波法<br>过零检波法<br></td><td style="text-align:center">无<br>无<br>$\frac{a}{2}$</td><td style="text-align:center">$\frac{R_B}{\lvert f_1-f_2\rvert +2R_B}$</td><td style="text-align:center">$\frac{1}{2}erfc(\sqrt{\frac{SNR_{FSK}}{2}})$ <br> $\frac{1}{2}e^{-\frac{SNR_{FSK}}{2}}$</td></tr><tr><td style="text-align:center">PSK</td><td style="text-align:center">双极性码</td><td style="text-align:center">$2B_s$</td><td style="text-align:center">相干解调</td><td style="text-align:center">0</td><td style="text-align:center">$\frac{1}{2}$</td><td style="text-align:center">$\frac{1}{2}erfc(\sqrt{SNR_{PSK}})$</td></tr><tr><td style="text-align:center">DPSK</td><td style="text-align:center">双极性码</td><td style="text-align:center">$2B_s$</td><td style="text-align:center">相干解调<br>相位比较法</td><td style="text-align:center">0</td><td style="text-align:center">$\frac{1}{2}$</td><td style="text-align:center">$\frac{1}{2}e^{-SNR_{PSK}}$</td></tr></tbody></table></div><p>所有调制方法的信噪比均为： $SNR=\frac{\frac{a^2}{2}}{2n_0B_{S}}$。  </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>通信原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>09. 线性相位滤波器·FIR滤波器类型</title>
    <link href="/2021/11/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/9.%20%E7%BA%BF%E6%80%A7%E7%9B%B8%E4%BD%8D%E6%BB%A4%E6%B3%A2%E5%99%A8/"/>
    <url>/2021/11/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/9.%20%E7%BA%BF%E6%80%A7%E7%9B%B8%E4%BD%8D%E6%BB%A4%E6%B3%A2%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="线性相位滤波器·FIR滤波器类型"><a href="#线性相位滤波器·FIR滤波器类型" class="headerlink" title="线性相位滤波器·FIR滤波器类型"></a>线性相位滤波器·FIR滤波器类型</h1><blockquote><p>本节中需要格外注意公式的角标  </p></blockquote><h2 id="线性相位滤波器"><a href="#线性相位滤波器" class="headerlink" title="线性相位滤波器"></a>线性相位滤波器</h2><p>由于滤波器系统方程是一个复数函数方程，因此可以将滤波器系统方程表示为幅度和相位相乘的形式：  </p><script type="math/tex; mode=display">H(e^{jω})=|H(e^{jω})|e^{j∠H(e^{jω})}</script><p>其中$∠H(e^{jω})$是滤波器的相频响应(Phase Response)，$H_r(e^{jω})=|H(e^{jω})|$是滤波器的幅度值响应(Maganitude Response)，是幅度相应(Amplitude Response)的绝对值。<br>线性相位能保证信号通过系统后其中各频率成分的相对相位关系不改变，因此不容易出现在滤波器系统中因为发生码间串扰而信号失真。<br>线性相位滤波器的系统方程中，其相位可以表示为：  </p><script type="math/tex; mode=display">∠H(e^{jω})=β-αω,-π<ω<π</script><p><strong>在时域上，线性相位滤波器的冲激响应具有对称性或者反对称性</strong>：  </p><script type="math/tex; mode=display">h[n]=h[M-1-n],0≤n≤M-1</script><blockquote><p>例如：$h[n]=\{-1,2,0,2,-1\}$  </p></blockquote><script type="math/tex; mode=display">h[n]=-h[M-1-n],0≤n≤M-1</script><blockquote><p>例如：$h[n]=\{-1,2,0,-2,1\}$  </p></blockquote><p>由于线性相位系统不会改变信号相位，从而减小码间串扰的特点，在滤波器设计时基本都会保证滤波器是线性相位的。  </p><h2 id="FIR-滤波器的优点"><a href="#FIR-滤波器的优点" class="headerlink" title="FIR 滤波器的优点"></a>FIR 滤波器的优点</h2><p>FIR滤波器的系统方程可以由：  </p><script type="math/tex; mode=display">H(z)=∑_{n=N_1}^{N_2}h[n]z^{-n}</script><p>FIR 滤波器具有以下主要优点：</p><ul><li>它们可以具有精确的线性相位。</li><li>由于$∑_{k=N_1}^{N_2}|h[n]|&lt;∞$，它们始终稳定。</li><li>设计方法通常是线性的。</li><li>它们可以在硬件中高效实现。</li></ul><blockquote><p>FIR 滤波器的主要缺点是，要达到同样的性能水平，其所需阶数远高于 IIR 滤波器。相应地，这些滤波器的延迟通常比同等性能的 IIR 滤波器大得多。</p></blockquote><p>最重要的原因是FIR滤波器是线性相位滤波器，因此实际设计中，通常更倾向于设计FIR滤波器。  </p><h2 id="线性相位FIR滤波器的类型"><a href="#线性相位FIR滤波器的类型" class="headerlink" title="线性相位FIR滤波器的类型"></a>线性相位FIR滤波器的类型</h2><p>按照系统方程的冲激响应序列是对称/反对称的，以及整个序列的长度$M$的奇偶性，可以将线性相位的FIR滤波器分为四类。下面来求这四种系统类型的相频响应。  </p><h3 id="第一类：冲激响应对称、序列长度为奇数"><a href="#第一类：冲激响应对称、序列长度为奇数" class="headerlink" title="第一类：冲激响应对称、序列长度为奇数"></a>第一类：冲激响应对称、序列长度为奇数</h3><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211207150420.png width=40%>  </p><p>此时的冲激响应表示为：  </p><script type="math/tex; mode=display">h[n]=h[M-1-n],\frac{M-1}{2}\text{是整数。}</script><p>由于序列中以中间项为分割线，前一半序列和后一半序列完全相同。<br>那么系统的频率响应序列可以表示为：前一半序列的离散时间傅里叶变换的二倍与中间项的离散时间傅里叶变换之和：  </p><script type="math/tex; mode=display">\begin{aligned}    H(e^{jω})&=∑_{n=0}^{M-1}h(n)e^{-jωn}\\    &=∑_{n=0}^{(M-3)/2}h(n)e^{-jωn}+h(\frac{M-1}{2})e^{-j(M-1)ω/2}+∑_{n=(M+1)/2}^{M-1}h(n)e^{-jωn}\\\end{aligned}</script><p>对于每一个对称项，有：  </p><script type="math/tex; mode=display">h(0+n)e^{-jω(0+n)}+h(\frac{M-1}{2}-n)e^{-jω(\frac{M-1}{2}-n)}=2h(\frac{M-1}{2})cos(ωn)</script><p>令：$a[n]=2h[\frac{M-1}{2}-n]$，带入$a[n]$，得到：  </p><script type="math/tex; mode=display">H(e^{jω})=\left(∑_{n=0}^{(M-1)/2}a[n]cos(ωn)\right)e^{-jω(M-1)/2}</script><p>根据上述式子可以得到其相频响应为：  </p><script type="math/tex; mode=display">∠H(e^{jω})=-\frac{(M-1)ω}{2}</script><p>即$β=0$,$α=\frac{M-1}{2}$。  </p><h3 id="第二类：冲激响应对称、序列长度为偶数"><a href="#第二类：冲激响应对称、序列长度为偶数" class="headerlink" title="第二类：冲激响应对称、序列长度为偶数"></a>第二类：冲激响应对称、序列长度为偶数</h3><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211207151600.png width=40%>  </p><p>此时的冲激响应表示为：  </p><script type="math/tex; mode=display">h[n]=h[M-1-n],\frac{M-1}{2}\text{非整数。}</script><p>由于不存在中间项，相比于第一类，其系统方程中不存在中间项：  </p><script type="math/tex; mode=display">\begin{aligned}    H(e^{jω})&=∑_{n=0}^{M-1}h(n)e^{-jωn}\\    &=∑_{n=0}^{(M-2)/2}h(n)e^{-jωn}+∑_{n=M/2}^{M-1}h(n)e^{-jωn}\\\end{aligned}</script><p>将序列改写，并把相同项进行合并，注意前半部分和后半部分对应项的奇偶性正好相反：  </p><script type="math/tex; mode=display">b[n]=2h[\frac{M}{2}-n]</script><p>同理运用欧拉公式可得：  </p><script type="math/tex; mode=display">H(e^{jω})=\left(∑_{n=0}^{M/2}b[n]cos(ω(n-\frac{1}{2}))\right)e^{-jω(M-1)/2}</script><p>其相频响应为：  </p><script type="math/tex; mode=display">∠H(e^{jω})=-\frac{(M-1)ω}{2}</script><p>即$β=0$,$α=\frac{M-1}{2}$。  </p><h3 id="第三类：冲激响应反对称、序列长度为奇数"><a href="#第三类：冲激响应反对称、序列长度为奇数" class="headerlink" title="第三类：冲激响应反对称、序列长度为奇数"></a>第三类：冲激响应反对称、序列长度为奇数</h3><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211207152015.png width=40%>  </p><p>同理可得其系统方程的化简结果为：  </p><script type="math/tex; mode=display">H(e^{jω})=\left(\sum_{n=1}^{(M-1)/2}c[n]sin(ωn)\right)e^{j[\frac{π}{2}-\frac{ω(M-1)}{2}]}</script><script type="math/tex; mode=display">c[n]=2h[\frac{M-1}{2}-n]</script><p>其相频响应为：  </p><script type="math/tex; mode=display">∠H(e^{jω})=\frac{π}{2}-\frac{(M-1)ω}{2}</script><p>即$β=\frac{π}{2}$,$α=\frac{M-1}{2}$。  </p><h3 id="第四类：冲激响应反对称、序列长度为偶数"><a href="#第四类：冲激响应反对称、序列长度为偶数" class="headerlink" title="第四类：冲激响应反对称、序列长度为偶数"></a>第四类：冲激响应反对称、序列长度为偶数</h3><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211207151838.png width=40%>  </p><p>同理可得其系统方程的化简结果为：  </p><script type="math/tex; mode=display">H(e^{jω})=\left(\sum_{n=1}^{M/2}d[n]sin(ω(n-\frac{1}{2}))\right)e^{j[\frac{π}{2}-\frac{ω(M-1)}{2}]}</script><script type="math/tex; mode=display">d[n]=\frac{M-1}{2}</script><p>其相频响应为：  </p><script type="math/tex; mode=display">∠H(e^{jω})=\frac{π}{2}-\frac{(M-1)ω}{2}</script><p>即$β=\frac{π}{2}$,$α=\frac{M-1}{2}$。  </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>数字信号处理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>08. 数字滤波器的结构设计</title>
    <link href="/2021/11/25/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/8.%20%E6%95%B0%E5%AD%97%E6%BB%A4%E6%B3%A2%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/"/>
    <url>/2021/11/25/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/8.%20%E6%95%B0%E5%AD%97%E6%BB%A4%E6%B3%A2%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="数字滤波器的结构设计"><a href="#数字滤波器的结构设计" class="headerlink" title="数字滤波器的结构设计"></a>数字滤波器的结构设计</h1><p>数字滤波器设计的核心是通过给定的时域或频域系统方程，在时域设计出对应的滤波器。<br>数字系统的差分方程表示为：  </p><script type="math/tex; mode=display">∑_{k=0}^Na_ky[n-k]=∑_{k=0}^Mb_kx[n-k]</script><p>从中提取出$y[n]$，并简单变换后得到关于现态输出$y[n]$的差分方程：  </p><script type="math/tex; mode=display">y[n]=\frac{1}{a_0}(∑_{k=0}^Mb_kx[n-k]-∑_{k=1}^Na_ky[n-k]),a_0≠0</script><p>这个方程是数字滤波器设计的主要依据。<br>根据加法的性质，这个差分方程中求和运算中的内部和外部的各部分可以调换计算次序，进而根据计算过程中每个部分计算次序的先后、滤波器的结构也随之不同。  </p><h2 id="滤波器设计图的画法"><a href="#滤波器设计图的画法" class="headerlink" title="滤波器设计图的画法"></a>滤波器设计图的画法</h2><p>滤波器设计图的画法有两种：信号框图和信号流图。差分方程中的计算以加法、乘法、和时延为主，本小节也主要关注这两种画法中三种模块的表示方法。  </p><h3 id="信号框图"><a href="#信号框图" class="headerlink" title="信号框图"></a>信号框图</h3><p>信号框图中加法器、乘法器和延迟器的画法如下图所示：  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211125160512.png width=70%>  </p><h3 id="信号流图"><a href="#信号流图" class="headerlink" title="信号流图"></a>信号流图</h3><p>信号流图中加法器、乘法器和延迟器的画法如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211125160644.png width=70%>  </p><blockquote><p>需要注意的是，无论是信号流图还是信号框图，加法器只允许不超过两个的输入信号存在。  </p></blockquote><h2 id="FIR系统的物理结构类型"><a href="#FIR系统的物理结构类型" class="headerlink" title="FIR系统的物理结构类型"></a>FIR系统的物理结构类型</h2><p>FIR系统的差分方程由于不含有除了$y[n]$的其他含$y$项，因此FIR系统中没有反馈。FIR系统的差分方程可以写作：    </p><script type="math/tex; mode=display">y[n]=∑_{k=0}^Mb_kx[n-k]</script><p>FIR系统的冲激响应即为系统差分方程的系数：  </p><script type="math/tex; mode=display">h[n]=\begin{cases}    b_n,0≤n≤M\\    0,otherwise\\\end{cases}</script><p>FIR系统的物理结构可以分为直接型（Direct form）和级联型（Cascade form）两种。  </p><h3 id="直接型"><a href="#直接型" class="headerlink" title="直接型"></a>直接型</h3><p>将FIR系统的差分方程中的求和直接拆开，有：  </p><script type="math/tex; mode=display">y[n]=b_1x[n-1]+b_2x[n-2]+..+b_Mx[n-M]</script><p>替换系统的冲激响应：  </p><script type="math/tex; mode=display">y[n]=h[1]x[n-1]+h[x][n-2]+..+h[M]x[n-M]</script><p>系统的直接型结构为：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211125161657.png width=80%>  </p><p>如上图所示，在直接型结构中，$x[n]$分别做$M$次时延，每一次时延后的信号与对应系数相乘后，与前面的序列相加。  </p><h4 id="硬件消耗"><a href="#硬件消耗" class="headerlink" title="硬件消耗"></a>硬件消耗</h4><p>因此，直接型需要：  </p><ul><li>M个时延单元(也称为存储单元，用于存放之前的输入)</li><li>M+1个乘法单元</li><li>M个加法单元</li></ul><p>直接型虽然容易搭建，但是消耗器件较多。此外，由于加法器和延迟器都处于系统干路上，如果任何一个延迟器或者加法器出现故障，则整个滤波器系统将无法正常工作。  </p><h3 id="级联型"><a href="#级联型" class="headerlink" title="级联型"></a>级联型</h3><p>系统方程（z域）和系统的冲激响应之间存在如下关系：  </p><script type="math/tex; mode=display">H(z)=∑_{n=0}^Mh[n]z^{-n}</script><p>可以考虑构造若干个关于$z^{-n}$的多项式$(b_{0k}+b_{1k}z^{-1}+b_{2k}z^{-2})$，通过若干个多项式相乘构造$∑_{n=0}^Mh[n]z^{-n}$，即：  </p><script type="math/tex; mode=display">H(z)=∑_{n=}^Mh[n]z^{-n}=∏_{k=1}^{M_s}(b_{0k}+b_{1k}z^{-1}+b_{2k}z^{-2})</script><p>其中$M_s=[(M+1)/2]$,向下取整。$b_{1k}$表示第$k$个多项式的第1项系数，以此类推。<br>那么有Z域下系统输入输出关系为：  </p><script type="math/tex; mode=display">Y(z)=(b_{01}+b_{11}z^{-1}+b_{21}z^{-2})...(b_{0M_s}+b_{1M_s}z^{-1}+b_{2M_s}z^{-2})X(z)</script><p>回到时域，得到此时系统的差分方程为：  </p><script type="math/tex; mode=display">y[n]=(b_{01}x[n]+b_{11}x[n-1]+b_{21}x[n-2])*...*(b_{0M_s}x[n]+b_{1M_s}x[n-1]+b_{2M_s}x[n-2])</script><p>差分方程中卷积的实际意义是当前的节点（指某个卷积号）上携带此前所有节点的信息：<br>令$w_1[n]=b_{01}x[n]+b_{11}x[n-1]+b_{21}x[n-2]$为初始节点，有：  </p><script type="math/tex; mode=display">w_2=b_{02}w_1[n]+b_{12}w_1[n-1]+b_{22}w_1[n-2]</script><script type="math/tex; mode=display">w_3=b_{03}w_2[n]+b_{13}w_2[n-1]+b_{23}w_2[n-2]</script><script type="math/tex; mode=display">...</script><p>以此类推。<br>级联型结构如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211125170748.png width=80%></p><h4 id="硬件消耗-1"><a href="#硬件消耗-1" class="headerlink" title="硬件消耗"></a>硬件消耗</h4><p>在这个模块中，需要：  </p><ul><li>M个时延单元</li><li>$\frac{3}{2}M$个乘法单元</li><li>M个加法单元</li></ul><p>如果将$b_0k$做归一化处理，此时系统方程为：  </p><script type="math/tex; mode=display">y[n]=(1+b'_{01}x[n]+b'_{11}x[n-1]+b'_{21}x[n-2])*...*(1+b'_{0M_s}x[n]+b'_{1M_s}x[n-1]+b'_{2M_s}x[n-2])</script><p>那么每一个模块的第一项不再需要做乘法：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211125172005.png width=80%>  </p><p>乘法单元数将减少到M+1.  </p><p>该结构的优点是便于控制零点，缺点是所需系数较多，因此所需的乘法单元竖线较多。  </p><h2 id="IIR系统的物理结构类型"><a href="#IIR系统的物理结构类型" class="headerlink" title="IIR系统的物理结构类型"></a>IIR系统的物理结构类型</h2><p>描述IIR系统的差分方程可以表示为：  </p><script type="math/tex; mode=display">y[n]=∑_{k=0}^Mb_kx[n-k]+∑_{k=1}^Na_ky[n-k]</script><p>描述IIR系统的差分方程中除了$y[n]$外还有其他的含$y$项，即$y[n-m]$。因此IIR系统的物理结构中含有反馈信号。  </p><h3 id="直接型-直接型I"><a href="#直接型-直接型I" class="headerlink" title="直接型/直接型I"></a>直接型/直接型I</h3><p>描述IIR系统的差分方程在z域上可以表示为：  </p><script type="math/tex; mode=display">Y(z)=H(z)X(z)=(∑_{k=0}^Mb_kz^{-k})\frac{1}{1-∑_{k=1}^Na_kz^{-k}}X(z)</script><p>设$H_1(z)=∑_{k=0}^Mb_kz^{-k}$,$H_2=\frac{1}{1-∑_{k=1}^Na_kz^{-k}}$。<br>可以发现$H_1(z)$没有极点，是FIR系统，$H_2(z)$是IIR系统。<br>在直接型I中，$X(z)$首先与$H_1(z)$结合，有：  </p><script type="math/tex; mode=display">V(z)=H_1(z)X(z)</script><script type="math/tex; mode=display">Y(z)=V(z)H_2(z)</script><p>在时域中，直接型I将系统的差分方程分解为了两部分：  </p><script type="math/tex; mode=display">y[n]=v[n]+∑_{k=1}^Na_ky[n-k]</script><script type="math/tex; mode=display">v[n]=∑_{k=0}^Mb_kx[n-k]</script><blockquote><p>可以看出$y[n]$是IIR系统，$v[n]$是一个FIR系统。  </p></blockquote><p>直接型I的结构如下图所示，输入信号$x[n]$在通过若干个延迟器后的结果赋权相加，然后将此结果与输出信号$y[n]$的反馈信号通过若干个延迟器后的结果赋权相加，得到现态输出$y[n]$的结果。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211127131242.png width=50%>  </p><h4 id="硬件消耗-2"><a href="#硬件消耗-2" class="headerlink" title="硬件消耗"></a>硬件消耗</h4><p>直接型I需要：  </p><ul><li>M+N个加法单元</li><li>M+N+1个乘法单元</li><li>M+N+1个时延单元</li></ul><p>直接型I的优点是搭建简单，整个信号流图基本按照公式原本的样子即可搭建。缺点是所需要的硬件消耗较大。  </p><h3 id="标准型-直接型II"><a href="#标准型-直接型II" class="headerlink" title="标准型/直接型II"></a>标准型/直接型II</h3><p>由，</p><script type="math/tex; mode=display">Y(z)=H_1(z)H_2(z)X(z)=(∑_{k=0}^Mb_kz^{-k})\frac{1}{1-∑_{k=1}^Na_kz^{-k}}X(z)</script><p>在直接型II中，$X(z)$首先与$H_2(z)$结合：  </p><script type="math/tex; mode=display">W(z)=X(z)H_2(z)</script><script type="math/tex; mode=display">Y(z)=W(z)H_1(z)</script><p>即</p><script type="math/tex; mode=display">H(Z)=\frac{Y(Z)}{W(Z)}\frac{W(Z)}{X(Z)}</script><p>在时域中表示为：  </p><script type="math/tex; mode=display">w[n]=∑_{k=1}^Na_kw[n-k]+x[n]</script><script type="math/tex; mode=display">y[n]=∑_{k=0}^Mb_kw[n-k]</script><p>因此，虽然同直接型I，$x[n]$信号也是通过若干延迟器后赋权相加，但是此时的权重不再是$b_N$而应当为$a_N$。赋权后的信号进入另一组延迟器后赋权$b_N$相加。<br>下图表示了$M=N$时标准型II的结构：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211127134905.png width=70%>  </p><p>进一步化简，由于两组延迟器存储的内容都是$w[n-k]$，因此两路信号可以共用一组延迟器，进而大幅度减小延迟器的消耗：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211127135151.png width=70%>  </p><h4 id="硬件消耗-3"><a href="#硬件消耗-3" class="headerlink" title="硬件消耗"></a>硬件消耗</h4><p>直接型II需要：</p><ul><li>M+N个加法单元</li><li>M+N+1个乘法单元</li><li>max(M,N)个时延单元</li></ul><p>相比于直接型I，直接型II大幅度减少了时延单元的消耗。   </p><h3 id="级联型-1"><a href="#级联型-1" class="headerlink" title="级联型"></a>级联型</h3><p>IIR系统的级联型原理与FIR系统的级联型原理相同，都是在Z域内把一个多项式分解为多个多项式的乘积。</p><script type="math/tex; mode=display">H(z)=G∏_{k=1}^{N_s}\frac{1+b'_{1k}z^{-1}+b'_{2k}z^{-2}}{1-a'_{1k}z^{-1}-a'_{2k}z^{-2}}</script><p>其中$N_s=\frac{N+1}{2}$<br>但是IIR系统中每一个二级多项式单元$\frac{1+b’_{1k}z^{-1}+b’_{2k}z^{-2}}{1-a’_{1k}z^{-1}-a’_{2k}z^{-2}}$可以选择用直接型I或者直接型II实现，但是通常仍然选择使用直接型II以节省时延单元的使用个数。  </p><p>级联型的结构图如下所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211127141419.png width=70%></p><h4 id="硬件消耗-4"><a href="#硬件消耗-4" class="headerlink" title="硬件消耗"></a>硬件消耗</h4><p>当$M=N$时，级联型需要：  </p><ul><li>$4\frac{(N+1)}{2}$个加法单元</li><li>$4\frac{(N+1)}{2}+1$个乘法单元</li><li>$2N_s$个时延单元</li></ul><p>相比于直接型，级联型结构中每一个子系统单元都是独立运行的，因此系统鲁棒性优于普通型。  </p><h3 id="并联型"><a href="#并联型" class="headerlink" title="并联型"></a>并联型</h3><p>由z域下系统频率响应可以通过提取常数改写为：  </p><script type="math/tex; mode=display">H(z)=∑_{k=0}^{N_p}C_kz^{-k}+∑_{k=1}^{N_s}\frac{e_{0k}+e_{1k}z^{-1}}{1-a_{1k}z^{-1}-a_{2k}z^{-2}}</script><p>其中$M≥N$时（即$H(z)$是假分数时）存在第一项，$C_k$为常数，$N_p=M-N$。$N_S=\frac{N+1}{2}$。<br>由于其后的求和符号，每一个二级多项式分式都可以独立计算，从而实现并行化。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211127143607.png width=60%>  </p><h4 id="硬件消耗-5"><a href="#硬件消耗-5" class="headerlink" title="硬件消耗"></a>硬件消耗</h4><p>当$M=N$时，级联型需要：  </p><ul><li>$4\frac{(N+1)}{2}$个加法单元</li><li>$3\frac{(N+1)}{2}+1$个乘法单元</li><li>$2N_s$个时延单元</li></ul><h2 id="FIR和IIR的物理结构类型的特点"><a href="#FIR和IIR的物理结构类型的特点" class="headerlink" title="FIR和IIR的物理结构类型的特点"></a>FIR和IIR的物理结构类型的特点</h2><ul><li>当$h[n]$是一个对称或者反对称序列时，直接型的计算复杂度可以被减少。  </li><li>级联型和并联型系统的鲁棒性高于直接型。  </li><li>相比于FIR滤波器，IIR滤波器对量化噪声更敏感。  </li><li>级联型和并联型系统中的每一个子系统的运行情况相比于直接型更容易被观察。  </li></ul><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211127150608.png width=80%></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>数字信号处理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>12. 数字带通系统的调制解调方法</title>
    <link href="/2021/11/18/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/12.%20%E6%95%B0%E5%AD%97%E5%B8%A6%E9%80%9A%E4%BF%A1%E5%8F%B7%E4%BC%A0%E8%BE%93/"/>
    <url>/2021/11/18/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/12.%20%E6%95%B0%E5%AD%97%E5%B8%A6%E9%80%9A%E4%BF%A1%E5%8F%B7%E4%BC%A0%E8%BE%93/</url>
    
    <content type="html"><![CDATA[<h1 id="数字带通系统的调制解调方法"><a href="#数字带通系统的调制解调方法" class="headerlink" title="数字带通系统的调制解调方法"></a>数字带通系统的调制解调方法</h1><h2 id="数字带通系统简述"><a href="#数字带通系统简述" class="headerlink" title="数字带通系统简述"></a>数字带通系统简述</h2><p>数字带通传输系统是将数字基带信号通过载波调制，进入信道，最后在发射端解调，然后通过抽样判决器还原数字信号的过程。数字带通系统主要应用于无线传输，其结构如下图所示。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211118084917.png width=60%>  </p><p>PCM信号在经过数字基带系统之后生成数字基带系统的输入信号$S(t)$，输入信号与载波$c(t)$相乘进行调制。在信道中，存在加性高斯白噪声$n(t)$。在接收端，经过带通滤波器后，噪声的频谱收到限制，转变为窄带噪声$n_R(t)$。信号进行相干解调或者非相干解调（包络检波法），通过低通滤波器过滤出高频分量，最后在抽样判决器处还原为数字信号$m(t)$。  </p><h2 id="2ASK"><a href="#2ASK" class="headerlink" title="2ASK"></a>2ASK</h2><p>2ASK(Binary amplitude shift keying)是一种针对数字信号的调幅方法。  </p><h3 id="调制方法"><a href="#调制方法" class="headerlink" title="调制方法"></a>调制方法</h3><p>进入调制模块的输入信号由两部分组成：周期方波脉冲信号$g(t-nT_s)$和需要传输的信息$a_n=\begin{cases}<br>    1,以概率P\\<br>    0,以概率1-P\\<br>\end{cases}$整个信号表达为：$S(t)=∑_na_ng(t-nT_s)$。<br>该信号与载波$cosω_ct$相乘，得到$S_{2ASK}(t)=[∑_na_ng(t-nT_s)]cosω_ct$，其等价表达为：  </p><script type="math/tex; mode=display">S_{2ASK}(t)=\begin{cases}    cosω_ct,以概率P\\    0,以概率1-P\\\end{cases}</script><h3 id="物理实现"><a href="#物理实现" class="headerlink" title="物理实现"></a>物理实现</h3><p>2ASK调制的实现有两种:  </p><ol><li>模拟调制，载波和信号通过乘法器实现。  </li><li>键控法：原来的数字信号作为数字开关的控制信号，控制数字开关的开闭时间。数字开关的两个输入信号一个接地，即零信号，另一个输入接入载波信号$cosω_0t$。在原信号为“1”的时刻，数字开关打开，输出载波波形，在原信号为“0”的时刻，数字开关关闭，不输出任何信号。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211118091332.png width=50%></li></ol><h3 id="波形分析和频谱分析"><a href="#波形分析和频谱分析" class="headerlink" title="波形分析和频谱分析"></a>波形分析和频谱分析</h3><p>整个调制过程的波形如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211118090537.png width=60%>  </p><p>波形中每一个码元中载波的数量$N_c$与载波周期与码元周期之比有关：  </p><script type="math/tex; mode=display">N_c=\frac{T_s}{T_c}=\frac{f_s}{R_B}</script><p>对$S(t)$和载波信号的功率时间表达做傅里叶变换后相乘，得到2ASK信号的频谱表达式：  </p><script type="math/tex; mode=display">P_{2ASK}(f)=\frac{T_S}{16}\{Sa^2[π(f+f_c)T_s]+Sa^2[(f-f_c)T_s]\}+\frac{1}{16}[δ(f+f_c)+δ(f-f_c)]</script><p>其中：  </p><ul><li>$\frac{T_S}{16}\{Sa^2[π(f+f_c)T_s]+Sa^2[(f-f_c)T_s]\}$:连续信号，根据$cosω_ct$的采样性质，2ASK的频谱实际上是$s(t)$的频谱频域左右侧各复制一次，且幅度减半之后的结果。  </li><li>$\frac{1}{16}[δ(f+f_c)+δ(f-f_c)]$：离散信号，用于提取定时脉冲。  </li></ul><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211118100000.png width=60%>  </p><p>由于$cosω_ct$的采样性质，同时观察频谱可以得到，2ASK的频谱带宽是基带信号带宽的2倍：  </p><script type="math/tex; mode=display">B_{2ASK}=2B_s</script><p>带宽利用效率为：  </p><script type="math/tex; mode=display">η=\frac{R_B}{B_{2ASK}}</script><p>当基带信号为不归零码、没有码间串扰、且基带系统中使用理想低通滤波器时：$B_s=2R_B=2f_s$。<br>此时带宽利用效率为$η=\frac{R_B}{B_{2ASK}}=0.5b/s.Hz$。  </p><h3 id="解调方法"><a href="#解调方法" class="headerlink" title="解调方法"></a>解调方法</h3><p>2ASK的解调可以有两种方法：相干解调和非相干解调（包络检波法）。<br>无论是何种解调方法，调制后的信号都要先通过带通滤波器以将高斯白噪声转换为窄带高斯白噪声，在解调模块末端，信号通过低通滤波器以除去高频分量，同时不损失原有的信息。低通滤波器的最小截止频率应当为基带信号的带宽$ω_m$（实际上往往采用1.5倍$ω_m$或者更高倍数）。  </p><h4 id="相干解调"><a href="#相干解调" class="headerlink" title="相干解调"></a>相干解调</h4><p>同模拟信号调幅的解调，在接收端信号与另个同频同相的载波信号$cosω_ct$相乘得到：  </p><script type="math/tex; mode=display">S(t)cos^2ω_ct=S(t)\frac{1}{2}(1+cos2ω_ct)</script><p>由上述式子可以发现：  </p><ol><li>在与相干波形相乘后，原信号的极性被移除。  </li><li>相乘后的波形由直流分量和时变波形两部分组成。  </li></ol><p>因此，使用低通滤波器只保留直流分量，最终通过抽样判决器输出数字信号。<br>抽样判决器的最佳判决门限应该为$\frac{a}{2}$。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211122205046.png width=50%>  </p><h4 id="非相干解调（包络检波法）"><a href="#非相干解调（包络检波法）" class="headerlink" title="非相干解调（包络检波法）"></a>非相干解调（包络检波法）</h4><p>另一种去除信号极性的方式是使用全波整流器输出信号的绝对值波形，然后使用低通滤波器过滤高频分量，最终通过抽样判决器输出数字信号。  </p><blockquote><p>注意在模拟信号的解调中，包络检波法不需要全波整流器去除极性，注意区分。  </p></blockquote><p>非相干解调过程如图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211122205159.png width=50%></p><p>由于非相干解调中信号没有与余弦函数相乘获得余弦函数的平方，因此非相干解调输出的幅度值应当为相干解调输出信号的2倍。</p><div class="note note-info">            <p>由于多径传播会造成波形的振荡，影响电磁波的幅度。因此在实际通信中不会使用ASK。</p>          </div><h2 id="FSK"><a href="#FSK" class="headerlink" title="FSK"></a>FSK</h2><h3 id="调制方法-1"><a href="#调制方法-1" class="headerlink" title="调制方法"></a>调制方法</h3><p>FSK使用两个不同频率的载波$cos(ω_1t)$、$cos(ω_2t)$来表示数字信号“1”和“0”。<br>假设原信号以$a_n$表示（表达式和之前的相同），$\overline{a_n}$表示其取反后的数字信号，那么原信号经过调制后的波形表示为：  </p><script type="math/tex; mode=display">S_{FSK}=[∑_na_ng(t-nT_s)]cos(ω_1t)+[∑_n\overline{a_n}g(t-nT_s)]cos(ω_2t)</script><p>从上式可以看出FSK其实是两个频率不同的ASK信号的叠加。  </p><h3 id="物理实现-1"><a href="#物理实现-1" class="headerlink" title="物理实现"></a>物理实现</h3><p>FSK调制的实现有两种:  </p><ol><li><p>模拟调制：两个波形完全相反的信号各通过模拟调制乘上不同频率的载波后相加。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211122210724.png width=50%>  </p></li><li><p>键控法：原信号作为一个数字开关的控制信号的同时，其反相信号作为另一个数字开关的控制信号，两个数字开关在打开时分别输出$cosω_1t$与$cosω_2t$的波形。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211122211148.png width=50%>  </p></li></ol><h3 id="波形和频谱分析"><a href="#波形和频谱分析" class="headerlink" title="波形和频谱分析"></a>波形和频谱分析</h3><p>整个调制过程的波形如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211122211340.png width=50%>  </p><p>其频谱函数表达为：  </p><script type="math/tex; mode=display">P_{2FSK}(f)=\frac{T_s}{16}[Sa^2[π(f+f_1)T_s]+Sa^2[π(f-f_1)T_s]+Sa^2[π(f+f_2)T_s]+Sa^2[π(f-f_2)T_s]]+\frac{1}{16}[δ(f+f_1)+δ(f-f_1)+δ(f+f_2)+δ(f-f_2)]</script><p>其中：  </p><ul><li>$Sa^2[π(f+f_1)T_s]+Sa^2[π(f-f_1)T_s]$：以$f_1$为中心的连续谱分量，根据$cosω_ct$的采样性质, 其带宽为$B_s$。</li><li>$Sa^2[π(f+f_2)T_s]+Sa^2[π(f-f_2)T_s]$：以$f_2$为中心的连续谱分量,其带宽为$B_s$。</li><li>$δ(f+f_1)+δ(f-f_1)$：以$f_1$为中心的冲激分量</li><li>$δ(f+f_2)+δ(f-f_2)$：以$f_2$为中心的冲激分量</li></ul><p>可以发现，受调信号的频谱与$f_1$和$f_2$的大小有关,当且仅当$|f_2-f_1|≥2f_s$时，两个连续谱分量能够完全分离。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211122212634.png width=50%><br>受调信号的带宽表示为：  </p><script type="math/tex; mode=display">B_{2FSK}=2B_S+|f_2-f_1|</script><h3 id="解调方法-1"><a href="#解调方法-1" class="headerlink" title="解调方法"></a>解调方法</h3><h4 id="相干解调-1"><a href="#相干解调-1" class="headerlink" title="相干解调"></a>相干解调</h4><p>在接收端，FSK信号$S_{2FSK}(t)$分为两路，各通过一个带通滤波器，只过滤出$f_1$或者$f_2$的频谱分量，每一路信号在通过带通滤波器之后与对应的同频同向的载波信号相乘去除极性，通过低通滤波器过滤掉高频分量后，送入抽样判决器进行判决。<br>只有在$f_1$和$f_2$的连续谱分量完全分离时，带通滤波器才能准确提取出对应频率的分量，因此相干解调只适用于$|f_1-f_2|≥2f_s$的情况。<br>抽样判决器的判决标准是两路信号在同一个码元周期$T_s$内的电平大小进行比较，哪路信号的电平高，则数字信号的值就为这一路所代表的逻辑值。因此，相干解调不需要设置判决门限。  </p><blockquote><p>虽然对2FSK信号仍然可以通过带通滤波器提取其中一个频率的连续谱分量，使用ASK的解调方式进行解调。但是在M-FSK（即进制数不再为二进制时）信号的解调中无法单独使用某一路信号来还原全部数字信号，因此这种方法并不通用。  </p></blockquote><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211123130813.png width=70%>  </p><h4 id="非相干解调（包络检波法）-1"><a href="#非相干解调（包络检波法）-1" class="headerlink" title="非相干解调（包络检波法）"></a>非相干解调（包络检波法）</h4><p>非相干解调的过程和相干解调基本相同，只不过每一路信号采用包络检波法取代与载波相乘。<br>由于仍然需要带通滤波器分别提取两路信号的频谱分量，因此非相干解调也只适用于$|f_1-f_2|≥2f_s$的情况。<br>抽样判决的过程和相干解调相同，也不需要设置判决门限。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211211202715.png width=50%></p><h4 id="过零检波法"><a href="#过零检波法" class="headerlink" title="过零检波法"></a>过零检波法</h4><p>非相干解调和相干解调都只适用于$|f_1-f_2|≥2f_s$的情况，而过零检波法没有这样的条件限制。<br>在波形图上波形过0的次数越多代表码元周期内的频率越高，过零检波法的基本思路是用码元周期内平均幅度的大小来表示频率的高低。<br>过零检波法的具体过程是：FSK信号首先通过限制幅度将正弦波转变为方波，方波通过微分器后变为脉冲信号，经过整流器去除极性后，再用宽脉冲发生器依据脉冲信号重新生成无极性的方波信号。  </p><blockquote><p>宽脉冲发生器的作用是扩大码元周期之间符号持续时间的差异，这个差异在信号通过低通滤波器后会转变成直流分量幅值的差异。  </p></blockquote><p>方波信号会通过低通滤波器，低通滤波器只会允许低频分量（在此看做只有直流分量可以通过）通过滤波器，在单个码元周期中，方波脉冲的个数越多，代表其平均幅度越大，根据直流分量代表波形中的平均幅度可知，其直流分量也会更大。因此原波形中高频的部分通过低通滤波器之后的直流分量更大，低频部分通过低通滤波器后的直流分量更小。  </p><blockquote><p>方波脉冲信号的直流分量：$\frac{1}{T_s}∑τ_iA_i,τ_i$为周期内第$i$个方波脉冲的持续时间。  </p></blockquote><p>最后信号通过抽样判决器，抽样判决器的最佳判决门限为$\frac{a}{2}$。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211123133627.png width=50%>  </p><h2 id="PSK"><a href="#PSK" class="headerlink" title="PSK"></a>PSK</h2><h3 id="调制方法-2"><a href="#调制方法-2" class="headerlink" title="调制方法"></a>调制方法</h3><p>PSK对数字信号的相位进行调制，其使用两个相位不同的载波（通常相位差为$π$）$Acosω_Ct$、$Acos(ω_ct+π)$来表达逻辑“1”和“0”。  </p><script type="math/tex; mode=display">S_{2PSK}=\begin{cases}   Acosω_Ct \text{ 表示"1"}\\   Acos(ω_Ct+π) \text{ 表示"0"}\end{cases}=\begin{cases}   Acosω_Ct \text{ 表示"1"}\\   -Acos(ω_Ct) \text{ 表示"0"}\end{cases}</script><p>从表达式上可以看出，PSK将原信息$a_n$由单极性码转变为双极性码：$a_n=\begin{cases}<br>   +1 \text{ 以概率P表示“1”}\\<br>   -1 \text{ 以概率P表示“0”}<br>\end{cases}$，再与载波相乘。因此可以将PSK看做是双极性码的ASK。  </p><h3 id="物理实现-2"><a href="#物理实现-2" class="headerlink" title="物理实现"></a>物理实现</h3><p>物理实现的方法有两种：  </p><ol><li>模拟调制：将单极性码通过码型变换模块转为双极性码，再与载波相乘。  </li><li>键控法：数字开关的两个输入端一个为$cosω_ct$，其通过相移模块相移$π$后成为数字开关的第二个输入信号，数字开关以$S(t)$作为控制信号。  </li></ol><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211125132110.png width=30%>  </p><h3 id="波形和频谱分析-1"><a href="#波形和频谱分析-1" class="headerlink" title="波形和频谱分析"></a>波形和频谱分析</h3><p>PSK信号的波形可以表示为：</p><script type="math/tex; mode=display">S_{2PSK}(t)=∑_na_ng(t-nT_s)cosω_ct</script><p>其中$a_n$是双极性码。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211125133034.png width=50%>  </p><p>PSK的功率谱表达式为：  </p><script type="math/tex; mode=display">P_{2PSK}(f)=\frac{T_s}{4}\{Sa^2[π(f+f_c)T_s]+Sa^2[π(f-f_c)T_s]\}</script><p>可以发现，PSK的功率谱表达式实则为ASK功率谱中的连续分量。由于$a_n$是双极性码，因此功率谱中不含有离散的冲激分量。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211125134908.png width=70%>  </p><p>PSK信号的带宽：  </p><script type="math/tex; mode=display">B_{2PSK}=2B_s</script><h3 id="解调方法-2"><a href="#解调方法-2" class="headerlink" title="解调方法"></a>解调方法</h3><h4 id="相干解调-2"><a href="#相干解调-2" class="headerlink" title="相干解调"></a>相干解调</h4><p>由于PSK信号通过全波整流器后各个码元周期内的信号完全相同，无法辨认“0”或“1”，因此PSK信号不能使用非相干解调，只能使用相干解调。<br>在相干解调中，PSK信号通过带通滤波器后和同频同向的载波相乘，表示“-1”的波形与载波相乘，得到的波形会完全在小于0的一侧，表示“1”的波形与载波相乘，得到的波形会完全在大于0的一侧。信号通过低通滤波器消除高频分量后送入抽样判决器进行判别。抽样判决器的最佳判决门限为0。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211125141819.png width=60%></p><h2 id="DPSK"><a href="#DPSK" class="headerlink" title="DPSK"></a>DPSK</h2><h3 id="调制方法-3"><a href="#调制方法-3" class="headerlink" title="调制方法"></a>调制方法</h3><p>传统的PSK在解调过程中需要依赖未调制载波$cosω_ct$的相位，如果载波相位发生反转，调制结果会随之发生反转，这种现象称为倒π现象。为了解决倒π现象，DPSK（相对相移键控）选择使用相对码来取代PSK中使用的绝对码，以使得解调结果不依赖$cosω_ct$的相位。<br>DPSK的具体做法是:假设$b_n$为$a_n$的差分码，有：</p><script type="math/tex; mode=display">b_n=a_n⊕b_{n-1}</script><p>即当前差分码$b_n$是前一个差分码$b_{n-1}$与当前绝对码$a_n$的模二加法（异或）结果。<br>再将差分码做PSK调制即可。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211125144556.png width=50%></p><h3 id="物理实现-3"><a href="#物理实现-3" class="headerlink" title="物理实现"></a>物理实现</h3><p>DPSK中差分和PSK调制的顺序可以倒换：  </p><ol><li>先求得码型的差分码$b_n$，再做PSK调制。  </li><li>先对码型做PSK调制，再将波形进行差分处理。<br>生成波形也同样可以采用键控和模拟调制两种方法。  </li></ol><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211125144704.png width=60%></p><h3 id="解调方法-3"><a href="#解调方法-3" class="headerlink" title="解调方法"></a>解调方法</h3><h4 id="相干解调-3"><a href="#相干解调-3" class="headerlink" title="相干解调"></a>相干解调</h4><p>同PSK相干解调</p><h4 id="非相干解调（相位比较法-差分相干解调）"><a href="#非相干解调（相位比较法-差分相干解调）" class="headerlink" title="非相干解调（相位比较法/差分相干解调）"></a>非相干解调（相位比较法/差分相干解调）</h4><p>除了使用同频同相的载波与DPSK信号相乘外，还可以使用延时一个码元周期的原DPSK信号与自身信号相乘，两者都能够达到“表示-1的波形与载波相乘，得到的波形会完全在小于0的一侧，表示1的波形与载波相乘，得到的波形会完全在大于0的一侧。”的效果。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211125145153.png width=50%>  </p><p>由于延迟模块比产生载波的振荡器价格更便宜，因此相位比较法在实际中的应用更为广泛。但是相位比较法的误码率高于相干解调。  </p><div class="table-container"><table><thead><tr><th style="text-align:center">调制方式</th><th style="text-align:center">受调信号的码型</th><th style="text-align:center">受调信号的带宽</th><th style="text-align:center">解调方法</th><th style="text-align:center">解调的最佳判决门限</th></tr></thead><tbody><tr><td style="text-align:center">ASK</td><td style="text-align:center">单极性码</td><td style="text-align:center">$2B_s$</td><td style="text-align:center">相干解调<br>包络检波法</td><td style="text-align:center">$\frac{a}{2}$</td></tr><tr><td style="text-align:center">FSK</td><td style="text-align:center">单极性码</td><td style="text-align:center">$\lvert f_1-f_2\rvert +2B_s$</td><td style="text-align:center">相干解调<br>包络检波法<br>过零检波法<br></td><td style="text-align:center">无<br>无<br>$\frac{a}{2}$</td></tr><tr><td style="text-align:center">PSK</td><td style="text-align:center">双极性码</td><td style="text-align:center">$2B_s$</td><td style="text-align:center">相干解调</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">DPSK</td><td style="text-align:center">双极性码</td><td style="text-align:center">$2B_s$</td><td style="text-align:center">相干解调<br>相位比较法</td><td style="text-align:center">0</td></tr></tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>通信原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>08. 晶体管的交流工作分析</title>
    <link href="/2021/11/13/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%AD%90%E7%B3%BB%E7%BB%9F/8.%20BJT%20models/"/>
    <url>/2021/11/13/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%AD%90%E7%B3%BB%E7%BB%9F/8.%20BJT%20models/</url>
    
    <content type="html"><![CDATA[<h1 id="晶体管的交流工作分析"><a href="#晶体管的交流工作分析" class="headerlink" title="晶体管的交流工作分析"></a>晶体管的交流工作分析</h1><h2 id="交流工作下的基极偏置"><a href="#交流工作下的基极偏置" class="headerlink" title="交流工作下的基极偏置"></a>交流工作下的基极偏置</h2><h3 id="耦合电容"><a href="#耦合电容" class="headerlink" title="耦合电容"></a>耦合电容</h3><p>在交流状态下工作的电容器称为耦合电容，耦合电容的特性可以用一句话总结：耦合电容会阻碍直流分量并允许交流分量通过，即“隔直流，通交流”。<br>根据电容的容抗计算公式：$X_c=\frac{1}{2πfc}$<br>当直流分量通过电容时，电容的容抗会非常的大，电容视为断路。<br>当交流分量通过电容时，如果频率非常的高，则电容视为短路。一般认为$X_c&lt;0.1R$（$R$为电路中的总电阻值）时，电容就视为短路。<br>在晶体管电路中，耦合电容的作用是阻止交流源电压源和输出电阻改变晶体管的静态工作点。</p><h3 id="基极偏置电路分析"><a href="#基极偏置电路分析" class="headerlink" title="基极偏置电路分析"></a>基极偏置电路分析</h3><p>交流下的基极偏置电路如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211113163113.png width=60%>  </p><p>电路特点：</p><ul><li>在输入端（基极）和输出端（集电极）各有一个耦合电容。   </li><li>输入电压（即基极处的电源）$v_{bb}$是一个交流信号，不含有直流分量。  </li><li>供电电压$V_{CC}$是一个直流信号，不含有交流分量。  </li></ul><p>当晶体管的基极和集电极存在耦合电容时，基极端的交流电源和输出端的输出电阻对晶体管的工作状态不会有任何的影响。<br>电路中所有的电流都可以分解为直流分量和交流分量两部分：  </p><script type="math/tex; mode=display">i_B=I_B+i_b</script><p><strong>晶体管只会改变电路中电流的直流分量，交流分量保持不变。</strong><br>因此，交流状态下的基极偏置<strong>只需要按照对应静态工作点计算出直流分量的值，在加上或减去交流分量即可。</strong>  </p><blockquote><p>需要注意的是由于$v_C=V_{CC}-i_CR_c$，因此$v_C$的波形与$i_C$应当是<strong>反相</strong>的。由于$i_C=βi_B$，因此$i_B$的波形与$i_C$<strong>同相</strong>。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211113162613.png width=50%>  </p></blockquote><p>同时，由于耦合电容的特性，输出端的耦合电容会将直流分量完全去除，<strong>最终在输出电阻$R_L$上的电压/电流没有直流分量</strong>。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211113162834.png width=60%>  </p><h2 id="大信号模型"><a href="#大信号模型" class="headerlink" title="大信号模型"></a>大信号模型</h2><p>晶体管的大小信号模型针对基极的输入电压含有直流分量和交流分量时的电路进行分析。基极输入电压信号幅值较大时的电路分析模型称为大信号模型。<br>在大信号模型下，$v_{BE}$与$i_C$是非线性关系，两者之间满足：  </p><script type="math/tex; mode=display">i_C=I_Se^{\frac{v_{BE}}{V_T}}</script><p>其中$I_S$是$I_C$的饱和电流，$V_T$是晶体管在CB两点间存在温差而出现的电位差（热电压），在室温下约为25.9mV。<br>根据上述关系，可以将集电极的等效二极管近似看做是一个电压控制电流源，发射极的等效二极管保持不变：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211113164129.png width=30%>  </p><p>同时，希望在CE出导出输出电压，得到一个电压放大器（小的输出电压$v_{BE}$放大为$v_{CE}$），因此在集电极处加入一个电阻$R_C$。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211113164622.png width=30%>  </p><p>那么，在大信号模型电路中输出电压$v_{CE}$与输入电压$v_{BE}$的关系如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211113164828.png width=50%>  </p><p>在大信号模型下，$v_{BE}$很容易超出放大模式区域，进入饱和工作状态，导致电路出现非线性失真。  </p><h2 id="小信号模型"><a href="#小信号模型" class="headerlink" title="小信号模型"></a>小信号模型</h2><p>基极输入电压的$v_{BE}$比较小，正好处于放大模式下时电路分析模型称为小信号模型。在小信号模型中，可以近似将$v_{BE}$与$v_{CE}$的关系视为线性，即将整个晶体管的工作状态视作直流工作状态。<br>小信号模型可以看做是大信号模型在放大模式下的表现。  </p><h3 id="电压变换特性"><a href="#电压变换特性" class="headerlink" title="电压变换特性"></a>电压变换特性</h3><p>输入电压$v_{BE}$必须控制在一个小电压范围内，才能使晶体管的工作状态处于放大模式。在放大模式下：</p><script type="math/tex; mode=display">\begin{aligned}v_{CE}=&V_{CC}-R_Ci_C\\    =&V_{CC}-R_CI_Se^{\frac{v_{BE}}{V_T}}\end{aligned}</script><p>通过上述公式可知，$v_{CE}$的波形与$v_{BE}$<strong>反相</strong>。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211113165310.png width=50%>  </p><p>当$v_{BE}=V_{BE}$时，说明输入电压仅含直流分量，此时晶体管处于静态工作点。在该点对其求斜率得到（等效电压放大器的）直流电压增益：  </p><script type="math/tex; mode=display">A_v=\frac{dv_{CE}}{dv_{BE}}|_{v_{BE}=V_{BE}}</script><p>带入$i_C$的表达式，有：  </p><script type="math/tex; mode=display">A_v=-\frac{I_C}{V_T}R_C=-\frac{V_{CC}-V_{CE}}{V_T}</script><p>可以发现，在放大模式下，$V_{CE}$越低，直流电压增益越大。  </p><h3 id="小信号模型的电流分析"><a href="#小信号模型的电流分析" class="headerlink" title="小信号模型的电流分析"></a>小信号模型的电流分析</h3><p>在小信号模型下，如果将$v_{BE}$视为输入信号、$i_C$视为输出信号，那么放大的结果是将小电压放大为大电流，这样的放大器称为跨导放大器。<br>那么对输出$i_C$引入输入$v_{BE}$进行分析：<br>由于小信号模型是大信号模型的一部分，因此$i_C$的导出式不变：  </p><script type="math/tex; mode=display">i_c=I_Se^{\frac{v_{BE}}{V_T}}</script><p>带入$v_{BE}=V_{BE}+v_{be}$</p><script type="math/tex; mode=display">\begin{aligned}    i_c&=I_Se^{\frac{V_{BE}+v_{be}}{V_T}}\\    &=I_Se^{\frac{V_{BE}}{V_T}}e^{\frac{v_{be}}{V_T}}\end{aligned}</script><p>根据$I_C=I_Se^{\frac{V_{BE}}{V_T}}$，有：  </p><script type="math/tex; mode=display">i_c=I_Ce^{\frac{v_{be}}{V_T}}</script><p>根据泰勒展开式，有：  </p><script type="math/tex; mode=display">i_c=I_C(1+∑_k(\frac{v_{be}}{V_T})^k\frac{1}{k!})</script><p>根据小信号模型的条件，$v_{be}$应当很小，$b_{be}&lt;&lt;V_T$，此时泰勒展开式的高阶项可以全部被忽略，有：  </p><script type="math/tex; mode=display">i_C≈I_C(1+\frac{v_{be}}{V_T})</script><p>带入$i_C=I_C+i_c$:  </p><script type="math/tex; mode=display">i_C=\frac{I_C}{V_T}v_{be}</script><h4 id="跨导"><a href="#跨导" class="headerlink" title="跨导"></a>跨导</h4><p>定义$g_m$为跨导（Transconductance）：  </p><script type="math/tex; mode=display">g_m=\frac{I_C}{V_T}</script><blockquote><p>$g_m$是电流和电压之比，本质上是电导。  </p></blockquote><p>有：  </p><script type="math/tex; mode=display">i_C=g_mv_{be}</script><p>跨导也是$i_C-v_{BE}$图中当$i_C=I_C$时的斜率：  </p><script type="math/tex; mode=display">g_m=\frac{di_C}{dv_{BE}}|_{i_C=I_C}</script><p>带回$A_v$，可以得到</p><script type="math/tex; mode=display">A_V=\frac{v_{CE}}{v_{BE}}=-g_mR_e</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211114115547.png width=40%>  </p><h3 id="小信号模型中的直流分量和交流分量"><a href="#小信号模型中的直流分量和交流分量" class="headerlink" title="小信号模型中的直流分量和交流分量"></a>小信号模型中的直流分量和交流分量</h3><p>由于小信号模型满足线性条件，因此电路中的直流分量和交流分量可以完全独立分别计算，然后将计算直流分量的结果与计算交流分量的结果相加。<br>小信号模型中，<strong>直流分量的作用是确定晶体管所处的静态工作点。</strong><br>交流分量的作用是携带信息，因此在小信号模型中更关注交流分量的变化。  </p><h3 id="小信号模型的交流参数"><a href="#小信号模型的交流参数" class="headerlink" title="小信号模型的交流参数"></a>小信号模型的交流参数</h3><p>小信号模型中直流分量的来源为集电极供电$V_{CC}$和基极供电$V_{BE}$，令它们为0（接地）后进行交流分量的等效模型分析。  </p><h4 id="基极电流"><a href="#基极电流" class="headerlink" title="基极电流"></a>基极电流</h4><p>由$i_B=\frac{1}{β}i_C,i_C=g_mv_{be}$:  </p><script type="math/tex; mode=display">i_B=\frac{I_C}{β}+\frac{g_m}{β}v_{be}</script><script type="math/tex; mode=display">i_b=\frac{g_m}{β}v_{be}</script><h4 id="输入阻抗"><a href="#输入阻抗" class="headerlink" title="输入阻抗"></a>输入阻抗</h4><p>定义输入阻抗为输入端电压与电流之比。<br>当发射极接地，信号从基极输入时：</p><script type="math/tex; mode=display">r_π=\frac{v_{be}}{i_b}</script><p>带入$v_{be}$和$i_b$，得到：  </p><script type="math/tex; mode=display">r_π=\frac{V_T}{I_B}=\frac{β}{g_m}</script><p>当基极接地，信号从发射极输入时：  </p><script type="math/tex; mode=display">r_e=\frac{v_{be}}{i_e}</script><p>带入$v_{be}$和$αi_e=i_c$，得到：  </p><script type="math/tex; mode=display">r_e=\frac{V_T}{I_E}=\frac{α}{g_m}</script><p>可以发现输入阻抗$r_π$或$r_e$都不含有交流分量，是一个等效电阻。  </p><h4 id="厄利效应"><a href="#厄利效应" class="headerlink" title="厄利效应"></a>厄利效应</h4><p>厄利效应/基区宽度调制效应(Early Effect)，是指晶体管的$V_{CE}$改变，基极－集电极耗尽层宽度也会跟着改变。集电极电压升高，会使基极层变窄，使集电区或晶体管的输出电流增大。特性曲线中电压较大时的切线进行反向外推，其延长线与电压轴相交，在电压轴上截得的负截距称为厄利电压。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211114123021.png width=50%>  </p><p><strong>厄利效应可以等效为一个横跨在$CE$两极、与输出电阻$R_C$并联的电阻。</strong>  </p><script type="math/tex; mode=display">r_o=\frac{V_A}{I_C}</script><h3 id="等效小信号模型"><a href="#等效小信号模型" class="headerlink" title="等效小信号模型"></a>等效小信号模型</h3><h4 id="π模型"><a href="#π模型" class="headerlink" title="π模型"></a>π模型</h4><p><strong>当发射极接地时，信号从基极输入。</strong><br>通过对交流参数的分析，由$r_π=\frac{v_{be}}{i_b}$，可以将基极等效为一个阻值为$r_π$的电阻。而由：$i_C=g_mv_{be}=βi_b$发射极等效为一个电流控制电压源或者$i_b$的电流控制电流源，得到π模型。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211114121839.png width=70%><br>考虑厄利效应，有：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211114123326.png width=70%>  </p><h4 id="T模型"><a href="#T模型" class="headerlink" title="T模型"></a>T模型</h4><p><strong>当基极接地时，信号从发射极输入。</strong><br>由$r_e=\frac{v_{be}}{i_e}$，可以将发射极等效为一个阻值为$r_e$的电阻。<br>由$i_C=g_mv_{be}=αi_e$可以将发射极等效为一个电流控制电压源或者$i_e$的电流控制电流源，得到T模型。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211114124640.png width=50%><br>考虑厄利效应：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211114124920.png width=50%>  </p><p><strong>当E极在等效后没有电阻时，使用π模型进行分析。在等效后有电阻时，使用T模型进行分析。</strong>  </p><h4 id="电阻投射定理-Resistance-Reflection-Rule"><a href="#电阻投射定理-Resistance-Reflection-Rule" class="headerlink" title="电阻投射定理(Resistance Reflection Rule)"></a>电阻投射定理(Resistance Reflection Rule)</h4><p>T模型中发射极的电阻可以通过投射定理与π模型中基极的电阻相互转换。<br>由于：</p><script type="math/tex; mode=display">r_π=r_e(β+1)</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211128160204.png width=50%>  </p><p>因此，发射极的所有电阻值可以乘上$β+1$转为基极的输入电阻的阻值。  </p><script type="math/tex; mode=display">R_B=(β+1)R_E</script><p>应用该定理可以更加灵活地判断电路中放大电路部分输入电阻的阻值。  </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>电子系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>11. 数字基带系统的抗噪性分析</title>
    <link href="/2021/11/12/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/11.%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    <url>/2021/11/12/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/11.%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="数字基带系统的抗噪性分析"><a href="#数字基带系统的抗噪性分析" class="headerlink" title="数字基带系统的抗噪性分析"></a>数字基带系统的抗噪性分析</h1><h2 id="抽样判决器"><a href="#抽样判决器" class="headerlink" title="抽样判决器"></a>抽样判决器</h2><p>在接收端，设通过接收端滤波器的信号为$x(t)$，它由传输信息$s(t)$和窄带高斯白噪声$n_R(t)$两部分构成。接下来，信号$x(t)$将通过抽样判决器，抽样判决器以$f_s$的抽样频率对其进行抽样，并对每一个抽样结果进行判断，决定抽样结果为数字逻辑“1”还是逻辑“0”。抽样判决器的工作原理可以表示为：  </p><script type="math/tex; mode=display">m'(kT_s)=\begin{cases}   1, x(kT_s)>V_d\\   0,x(kT_s)<V_d\end{cases}</script><p>$V_d$称为判决阈值。  </p><h2 id="误码率"><a href="#误码率" class="headerlink" title="误码率"></a>误码率</h2><p>数字基带系统在抽样判决器处的判决错误是产生误码率的重要原因，误码率$P_e$可以表示为两个条件概率之和：  </p><script type="math/tex; mode=display">P_e=P(0)P(\frac{1}{0})+P(1)P(\frac{0}{1})</script><p>$P(0)P(\frac{1}{0})$:原本的电平为0，误判为1的概率。<br>$P(1)P(\frac{0}{1})$：原本的电平为1，误判为0的概率。  </p><p>抽样判决器判决错误的主要原因是$x(t)$中包含的窄带高斯白噪声$n_R(t)$对判决结果产生了影响。<br>设$n_R(t)$的方差为$σ_n^2$、均值为0，则其概率密度函数为：  </p><script type="math/tex; mode=display">f(n)=\frac{1}{√(2π)σ_n}e^{-\frac{n^2}{2σ_n^2}}</script><p>并假设$s(t)$在为逻辑“0”的时刻电平为0，在为逻辑“1”的时刻电平对应其幅值$A$，那么$x(kT_s)$可以表示为：  </p><script type="math/tex; mode=display">x(kT_s)=\begin{cases}    A+n_R(kT_s),logic-1\\    n_R(kT_s),logic-0\end{cases}</script><p>那么，在发送逻辑“0”的时刻，$x(kT_s)$只包含$n_R(t)$，发送“0”的概率密度函数为：  </p><script type="math/tex; mode=display">f_0(x)=\frac{1}{√(2π)σ_n}e^{-\frac{n^2}{2σ_n^2}}</script><p>当$x(kT_s)$的值大于$V_d$时，抽样判决器将原本为0的电平$x(kT_s)$误判为1，该概率可以表示为：  </p><script type="math/tex; mode=display">P_{e0}=∫_{V_d}^∞f_0(x)dx=∫_{V_d}^∞\frac{1}{√(2π)σ_n}e^{-\frac{n^2}{2σ_n^2}}dx</script><p>同理可以得到，当$x(kT_s)$的值小于$V_d$时原本抽样判决器原本为1的电平$x(kT_s)$误判为0，该概率可以表示为：  </p><script type="math/tex; mode=display">P_{e1}=∫_∞^{V_d}f_0(x)dx=∫_∞^{V_d}\frac{1}{√(2π)σ_n}e^{-\frac{n^2}{2σ_n^2}}dx</script><p>那么总的误码率就可以表示为：  </p><script type="math/tex; mode=display">P_e=P(0)P_{e0}+P(1)P_{e1}</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211112191352.png width=70%>  </p><p>图示中的涂色部分表示误码率的两个条件概率，可以发现，只有当$V_d=\frac{A}{2}$时，“额外的概率”（图中红色部分所示）才能被抵消为0，此时误码率最小，$V_d=\frac{A}{2}$称为优化阈值。<br>在优化阈值下重新计算误码率，可以得到：  </p><script type="math/tex; mode=display">P_e=\frac{1}{2}erfc(\frac{A}{2√2σ_n})</script><p>$A$与信号的功率有关，$σ_n$与噪声的功率有关。可以发现，在优化阈值下，<strong>影响误码率的唯一因素为信噪比。</strong><br>对于单极性信号，其平均功率为$S=\frac{A^2}{2}$，因此单极性信号的信噪比为：  </p><script type="math/tex; mode=display">SNR_u=\frac{A^2}{2σ^2}</script><p>此时误码率为：  </p><script type="math/tex; mode=display">P_e=\frac{1}{2}erfc(\frac{√SNR_u}{2})</script><p>对于双极性信号，其平均功率为$S={A^2}$，因此双极性信号的信噪比为：  </p><script type="math/tex; mode=display">SNR_b=\frac{A^2}{σ^2}</script><p>此时误码率为：  </p><script type="math/tex; mode=display">P_e=\frac{1}{2}erfc(√{\frac{SNR_b}{2}})</script><p>比较两者的误码率，可以发现双极性信号的误码率总是优于单极性信号的误码率。  </p><h2 id="眼图"><a href="#眼图" class="headerlink" title="眼图"></a>眼图</h2><p>眼图是一种能够表现数字基带系统噪声和码间串扰的图像，它由示波器的余晖效应使得若干个$T_s$内的波形在示波器屏幕上叠加得到。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211113102645.png width=30%><br>直观通过眼图判断系统抗噪性的指标为：</p><ol><li>眼图是否清晰<ul><li>系统的信噪比越高，眼图越清晰。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211113103039.png width=50%></li></ul></li><li>“眼睛”的开闭程度<ul><li>系统的滚降系数越大，“眼睛”张开程度越大。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211113103137.png width=50%>  </li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>通信原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>10. 无码间串扰的数字基带传输系统</title>
    <link href="/2021/11/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/10.%20%E7%A0%81%E9%97%B4%E4%B8%B2%E6%89%B0/"/>
    <url>/2021/11/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/10.%20%E7%A0%81%E9%97%B4%E4%B8%B2%E6%89%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="无码间串扰的数字基带传输系统"><a href="#无码间串扰的数字基带传输系统" class="headerlink" title="无码间串扰的数字基带传输系统"></a>无码间串扰的数字基带传输系统</h1><h2 id="码间串扰的产生"><a href="#码间串扰的产生" class="headerlink" title="码间串扰的产生"></a>码间串扰的产生</h2><p>由于系统的带宽有限，单个字符信号的脉冲发生了失真，使得波形发生延展、含有拖尾，波形延展到其他码元时间间隔中时，会对其他字符的抽样产生干扰，称为码间串扰。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211109115908.png width=60%><br>码间串扰与系统的带宽有关，系统的带宽越小，字符脉冲的拖尾就会越长越严重，发生码间串扰的可能性越大。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211109120140.png width=80%>  </p><h3 id="码间串扰的数学分析"><a href="#码间串扰的数学分析" class="headerlink" title="码间串扰的数学分析"></a>码间串扰的数学分析</h3><p>数字信号$d(t)=∑a(b)δ(t-nT)$通过信道和接受滤波器后表示为：  </p><script type="math/tex; mode=display">y(t)=d(t)*h(t)+n_R(t)=∑a_nh(t-nT_s)+n_R(t)</script><p>其中$n_R(t)$表示窄带噪声。<br>经过采样周期为$T_s$的采样后：  </p><script type="math/tex; mode=display">y(kT_s+t_0)=∑a_nh(kT_s+t_0-nT_s)+n_R(kT_s+t_0)+a_kh(t_0)</script><p>其中：<br>$a_kh(t_0)$是第$k$个字符采样后波形的主瓣。<br>$a_nh(kT_s+t_0-nT_s)$是采样后波形的拖尾。<br>$n_R(kT_s+t_0)$是采样后的窄带噪声。<br>可以发现，要想消除码间串扰，就要让采样后的波形中不含有$a_nh(kT_s+t_0-nT_s)$一项，即系统的时域方程满足下列等式：  </p><script type="math/tex; mode=display">h(kT_s)=\begin{cases}    Const, k=0 \\    0, k≠0 \text{  除了采样时刻，其余时间波形的采样值为0}\end{cases}</script><p>有两种方式可以使得系统波形满足$a_nh(kT_s+t_0-nT_s)=0$：  </p><ol><li>系统波形正好在$t_0+T_s$时戛然而止  </li><li>系统波形虽然有拖尾，但是拖尾在每一个$t_0+kT_S,k≠0$的时刻为0。  </li></ol><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211109133725.png width=80%>  </p><p>方案1无法在现实的电路中完成，因此现实中基本采用方法2来设计无码间串扰的系统。<br>下面推导符合上述条件的系统方程$H(ω)$：<br>根据傅里叶反变换：$h(kT_s)=\frac{1}{2π}∫H(ω)e^{jωkT_s}dω$<br>由于一个采样周期只有一个字符被抽样，因此修改积分上限，提取出一个抽样周期内的频谱函数(称为剪切)：  </p><script type="math/tex; mode=display">h(kT_s)=\frac{1}{2π}∑_i∫_{(2i-1)π/T_s}^{(2i+1)π/T_s}H(ω)e^{jωkT_s}dω</script><p>令$ω’=ω-\frac{2iπ}{T}$（称为时移）,  </p><script type="math/tex; mode=display">\begin{aligned}    h(kT_s)&=\frac{1}{2π}∑_i∫_{-π/T_s}^{π/T_s}H(ω'+\frac{2iπ}{T})e^{jω'kT_s}e^{2πikj}dω'\\    &=\frac{1}{2π}∑_i∫_{-π/T_s}^{π/T_s}H(ω'+\frac{2iπ}{T})e^{jω'kT_s}dω'\\    &=\frac{1}{2π}∫_{-π/T_s}^{π/T_s}∑_iH(ω'+\frac{2iπ}{T})e^{jω'kT_s}dω'\end{aligned}</script><p>剪切、时移、叠加的物理意义如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211109150814.png width=70%></p><p>那么就得到了$H(ω)$的等效替代式子：  </p><script type="math/tex; mode=display">H_{eq}(ω)=∑_iH(ω'+\frac{2iπ}{T}),|ω|≤\frac{π}{T_s}</script><p>$H_{eq}(ω)$的物理意义是将切断的各部分平移到$|ω|≤\frac{π}{T_s}$内对应叠加求和，简称切断叠加。<br>那么将该式子带入$h(kT_s)$需要满足的条件中，得到频域中，系统方程等价为：  </p><script type="math/tex; mode=display">H(ω)=\begin{cases}    ∑H(ω+\frac{2πi}{T_s})=T_s, |ω|≤\frac{π}{T_s} \\    0, |ω|>\frac{π}{T_s} \text{  除了采样时刻，其余时间波形的采样值为0}\end{cases}</script><p>即，<strong>当且仅当系统的等效频谱在为一个在$±\frac{π}{T_s}$上的门函数时，这个系统可以满足没有码间串扰，该定律称为奈奎斯特第一定律。</strong>  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211109143853.png width=20%>  </p><h3 id="导出结论"><a href="#导出结论" class="headerlink" title="导出结论"></a>导出结论</h3><ul><li>满足奈奎斯特第一定律时，频谱图的带宽称为奈奎斯特带宽$B_N$,$B_N=\frac{1}{2T_s}Hz$。  </li><li>奈奎斯特间隔为：$T_s=\frac{1}{2B_N}$。  </li><li>当采样周期为奈奎斯特间隔的整数倍（$T_s=\frac{Const}{2B_N}$）时，可以使得每次采样时信号拖尾的采样值都为0，系统无码间串扰。对应的数据传输速率为：$R_B=\frac{1}{nT_s}$。  </li><li>系统支持的最大的传输速率为$R_{B|max}=\frac{1}{T_s}=2B_N$，当且仅当： <script type="math/tex; mode=display">\frac{R_{B|max}}{R_B}=Const</script>时，系统无码间串扰。  </li><li>由频谱利用率$η=\frac{R_B}{B}$，系统最大的频谱利用率为$η=\frac{2B_N}{B_n}=2$。</li></ul><h2 id="无码间串扰系统"><a href="#无码间串扰系统" class="headerlink" title="无码间串扰系统"></a>无码间串扰系统</h2><p>在频域中，要想使得系统频谱图为一个门函数，有两种方法：  </p><ol><li>理想低通滤波器</li><li>滚降滤波器</li><li>部分响应系统</li></ol><h3 id="理想低通滤波器"><a href="#理想低通滤波器" class="headerlink" title="理想低通滤波器"></a>理想低通滤波器</h3><p>理想低通滤波器的频谱正好是一个门函数：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211112173008.png width=60%>  </p><p>但是，可以从理想低通滤波器系统的频谱和波形图看出：理想低通滤波器有边界陡峭、难以实现、且时域中Sa函数收敛较慢的特点，因此考虑采用其他方法模拟等效理想低通滤波器的频谱。  </p><h3 id="滚降滤波器"><a href="#滚降滤波器" class="headerlink" title="滚降滤波器"></a>滚降滤波器</h3><p>滚降滤波器的基本思路是在理想低通滤波器频谱后加入一段奇对称的频谱，使得被剪切、时移、叠加后的等效频谱中奇对称的一半正好可以填充另一半，得到一个门函数的频谱，这种方法称为滚降。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211109153130.png width=30%><br>常常被选用的奇函数为反比例函数和升余弦函数（即余弦函数+常数）：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211109153809.png width=50%>  </p><p>设奇对称信号的带宽为$B_2$,那么滚降后的系统带宽为$B_N+B_2$。<br>滚降滤波器的系统方程可以表示为：</p><script type="math/tex; mode=display">H(ω)=\begin{cases}    Const, 0≤ω≤B_N\\    f(ω), B_N≤ω≤B_N+B_2\\    0,ω≥B_N+B_2\end{cases}</script><blockquote><p>根据系统方程可以将滚降系统的频谱分为：非滚降区、滚降区和截止区。  </p></blockquote><p>定义滚降系数$α=\frac{B_2}{B_N}$，那么系统带宽又可以写作：  </p><script type="math/tex; mode=display">B=(1+α)B_N,0≤α≤1</script><p>频谱利用效率为:$η=\frac{2}{1+α}$<br>系统所支持的无码间串扰的最大速率为:$R_{B|max}=2B_N$<br>可以发现，$α$越大，系统带宽就越大，系统有效性下降，但是从频谱图上来看，$α$越大，系统波形拖尾越小，可靠性上升。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211109154450.png width=50%>  </p><h4 id="全滚降滤波器"><a href="#全滚降滤波器" class="headerlink" title="全滚降滤波器"></a>全滚降滤波器</h4><p>$α=1$时的滤波器称为全滚降滤波器，全滚降滤波器没有非滚降段，系统方程表示为：  </p><script type="math/tex; mode=display">H(ω)=\begin{cases}    f(ω), 0≤ω≤2B_N\\    0,ω≥2B_N\end{cases}</script><p>此时系统的带宽为$B=2B_N$。  </p><h3 id="部分响应系统"><a href="#部分响应系统" class="headerlink" title="部分响应系统*"></a>部分响应系统*</h3><p>滚降滤波器虽然可以解决理想低通滤波器在实际系统设计中无法应用的问题，但是其频谱效率只有$\frac{2}{1+α}$，不能达到理想低通滤波器$η=2$的效果。部分响应系统通过人为地引入码间串扰来改善这一问题。<br>部分响应系统的基本设想是使用两个波形相同，但是各自时移$\frac{T_s}{2}$的脉冲信号传输一个码元：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211112183659.png width=60%><br>虽然部分响应系统在每一个采样时刻都存在码间串扰，但是这个码间串扰仅由表达一个码元的相邻两个脉冲引起，这个特性使得在接收端可以消除码间串扰。  </p><div class="table-container"><table><thead><tr><th style="text-align:center">系统类型</th><th style="text-align:center">$R_{Bmax}$</th><th style="text-align:center">$B$</th><th style="text-align:center">$η$</th></tr></thead><tbody><tr><td style="text-align:center">理想低通滤波器</td><td style="text-align:center">$2B_N$</td><td style="text-align:center">$B_N$</td><td style="text-align:center">$2$</td></tr><tr><td style="text-align:center">滚降滤波器</td><td style="text-align:center">$2B_N$</td><td style="text-align:center">$(1+α)B_N$</td><td style="text-align:center">$\frac{2}{1+α}$</td></tr><tr><td style="text-align:center">全滚降滤波器</td><td style="text-align:center">$2B_N$</td><td style="text-align:center">$2B_N$</td><td style="text-align:center">$1$</td></tr><tr><td style="text-align:center">部分响应系统</td><td style="text-align:center">$2B_N$</td><td style="text-align:center">$B_N$</td><td style="text-align:center">$2$</td></tr></tbody></table></div><h2 id="时域均衡"><a href="#时域均衡" class="headerlink" title="时域均衡*"></a>时域均衡*</h2><p>由于信道是时变系统，信道总会使得信号产生码间串扰。解决这一问题的方法是在接收机与接收滤波器之间增加一个均衡器$E_x$，通过均衡使得波形满足奈奎斯特第一定律进而消除码间串扰。均衡的方式有两种：时域均衡和频域均衡。本课只介绍时域均衡。<br>时域均衡的基本思想是在$t+n,n≠0$的时刻对采样信号叠加一个完全相反的冲激信号以抵消原本在采样时刻存在的非零电平，迫使$x(t+nT_s)=0$。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211113104051.png width=70%>  </p><p>时域均衡器由若干个延迟器和自动调整权重的抽头以及相加器组成。延迟器的作用是确保获取$x(t)$在每一个$nT_s$上的抽样值，由自动调整权重的抽头赋予冲激信号一个与抽样值完全相反的权重、并与抽样值抵消，得到抽头信号。理论上，抽头信号只会在$x(t)$时有值。最后相加器将所有抽头信号相加，得到满足奈奎斯特第一定律的输出信号。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211113104527.png width=70%></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>通信原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>07. 数字滤波器·数字系统的表示</title>
    <link href="/2021/11/07/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/7.%20%E6%95%B0%E5%AD%97%E6%BB%A4%E6%B3%A2%E5%99%A8/"/>
    <url>/2021/11/07/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/7.%20%E6%95%B0%E5%AD%97%E6%BB%A4%E6%B3%A2%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="数字滤波器·数字系统的表示"><a href="#数字滤波器·数字系统的表示" class="headerlink" title="数字滤波器·数字系统的表示"></a>数字滤波器·数字系统的表示</h1><h2 id="数字系统的响应"><a href="#数字系统的响应" class="headerlink" title="数字系统的响应"></a>数字系统的响应</h2><p>数字滤波器是一种处理离散时间信号的系统。数字信号$x[n]$输入数字滤波器进行处理后生成输出信号$y[n]$。这个过程可以用卷积定理表示为：  </p><script type="math/tex; mode=display">y[n]=x[n]⊗h[n]=∑x[m]h[n-m] \tag{1}</script><p>$h[n]$是数字系统在时域上的表示，称为<strong>冲激响应</strong>，也是系统输入信号为冲激序列时系统的输出结果。<br>对(1)做离散时间傅里叶变换，可以得到：  </p><script type="math/tex; mode=display">Y(e^{jω})=X(e^{jω})H(e^{jω}) \tag{2}</script><p>$H(e^{jω})$是$h[n]$做离散时间傅里叶变换的结果，称为系统的<strong>频率响应</strong>。  </p><blockquote><p>可以发现(2)成立的条件中包含$h[n]$收敛的条件，如果$h[n]$不收敛，则不存在其离散时间傅里叶变换的结果$H(e^{jω})$。  </p></blockquote><h2 id="数字系统的表示"><a href="#数字系统的表示" class="headerlink" title="数字系统的表示"></a>数字系统的表示</h2><p>除了上述两个表达式可以描述一个特定的数字系统外，一个特定的数字系统还可以使用如下两种方法进行表达：差分方程和传递函数。<br>系统可以表示为线性常系数差分方程：    </p><script type="math/tex; mode=display">∑_{k=0}^Na_ky[n-k]=∑_{k=0}^Mb_kx[n-k],a_0≠0,b_0≠0</script><p>对上式做Z变换，两边相比，得到系统的传递函数：  </p><script type="math/tex; mode=display">H(z)=\frac{Y(z)}{X(z)}=\frac{∑_{k=0}^Mb_kz^{-k}}{∑_{k=0}^Na_kz^{-k}}</script><p>但是由于z变换成立的条件是要给出收敛域RoC，因此在未给出传递函数的前提下，其对应的差分方程可能有两个：</p><ul><li>右边序列：<script type="math/tex; mode=display">∑_{k=0}^Na_ky[n-k]=∑_{k=0}^Mb_kx[n-k]</script>此时数字系统是因果系统。  </li><li>左边序列:<script type="math/tex; mode=display">∑_{k=0}^Na_ky[n-k]=-∑_{k=-M}^{-1}b_kx[n+k]</script>此时数字系统是非因果系统。  </li></ul><h2 id="传递函数的特征"><a href="#传递函数的特征" class="headerlink" title="传递函数的特征"></a>传递函数的特征</h2><h3 id="与冲激响应"><a href="#与冲激响应" class="headerlink" title="与冲激响应"></a>与冲激响应</h3><p>系统传递函数可以写作两个多项式的比：  </p><script type="math/tex; mode=display">H(z)=\frac{b_0}{a_0}\frac{Π_{k=1}^M(1-c_kz^{-1})}{Π_{k=1}^N(1-b_kz^{-1})}</script><p>其中$M$对应差分方程右侧除去$x[n]$外含有$x$项的个数，$N$对应差分方程左侧除去$y[n]$外含有$y$项的个数，$c_k$表示零点，$d_k$表示极点。<br>化简上式得到如下结构：  </p><script type="math/tex; mode=display">H(z)=∑_{r=0}^{M-N}B_rZ^{-r}+∑_{k=1}^N\frac{A_k}{1-d_kz^{-1}}</script><p>对其做Z反变换：  </p><script type="math/tex; mode=display">h[n]=∑_{r=0}^{M-N}B_rδ[n-r]+∑_{k=1}^NA_k(d_k)^nu[n]</script><p>对上述反变换结果进行讨论：<br>当$N&gt;0$时，差分方程左边有除了$y[n]$的其他含$y$项$y[n-k]$，即此时系统方程当前输出由$x$项、系统以前的输出$y[n-k]$共同决定，系统含有反馈，此时系统方程为：  </p><script type="math/tex; mode=display">h[n]=∑_{r=0}^{M-N}B_rδ[n-r]+∑_{k=1}^NA_k(d_k)^nu[n]</script><p>由于$u[n]$是一个无限长度的序列，因此系统的冲激响应也是无限长度的，称这样的系统为无限冲激响应系统（IIR System）。<br>当$N=0$时，差分方程左边只含有$y[n]$，系统方程的当前输出只由输入$x$决定，系统不含有反馈，此时系统方程为：  </p><script type="math/tex; mode=display">h[n]=∑_{r=0}^{M}B_rδ[n-r]</script><p>由于$δ[n-r]$长度有限，整个系统的冲激响应的长度是有限的，称这样的系统为有限冲激响应系统（FIR System）。  </p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">N</th><th style="text-align:center">差分方程左侧</th><th style="text-align:center">有无反馈</th><th style="text-align:center">冲激响应长度</th></tr></thead><tbody><tr><td style="text-align:center">IIR</td><td style="text-align:center">N&gt;0</td><td style="text-align:center">含有$y[n-k]$</td><td style="text-align:center">有</td><td style="text-align:center">无限</td></tr><tr><td style="text-align:center">FIR</td><td style="text-align:center">N=0</td><td style="text-align:center">只有$y[n]$</td><td style="text-align:center">无</td><td style="text-align:center">有限</td></tr></tbody></table></div><h3 id="与频率响应"><a href="#与频率响应" class="headerlink" title="与频率响应"></a>与频率响应</h3><p>根据Z变换和离散时间傅里叶的定义式，可以推出：  </p><script type="math/tex; mode=display">H(e^{jω})=H(z)|_{z=exp(jω)}</script><p>因此系统的频率响应也可以写作多项式分式：  </p><script type="math/tex; mode=display">H(e^{jω})=\frac{b_0}{a_0}\frac{Π_{k=1}^M(1-c_ke^{-jω})}{Π_{k=1}^N(1-b_ke^{-jω})}</script><h4 id="使用MATLAB®绘制系统的频率响应"><a href="#使用MATLAB®绘制系统的频率响应" class="headerlink" title="使用MATLAB®绘制系统的频率响应"></a>使用MATLAB®绘制系统的频率响应</h4><p>在$[0,2\pi]$上生成若干个采样点，作为作图的$x$轴。<br>使用函数<code>fft()</code>可以生成指定序列的离散傅里叶变换结果。<code>abs()</code>函数能够给出指定序列在每个采样点上的绝对值，即幅度。<code>angle()</code>函数可以生成指定序列在每个采样点上的相位。<br>绘制其频率响应需要注意的是：  </p><ul><li>需要对$h[n]$进行周期延拓，方法是使用<code>zeros(1,L)</code>创建一个长度为L的全0向量用<code>x=[x,zeros(1,L)]</code>对其填充。  </li><li>使用<code>fft()</code>函数求其FFT结果。<code>abs()</code>求结果的绝对值得到幅频响应，<code>angle()</code>求FFT结果的相频响应。  </li><li>横轴应当为<code>[0:(N+L)]*2*pi/(N+L+1)</code>使得0-2π内每一格的长度为$\frac{2π}{N+L+1}$ （因为<code>0:(N+L)</code>有N+L+1个数）<br>下面的示例程序展示了如何绘制$h[n]=Sa(0.1(n-50)),0≤n≤100$的幅频和相频响应曲线：  <figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs M">N<span class="hljs-built_in">=</span><span class="hljs-number">100</span>; <span class="hljs-comment">%100点FFT</span><br>n<span class="hljs-built_in">=</span><span class="hljs-number">0</span>:N;<br>x<span class="hljs-built_in">=</span>sinc(<span class="hljs-number">0.1</span>*(n-<span class="hljs-number">50</span>));<br>x<span class="hljs-built_in">=</span>[x,zeros(<span class="hljs-number">1</span>,<span class="hljs-number">1000</span>)]; <span class="hljs-comment">%对x周期延拓到长度为1000</span><br>X<span class="hljs-built_in">=</span>fft(x); <span class="hljs-comment">%求其FFT/DFS结果（Amplitude Response）</span><br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br>w<span class="hljs-built_in">=</span>[<span class="hljs-number">0</span>:(N+<span class="hljs-number">1000</span>)]*<span class="hljs-number">2</span>*pi/(N+<span class="hljs-number">1001</span>);<span class="hljs-comment">%横轴，每一格表示2π/(N+1001)</span><br>plot(w./pi,abs(X));  <span class="hljs-comment">%取绝对值求幅频响应（Magnitude Response）并作π归一化</span><br>title(<span class="hljs-string">&#x27;Magnitude Response&#x27;</span>);<br>axis ([<span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">12</span>]);<br>xlabel(<span class="hljs-string">&#x27;\omega/\pi&#x27;</span>);<br>subplot(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>plot(w./pi,angle(X)); <span class="hljs-comment">% angle(X)表示求其相频响应</span><br>title(<span class="hljs-string">&#x27;Phase Response&#x27;</span>);<br>axis ([<span class="hljs-number">0</span> <span class="hljs-number">2</span> -<span class="hljs-number">4</span> <span class="hljs-number">4</span>]);<br>xlabel(<span class="hljs-string">&#x27;\omega/\pi&#x27;</span>);<br></code></pre></td></tr></table></figure>给定系统Z域下的传递函数$H(z)=\frac{∑b_kz^{-k}}{∑a_kz^{-k}}$时，可以使用<code>[H,w]=freqz(b,a,n)</code>返回其频率响应<code>H</code>和对应的π归一化的角频率横轴<code>w</code>，其中<code>a</code>是$∑a_kz^{-k}$由高次幂到低次幂排列时的系数向量，其中<code>b</code>是$∑b_kz^{-k}$由高次幂到低次幂排列时的系数向量，<code>n</code>为计算时所指定的N点FFT的点数，缺省值为512。<br>如下的例程中给出了如何绘制$H(z)=\frac{1-0.5z^{-1}}{1-2z^{-1}+z^{-2}}$的频率响应图：  <figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs m">b<span class="hljs-built_in">=</span>[<span class="hljs-number">1</span>,-<span class="hljs-number">0.5</span>];<br>a<span class="hljs-built_in">=</span>[<span class="hljs-number">1</span>,-<span class="hljs-number">2</span>,<span class="hljs-number">1</span>];<br>[H,w]<span class="hljs-built_in">=</span>freqz(b,a); <br>plot(w,abs(X));  <span class="hljs-comment">%取绝对值求幅频响应（Magnitude Response）</span><br>title(<span class="hljs-string">&#x27;Magnitude Response&#x27;</span>);<br>plot(w,angle(X)); <span class="hljs-comment">% angle(X)表示求其相频响应</span><br>title(<span class="hljs-string">&#x27;Phase Response&#x27;</span>);<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>数字信号处理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>09. 数字基带传输系统中信号的码型、波形和频谱</title>
    <link href="/2021/11/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/9.%20%E7%A0%81%E5%9E%8B%E5%92%8C%E6%B3%A2%E5%BD%A2%E5%88%86%E6%9E%90/"/>
    <url>/2021/11/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/9.%20%E7%A0%81%E5%9E%8B%E5%92%8C%E6%B3%A2%E5%BD%A2%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="数字基带传输系统中信号的码型、波形和频谱"><a href="#数字基带传输系统中信号的码型、波形和频谱" class="headerlink" title="数字基带传输系统中信号的码型、波形和频谱"></a>数字基带传输系统中信号的码型、波形和频谱</h1><h2 id="数字基带传输系统简述"><a href="#数字基带传输系统简述" class="headerlink" title="数字基带传输系统简述"></a>数字基带传输系统简述</h2><p>数字基带传输系统的模型如图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211105164556.png width=80%><br>经过脉冲编码调制的PCM编码成为数字信号(a)，通过脉冲形成器由单极性码变成双极性码(b)，并提供定时脉冲(f)。生成的双极性码信号通过发送端的低通滤波器过滤掉高频分量后，成为升余弦波形(c)。  </p><blockquote><p>由0/1组成的编码称为单极性码。单极性码含有直流分量，无法通过由逻辑门电路构成的判决器。双极性码含有负电平（逻辑中以-1表示）。  </p><p>定时脉冲是周期为$T_s$的冲激序列，目的是为了让接收端知道每个字符（0/1/-1）的持续时间和出现时间间隔。  </p></blockquote><p>数字基带传输系统的信道常采用线缆、明线。在信道中存在加性噪声，使信号发生失真等现象(d)。<br>发送的模拟信号在接收端通过低通滤波器过滤掉信道中的加性噪声(e)，在同步提取模块中提取出信号的定时脉冲(f)，接收信号和这个定时脉冲被送入抽样判决器：抽样判决器会在每一个定时脉冲时判断接收信号的电平大小对应数字信号的1还是0，抽样判决器生成信号如(g)所示。最终，接收信号被复原为数字信号(h)。<br>数字传输系统中各阶段的波形如图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211105164652.png width=60%>  </p><h2 id="码间串扰"><a href="#码间串扰" class="headerlink" title="码间串扰"></a>码间串扰</h2><p>通过上图可以看出，原来的PCM信号在传输过程中产生了失真，使得原有的两个字符信号发生重叠而无法被判决器识别，最终导致误码。这样的两个字符重叠而产生的干扰称为码间串扰（Inter Symbol Interferance, ISI）。如何减少传输过程中的码间串扰是数字通信中的一个重点问题。  </p><h2 id="信道编码的码型设计"><a href="#信道编码的码型设计" class="headerlink" title="信道编码的码型设计"></a>信道编码的码型设计</h2><h3 id="码型设计标准"><a href="#码型设计标准" class="headerlink" title="码型设计标准"></a>码型设计标准</h3><p>原始信息编码为方便基带数字信号传输系统传输的编码方式（称为码型）。通常认为，对码型的要求包含如下几点：  </p><ol><li>在编码阶段不能包含直流分量，且低频分量少。  </li><li>码型要便于提取出定时脉冲。  </li><li>具备纠错、检错能力。  </li><li>高频分量尽量少，以减小码间串扰。  </li><li>传输和变换设备简单，便于实现。  </li></ol><h3 id="码型选择"><a href="#码型选择" class="headerlink" title="码型选择"></a>码型选择</h3><p>根据有无极性和是否归零可以将可能的编码大致分成四类：单极性归零码、单极性不归零码、双极性归零码、双极性不归零码。其频域内频谱图如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211105194506.png width=80%>  </p><p>无直流分量在频域内的直接体现为0频时没有冲激信号，单极性不归零码(a)和单极性归零码(b)都存在直流分量，因此不适合用于传输。但是单极性归零码存在一个周期性的冲激序列，可以直接作为定时脉冲使用。<br>对双极性不归零码而言，不能直接提取定时脉冲，分离出定时脉冲的过程也比较复杂，因此不适用于传输。<br>对双极性归零码而言，虽然不能直接提取定时脉冲，但可以通过使用一个整流器转换为单极性归零码，从而提取出定时脉冲，且无直流分量，因此<strong>双极性归零码在数字基带传输中得到广泛应用</strong>。  </p><p>除了上述四类码型外，还有差分码，时钟脉冲和输入单极性数字信号做异或运算/模二加法，得到输入信号的差分码。<br>差分码在接收端收到的极性与发送端完全相反时，也能够正确的判决。在此不详述。  </p><h2 id="AMI码和HDB3编码"><a href="#AMI码和HDB3编码" class="headerlink" title="AMI码和HDB3编码"></a>AMI码和HDB<sub>3</sub>编码</h2><h3 id="AMI码"><a href="#AMI码" class="headerlink" title="AMI码"></a>AMI码</h3><p>AMI码是传号交替反转码的缩写，AMI码是一种双极不归零码，其编码规则如下：  </p><ul><li>消息编码中的0保持不变  </li><li>消息编码中的1在AMI码中为1或-1，1和-1交替出现  </li></ul><p>例如：<br>消息编码： 1.0.0.1.1.1<br>其AMI码： +1.0.0.-1.1.-1</p><p>因此AMI码可以通过交替出现的极性观察传输过程中是否出现误码。<br>但是，当消息编码中含有过长的连0信号时（如：0000000），会给定时脉冲的提取造成困难，为了改进AMI码在长0信号下的传输问题，HDB<sub>3</sub>码应运而生。  </p><h3 id="HDB3-码"><a href="#HDB3-码" class="headerlink" title="HDB3 码"></a>HDB<sub>3</sub> 码</h3><p>HDB<sub>3</sub>的编码规则基本和AMI码相同，但相比于AMI码，其规定在连续三个0信号出现时加入一个破坏脉冲V以防止过长0信号导致定时脉冲难以提取的问题。HDB<sub>3</sub>码的编码规则如下：  </p><ol><li>给定一个初始符号以指定消息编码中起始1的极性，使用AMI编码方式对消息进行编码。<strong>起始1的极性与初始符号的极性相反。</strong>  </li><li>当有连续4个0信号出现时，第四个0信号改为破坏脉冲V，对破坏脉冲的极性有如下规定：<br>i）V的极性交替反转（高优先级）<br>ii）破坏脉冲的极性与前一个“1”的极性相同（V视作1）  </li><li><strong>在V的极性不满足条件2时</strong>，连0信号的第一个0变为补性码B’，B’的极性与其后一个V的极性相同。<strong>B’后的1全部反转极性</strong>。  </li><li>V和B’保留极性，并替换为“1”。  </li></ol><p>例如：指定符号位为“+”：<br>消息编码：10000 0000 0000 0000 1<br>AMI编码： -10000 0000 0000 0000 1<br>加入破坏脉冲：-1000-V 000V 000-V 000V 1<br>加入补性码：-1000-V B’00V -B’00-V B’00V -1<br>HDB<sub>3</sub>编码： -1000-1 1001 -100-1 1001 -1  </p><p>HDB<sub>3</sub>在解码时只需要找到连0信号两端极性相同的部分，替换为0即可：<br>HDB<sub>3</sub>解码：-10000 0000 0000 0000 -1  </p><h2 id="曼彻斯特码"><a href="#曼彻斯特码" class="headerlink" title="曼彻斯特码"></a>曼彻斯特码</h2><h3 id="曼彻斯特码-双向码"><a href="#曼彻斯特码-双向码" class="headerlink" title="曼彻斯特码/双向码"></a>曼彻斯特码/双向码</h3><p>曼彻斯特码是一种双极性不归零码，其01编码为脉冲信号的上升沿和下降沿，巧妙地解决了长连0信号由于电平不发生变化而导致的定时脉冲提取困难的问题。其编码规则为：<br>脉冲波形在同步脉冲间隔周期50%时：  </p><ul><li>脉冲上升沿表示逻辑1  </li><li>脉冲下降沿表示逻辑0  </li></ul><p>例如：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211105205712.png width=70%><br>但是曼彻斯特码在极性发生反转时容易发生译码错误，为了解决这个问题，引入了差分码的概念。  </p><h3 id="差分曼彻斯特码"><a href="#差分曼彻斯特码" class="headerlink" title="差分曼彻斯特码"></a>差分曼彻斯特码</h3><p>差分曼彻斯特码的编码规则为：<br>脉冲间隔开始时：  </p><ul><li>脉冲电平不发生变化（无触发沿）表示逻辑1</li><li>脉冲电平发生变化（有触发沿）表示逻辑0</li></ul><p>例如：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211105210411.png width=70%>  </p><h2 id="基带波形的选择"><a href="#基带波形的选择" class="headerlink" title="基带波形的选择"></a>基带波形的选择</h2><p>除了考虑合适的码型外，还需要考虑使用什么形状的波形来表示选择的码型。<br>对波形的选择标准要求频谱图上的主瓣（即信号的有用带宽）后杂波的带宽越小越好，换言之，频谱函数收敛速度越快越好。<br>在方波脉冲、三角脉冲、升余弦脉冲中，升余弦脉冲的收敛速度最快，意味着杂波的带宽通常比较小，因此在数字基带通信中常选择升余弦脉冲作为基带波形。  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211105211419.png width=80%>  </p><h2 id="频谱分析"><a href="#频谱分析" class="headerlink" title="频谱分析"></a>频谱分析</h2><p>设脉冲信号$g_1(t-nT_s)$表示逻辑0，$g_2(t-nT_s)$表示逻辑1，假设随机脉冲序列在码元时间间隔$T_s$内逻辑1和0的出现是相互独立的，那么对任何一个数字信号$s(t)$都可以表示为：  </p><script type="math/tex; mode=display">s(t)=∑s_n(t)</script><p>其中:</p><script type="math/tex; mode=display">s_n(t)=\begin{cases}  g_1(t-nT_s),\text{概率为}P\\  g_2(t-nT_s),\text{概率为}1-P\\\end{cases}</script><p>$s(t)$的图示如下：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211109111353.png width=50%>  </p><p>由于任何波形都可以分解为两个波形的叠加，考虑要知道基带信号中是否存在可以提供频谱分量的周期同步信息，因此将$s(t)$分解为能够提取同步信息的周期波形$v(t)$和随机信号$u(t)$：  </p><script type="math/tex; mode=display">s(t)=v(t)+u(t)</script><p>经过数学运算可知，$v(t)$的功率谱表示为：  </p><script type="math/tex; mode=display">P_v(f)=∑|f_s[PG_1(mf_s)+(1-P)G_2(mf_s)]|^2δ(f-mf_s)</script><p>$u(t)$的功率谱表示为：  </p><script type="math/tex; mode=display">P_u(f)=f_sP(1-P)|G_1(f)-G_2(f)|^2</script><p>那么数字信号$s(t)$的频谱可以表示为：  </p><script type="math/tex; mode=display">\begin{aligned}  P_s(f)&=P_u(f)+P_v(f)\\  &=∑|f_s[PG_1(mf_s)+(1-P)G_2(mf_s)]|^2δ(f-mf_s)+f_sP(1-P)|G_1(f)-G_2(f)|^2\end{aligned}</script><p>化简为单边谱：  </p><script type="math/tex; mode=display">P_s(f)=2f_sP(1-P)|G_1(f)-G_2(f)|^2+f^2_s|PG_1(0)+(1-P)G_2(0)|^2δ(f)+2f_s^2∑|[PG_1(mf_s)+(1-P)G_2(mf_s)]|^2δ(f-mf_s)</script><p>可以发现这个单边谱公式由三部分组成：<br>$f^2_s|PG_1(0)+(1-P)G_2(0)|^2δ(f)$：在零频时的冲激信号，即信号的<strong>直流分量</strong>。<br>$2f_s^2∑|[PG_1(mf_s)+(1-P)G_2(mf_s)]|^2δ(f-mf_s)$：周期冲激序列，即可以提取用于同步的<strong>定时脉冲</strong>。<br>$2f_sP(1-P)|G_1(f)-G_2(f)|^2$:连续谱分量，由随机信号产生，极大地影响频谱效率。<br>下图表示了符号持续时间$τ$和对应频谱带宽的关系：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211109114653.png width=60%><br>可以发现，<strong>符号持续时间越长，占用带宽越小</strong>。  </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>通信原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>07. 晶体管的直流偏置状态</title>
    <link href="/2021/11/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%AD%90%E7%B3%BB%E7%BB%9F/7.%20BJT_Biasing/"/>
    <url>/2021/11/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%AD%90%E7%B3%BB%E7%BB%9F/7.%20BJT_Biasing/</url>
    
    <content type="html"><![CDATA[<h1 id="晶体管的直流偏置状态"><a href="#晶体管的直流偏置状态" class="headerlink" title="晶体管的直流偏置状态"></a>晶体管的直流偏置状态</h1><h2 id="晶体管的偏置类型"><a href="#晶体管的偏置类型" class="headerlink" title="晶体管的偏置类型"></a>晶体管的偏置类型</h2><p>BJT晶体管只有在直流工作状态下，才能作为放大器或者开关正常工作。在实际设计中，有两种方式来控制静态工作点（$I_C$和$V_{CE}$）的值：  </p><ul><li>基极偏置<br>在基极偏置下，保持$I_B$始终不变来设置$I_C$和$V_{CE}$的值。<br>基极偏置通常用于晶体管作为开关时。  </li><li>发射极偏置<br>在发射极偏置下，保持$I_E$始终不变来设置$I_C$和$V_{CE}$的值。<br>发射极偏置通常用于晶体管作为放大器时。  </li></ul><h2 id="基极偏置"><a href="#基极偏置" class="headerlink" title="基极偏置"></a>基极偏置</h2><p>基极偏置的电路图如图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211104153700.png width=50%>  </p><p>基极偏置下，发射极接地，基极接入一个直流电压$V_{BB}$。<strong>当$V_{BB}$和$R_B$固定时（这两个值已知），$I_B$固定。</strong><br>通过对基极环路和集电极环路应用基尔霍夫电流/电压定律计算出$I_C$和$V_{CE}$。  </p><script type="math/tex; mode=display">\begin{aligned}    I_B&=\frac{V_{BB}-V_{BE}}{R_B}\\    I_C&=βI_B\\    V_{CE}&=V_{CC}-I_CR_C\\\end{aligned}</script><p>可以发现这个计算过程中要用到电流增益$β$，因此静态工作点的选取和$β$有关。<br>由于静态工作点对$β$极为敏感，因此静态工作点很容易出现在饱和和截止区域，因此基极偏置通常用于晶体管作为开关时。  </p><blockquote><p>饱和状态下可以通过计算$I_{CSat}$反求$I_B$。  </p></blockquote><h2 id="反馈偏置"><a href="#反馈偏置" class="headerlink" title="反馈偏置*"></a>反馈偏置*</h2><p>由于电流增益$β$的大小与温度、器件本身等诸多因素有关，在电路设计时应当尽量避免$β$对电路的输出产生影响，导致不稳定的结果。反馈偏置就是一类利用负反馈对$β$变化而导致的静态工作点变化进行抑制的电路。  </p><h3 id="发射极反馈偏置"><a href="#发射极反馈偏置" class="headerlink" title="发射极反馈偏置"></a>发射极反馈偏置</h3><p>由于基极偏置的静态工作点对$β$极为敏感，考虑使用负反馈让$I_C$不会产生过多变化。发射极反馈偏置就是采用这样一种思路的电路，其结构如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211104192421.png width=30%>  </p><p>在这个电路中：<br>如果$I_C$增大，由$I_C≈I_E,V_E=I_ER_E$可知$V_E$会增大；<br>由$V_{BE}=V_{B}-V_E=0.7V$可知$V_B$增大；<br>由$V_B=V_{BB}-I_BR_B$可知$I_B$减小；<br>由$I_C=βI_B$可知$I_C$最终会减小。<br>反之亦然。<br>但是相比于静态工作点不随$β$发生任何变化的发射极偏置而言，$β$仍然对发射极反馈偏置存在影响：虽然存在负反馈限制$I_C$的变化，但是在实际过程中$I_C$的变化仍可能不满足设计需求，因此发射极反馈偏置电路不常用。  </p><h3 id="集电极反馈偏置"><a href="#集电极反馈偏置" class="headerlink" title="集电极反馈偏置"></a>集电极反馈偏置</h3><p>集电极反馈是另一种尝试负反馈来抑制$I_C$发生变化的电路，其结构如图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211104195052.png width=30%>  </p><p>在这个电路中：<br>如果$I_C$增大，由$V_C=V_{CC}-I_CR_C$可知$V_C$减小；<br>由$V_B=V_{BE}=V_{C}-I_BR_B=0.7V$可知$I_B$减小；<br>由$I_C=βI_B$可知$I_C$最终会减小。<br>反之亦然。<br>在实际应用中，由于比发射极反馈偏置电路图更简单，集电极反馈偏置的负反馈更容易抑制$I_C$的变化，但是也对$β$很敏感。  </p><h3 id="集电极-发射极反馈偏置"><a href="#集电极-发射极反馈偏置" class="headerlink" title="集电极-发射极反馈偏置*"></a>集电极-发射极反馈偏置*</h3><p>集电极-发射极反馈偏置试图综合上述两种反馈偏置的负反馈效果，来达到更好抑制效果的目的。但是事实上，集电极-发射极反馈偏置虽然优于前两者的反馈抑制效果，但是很难大规模生产，因此不常应用，其电路图如下图所示。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211104195335.png width=30%>  </p><h2 id="发射极偏置"><a href="#发射极偏置" class="headerlink" title="发射极偏置"></a>发射极偏置</h2><p>发射极偏置的电路如图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211104174419.png width=50%>  </p><p>发射极偏置下，发射极接入一个电阻$R_E$，在$V_{BB}$和$V_{BE}$的作用下，发射极产生一个发射极电流$I_E$。<strong>当给定$R_E$和$V_{BB}$时，$I_E$固定不发生变化</strong>。<br>通过对基极环路和集电极环路应用基尔霍夫电流/电压定律计算出$I_C$和$V_{CE}$。<br>在这种情况下：  </p><script type="math/tex; mode=display">\begin{aligned} I_E&=\frac{V_{BB}-V_{BE}}{R_E}\\I_E&≈I_C\\V_{CE}&=V_C-V_E\\&=V_{CC}-I_CR_C-I_ER_E\end{aligned}</script><p>可以发现，此处计算$I_C$时不会用到$β$，即静态工作点的选取与$β$无关。这种情况下的静态工作点较为稳定，处于放大区域内，因此发射极偏置常用于晶体管作为放大器时。  </p><h3 id="发射极偏置的变形"><a href="#发射极偏置的变形" class="headerlink" title="发射极偏置的变形"></a>发射极偏置的变形</h3><h4 id="分压偏置"><a href="#分压偏置" class="headerlink" title="分压偏置"></a>分压偏置</h4><p>分压偏置（Voltage Divider Bias，VDB）的电路图如图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211104185532.png width=30%>  </p><p>分压偏置其实是发射极偏置的改装：与发射极偏置的唯一不同点在于基极供电$V_{BB}$直接由$V_{CC}$和分压器提供：  </p><script type="math/tex; mode=display">V_{BB}=\frac{R_2}{R_1+R_2}V_{CC}</script><p>其余计算与分压偏置相同。  </p><h4 id="双电源发射极偏置"><a href="#双电源发射极偏置" class="headerlink" title="双电源发射极偏置"></a>双电源发射极偏置</h4><p>双电源发射极偏置（Two supply Emitter Bias，TSEB）结构如图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211104190922.png width=30%>  </p><p>在这种情况下，发射极有两个直流电压源$V_{BE}$和$V_{EE}$。由于<strong>基极连接电阻后直接接地，$I_B$非常小，可以认为$V_{B}=0$。</strong><br>因此对于发射极：  </p><script type="math/tex; mode=display">V_E=0-V_{BE}=-0.7V</script><script type="math/tex; mode=display">I_E=\frac{V_E-V_{EE}}{R_E}</script><p>其余计算同发射极偏置。  </p><div class="table-container"><table><thead><tr><th style="text-align:center">偏置类型</th><th style="text-align:center">恒定量</th><th style="text-align:center">电路特征</th><th style="text-align:center">静态工作点与$β$独立？</th></tr></thead><tbody><tr><td style="text-align:center">基极偏置</td><td style="text-align:center">$I_B$</td><td style="text-align:center">基极端有电阻$R_B$</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">发射极偏置</td><td style="text-align:center">$I_E$</td><td style="text-align:center">发射极端有有电阻$R_E$</td><td style="text-align:center">是</td></tr></tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>电子系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>06. 快速傅里叶变换</title>
    <link href="/2021/10/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/6.%20%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"/>
    <url>/2021/10/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/6.%20%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="快速傅里叶变换"><a href="#快速傅里叶变换" class="headerlink" title="快速傅里叶变换"></a>快速傅里叶变换</h1><p>快速傅里叶变换（FFT）是一种计算离散傅里叶变换的算法，其独有的计算方式能够大幅度减小离散傅里叶变换的计算量，使得离散傅里叶变换在计算机上具有可实现性。  </p><h2 id="离散傅里叶变换的计算量"><a href="#离散傅里叶变换的计算量" class="headerlink" title="离散傅里叶变换的计算量"></a>离散傅里叶变换的计算量</h2><p>回顾离散傅里叶变换：  </p><script type="math/tex; mode=display">X[k]=\sum_{n=0}^{N-1}x[n]W^{kn}_N</script><p>可以发现，计算一个离散傅里叶变换需要计算：  </p><ol><li>N个$x[n]W$，即N次复数乘法</li><li>N-1次$x[i]W+x[i+1]W$，即(N-1)次复数加法</li></ol><p>根据复数乘法原则$(a+jb)(c+jd)=(ac-bd)+j(ad+bc)$，和复数加法原则$(a+jb)+(c+jd)=(a+c)+j(b+d)$，可以发现：1次复数乘法与4个实数乘法和2个实数加法等价；1次复数加法和2次实数加法等价。<br>因此计算一次离散傅里叶变换需要计算：  </p><ol><li>$4N^2$次实数乘法</li><li>$4N^2-2N$次实数加法  </li></ol><p>其中实数乘法对计算资源的消耗非常的大，因此考虑使用别的算法以简化实数乘法的次数。  </p><h2 id="时域抽取的快速傅里叶变换"><a href="#时域抽取的快速傅里叶变换" class="headerlink" title="时域抽取的快速傅里叶变换"></a>时域抽取的快速傅里叶变换</h2><p>将离散傅里叶变换分为奇数和偶数两个段落：  </p><script type="math/tex; mode=display">\begin{aligned}    X[k]&=\sum_{r=0}^{\frac{N}{2}-1}x[2r]W^{2rk}_N+\sum_{r=0}^{\frac{N}{2}-1}x[2r+1]W^{(2r+1)k}_N\\    &=\sum_{r=0}^{\frac{N}{2}-1}x[2r]W^{2rk}_N+W_N^{k}\sum_{r=0}^{\frac{N}{2}-1}x[2r+1]W^{2rk}_N\end{aligned}</script><p>根据复数的共轭对称性质：$W_N^{k(N-n)}=W_N^{kN}W^{-kn}_N=W^{-kn}_N$，前半段（$0-N/2$）的表达式可以写作：  </p><script type="math/tex; mode=display">X[k]=\sum_{r=0}^{\frac{N}{2}-1}x[2r]W^{rk}_{N/2}+W_N^k\sum_{r=0}^{\frac{N}{2}-1}x[2r+1]W^{rk}_{N/2}</script><p>令$G[k]=\sum_{r=0}^{\frac{N}{2}-1}x[2r]W^{rk}_{N/2}$，$H[k]=\sum_{r=0}^{\frac{N}{2}-1}x[2r+1]W^{rk}_{N/2}$:  </p><script type="math/tex; mode=display">X[k]=G[k]+W^k_NH[k],k=0,1,..,N-1</script><p>将前半段式子的下标加上$N/2$考虑后半段式子的和，由于$W_N^{k+N/2}=-1$，因此：  </p><script type="math/tex; mode=display">X[k+N/2]=G[k]-W^k_NH[k],k=0,1,..,N-1</script><p>综合两段，得到时域抽取的快速傅里叶变换：  </p><script type="math/tex; mode=display">X[k]=G[k]+W^k_NH[k],k=0,1,..,N/2-1</script><script type="math/tex; mode=display">X[k+N/2]=G[k]-W^k_NH[k],k=0,1,..,N/2-1</script><p>上述式子称为蝶式结构，用图示可以表示为：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211030143805.png width=40%> </p><p>可以将整个序列继续折中细分成多个小部分，每个部分计算蝶形结构。在$N$为2的次方数时，使用折中法正好可以使得最终细分到相邻的奇偶两项做蝶形结构运算：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211030144247.png width=30%>  </p><p>比如$N=8$时就可以通过折中法多次两两分组，每组内部进行蝶形运算后的结果再进行蝶形运算：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211030144446.png width=80%><br>其中最低一级的分组通过如下方式进行：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211030144544.png width=50%>  </p><h3 id="蝶形结构运算"><a href="#蝶形结构运算" class="headerlink" title="蝶形结构运算"></a>蝶形结构运算</h3><p>观察整个快速傅里叶变换的结构：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211030144723.png width=80%></p><p>可以得出如下结论：  </p><ol><li>对于$N=2^m$，需要$m$级次蝶形结构的运算。  </li><li>对于第$m$级运算，组数为$2^N-m-1$。每一组的$q$总是被赋予$-1$和权重，权重表示为：  <script type="math/tex; mode=display">W_{2^{m+1}}^r,r=0,1,2,..,2^m-1</script>&lt;<img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211222132037.png width=50%></li></ol><blockquote><p>注意计算之前首先得按照比特反转的方法对序列进行重排序。  </p></blockquote><h3 id="快速傅里叶变换的计算量"><a href="#快速傅里叶变换的计算量" class="headerlink" title="快速傅里叶变换的计算量"></a>快速傅里叶变换的计算量</h3><p>由于一点蝶形运算中不包含乘法，快速傅里叶变换通过应用这样的蝶形结构来削减乘法计算的次数。当长度$N=2^m$时，简单分析可得快速傅里叶变换的计算量：  </p><script type="math/tex; mode=display">\frac{N^2}{2^m}+m\frac{N}{2}=N+\frac{N}{2}log_2N</script><h2 id="频域抽取的快速傅里叶变换"><a href="#频域抽取的快速傅里叶变换" class="headerlink" title="频域抽取的快速傅里叶变换"></a>频域抽取的快速傅里叶变换</h2><p>在频域内对离散傅里叶变换进行拆分，可以得到：  </p><script type="math/tex; mode=display">\begin{aligned}    X[2r]=&∑_{n=0}^{N/2-1}x[n]W_N^{2nr}+∑_{n=0}^{N/2-1}x[n+N/2]W^{2r(n+N/2)}_N\\    =&∑_{n=0}^{N/2-1}[x[n]+x[n+N/2]]W^{rn}_{N/2},r=0,1,..,N/2-1\end{aligned}</script><p>同理对于频域内的奇数序列有：  </p><script type="math/tex; mode=display">X[2r+1]=[x[n]-x[n+N/2]]W^{rn}_{N/2},r=0,1,..,N/2-1</script><p>令$g[n]=x[n]+x[n+N/2]$,$h[n]=x[n]-x[n+N/2]$，得到频域抽取的快速傅里叶变换：  </p><script type="math/tex; mode=display">X[2r]=∑_{n=0}^{N/2-1}g[n]W_{N/2}^{rn}</script><script type="math/tex; mode=display">X[2r+1]=W_N^n∑_{n=0}^{N/2-1}h[n]W_{N/2}^{rn},r=0,1,..,N/2-1</script><p>同样符合蝶形结构：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211030150736.png width=60%>  </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>数字信号处理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>06. 晶体管的结构和直流工作状态</title>
    <link href="/2021/10/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%AD%90%E7%B3%BB%E7%BB%9F/6.%20foundamentals%20of%20BJT/"/>
    <url>/2021/10/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%AD%90%E7%B3%BB%E7%BB%9F/6.%20foundamentals%20of%20BJT/</url>
    
    <content type="html"><![CDATA[<h1 id="晶体管的结构和直流工作状态"><a href="#晶体管的结构和直流工作状态" class="headerlink" title="晶体管的结构和直流工作状态"></a>晶体管的结构和直流工作状态</h1><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>半导体有两种：N型半导体和P型半导体，两种半导体内部有多余的负电荷或者是正电荷。制造半导体的主要工艺为掺杂：掺杂有两种类型： p 型掺杂（具有额外的空穴，带正电）和 n 型掺杂（具有额外的电子，带负电）。此外不同半导体的掺杂程度也可以不同，掺杂程度越高（称为重掺杂），半导体导电性能越强。<br>BJT晶体管/三极管是广泛运用于电子设计中的电路元件，它由三个N型或者P型半导体结合组成，三个半导体既可以是P-N-P，也可以是N-P-N，结合的部分称为PN结。本课主要讲N-P-N型三极管，其结构如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211027153932.png width=30%><br>三极管有三个输入端，分别为：集电极、基极和发射极，NPN三极管中三者半导体类型如下：   </p><div class="table-container"><table><thead><tr><th style="text-align:center">集电极</th><th style="text-align:center">基极</th><th style="text-align:center">发射极</th></tr></thead><tbody><tr><td style="text-align:center">N型</td><td style="text-align:center">P型</td><td style="text-align:center">N型</td></tr><tr><td style="text-align:center">中度掺杂</td><td style="text-align:center">轻度掺杂</td><td style="text-align:center">重度掺杂</td></tr><tr><td style="text-align:center">自由电子</td><td style="text-align:center">空穴</td><td style="text-align:center">自由电子</td></tr></tbody></table></div><p>由于这样的设计，自由电子只能从集电极/发射极流向基极，而无法从基极流向两边，<br>因此可以将NPN三极管等效为两个背靠背的二极管：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211027155507.png width=30%>  </p><h3 id="偏置状态"><a href="#偏置状态" class="headerlink" title="偏置状态"></a>偏置状态</h3><p>在外接电源的情况（称为偏置）下，自由电子受到电场的作用从而定向移动：从两端的N型半导体移动到中心的P型半导体。其中的一部分自由电子在基极内部的两侧与空穴结合，从而形成两个枯竭层阻挡自由电子继续前进。硅半导体枯竭层的两侧在25℃条件下具有0.7V的电压差。但是基极通常很薄，且为轻度掺杂，因此大部分的电子仍然可以穿过基极，流向两端。这一过程中，由于发射极为重度掺杂，导电性大于集电极，因此<strong>绝大多数电子的流向是从发射极经过基极流向集电极。</strong><br>自由电子到达集电极后会受到$V_{cc}$的吸引，最终流向$V_{cc}$的正极。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211028212658.png width=50%>  </p><p>该过程转化为电流的流向，NPN三极管内部的电流流向如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211028212033.png width=20%><br>在这样的电流流动情况下，集电极处的等效二极管处于反向偏置状态，发射极处的等效二极管处于正向偏置状态。  </p><p>三极管的等效电路图如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211028222936.png width=50%></p><h2 id="共发射极电路中三极管的电流变化"><a href="#共发射极电路中三极管的电流变化" class="headerlink" title="共发射极电路中三极管的电流变化"></a>共发射极电路中三极管的电流变化</h2><p>根据三极管不同的端接地分为不同的连接方式，其中最常见的是发射极接地的情况，称为共发射极电路（Common Emitter connection）：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211028214554.png width=50%>  </p><p>如果如果信号由晶体管基极输入，从集电极输出。下面在共发射极的电路中讨论基极和集电极的电流变化。  </p><h3 id="基极的电流变化曲线"><a href="#基极的电流变化曲线" class="headerlink" title="基极的电流变化曲线"></a>基极的电流变化曲线</h3><p>探究$V_{BE}$对基极电流$I_B$的影响：<br>根据电流图示，基极和发射极之间的等效二极管处于正向偏置状态，可以将$I_B$和$V_{BE}$之间的关系看做是一个二极管的电压-电流曲线：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211028215817.png width=20%><br>通过图像可以看出：这个等效二极管只需要0.7V就可以完全导通。<br>同时，晶体管在正常工作($I_B$并非非常小)时，基极和发射极之间始终存在压降$V_{BE}$。<br><strong>对于理想三极管$V_{BE}=0V$（称为一级近似），对于非理想三极管$V_{BE}=0.7V$</strong>（称为二级近似）。<br>根据欧姆定律可以得到基极侧的电流电压关系：  </p><script type="math/tex; mode=display">I_B=\frac{V_{BB}-V_{BE}}{R_B}</script><h3 id="集电极的电流变化曲线"><a href="#集电极的电流变化曲线" class="headerlink" title="集电极的电流变化曲线"></a>集电极的电流变化曲线</h3><p>探究$V_{CE}$对基极电流$I_C$的影响：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211028220139.png width=50%><br>根据之前的电流图示，可以得到：  </p><script type="math/tex; mode=display">I_E=I_C+I_B</script><p>根据上述特性曲线，可以将工作状态分为：<strong>饱和、放大、截止</strong>三种。此外还有称为击穿的异常工作状态。  </p><h4 id="放大-线性"><a href="#放大-线性" class="headerlink" title="放大/线性"></a>放大/线性</h4><p>放大状态是三极管的正常工作状态，在这种工作状态下，几乎所有的电子都已经流向了集电极。发射极的等效二极管处于前向偏置状态。<strong>无论$V_{CC}$和$V_{CE}$如何变化，集电极的电流$I_C$始终只与$I_B$有关。</strong><br>在放大状态下，输入一个较小的$I_B$可以输出一个较大的电流信号：$I_C$。此时晶体管可以用做放大器。  </p><p>定义三极管的<strong>电流增益</strong>:</p><script type="math/tex; mode=display">β=\frac{I_C}{I_B}</script><p>电流增益会随着<strong>三极管型号</strong>、<strong>温度</strong>和<strong>集电极电流$I_C$</strong><br>的不同而变化，在设计放大电路时应当尽量避免$β$对电路输出产生影响。    </p><p>同时定义晶体管的修正系数$α$为集电极电流和发射极电流之比:  </p><script type="math/tex; mode=display">α=\frac{I_C}{I_E}=\frac{β}{β+1}</script><p>通常认为在$β&gt;100$的情况下，$α≈1$。  </p><h4 id="饱和"><a href="#饱和" class="headerlink" title="饱和"></a>饱和</h4><p>在饱和工作状态下，几乎所有的自由电子都从发射极流向基极。$I_B$大于放大状态的电流。此时$CE$间相当于短路，是晶体管用做开关时的导通状态。<br>由于$CE$间相当于短路，饱和状态下集电极环路的电流为：  </p><script type="math/tex; mode=display">I_{CSat}=\frac{V_{CC}}{R_C}</script><p>此电流为集电极环路中的最大电流。  </p><blockquote><p>由于$β$与$I_C$有关，在饱和状态下，无法使用$I_C=βI_B$进行计算。  </p></blockquote><h4 id="截止"><a href="#截止" class="headerlink" title="截止"></a>截止</h4><p>在截止状态下，$I_B=0$，此时$CE$之间相当于断路，是是晶体管用做开关时的关断状态。<br>此时$V_{CE}$与供电电压$V_{CC}$相等：  </p><script type="math/tex; mode=display">V_{CEcutoff}=V_{CC}</script><h4 id="击穿"><a href="#击穿" class="headerlink" title="击穿"></a>击穿</h4><p>当$V_{CE}$相当大时，晶体管被击穿，晶体管处于永久短路状态，此时的$I_C$迅速增大。  </p><h2 id="直流工作状态"><a href="#直流工作状态" class="headerlink" title="直流工作状态"></a>直流工作状态</h2><p>要想使三极管处于开关或者放大器的工作模式，三极管必须处于直流工作状态（即三极管静态工作点就是交流输入信号为零时），在直流工作状态下，对集电极环路进行分析：  </p><script type="math/tex; mode=display">V_{CE}=V_{CC}-I_CR_C</script><script type="math/tex; mode=display">I_C=-\frac{1}{R_C}V_{CE}+\frac{V_{CC}}{R_C}</script><p>可以发现当$V_{CC}$和$R_C$固定时，$V_{CE}$和$I_C$需要设置为某些特定的值下，才能使得三极管满足直流工作状态，且在直流工作状态下两者成线性关系。这条线称为<strong>直流负载线</strong>，也是三极管在直流工作状态下的特性曲线。<br>这条曲线的<strong>斜率为$-\frac{1}{R_C}$，截距为集电极饱和电流$\frac{V_{CC}}{R_C}$，零点为集电极的截止电压</strong>。随着$V_{CE}$的增大，$I_C$逐渐减小。  </p><h3 id="静态工作点"><a href="#静态工作点" class="headerlink" title="静态工作点"></a>静态工作点</h3><p>在直流工作状态下，随着基极电阻的增大，基极电流$I_B$会相应的发生变化，不同的$I_B$会导致集电极环路中$V_{CE}$和$I_C$的关系发生变化：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211030123051.png width=50%>  </p><p>要得到$I_B$一定时，三极管处于直流工作状态下对应的$I_C$和$V_{CE}$，应当在此图上作出直流负载曲线，与$V_{CE}$和$I_C$的关系曲线的交点即为所求。该交点称为三极管的<strong>静态工作点</strong>（Q Point），表示三极管处于直流工作状态下，$I_B$为某个固定值时$I_C$和$V_{CE}$的值。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211030123451.png width=50%>  </p><p>从图上可以看出，当基极的电流增益$β$非常大时，$I_B$不变的情况下（称为Base-Biasing），$I_C$随之升高，可能会使$V_{CE}$非常小，甚至接近短路，使得静态工作点位于饱和区域。同理，当基极的电流增益$β$非常小时，$V_{CE}$非常大，甚至接近断路，使得静态工作点位于截止区域。  </p><p>在三极管用做放大器时，静态工作点位于放大区域。在此状态下，三极管可以生成非常稳定的电流增益，防止电路产生非线性失真。<br>在三极管用做开关时，静态工作点在饱和和截止区域之间切换。此状态方便用数字信号进行表达：当静态工作点处于饱和区域时，数字信号为1，处于截止区域时，代表的数字信号为0。  </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>电子系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>08. 模拟信号的数字化/信源编码</title>
    <link href="/2021/10/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/8.%20%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E4%BC%A0%E8%BE%93/"/>
    <url>/2021/10/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/8.%20%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E4%BC%A0%E8%BE%93/</url>
    
    <content type="html"><![CDATA[<h1 id="模拟信号的数字化-信源编码"><a href="#模拟信号的数字化-信源编码" class="headerlink" title="模拟信号的数字化/信源编码"></a>模拟信号的数字化/信源编码</h1><p>在现代通信中，更经常用到的是将模拟信号在发送端进行数字化处理后进行传输，信号在接收端进行解码还原。整个过程如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211023130519.png width=80%>  </p><p>原信号经过抽样、量化后由模拟信号变成数字信号，再经过编码使得信号的幅值由无限（注意$δ(t)$的幅值是无限大的）变为有限描述，传输至信道，在接收端，首先通过定时规定信号的起始点和周期，再经过译码还原为量化信号（PAM，仍然是数字信号），最后通过低通滤波器过滤高频信号后在接收端还原为模拟信号$f_o(t)$。  </p><blockquote><p>$f_o(t)$和$f(t)$实际上是不同的两个信号，原因有三：  </p><ol><li>采样结果受到采样频率和信号变化频率的影响，不同的采样频率对同一个信号变化频率采集到的结果不同，甚至得到的采样信号可能是和原信号完全相反的波形。  </li><li>量化过程受到精度限制，极有可能获得原信号在某时间点上幅值的近似值而非准确值，这两个值之间的差距称为量化噪声。量化噪声产生后无法被消除。  </li><li>传输过程中信道的噪声和干扰。  </li></ol></blockquote><h2 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h2><p>由奈奎斯特采样定理可知：采样的实质是原信号与周期冲激序列相乘:  </p><script type="math/tex; mode=display">m_s(t)=m(t)δ_T(t)</script><p>现实中很难获得一个周期冲激序列，因此改用一个周期方波序列作为抽样使用的信号。在自然采样中(Natural sampling)，采样后的每一个信号分量的幅值是随着时间变化的：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211023131900.png width=50%><br>平顶抽样（Ceiling sampling）在自然采样后加入了一个保持器，可以使得信号的每一个分量的幅值被采集到后保留一段时间：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211023132058.png width=50%>  </p><p>由奈奎斯特采样定理可得：  </p><script type="math/tex; mode=display">\begin{aligned}    m_s(t)&=m(t)δ_T(t)\\    =&∑m(nT_s)δ(t-nT_s)\\\end{aligned}</script><p>在频域中可得到采样后的信号频谱：  </p><script type="math/tex; mode=display">M_s(f)=\frac{1}{T}∑M(f-nf_s)</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211023132549.png width=50%></p><p>采样后频谱的每一个分量都包含原信号的完整信息，因此可以设计低通滤波器滤出一个频域周期内($f_s$)的信号。这种做法的前提条件是频谱分量间不能有任何的重叠，否则滤出的信号会由于重叠而产生混叠误差。（Aliasing error）<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211023132927.png width=50%>  </p><p>因此规定采样频率必须至少高于原信号带宽：  </p><script type="math/tex; mode=display">f_s≥2f_H</script><p>但是采样频率越高，整个频谱的带宽越大，频谱利用率越低，最好的采样频率为两者相等时：$f_s=2f_H$，称为奈奎斯特采样频率。  </p><h3 id="带通信号采样"><a href="#带通信号采样" class="headerlink" title="带通信号采样"></a>带通信号采样</h3><p>这样的采样方式对低通信号（原信号频谱$f_L=0$）固然是可行的，对于带通信号（原信号$f_L≠0$），这样的采样使得频谱中出现很多无信号部分，称为频谱空洞，导致频谱利用效率降低。因此需要在上述方法上进行改进。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211023133539.png width=50%>  </p><p>对于带通信号，其采样频率$f_s$应当满足如下条件：  </p><script type="math/tex; mode=display">f_s≥2B(1+\frac{M}{N})</script><p>其中$M$为$|\frac{f_H}{B}|$的小数部分，$N$为$|\frac{f_H}{B}|$的整数部分。<br>满足$f_s=2B(1+\frac{M}{N})$的采样结果不会出现频谱空洞。<br>对于上式，当$f_L$非常大时，$f_s≈2B$。  </p><h2 id="量化"><a href="#量化" class="headerlink" title="量化"></a>量化</h2><h3 id="均匀量化"><a href="#均匀量化" class="headerlink" title="均匀量化"></a>均匀量化</h3><p>量化过程简述如下：将信号的幅值划分成若干个区间，某时刻原信号幅值落在该区间时，量化信号在此时刻的幅值为这个区间的中值。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211023135157.png width=80%>  </p><p>该过程可以用数学表示为：  </p><script type="math/tex; mode=display">m_q(kT_S)=q_i,\text{if }m_{i-1}≤m(kT_s)≤m_i</script><p>这个过程中的每个区间称为量化间隔，在均匀量化中，这个间隔是均等的：$Δ=\frac{V_m}{N}$，$N$为用于描述信号的比特数，与量化精度相关。每个区间的上界是下一个区间的下界，每个界限以$m_i$表示。当原信号落入某区间时，用于描述/替代原信号幅值的值称为量化电平$q_i$，量化电平通常是该区间的中值，以减小总体的量化误差：  </p><script type="math/tex; mode=display">q_i=\frac{m_i+m_{i-1}}{2}</script><h4 id="均匀量化的信噪比"><a href="#均匀量化的信噪比" class="headerlink" title="均匀量化的信噪比"></a>均匀量化的信噪比</h4><p>输入信号的平均功率：  </p><script type="math/tex; mode=display">S=E[(m_k)^2]=∫x^2f(x)dx</script><p>$m_k$表示采样值，$m_q$表示量化值。<br>量化值与实际值之间的误差称为量化误差/量化噪声，量化噪声的功率在数学上表示为：  </p><script type="math/tex; mode=display">N_q=E[(m_k-m_q)^2]=∫_a^b(x-m_q)^2f(x)dx</script><p>$f(x)$是原信号的概率密度函数，原信号需要符合均匀分布才能使用均匀量化。<br>带入$m_i=a+iΔ$，$q_i=a+iΔ+i\frac{Δ}{2}$后化简计算，可以发现<strong>量化噪声的功率只与量化间隔有关。</strong><br>定义量化信噪比为输入的采样信号功率与量化噪声的功率之比：  </p><script type="math/tex; mode=display">\frac{S}{N_q}=\frac{E[(m_k)^2]}{E[(m_k-m_q)^2]}</script><p>从上述结论可以发现，量化噪声与输入信号的功率大小无关，因此小的输入信号功率会导致非常小的量化信噪比。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211023140452.png width=50%>  </p><h3 id="非均匀量化"><a href="#非均匀量化" class="headerlink" title="非均匀量化"></a>非均匀量化</h3><p>解决“小的输入信号功率会导致量化信噪比小”这一问题的基本思路是使用一个函数对信号的幅值进行重映射，使其能够扩大小功率时的幅值，缩小大功率时的幅值。这个函数称为压缩律。输入信号经过压缩器使用压扩器增大小功率信号的幅值后，再使用均匀量化就能减小量化信噪比。在接收处，通过压缩率的反函数可以对压缩信号进行还原。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211023140905.png width=80%>  </p><p>国际电信联盟（ITU）所采用的两种压缩律分别为A压缩律和μ压缩律，A压缩律在中国和欧盟国家使用，μ压缩律在美国、日本、韩国使用，国际通信时使用A压缩律作为标准。本章只介绍A压缩律。<br>A压缩律可以用如下公式表示：  </p><script type="math/tex; mode=display">y=\begin{cases}    \frac{Ax}{1+lnA},0≤x≤\frac{1}{A}\\    \frac{1+ln(Ax)}{1+lnA},\frac{1}{A}≤x≤1\end{cases}</script><p>其中$x$,$y$分别表示最大值归一化后压扩器的输入和输出信号。  </p><h3 id="A压缩律的数字化"><a href="#A压缩律的数字化" class="headerlink" title="A压缩律的数字化"></a>A压缩律的数字化</h3><p>在数字系统中，压缩律通过折线对模拟压缩律进行近似，ITU规定数字化的A压缩律以13折折线近似，μ压缩律以15折折线近似。对A压缩律，具体的表示方法如下：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211023142704.png width=80%>  </p><ol><li><p>将最大值归一化后的$x$轴采用折中法反复折中，划分为8段落（$0-\frac{1}{128}$到$\frac{1}{2}-1$），称为量化段。对于每一个段落，分为16个小区间，称为量化级。最小的区间长度出现在$0-\frac{1}{128}$段，定义$Δ=\frac{1}{128×16}=\frac{1}{2048}$。每一量化段的量化间隔如下表所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211023143157.png width=50%>  </p><p>需要注意，声音信号的幅值分布在I象限和III象限，因此量化折线还需要镜像对称到第III象限。由于-2，-1，1，2四个量化段的斜率相等，是同一条线，因此一共使用了13条折线来描述A压缩律（I象限、III象限）。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211023143939.png width=50%></p><p>那么$x$轴一共有256个量化级，可以用8bit进行表示：  </p><script type="math/tex; mode=display">M=2×8×16=2^8</script></li><li>$y$轴平分为8段，每一段间隔相等。  </li><li>连线。  </li></ol><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>通信系统中常用的编码有三种：  </p><ol><li>自然二进制编码（NBC）</li><li>格雷码</li><li>折叠码（FBC）</li></ol><h3 id="折叠码"><a href="#折叠码" class="headerlink" title="折叠码"></a>折叠码</h3><p>本节着重介绍折叠码，折叠码化需要选取折叠的位置，取折叠码第一位表示极性，即是折叠位置以上（正，1）还是折叠位置以下（负，0），然后出去极性，将值到折叠位置的距离二进制化，得到该值对应的折叠码。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211025180629.png width=80%>  </p><p>折叠码的优势在于，对相同的点平/值，折叠码表示所用的比特数要少于自然二进制编码。此外，折叠码对小信号（0附近的信号）比较友好，当表示极性的比特位发生错误时，对应的电平误差只有1。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211025180940.png width=50%>  </p><h3 id="脉冲编码调制（PCM）"><a href="#脉冲编码调制（PCM）" class="headerlink" title="脉冲编码调制（PCM）"></a>脉冲编码调制（PCM）</h3><p>脉冲编码调制是基于A压缩律的非均匀调制的一种编码方法，是一种折叠码。但是由于声音格式有负幅值，因此其折线位于0处。PCM采用了如下格式进行编码：  </p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">极性码</th><th style="text-align:center">段落码</th><th style="text-align:center">段内码</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center">$C_1$</td><td style="text-align:center">$C_2C_3C_4$</td><td style="text-align:center">$C_5C_6C_7C_8$</td></tr><tr><td style="text-align:center">意义</td><td style="text-align:center">极性</td><td style="text-align:center">对应8个段落</td><td style="text-align:center">对应每一个段落中的16个量化级</td></tr></tbody></table></div><p>PCM编码与数字化的13折A压缩律对应如下：  </p><div class="table-container"><table><thead><tr><th style="text-align:center">段落编号</th><th style="text-align:center">电平区间</th><th style="text-align:center">段落码</th><th style="text-align:center">量化间隔Δ</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">0-16</td><td style="text-align:center">000</td><td style="text-align:center">$1=2^0$</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">16-32</td><td style="text-align:center">001</td><td style="text-align:center">$1=2^0$</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">32-64</td><td style="text-align:center">010</td><td style="text-align:center">$2=2^1$</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">64-128</td><td style="text-align:center">011</td><td style="text-align:center">$4=2^2$</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">128-256</td><td style="text-align:center">100</td><td style="text-align:center">$8=2^3$</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">256-512</td><td style="text-align:center">101</td><td style="text-align:center">$16=2^4$</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">512-1024</td><td style="text-align:center">110</td><td style="text-align:center">$32=2^5$</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">1024-2048</td><td style="text-align:center">111</td><td style="text-align:center">$64=2^6$</td></tr></tbody></table></div><h3 id="脉冲调制编码过程"><a href="#脉冲调制编码过程" class="headerlink" title="脉冲调制编码过程"></a>脉冲调制编码过程</h3><p>量化后的电平值转化为脉冲调制编码的步骤为：  </p><ol><li><p>判断电平的正负，如果是正：$C_1=1$，如果为负，$C_1=0$。</p><blockquote><p>注意“1正0负”</p></blockquote></li><li><p>根据电平值和电平区间，判断电平落在了哪一个段落，决定段落码$C_2C_3C_4$。  </p></li><li>将电平值减去段落的起始值，与量化间隔相除，结果转化为8421码即为$C_5C_6C_7C_8$。  </li></ol><p>与量化间隔相除结果的余数部分无法通过编码表示，称为编码噪声$N_e$。<br>由于这样的转换方式比较低效，实际上的通信系统通常采用逐位进行比较的逐次比较法，过程如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211025183903.png width=80%>  </p><h3 id="脉冲调制的解码"><a href="#脉冲调制的解码" class="headerlink" title="脉冲调制的解码"></a>脉冲调制的解码</h3><p>PCM编码在解码端首先会变成11位的自然二进制编码。  </p><h4 id="PCM与11-NBC的关系"><a href="#PCM与11-NBC的关系" class="headerlink" title="PCM与11-NBC的关系"></a>PCM与11-NBC的关系</h4><p>PCM基于非均匀脉冲，是一种非线性编码。由于之后的通信电路中含有仅支持线性输入的逻辑电路，因此还需要将7bit的PCM转化为11bit的自然二进制编码（NBC），两者之间满足：  </p><script type="math/tex; mode=display">I_{PCM}=I_{11-NBC}</script><p>即两者编码转化为10进制的结果是相同的。<br>因此PCM编码转为10进制后再转为自然二进制即可得到NBC。  </p><h4 id="PCM与12-NBC的关系"><a href="#PCM与12-NBC的关系" class="headerlink" title="PCM与12-NBC的关系"></a>PCM与12-NBC的关系</h4><p>由于PCM编码只考虑到了每个量化区间内的起始值$m_{i-1}$而并非量化电平$p_i$，在解码过程中需要补充每个量化段的半个量化区间$\frac{Δ_i}{2}$，由于最小的$\frac{Δ_1}{2}=0.5$，因此需要额外补充一个bit来弥补增加的精度，生成12位NBC码。  </p><script type="math/tex; mode=display">I_{12-NBC}=I_{PCM}+\frac{Δ_i}{2}</script><p>因此，脉冲编码调制的量化噪声$N_q$为编码噪声减去$\frac{Δ_i}{2}$:</p><script type="math/tex; mode=display">QN=EN-\frac{Δ_i}{2}</script><h3 id="PCM的抗噪性分析"><a href="#PCM的抗噪性分析" class="headerlink" title="PCM的抗噪性分析"></a>PCM的抗噪性分析</h3><h4 id="传输速率"><a href="#传输速率" class="headerlink" title="传输速率"></a>传输速率</h4><p>PCM的传输速率为：  </p><script type="math/tex; mode=display">R_B=f_s×log_2M</script><p>其中$f_s$为采样频率，$M$为比特数，A律13折PCM中$M=256$。  </p><h4 id="信噪比"><a href="#信噪比" class="headerlink" title="信噪比"></a>信噪比</h4><p>解码器端解码后的信号可以表示为：  </p><script type="math/tex; mode=display">\hat{m}(t)=m_0(t)+n_q(t)+n_e(t)</script><p>$n_q(t)$为量化噪声，$n_e(t)$为传输过程中的高斯白噪声。<br>因此整个过程的信噪比表示为：  </p><script type="math/tex; mode=display">\frac{S_o}{N_o}_{PCM}=\frac{\overline{m^2(t)}}{N_q+N_e}</script><p>通过计算可以发现，当$m(t)$服从均匀分布时，量化信噪比表示为：  </p><script type="math/tex; mode=display">\frac{S}{N_q}=M^2</script><h2 id="时分复用"><a href="#时分复用" class="headerlink" title="时分复用"></a>时分复用</h2><p>时分复用（TDM）可以达到在一个小时间段内同时传输多条信号的目的。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211101182433.png width=80%>  </p><p>如上图所示，多路信号作为输入，每一路的输入信号都要通过一个低通滤波器以保证信号的最高频小于$f_H$(对于声音信号是3400Hz)，保证采样时可以抽取到所有的信息。此后，多路信号汇合，通过一个抽样转盘，该抽样转盘会在一个周期内均匀地抽取每一路信号的一部分，对于声音信号，抽样转盘的采样频率为$f_s=8000Hz$。<br>在解码端也存在一个与发送端频率完全相同的抽样转盘，该转盘在一个周期内会将经过时分复用后的信号还原分配给每一路信号。  </p><p>对于每一路信号，抽样转盘能够提取这路信号的时间段称为一个路时隙$T_a$（Time slot），每一路信号的一个路时隙组成一帧（Frame），即抽样转盘的采样周期$T_s$，二者存在如下关系：  </p><script type="math/tex; mode=display">T_a=\frac{T_s}{n}</script><p>$n$表示信号的路数。<br>对于PCM信号，每一路信号的一个路时隙信息量为8bit，即一个路时隙的字长$l=8bit$，因此对于TDM-PCM信息传输速率可以表示为：  </p><script type="math/tex; mode=display">R_B=R_b=nlf_s</script><p>$f_s$为转盘的抽样频率。  </p><h3 id="占空比"><a href="#占空比" class="headerlink" title="占空比"></a>占空比</h3><p>对每一帧而言，其中电平不为0的时间段（即信息传输的时间）称为符号持续时间$τ$（Symbol duration），定义占空比（Duty Cycle）表示符号持续时间和一个周期时间之比：  </p><script type="math/tex; mode=display">Duty.Cycle=\frac{τ}{T_s}×100\%</script><p>当$τ=T_s$时，表示一个周期内所有时间都在发送符号，称为归零码（RZ Code），$τ≠T_s$时，称为不归零码（NRZ Code）。  </p><h3 id="30-32-PCM-基群结构"><a href="#30-32-PCM-基群结构" class="headerlink" title="30/32 PCM 基群结构*"></a>30/32 PCM 基群结构*</h3><p>30/32 PCM 基群结构是我国普遍使用的TDM-PCM方式，一帧有32个路时隙，其中有2个路时隙用于传输同步信号，剩余的30个路时隙用于传输信息。<br>其中TS0用于传输同步码、监视码、对端告警码组（简称对告码）；TS16用于传输信令码；TS1—TS15传前15个话路的话音数字码，TS17—TS31传输后15个话路的话音数字码。<br>此外还有16个复帧（Multi-frame）用于特殊用途（如定位信号，CRC校验码，信令传输等等）。  </p><blockquote><p>信令是用来表示通话状态的一系列信息，如：摘机、挂机信号、拨号、忙音等。  </p></blockquote><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211101184749.png width=80%>  </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>通信原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05. 定时器</title>
    <link href="/2021/10/22/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%AD%90%E7%B3%BB%E7%BB%9F/5.%20timers/"/>
    <url>/2021/10/22/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%AD%90%E7%B3%BB%E7%BB%9F/5.%20timers/</url>
    
    <content type="html"><![CDATA[<h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><h2 id="电容器的充放电特性"><a href="#电容器的充放电特性" class="headerlink" title="电容器的充放电特性"></a>电容器的充放电特性</h2><p>在RC电路中，当电容与电压源连通时电容会进行充电，而断开连接后电容器会放电，充电和放电的过程电容器的电压和电流都随着时间的变化而变化。设时间常数$τ=RC$，分析电容器充放电过程的特性。  </p><h3 id="电容器的充电特性"><a href="#电容器的充电特性" class="headerlink" title="电容器的充电特性"></a>电容器的充电特性</h3><p>充电时电容器上的电压会随着时间增大：  </p><script type="math/tex; mode=display">V=V_0(1-e^{-\frac{t}{τ}})</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211022194059.png width=50%>  </p><p>经过$1τ$，电容器电压达到最大值的62%，经过$5τ$时可以认为电容器已经充满电。<br>电流随着时间逐渐变为0:  </p><script type="math/tex; mode=display">I=I_0e^{-\frac{t}{τ}}</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211022193952.png width=50%>  </p><p>同样地，经过$1τ$，电容器电流流失到原来的37%，经过$5τ$时可以认为没有电流通过电容器。  </p><h3 id="电容器的放电特性"><a href="#电容器的放电特性" class="headerlink" title="电容器的放电特性"></a>电容器的放电特性</h3><p>放电时，电容器的电压变化与充电时相反，随着时间的推移，电压逐渐流失：  </p><script type="math/tex; mode=display">V=V_0e^{-\frac{t}{τ}}</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211022194713.png width=50%>  </p><p>经过$1τ$，电容器电流流失到原来的37%，经过$5τ$时可以认为没有电流通过电容器。<br>同时，电流也随着时间逐渐流失，与充电过程不同的是，电流流失的方向是相反的：  </p><script type="math/tex; mode=display">I=-I_0e^{-\frac{t}{τ}}</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211022194804.png width=50%>  </p><p>与电压流失相同，经过$1τ$，电容器电流流失到原来的37%，经过$5τ$时可以认为没有电流通过电容器。  </p><h3 id="三角波发生器"><a href="#三角波发生器" class="headerlink" title="三角波发生器"></a>三角波发生器</h3><p>利用电容器的充放电性质，可以让输入电压周期性地打开和关闭与电容的连接，电容器会不断地进行充放电，形成三角波形。事实上“周期性地打开和关闭”的效果与输入信号为方波时相同。<br>理想条件下，可以由此设计三角波发生器，其电路完全等同于低通滤波器。<br>需要注意的是，考虑到电容器的完全充放电是需要时间的，输入信号的频率应该比较低，以给予电容器合适的充放电时间。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211022195421.png width=50%>  </p><p>将上述的电路进一步改进，得到如下的电路：<br>该电路由两部分组成：  </p><ol><li>由直流电压源、电阻和电容组成的三角波发生器电路，该电路在电容和电压源附近各有一个开关，如图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211022200001.png width=50%>  <ul><li>当$S_1$闭合、$S_2$打开时，电压源会向电容器充电。  </li><li>当$S_1$打开、$S_2$闭合时，电容器会放电到$R_2$。<br>因此该电路通过控制$S_1$、$S_2$的开闭来控制电容器的充放电。  </li></ul></li><li>$S_1$、$S_2$开关连接至RS触发器电路，RS触发器的R端和S端分别连接两个比较器，如图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211022200338.png width=50%>  <ul><li>当输入电压$V_{in}&gt;V_1$时，上方的比较器向触发器的S端发送高电平，而下方比较器由于$V_2&gt;V_{in}$则不会向R端发送高电平，此时RS触发器的输入逻辑：$S=1,R=0$，根据RS触发器的真值表可以得到$Q=1,\overline{Q}=0$，$S_1$闭合、$S_2$打开时，电压源会向电容器充电。  </li><li>当输入电压$V_{in}&lt;V_1$时，下方的比较器向触发器的R端发送高电平，而上方比较器由于$V_{in}&lt;V_1$则不会向S端发送高电平，此时RS触发器的输入逻辑：$S=0,R=1$，根据RS触发器的真值表可以得到$Q=0,\overline{Q}=1$，$S_1$打开、$S_2$闭合，使电容器放电。  </li></ul></li></ol><blockquote><p>RS 触发器真值表：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211022205217.png width=50%>  </p></blockquote><p>当输入$V_{in}$是一个正弦波或者方波时，与$V_1$、$V_2$的大小关系会被自动触发，从而形成稳定而连续的三角波波形，其波形如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211022201022.png width=50%>  </p><h2 id="555定时器"><a href="#555定时器" class="headerlink" title="555定时器"></a>555定时器</h2><p>555定时器是一种利用电容器充放电性质的电路元件，它可以通过直流电压输出稳定的方波。其元件内部结构如图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211022201421.png width=80%>  </p><p>其中的NPN晶体管作用类似于开关。上方三个$5kΩ$的分压器将输入电压$V_{cc}$分割成$\frac{2}{3}V_{cc}$和$\frac{1}{3}V_{cc}$并分别送入比较器2、1。其中比较器2将$\frac{2}{3}V_{cc}$与外接电压Threshold进行比较，比较器1将$\frac{1}{3}V_{cc}$与外接电压Trigger进行比较，以控制SR触发器的输入。<br>同时，555定时器还支持使用ControlVoltage替代$\frac{2}{3}V_{cc}$作为比较电压。SR触发器的输出为Ouput和Reset。<br>555定时器有三种工作状态（电路连接方式）：非稳态、单稳态和多稳态，这三种连接分别可以产生三种不同的方波波形。  </p><h3 id="非稳态模式"><a href="#非稳态模式" class="headerlink" title="非稳态模式"></a>非稳态模式</h3><p>非稳态模式(Astable)下555定时器的连接图如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211022210029.png width=80%></p><p>如图，VCC分别作为内部和外部电路的电压源，外部电路是一个基本的RC电路。而外部电路的输出端与Threshold和Trigger连接，从而起到自我触发的效果。<br>开始时电容器充电，当$Threshold&gt;\frac{2}{3}V_{cc}$时，SR触发器输入逻辑为：$R=1,S=0$，输出为低电平，同时由于$\overline{Q}=1$，NPN晶体管被导通，电容器开始放电。<br>当$Threshold&lt;\frac{2}{3}V_{cc}$时，SR触发器输入逻辑为：$R=0,S=1$，输出为高电平，同时由于$\overline{Q}=0$，NPN晶体管关断，电容器充电。<br>此后，由于Threshold/Trigger电压的变化，电容器会不断地进行充放电，从而在输出端产生稳定的高低电平方波，而电容器处产生稳定的锯齿波三角波，且周期占空比与输出的方波信号完全相同:<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211022210401.png width=50%>  </p><p>可以发现锯齿波/三角波的上下限为$\frac{2}{3}V_{CC}$和$\frac{1}{3}V_{CC}$。  </p><p>在电路连接时往往还会增加另一个电容$C_2$以提高电路的稳定性。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211104164835.png width=50%>  </p><h4 id="有关计算"><a href="#有关计算" class="headerlink" title="有关计算"></a>有关计算</h4><p>在电容器充电过程，电流实际上流过了外部的两个电阻$R_1、R_2$，因此充电过程的时间常数：$τ_1=(R_1+R_2)C_1$。<br>放电过程中电流只流过了$R_2$,因此放电过程的时间常数：$τ_2=R_2C_1$。<br>根据数学推导得到充电时间：   </p><script type="math/tex; mode=display">t_{char}=ln2(R_1+R_2)C_1</script><p>放电时间：  </p><script type="math/tex; mode=display">t_{Discr}=ln2R_2C_1</script><p>周期：  </p><script type="math/tex; mode=display">T=t_{char}+t_{Discr}=ln2(R_1+2R_2)C_1</script><p>振荡频率：  </p><script type="math/tex; mode=display">f_r=\frac{1}{T}=\frac{1.44}{(R_1+2R_2)C_1}</script><p>定义输出波形一周期内的高电平出现时间占整个周期时间的比例为占空比，有：  </p><script type="math/tex; mode=display">Duty Cyecle=\frac{R_1+R_2}{R_1+2R_2}× 100\%</script><p><strong>因此，非稳态的555定时器输出的方波可以通过改变$R_1$和$R_2$的值改变占空比。</strong><br>可以发现这种基本的非稳态555振荡器配置的问题在于占空比，因为电阻$R_2$的存在使得占空比永远大于50%。<br>换句话说，该电路不能使输出“ON”时间短于“OFF”时间，因为$(R_1 + R_2)C$ 总是大于$R_1C$的值。  </p><blockquote><p>当$R_2$远大于$R_1$时，$Duty Cyecle=50\%$。  </p></blockquote><p><strong>$V_{Control}$对输出波形的影响</strong>：<br>充放电时间中的参数$ln2$实际上是由$\frac{1}{3}V_{CC}$和$\frac{2}{3}V_{CC}$进行决定的：  </p><script type="math/tex; mode=display">Const=ln\frac{V_{CC}-0.5V_{Control}}{V_{CC}-V_{Control}}</script><p>当$V_{CC}=15V,V_{Control}=\frac{2}{3}V_{CC}$时，$Const=ln2$。<br>如果Pin5：Control-Voltage接入直流电压，则$V_{Control}≠\frac{2}{3}V_{CC}$。<br>此时产生的三角波的上下限应该为：$\frac{1}{3}V_{CC}-V_{Control}$。<br>输出的方波周期发生变化，高电平和低电平的持续时间同比例增加或者减小，占空比仍然保持不变。  </p><h4 id="50-占空比555稳定器"><a href="#50-占空比555稳定器" class="headerlink" title="50%占空比555稳定器*"></a>50%占空比555稳定器*</h4><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211104165149.png width=50%>   </p><p>555振荡器现在产生50％的占空比作为定时电容， $C_1$ 现在通过相同的电阻器充电和放电， $R_2$ 而不是如前所述通过定时器放电引脚7放电。当555振荡器的输出为高电平时，电容器通过 $R_2$ 充电，当输出为低电平时，它通过 $R_2$ 放电。电阻器 $R_1$ 用于确保电容器完全充电至与电源电压相同的值。</p><h3 id="单稳态模式"><a href="#单稳态模式" class="headerlink" title="单稳态模式*"></a>单稳态模式*</h3><p>单稳态模式由于振荡电容器$C_1$直接接地，因此电容器在充电后直接放电至接地，所以在单稳态模式下，555定时器的输出只会产生一个方波信号，其电路图如下所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211022211852.png width=80%><br>方波信号的持续时间：  </p><script type="math/tex; mode=display">τ=1.1R_1C_1</script>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>电子系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>07. 模拟基带信号的非线性调制和解调方法</title>
    <link href="/2021/10/18/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/7.%20%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%B0%83%E5%88%B6%C2%B7%E8%A7%A3%E8%B0%83/"/>
    <url>/2021/10/18/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/7.%20%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%B0%83%E5%88%B6%C2%B7%E8%A7%A3%E8%B0%83/</url>
    
    <content type="html"><![CDATA[<h1 id="模拟基带信号的非线性调制和解调方法"><a href="#模拟基带信号的非线性调制和解调方法" class="headerlink" title="模拟基带信号的非线性调制和解调方法"></a>模拟基带信号的非线性调制和解调方法</h1><p>载波信号：  </p><script type="math/tex; mode=display">C(t)=Acos(ω_ct+φ_0)</script><p>除了可以用载波信号的幅度携带基带信号之外，还可以用基带信号的角频率和相位携带基带信号，这两种方法都是非线性调制。<br>非线性调制的后信号的频谱会有额外增加的频率成分。<br>通常非线性调制的带宽远远大于线性调制的带宽，因此非线性调制通过牺牲其有效性增加可靠性。  </p><h2 id="调相"><a href="#调相" class="headerlink" title="调相"></a>调相</h2><p>设载波可以表示为：$φ(t)=K_pm(t)$<br>其中$K_p$称为相位敏感度（Phase Sensitivity）。  </p><script type="math/tex; mode=display">S_{PM}=Acos(ω_ct+K_pm(t))</script><p>当$m(t)=A_mcosω_mt$时：  </p><script type="math/tex; mode=display">S_{PM}(t)=Acos(ω_ct+K_pA_mcosω_mt)</script><p>称$m_P=K_pA_m$为调相指数：  </p><script type="math/tex; mode=display">S_{PM}(t)=Acos(ω_ct+m_Pcosω_mt)</script><h2 id="调频"><a href="#调频" class="headerlink" title="调频"></a>调频</h2><p>调频将基带信号携带到相位分量的微分形式上：$\frac{dφ(t)}{dt}=K_fm(t)$。<br>其中$K_f$称为频率敏感度（Frequency Sensitivity）。  </p><script type="math/tex; mode=display">S_{FM}=Acos[ω_ct+K_f∫m(t)dt]</script><p>当$m(t)=A_mcosω_mt$时：  </p><script type="math/tex; mode=display">S_{FM}=Acos[ω_ct+\frac{K_fA_m}{ω_m}sinω_mt]</script><p>称$m_f=\frac{K_fA_m}{ω_m}$为调相指数：  </p><script type="math/tex; mode=display">S_{FM}(t)=Acos(ω_ct+m_fsinω_mt)</script><h3 id="调频的非相干解调"><a href="#调频的非相干解调" class="headerlink" title="调频的非相干解调"></a>调频的非相干解调</h3><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211018184136.png width=50%>  </p><p>调频可以通过非相干解调进行，输出的信号为：  </p><script type="math/tex; mode=display">s_o(t)=K_d[ω_c+K_fm(t)]</script><p>通过低通滤波器：   </p><script type="math/tex; mode=display">s_o(t)=K_dK_fm(t)</script><h3 id="调频的相干解调（窄带信号）"><a href="#调频的相干解调（窄带信号）" class="headerlink" title="调频的相干解调（窄带信号）"></a>调频的相干解调（窄带信号）</h3><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211018184413.png width=50%>  </p><p>窄带信号的调频输出信号为：  </p><script type="math/tex; mode=display">m_o(t)=\frac{A}{2}K_fm(t)</script><h3 id="宽带调频参数"><a href="#宽带调频参数" class="headerlink" title="宽带调频参数"></a>宽带调频参数</h3><p>宽带调频时，其带宽存在如下关系：  </p><script type="math/tex; mode=display">B_{FM}≈2(Δf+f_H)=2(m_f+1)f_H</script><p>其中$Δf$是最大频率分量。<br>调频后的能量：  </p><script type="math/tex; mode=display">P_{FM}=\frac{A^2}{2}</script><p>调频的信噪比增益：  </p><script type="math/tex; mode=display">G=3m_f^2(m_f+1)</script><h2 id="调频和调相的关系"><a href="#调频和调相的关系" class="headerlink" title="调频和调相的关系"></a>调频和调相的关系</h2><p>$f(t)$积分后的信号通过积分器后调相的结果是其调频结果。<br>$f(t)$微分后的信号通过微分器后调频的结果是其调相结果。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211018183409.png width=50%>  </p><p>所有调制方法的信噪比增益如图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211018184536.png width=50%></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>通信原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04. 振荡器</title>
    <link href="/2021/10/17/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%AD%90%E7%B3%BB%E7%BB%9F/4.%20Osillator/"/>
    <url>/2021/10/17/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%AD%90%E7%B3%BB%E7%BB%9F/4.%20Osillator/</url>
    
    <content type="html"><![CDATA[<h1 id="振荡器"><a href="#振荡器" class="headerlink" title="振荡器"></a>振荡器</h1><h2 id="巴克豪森稳定性准则"><a href="#巴克豪森稳定性准则" class="headerlink" title="巴克豪森稳定性准则"></a>巴克豪森稳定性准则</h2><p>反馈放大器在提升增益的同时降低了放大器的稳定性，可以利用反馈放大器在高增益下低稳定性的特点制作振荡器，使得输入的直流信号能够被振荡从而产生交流信号。<br>振荡器电路的框图如下：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211017143453.png width=50%>  </p><p>要形成稳定的振荡波形，反馈电路中不能有外源输入存在，或者说外源输入对其无影响，根据反馈的$G=\frac{V_{o}}{V_{in}}=\frac{A}{1+AB}$可知，当$|AB|=1$时可以满足这一条件。<br>此外，反馈信号的相位和输入信号的相位相同，否则在叠加时产生的相移会使振荡不均匀。<br>因此，制造稳定振荡的两个条件：</p><ol><li><p>对于反馈：$G=\frac{A_v}{1+A_vB}$，$|AB|=1$：   </p><ul><li>当$|AB|&gt;1$时，每一次反馈都会加强信号，无法产生稳定的振荡波形：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211104144246.png width=30%>  </li><li>当$|AB|<1$时，每一次反馈都会削弱信号，无法产生稳定的振荡波形：  <img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211104144334.png width=30%>  </li><li>当$|AB|=1$时，每一次的反馈信号和输入信号相同，可以产生稳定的振荡波形：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211104144501.png width=30%>  </li></ul></li><li><p>反馈信号的相位与放大电路输入信号的相位相同。</p><ul><li>对于正反馈放大器，其反馈信号的相位和输入信号的相位相同。</li><li>对于负反馈放大器，反馈信号的相位和输入信号的相位相差180°，因此需要人为添加相移器对相移进行复位。    </li></ul></li></ol><p>这两个条件称为<strong>巴克豪森稳定性准则</strong>。满足这两个条件的反馈电路才可以产生稳定的正弦波。  </p><h2 id="文氏电桥振荡器"><a href="#文氏电桥振荡器" class="headerlink" title="文氏电桥振荡器"></a>文氏电桥振荡器</h2><p>由于正反馈放大器可以带来振荡，负反馈放大器可以带来稳定性，文氏电桥振荡器结合了上述两种反馈放大器的优点，其电路如图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211101214746.png width=50%><br>文氏电桥振荡器的 正相输入端连接的是一个由RC组成的带通滤波器电路，与正相输入端构成振荡电路，产生振荡。 其中带通滤波器的电路如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211017140810.png width=50%><br>这个带通滤波器的作用是选择特定频率的信号传入正反馈放大器，从而产生振荡。<br>其频率响应特性曲线如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211017141408.png width=50%>  </p><p>可以发现，当信号频率为:  </p><script type="math/tex; mode=display">f_r=\frac{1}{2πRC}</script><p>时，带通滤波器的相移为0，满足条件2。<br>文氏电桥的输出与放大器的同相输入端相连，此时放大器可以看做是一个同相放大器。<br>通过数学计算$|AB|=1$可以发现，这个结果取决于同相放大器的电压增益$A_v$，当电压增益$A_v=1+\frac{R_f}{R_g}≥3$时才能满足这一条件。  </p><blockquote><p>这一部分的数学推导：<a href="https://blog.csdn.net/weixin_43996900/article/details/106189102">https://blog.csdn.net/weixin_43996900/article/details/106189102</a>  </p></blockquote><p>同时放大器的反相输入端可视为一个反相放大器，以负反馈确保电路输出稳定。  </p><h2 id="相移振荡器"><a href="#相移振荡器" class="headerlink" title="相移振荡器"></a>相移振荡器</h2><p>由于负反馈放大器本身可以满足$|AB|=1$的条件，另一种满足相移条件的方式是将负反馈放大器连接到相移器电路上，当相移器能够实现信号相移180°时即可使电路输出稳定的正弦波。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211017150508.png width=50%>  </p><h3 id="相移器"><a href="#相移器" class="headerlink" title="相移器"></a>相移器</h3><p>相移器通过高通滤波器的并联实现，根据高通滤波器的频率响应关系和相移公式可知，每个相移器的相移为：  </p><script type="math/tex; mode=display">Δφ=arctan\frac{X_c}{R}</script><p>通过调整电路中RC的值即可使其在输入信号频率$f_r$固定的情况下产生特定的相移。<br>当高通滤波器并联时，要使相移平均到高通滤波器，有如下公式：  </p><script type="math/tex; mode=display">f_r=\frac{1}{2πRC\sqrt{2N}}</script><p>其中$N$代表高通滤波器的个数，它与相移之间满足如下关系:</p><script type="math/tex; mode=display">Δφ=\frac{N}{180°}</script><p>需要注意的是，$N$的值越大，所需要的器件越多，同时由于每个高通滤波器在$f_r$处的增益都小于0，对所连接的运算放大器电压增益的要求也更高：运算放大器的电压增益需要大于所有高通滤波器在$f_r$的增益之和，该电路才能正常工作。通常认为<strong>$A_v≥29$</strong>。<br>同时，根据高通滤波器的相频响应图可知，二阶90°相移器的$f_r$无限趋近于0，不具有实用性。  </p><h2 id="松弛振荡器"><a href="#松弛振荡器" class="headerlink" title="松弛振荡器"></a>松弛振荡器</h2><p>松弛振荡器电路如图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/312px-OpAmpHystereticOscillator.svg.png width=50%>  </p><p>其反相输入端可以看做是一个振荡电路，通过电容的充放电可以产生三角波，而同相输入端可以看做是一个同相放大器。<br>当所有电阻阻值、所有电容阻值都相等时，有电路的谐振频率：  </p><script type="math/tex; mode=display">f_r=\frac{1}{2.2RC}</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211017151737.png width=50%></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>电子系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05. 离散傅里叶级数·离散傅里叶变换</title>
    <link href="/2021/10/14/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/5.%20%E7%A6%BB%E6%95%A3%E5%82%85%E9%87%8C%E5%8F%B6%E7%BA%A7%E6%95%B0%C2%B7%E7%A6%BB%E6%95%A3%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"/>
    <url>/2021/10/14/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/5.%20%E7%A6%BB%E6%95%A3%E5%82%85%E9%87%8C%E5%8F%B6%E7%BA%A7%E6%95%B0%C2%B7%E7%A6%BB%E6%95%A3%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="离散傅里叶级数·离散傅里叶变换"><a href="#离散傅里叶级数·离散傅里叶变换" class="headerlink" title="离散傅里叶级数·离散傅里叶变换"></a>离散傅里叶级数·离散傅里叶变换</h1><h2 id="复指数序列的周期性"><a href="#复指数序列的周期性" class="headerlink" title="复指数序列的周期性"></a>复指数序列的周期性</h2><p>$x[n]=e^{jω_0n}$，由于$ω_0∈[0,2π)$的周期性，因此有：$x[n]=e^{jω_0n}=e^{j(ω_0+2πk)n}$，令$ω_0N=2πk,k∈Z$，有：  </p><script type="math/tex; mode=display">x[n]=e^{jω_0n}=e^{j(ω_0+2πk)n}=x[n+N]</script><p>复指数序列$x[n]$具有周期性，称$N$为其周期。<br>由于$ω_k=\frac{2πk}{N}∈[0,2π)$，因此当序列周期为$N$时，当且仅当$k=0,1,2,…,N-1$时存在$N$个不同的$ω_k$。$N=\frac{2πk}{ω_0}$。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/A5EC68750987DF38D05E1771EF035FF2.png width=50%></p><h2 id="离散傅里叶级数（DFS）"><a href="#离散傅里叶级数（DFS）" class="headerlink" title="离散傅里叶级数（DFS）"></a>离散傅里叶级数（DFS）</h2><p>根据连续时间周期信号的傅里叶变换：  </p><script type="math/tex; mode=display">x(t)=∑_{k=-∞}^∞X(kΩ_0)e^{jkΩ_0t}</script><p>其中连续信号的角频率为：$Ω_0=\frac{2π}{T}$<br>类比连续时间周期信号，设周期序列$\tilde{x}[n]$:$\tilde{x}[n]=\tilde{x}[n+rN],r∈Z$，有：  </p><script type="math/tex; mode=display">\tilde{x}[n]=∑_{k=-∞}^∞X(kΩ_0)e^{j\frac{2π}{N}kn}</script><p>由于满足条件的频率分量$ω_k$只有$N$个：  </p><script type="math/tex; mode=display">\begin{aligned}    \tilde{x}[n]&=∑_{k=-∞}^∞X(kΩ_0)e^{j\frac{2π}{N}kn}\\    &=∑_{k=0}^{N-1}X(kΩ_0)e^{j\frac{2π}{N}kn}\\    &=\frac{1}{N}∑_{k=0}^{N-1}\tilde{X}[k]e^{j\frac{2π}{N}kn}\end{aligned}</script><p>其中$\tilde{X}[k]$为离散傅里叶级数系数，可反推得到：  </p><script type="math/tex; mode=display">\tilde{X}[k]=∑_{n=0}^{N-1}\tilde{x}[n]e^{-j\frac{2π}{N}kn}</script><p>定义$W_N^{kn}=e^{-j(\frac{2π}{N})kn}$，有离散傅里叶级数分析：  </p><script type="math/tex; mode=display">\tilde{X}[k]=∑_{n=0}^{N-1}\tilde{x}[n]W_N^{kn}</script><p>离散傅里叶级数合成：  </p><script type="math/tex; mode=display">\tilde{x}[n]=\frac{1}{N}∑_{k=0}^{N-1}\tilde{X}[k]W_N^{-kn}</script><blockquote><p>$W_N^{kn}$是复数的角度表示形式，一般计算时转化为z域中的坐标以方便计算。如:$W_4^2=e^{-j\frac{2π}{4}×2}=-1$  </p></blockquote><h3 id="离散傅里叶级数的意义"><a href="#离散傅里叶级数的意义" class="headerlink" title="离散傅里叶级数的意义"></a>离散傅里叶级数的意义</h3><p><strong>周期为$N$的序列可以表示为$N$个周期为$N$的复指数序列的线性组合</strong>。  </p><h4 id="离散傅里叶级数与离散时间傅里叶变换（DTFT）的关系"><a href="#离散傅里叶级数与离散时间傅里叶变换（DTFT）的关系" class="headerlink" title="离散傅里叶级数与离散时间傅里叶变换（DTFT）的关系"></a>离散傅里叶级数与离散时间傅里叶变换（DTFT）的关系</h4><p>事实上，可以将离散傅里叶级数看作是<strong>对离散时间傅里叶变换结果$X(e^{jω})$以周期为$N$做延拓后，对其进行采样的结果。</strong><br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211014165116.png width=50%>  </p><h4 id="离散傅里叶级数与Z变换的关系"><a href="#离散傅里叶级数与Z变换的关系" class="headerlink" title="离散傅里叶级数与Z变换的关系"></a>离散傅里叶级数与Z变换的关系</h4><p>给定Z变换：$X(z)|_{z=e^{jω}}=X(e^{jω})$，那么：  </p><script type="math/tex; mode=display">\tilde{X}[k]=X(z)|_{z=e^{j(2π/N)k}}=X(e^{j(2π/N)k}),k=0,1,...,N-1</script><p>即离散傅里叶级数可以看做是在Z变换的单位圆上做均匀采样的结果。  </p><h3 id="离散傅里叶级数的性质"><a href="#离散傅里叶级数的性质" class="headerlink" title="离散傅里叶级数的性质"></a>离散傅里叶级数的性质</h3><ol><li>周期性：如果$\tilde{x}[n]$的周期为$N$，$\tilde{X}[k]$的周期同样为$N$。  </li><li>线性：$a\tilde{x_1}[n]+b\tilde{x_2}[n]↔a\tilde{X_1}[k]+b\tilde{X_2}[k]$  </li><li>时移：$\tilde{x}[n-m]↔W^{km}_N\tilde{X}[k]$  </li><li>频移：$\tilde{X}[k-l]↔W^{-nl}_N\tilde{x}[n]$  </li><li>对偶性：如果$\tilde{x}[n]↔\tilde{X}[k]$，那么$\tilde{X}[n]↔N\tilde{x}[-k]$</li></ol><h3 id="周期卷积"><a href="#周期卷积" class="headerlink" title="周期卷积"></a>周期卷积</h3><p>如果两个序列$\tilde{x_1}[n]$、$\tilde{x_2}[n]$有相同的周期$N$，有:</p><script type="math/tex; mode=display">\tilde{x_1}[n]\tilde{⊗}\tilde{x_2}[n]=∑_{m=0}^{N-1}\tilde{x_1}[m]\tilde{x_2}[n-m]↔\tilde{X_1}[k]\tilde{X_2}[k]</script><p>周期卷积定理可以被矩阵化为：  </p><script type="math/tex; mode=display">\tilde{x}[n]\tilde{⊗}\tilde{y}[n]=\left[\begin{matrix}    \tilde{z}[0] \\    \tilde{z}[1] \\    ...\\    \tilde{z}[N-2] \\    \tilde{z}[N-1]\end{matrix}\right]|_{periodic}=\left[\begin{matrix}    \tilde{y}[0] & \tilde{y}[N-1] & ...& \tilde{y}[2] & \tilde{y}[1]\\    \tilde{y}[1] & \tilde{y}[0] & ...& \tilde{y}[3] & \tilde{y}[2]\\    ...&...&...&...&...\\    \tilde{y}[N-2] & \tilde{y}[N-1] & ...& \tilde{y}[0] & \tilde{y}[N-1]\\    \tilde{y}[N-1] & \tilde{y}[N-2] & ...& \tilde{y}[1] & \tilde{y}[0]\\\end{matrix}\right]\left[\begin{matrix}    \tilde{x}[0] \\    \tilde{x}[1] \\    ...\\    \tilde{x}[N-2] \\    \tilde{x}[N-1]\end{matrix}\right]</script><p>可以发现矩阵$Y$内部每一列的元素在进行周期性的位置轮换。<br>周期卷积计算可以在MATLAB®中使用命令<code>toeplitz(x,y)</code>得到，其中<code>x</code>,<code>y</code>为两个周期序列单周期内所有元素组成的向量，两个向量长度相同。  </p><blockquote><p>当两向量长度不等时，使用0进行补齐。  </p></blockquote><h2 id="离散傅里叶变换（DFT）"><a href="#离散傅里叶变换（DFT）" class="headerlink" title="离散傅里叶变换（DFT）"></a>离散傅里叶变换（DFT）</h2><p>当离散傅里叶序列变换的对象变成非周期有限长度序列时，此时的变换称为离散傅里叶变换（DFT）：  </p><script type="math/tex; mode=display">X[k]=∑_{n=0}^{N-1}x[n]W_N^{kn},0≤n≤N-1</script><p>其反变换为：  </p><script type="math/tex; mode=display">x[n]=\frac{1}{N}∑_{k=0}^{N-1}X[k]W_N^{-kn},0≤n≤N-1</script><h3 id="离散傅里叶变换的性质"><a href="#离散傅里叶变换的性质" class="headerlink" title="离散傅里叶变换的性质"></a>离散傅里叶变换的性质</h3><ol><li>线性：$a{x_1}[n]+b{x_2}[n]↔a{X_1}[k]+b{X_2}[k],0≤k≤N-1$  </li><li>对偶性:如果${x}[n]↔{X}[k]$，那么$\tilde{X}[n]↔N{x}[(-k)mod(N)],0≤k≤N-1$</li><li>$N$点循环时移：$x[(n-m)mod(N)]↔W^{km}_NX[k],0≤k≤N-1$</li></ol><div class="note note-info">            <p>$(n+m)modN$运算的含义是取序列的$0-N$部分以$N$为周期进行延拓，延拓后的序列向左平移$m$个单位，取现在序列$0-N$的结果。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211016144821.png width=50%>  </p>          </div><h3 id="离散傅里叶变换-DFT-、离散傅里叶级数（DFS）、离散时间傅里叶变换（DTFT）、Z变换的关系"><a href="#离散傅里叶变换-DFT-、离散傅里叶级数（DFS）、离散时间傅里叶变换（DTFT）、Z变换的关系" class="headerlink" title="离散傅里叶变换(DFT)、离散傅里叶级数（DFS）、离散时间傅里叶变换（DTFT）、Z变换的关系"></a>离散傅里叶变换(DFT)、离散傅里叶级数（DFS）、离散时间傅里叶变换（DTFT）、Z变换的关系</h3><p>不难看出周期序列$\tilde{x}[n]$做傅里叶级数分析后一周期内（$0≤n≤N-1$）的结果与$x[n]$做离散傅里叶变换的结果完全一致。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211016143431.png width=50%></p><p>可以发现：<strong>离散傅里叶级数是对离散时间傅里叶变换的结果进行采样，而一周期内的采样结果则为离散傅里叶变换的结果。</strong><br>周期序列$\tilde{x}[n]$做傅里叶级数分析后一周期内（$0≤n≤N-1$）的结果与$x[n]$做离散傅里叶变换的结果完全一致。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211016143431.png width=50%></p><p>可以发现：<strong>离散傅里叶级数是对离散时间傅里叶变换的结果进行采样，而一周期内的采样结果则为离散傅里叶变换的结果。</strong><br>对于Z变换，$z=re^{jω}$，如果选择$r=1$，那么Z变换将退化为离散时间傅里叶变换：  </p><script type="math/tex; mode=display">X(e^{jω})=X(z)|_{z=e^{jω}}</script><p>因此，Z域单位圆上的任意一点表示$e^{jω}$。<br>而离散傅里叶变换是对离散时间傅里叶变换一周期内的采样，因此离散傅里叶变换是在Z域单位圆上的均匀采样。  </p><h3 id="循环卷积-圆周卷积"><a href="#循环卷积-圆周卷积" class="headerlink" title="循环卷积/圆周卷积"></a>循环卷积/圆周卷积</h3><p>定义两个序列非周期序列的$N$点$x[n]$、$y[n]$循环卷积/圆周卷积（Circular shift）为：  </p><script type="math/tex; mode=display">x[n]⊗_Ny[n]=∑_{m=0}^{N-1}x[m]y[(n-m)mod(N)]</script><p>$x[n]$和$y[n]$具有相同的序列长度，两个序列长度如果不相同，使用0进行补齐。<br>其物理意义是将其中一个序列反转（称为反褶）后，进行$N$点循环时移$m$次，与原序列线性卷积的结果。<br>同样地，循环卷积也可以被矩阵化为：  </p><script type="math/tex; mode=display">x[n]⊗y[n]=\left[\begin{matrix}    z[0] \\    z[1] \\    ...\\    z[N-2] \\    z[N-1]\end{matrix}\right]=\left[\begin{matrix}    y[0] & y[N-1] & ...& y[2] & y[1]\\    y[1] & y[0] & ...& y[3] & y[2]\\    ...&...&...&...&...\\    y[N-2] & y[N-1] & ...& y[0] & y[N-1]\\    y[N-1] & y[N-2] & ...& y[1] & y[0]\\\end{matrix}\right]\left[\begin{matrix}    x[0] \\    x[1] \\    ...\\    x[N-2] \\    x[N-1]\end{matrix}\right]</script><p>利用矩阵化后的式子可以高效地在时域计算循环卷积。  </p><p>在频域上，循环卷积对应两个序列DFT的乘积：  </p><script type="math/tex; mode=display">x[n]⊗y[n]↔X[k]Y[k]</script><p>当$N$大于两个序列的长度时，直接将两个序列的长度用0填充到长度$N$，再进行循环卷积。<br>当$N$小于两个序列的长度时，循环卷积时则会发生混叠（Alising）。长度为$L$的序列$x[n]$发生混叠的过程表示为：  </p><script type="math/tex; mode=display">\begin{aligned}x[0],x[1],...,&x[N],...,x[L-2],x[L-1]\\    &⇓\\x[0]+x[N],x[1]+&x[N+1],...,x[N-1]+x[2N-1]\end{aligned}</script><h4 id="循环卷积与线性卷积的关系"><a href="#循环卷积与线性卷积的关系" class="headerlink" title="循环卷积与线性卷积的关系"></a>循环卷积与线性卷积的关系</h4><p><strong>当循环卷积的点数大于$2L-1$（即线性卷积的长度）时，其结果与线性卷积（$x[n]*y[n]$）完全相同。</strong>  </p><h4 id="循环卷积与周期卷积的关系"><a href="#循环卷积与周期卷积的关系" class="headerlink" title="循环卷积与周期卷积的关系"></a>循环卷积与周期卷积的关系</h4><p>如果$\tilde{x_1}[n]$、$\tilde{x_2}[n]$分别对应是$x_1[n]$、$x_2[n]$以周期为$N$的延拓，有：  </p><script type="math/tex; mode=display">(x_1[n]⊗_Nx_2[n])R_N=\tilde{x_1}[n]\tilde{⊗}_N\tilde{x_2}[n]</script><p>$R_N$表示以周期为$N$的延拓。<br>即<strong>在周期卷积对象的主值序列是循环卷积对象时，$N$点循环卷积是$N$点周期卷积的主值序列。</strong></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>数字信号处理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>06. 线性调制的解调方法·抗噪性</title>
    <link href="/2021/10/14/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/6.%20%E7%BA%BF%E6%80%A7%E8%A7%A3%E8%B0%83/"/>
    <url>/2021/10/14/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/6.%20%E7%BA%BF%E6%80%A7%E8%A7%A3%E8%B0%83/</url>
    
    <content type="html"><![CDATA[<h1 id="线性调制的解调方法·抗噪性"><a href="#线性调制的解调方法·抗噪性" class="headerlink" title="线性调制的解调方法·抗噪性"></a>线性调制的解调方法·抗噪性</h1><p>线性调制的解调方法分为两种，其一为相干解调，适用于所有线性调制方法。其二为非相干解调（包络解波法），仅适用于调幅。  </p><h2 id="相干解调"><a href="#相干解调" class="headerlink" title="相干解调"></a>相干解调</h2><p>相干解调法适用于所有的线性调制，其过程如图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211218213249.png width=80%>  </p><p>如图，当信号传入解调端后，信号与另一个同频同相的载波相乘，通过低通滤波器过滤出直流分量即可得到复原后的信号$m_o(t)$。</p><h3 id="调幅、双边带调制的相干解调"><a href="#调幅、双边带调制的相干解调" class="headerlink" title="调幅、双边带调制的相干解调"></a>调幅、双边带调制的相干解调</h3><p>对于调幅（AM）：<br>输入进解调部分的信号:$S_{AM}(t)=[A_0+m(t)]cos(ω_ct+φ_0)$。<br>这个信号将与一个同频同相的载波相乘：  </p><script type="math/tex; mode=display">\begin{aligned}    ρ(t)&=[A_0+m(t)]cos(ω_ct+φ_0)cos(ω_ct+φ_0)\\    &=\frac{1}{2}[A_0+m(t)][cos(φ_0-φ_0)+cos(2ω_ct+2φ_0)]\end{aligned}</script><p>由于通常载波频率$ω_c$非常的高，因此通过低通滤波器时$cos(2ω_ct+2φ_0)$一项被过滤掉，只留下直流分量：  </p><script type="math/tex; mode=display">m_0=\frac{1}{2}[A_0+m(t)]</script><blockquote><p>低通滤波器只需要保证$m(t)$的频谱分量能够通过即可，因此理想的低通滤波器的截止频率应当为$ω_m$，实际上通常为$1.5ω_m$。</p></blockquote><p>接下来信号进入减法器，减去直流$\frac{1}{2}A_0$后得到最终的输出：  </p><script type="math/tex; mode=display">m_0=\frac{1}{2}m(t)</script><p>对于双边带调制（DSB）其过程与上述过程基本相同，由于双边带调制后的信号不存在直流分量$\frac{1}{2}A_0$，因此无需通过减法器。  </p><p>可以得到解调后信号的能量：  </p><script type="math/tex; mode=display">S_o|_{AM}=S_o|_{DSB}=\frac{\overline{m^2(t)}}{4}</script><p>非相干解调在$A_0+m(t)&gt;&gt;n_i(t)$时的结果和相干解调的各项值完全相同。  </p><h3 id="单边带调制的相干解调"><a href="#单边带调制的相干解调" class="headerlink" title="单边带调制的相干解调"></a>单边带调制的相干解调</h3><p>进入解调部分的信号：$S_{SSB}=\frac{1}{2}m(t)cosω_ct∓\frac{1}{2}\hat{m(t)sinω_ct}$，与同频同相位的载波相乘：  </p><script type="math/tex; mode=display">ρ(t)=\frac{1}{4}[m(t)cos(φ_0-φ_0)∓\hat{m}(t)sin(φ_0-φ_0)]+\frac{1}{4}[m(t)cos(2\omega_ct+2φ_0)∓\hat{m}(t)sin(2ω_c t+2φ_0)]</script><p>通过低通滤波器过滤掉含有$ω_c$的部分：  </p><script type="math/tex; mode=display">m_o(t)=\frac{1}{4}[m(t)cos(φ_0-φ_0)∓\hat{m}(t)sin(φ_0-φ_0)]</script><p>通过时协同步器，可以得到：</p><script type="math/tex; mode=display">m_o(t)=\frac{1}{4}m(t)</script><p>可以得到解调后信号的能量：  </p><script type="math/tex; mode=display">S_o|_{SSB}=\frac{\overline{m^2(t)}}{16}</script><h2 id="非相干解调（包络检波法）"><a href="#非相干解调（包络检波法）" class="headerlink" title="非相干解调（包络检波法）"></a>非相干解调（包络检波法）</h2><p>非相干解调（包络检波法）仅适用于调幅，对于$|m(t)|_{max}≤A_0$的调制信号，其通过如下图所示的包络线检测电路（本质上是低通滤波器的改装）后，即可消除保留波形图中幅度变化较大的部分，从而保留包络线。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211016155523.png width=50%>  </p><h2 id="相干解调过程的噪声"><a href="#相干解调过程的噪声" class="headerlink" title="相干解调过程的噪声"></a>相干解调过程的噪声</h2><p>对于解调过程，假设输入进解调模组的加性高斯白噪声为$n_p$，其可以分为同相分量和正交分量两部分：$n_p(t)=n_ccosω_ct-n_s(t)sinω_ct$。<br>这两部分与载波相乘：  </p><script type="math/tex; mode=display">\begin{aligned}    n_p(t)&=[n_ccosω_ct-n_s(t)sinω_ct]cosω_ct\\    &=\frac{1}{2}n_c(t)+\frac{1}{2}[n_c(t)cos2ω_ct--n_s(t)sin2ω_ct]\end{aligned}</script><p>通过低通滤波器过滤掉含有$ω_c$的部分：  </p><script type="math/tex; mode=display">n_o(t)=\frac{1}{2}n_c(t)</script><p>那么输出噪声的能量为：</p><script type="math/tex; mode=display">N_o=\frac{1}{4}N_i</script><p>由于DSB、AM与SSB的输入噪声能量不相同，有：  </p><script type="math/tex; mode=display">N_o|_{AM}=N_o|_{DSB}=\frac{n_0f_H}{2}</script><script type="math/tex; mode=display">N_o|_{SSB}=\frac{n_0f_H}{4}</script><p>可以得到三种调制模式在输出端的信噪比：  </p><script type="math/tex; mode=display">SNR_o|_{AM}=SNR_o|_{DSB}=\frac{\overline{m^2(t)}}{\frac{n_0f_H}{2}}</script><script type="math/tex; mode=display">SNR_o|_{SSB}=\frac{\overline{m^2(t)}}{\frac{n_0f_H}{4}}</script><h2 id="信噪比增益"><a href="#信噪比增益" class="headerlink" title="信噪比增益"></a>信噪比增益</h2><p>定义信噪比增益：  </p><script type="math/tex; mode=display">G=\frac{SNR_o}{SNR_i}</script><p>即解调端的信噪比与调制端的信噪比之比。<br>可求得三种调制模式的信噪比增益为：  </p><script type="math/tex; mode=display">G=\begin{cases}    \frac{2\overline{m^2(t)}}{A_0^2+\overline{m^2(t)}}≤\frac{2}{3}...AM \\    2...DSB\\    1...SSB\\\end{cases}</script><blockquote><p>在不能直接通过信噪比增益衡量调制效果的好坏，事实上，当输入信号相同时，DSB和SSB的抗噪性能理论上是相等的。  </p></blockquote><h2 id="总结：线性调制的解调的性质"><a href="#总结：线性调制的解调的性质" class="headerlink" title="总结：线性调制的解调的性质"></a>总结：线性调制的解调的性质</h2><div class="table-container"><table><thead><tr><th style="text-align:center">线性调制方法</th><th style="text-align:center">输出信号</th><th style="text-align:center">解调后功率</th><th style="text-align:center">解调后噪声</th><th style="text-align:center">输出信噪比$SNR_o$</th><th style="text-align:center">信噪比增益</th></tr></thead><tbody><tr><td style="text-align:center">调幅</td><td style="text-align:center">$\frac{1}{2}m(t)$</td><td style="text-align:center">$\frac{1}{4}\overline{m^2(t)}_{co}$ <br> $\overline{m^2(t)}_{noc}$</td><td style="text-align:center">$\frac{n_0f_H}{2}_{co}$ <br> ${2n_0f_H}_{noc}$</td><td style="text-align:center">$\frac{\overline{m^2(t)}}{2n_0f_H}_{co}$ <br> $\frac{\overline{m^2(t)}}{2n_0f_H}_{noc}$</td><td style="text-align:center">$\frac{2\overline{m^2(t)}}{A_0^2+\overline{m^2(t)}}≤\frac{2}{3}$</td></tr><tr><td style="text-align:center">双边带调制</td><td style="text-align:center">$\frac{1}{2}m(t)$</td><td style="text-align:center">$\frac{1}{4}\overline{m^2(t)}$</td><td style="text-align:center">$\frac{n_0f_H}{2}$</td><td style="text-align:center">$\frac{\overline{m^2(t)}}{2n_0f_H}$</td><td style="text-align:center">$2$</td></tr><tr><td style="text-align:center">单边带调制</td><td style="text-align:center">$\frac{1}{4}m(t)$</td><td style="text-align:center">$\frac{1}{16}\overline{m^2(t)}$</td><td style="text-align:center">$\frac{n_0f_H}{4}$</td><td style="text-align:center">$\frac{\overline{m^2(t)}}{4n_0f_H}$</td><td style="text-align:center">$1$</td></tr></tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>通信原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03. 反馈放大器</title>
    <link href="/2021/10/14/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%AD%90%E7%B3%BB%E7%BB%9F/3.%20Feedbacks/"/>
    <url>/2021/10/14/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%AD%90%E7%B3%BB%E7%BB%9F/3.%20Feedbacks/</url>
    
    <content type="html"><![CDATA[<h1 id="反馈放大器"><a href="#反馈放大器" class="headerlink" title="反馈放大器"></a>反馈放大器</h1><p>反馈电路指将系统输出经过处理后加入输入信号的电路，基本的反馈结构如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211014132513.png width=50%>  </p><p>反馈电路由两部分组成：正向系统（输入→输出方向），其增益称为<strong>开环增益</strong>（Open-loop Gain），系统方程（S域）以$A(s)$或者$G(s)$表示；反馈系统（输出→输入方向）中的反馈系数可以理解为反馈量和输出量的比值，值越大，反馈越强，系统方程（S域）以$B(s)$或者$H(s)$表示。开环（电压）增益的物理意义是只看放大器的输出端口和输入端口的电压之比。<br>根据加法器的符号正负，可以分为正反馈系统和负反馈系统。<br>整个系统的<strong>闭环增益</strong>（Close-loop Gain）表示为：  </p><script type="math/tex; mode=display">Gain_{cl}=\frac{θ_o}{θ_i}=\frac{G(s)}{1-G(s)H(s)}</script><blockquote><p>“-“表示正反馈电路，”+”表示负反馈电路</p></blockquote><p>其物理意义是整个电路的输出端口与输入端口的电压之比。<br>当反馈因子为0时（物理意义为不连接反馈电路），闭环增益退化为开环增益。  </p><h2 id="反馈放大器类型"><a href="#反馈放大器类型" class="headerlink" title="反馈放大器类型"></a>反馈放大器类型</h2><p>放大器引入反馈电路的目的是为了便于控制放大器的频率响应特性，使其变得稳定或者是不稳定。<br>运算放大器通过反馈电路连接输入端的正相/反相端口分为正反馈和负反馈放大器电路。  </p><h3 id="反馈放大器的稳定性"><a href="#反馈放大器的稳定性" class="headerlink" title="反馈放大器的稳定性"></a>反馈放大器的稳定性</h3><p>对于反馈放大器电路，电路中的反馈部分可以是非线性元件：LC，此时反馈因子的方程$H(ω)$同样与频率有关，那么放大器的闭环增益可以表示为：  </p><script type="math/tex; mode=display">A_{cl}(ω)=\frac{G(ω)}{1-G(ω)H(ω)}</script><p>因此，反馈放大器的增益是随着频率而变化的。<br>当处于低频时，$B$接近于0使得整个式子退化为开环增益，因此上式可以同时描述放大器的开环增益和闭环增益，同称为放大器的电压增益$A_v(ω)=A_{cl}(ω)$。  </p><script type="math/tex; mode=display">A_{v}(ω)=\frac{G(ω)}{1-G(ω)H(ω)}</script><p>运算放大器增益随带宽（频率）的变化如图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/ddfdfsdf.png width=50%>  </p><p>由上图总结出：  </p><ol><li>在低频时，反馈电路上电容由于反馈信号频率太低处于断路状态，$B$接近于0，此时$A_v(ω)=G(ω)$放大器的增益是开环增益。  </li><li>在当频率增加到$ω_H$时，使得$|GH|=1$，在此之后，反馈放大器的增益变成闭环增益。  </li><li>带宽越大，放大器的稳定性能越好，但是同时放大器的增益越小。  </li></ol><p>事实上，反馈放大器的开环带宽和闭环带宽之间存在着如下关系：  </p><script type="math/tex; mode=display">B_{cl}=\frac{B_{ol}}{A_v}</script><p>  其中$A_v$是运算放大器的电压增益。   </p><h3 id="正反馈放大器（振荡器）"><a href="#正反馈放大器（振荡器）" class="headerlink" title="正反馈放大器（振荡器）"></a>正反馈放大器（振荡器）</h3><p>对正反馈放大器电路，其反馈系数为正:$H&gt;0$，其放大器增益（即系统的闭环增益）可以表示为：  </p><script type="math/tex; mode=display">A_{cl}=\frac{G}{1-|GH|}</script><p>正反馈虽然能够提高放大倍数，但会使电路工作变得不稳定。当$|GH|=1$时，系统增益为无穷，此时系统变得不稳定，产生正弦波<strong>振荡</strong>的电压信号。利用同相放大器的这一特性可以制作振荡器电路，将输入的直流信号变为交流信号，当$Gain$非常大时，输出电压会受到放大器工作电压的限制，最终输出的信号接近于方波。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211014141623.png width=50%>  </p><h3 id="负反馈放大器"><a href="#负反馈放大器" class="headerlink" title="负反馈放大器"></a>负反馈放大器</h3><p>对于负反馈放大器电路，其反馈系数为负数:$H&lt;0$，其放大器增益（即系统的闭环增益）可以表示为：  </p><script type="math/tex; mode=display">Gain=\frac{G}{1+|GH|}</script><p>在放大电路中引入负反馈，虽然会导致闭环增益的下降，但能使放大电路的许多性能得到改善。例如，可以提高增益的<strong>稳定性</strong>，扩展通频带，减小非线性失真，改变输入电阻和输出电阻等。</p><blockquote><p>给出了负反馈增益的具体推导，以及频率响应为什么和低通滤波器如此相似的原因：<a href="https://alan.ece.gatech.edu/ECE3040/Lectures/Lecture29-OP%20Amp%20Frequency%20Response.pdf">https://alan.ece.gatech.edu/ECE3040/Lectures/Lecture29-OP%20Amp%20Frequency%20Response.pdf</a></p></blockquote><h2 id="负反馈放大器的类型"><a href="#负反馈放大器的类型" class="headerlink" title="负反馈放大器的类型"></a>负反馈放大器的类型</h2><p>根据基本放大电路和反馈网络之间的端口连接方式可分为四类负反馈电路：</p><ol><li><p>输入端（Mixer）：</p><ul><li>串联反馈：串联连接（输入电压信号）</li><li>并联反馈：并联连接（输入电流信号）</li></ul></li><li><p>输出端（Sensing）：</p><ul><li>电压反馈：采样电压信号</li><li>电流反馈：采样电流信号  </li></ul></li></ol><p>输出端和输入端组合后有四种负反馈方式：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211014152046.png width=60%></p><blockquote><p>负反馈放大器，上海交通大学：<a href="https://nuedc-sh.sjtu.edu.cn/analog/kejian/chapter-5.pdf">https://nuedc-sh.sjtu.edu.cn/analog/kejian/chapter-5.pdf</a></p></blockquote><p>最简单的判断电路属于哪种反馈类型的方式为看电路中反馈部分两端是否存在额外的接地电阻，如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211014152437.png width=80%>  </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>电子系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Unit 16~18</title>
    <link href="/2021/10/03/%E6%97%A5%E8%AF%AD/N2%E5%A4%87%E8%80%83/Unit%2016~19/"/>
    <url>/2021/10/03/%E6%97%A5%E8%AF%AD/N2%E5%A4%87%E8%80%83/Unit%2016~19/</url>
    
    <content type="html"><![CDATA[<h1 id="Unit-16-18-ま行・や行・わ行"><a href="#Unit-16-18-ま行・や行・わ行" class="headerlink" title="Unit 16~18 ま行・や行・わ行"></a>Unit 16~18 ま行・や行・わ行</h1><h2 id="Unit-16-ま・も"><a href="#Unit-16-ま・も" class="headerlink" title="Unit 16 ま・も"></a>Unit 16 ま・も</h2><ul><li>まま（に）  <ul><li>動詞辞書形・名詞～の＋まま（に）  <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【任凭……】</span>  </span></li><li>動詞普通形・い形容詞・な形容詞・名詞～の＋まま（に）   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【保持……的样子】</span>  </span></li><li>動詞受身形＋まま   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【任人……】，消极地任人摆布</span>  </span></li></ul></li><li>も当然だ  <ul><li>動詞普通形～の・い形容詞～の・な形容詞～の・名詞＋も当然だ   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【……也是理所当然的】</span>  </span></li></ul></li><li>～も～ば～も・～も～なら～も <ul><li>名詞＋も＋動詞ば形・い形容詞ば形＋名詞＋も </li><li>名詞＋も＋な形容詞・名詞＋なら＋名詞＋も   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【既……又……】</span>  </span></li></ul></li><li>ものか・もんか<br>動詞普通形・な形容詞・い形容詞＋ものか・もんか   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【再也不会……】，强烈的否定意志，口语</span>  </span></li><li>もかまわず<br>動詞普通形～の・名詞＋もかまわず   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【不顾……】</span>  </span></li><li>ものがある<br>動詞普通形・い形容詞・な形容詞＋ものがある   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【的确很……】，表示评价和感受</span>  </span></li><li>ものだ  <ul><li>動詞普通形・い形容詞・な形容詞＋ものだ   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【理应……】</span>  </span></li><li>動詞た形＋ものだ   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">语气，表示对过去的感慨</span>  </span></li><li>動詞普通形・い形容詞・な形容詞＋ものだ   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">语气，表示强烈的感情</span>  </span></li><li>動詞ます形～たい＋ものだ   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【真想……】，强烈的愿望</span>  </span></li></ul></li><li>ものだから<br>動詞普通形・い形容詞・な形容詞・名詞～な＋ものだから   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【因为……】</span>  </span></li><li>ものではない<br>動詞辞書形＋ものではない   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【不要……】，从常识性的角度给出忠告</span>  </span></li><li>ものなら  <ul><li>動詞可能形＋ものなら   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【如果能……的话】，描述几乎无法实现的事情</span>  </span></li><li>動詞意向形＋ものなら   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【如果要……的话】，后项为严重的事情，且能被预料到</span>  </span>  </li></ul></li></ul><h2 id="Unit-17-も・や・よ・わ"><a href="#Unit-17-も・や・よ・わ" class="headerlink" title="Unit 17 も・や・よ・わ"></a>Unit 17 も・や・よ・わ</h2><ul><li>ものの　　<br>動詞普通形・い形容詞・な形容詞～な・名詞～である＋ものの　  <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【虽然……但是……】</span>  </span>  </li><li>矢先に  <ul><li>動詞た形＋矢先に  </li><li>動詞意向形＋とする・とした＋矢先に    <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【正要……的时候】</span>  </span></li></ul></li><li>やら～やら<br>動詞辞書形・い形容詞・名詞＋やら＋動詞辞書形・い形容詞・名詞＋やら    <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【一边……一边/是……又是……】</span>  </span>  </li><li>ようがない・ようもない<br>動詞ます形＋ようがない・ようもない   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【没有办法……】，想要做也无济于事</span>  </span>  </li><li>ようで<br>動詞普通形・い形容詞・な形容詞～な・名詞～の＋ようで   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【看上去像……，但……】，实际与想象不符合</span>  </span></li><li>ようでは<br>動詞辞書形・ない形～ない＋ようでは   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【如果是……的话，那就……】，后面是负面的事件</span>  </span></li><li>ようならば・ようだったら<br>動詞辞書形・ない形・い形容詞・な形容詞～な＋ようならば・ようだったら   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【如果是……的话】</span>  </span></li><li>わけがない・わけはない<br>動詞普通形・い形容詞・な形容詞～な＋わけがない・わけはない   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【不可能……】，强烈的、确信的判断</span>  </span></li><li>わけだ<br>動詞普通形・い形容詞・な形容詞～な＋わけだ <ol><li>  <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【就是……】，解释说明</span>  </span></li><li>  <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【因为……】</span>  </span></li></ol></li><li>わけではない・わけでもない<br>動詞普通形・い形容詞・な形容詞～な＋わけではない・わけでもない   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">并不是……</span>  </span></li></ul><h2 id="Unit-18-わ・を"><a href="#Unit-18-わ・を" class="headerlink" title="Unit 18 わ・を"></a>Unit 18 わ・を</h2><ul><li>わけにはいかない・わけにもいかない  <ul><li>動詞辞書形＋わけにはいかない・わけにもいかない   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【不做……】，出于责任义务等不能做</span>  </span></li><li>動詞ない形～ない＋わけにはいかない・わけにもいかない   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【不能不做……】，出于责任义务等必须要做……</span>  </span></li></ul></li><li>わりに（は）<br>動詞普通形・い形容詞・な形容詞～な＋割には   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【相反地……】，后项的行为违背由前项得出理所应当的结论</span>  </span></li><li>を中心に・を中心にして・を中心として<br>名詞＋を中心に・を中心にして・を中心として   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【以……为中心/重点】</span>  </span></li><li>を通して・を通じて<br>名詞＋を通して・を通じて <ol><li>  <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【在……的期间/内的范围】，常与时间名词连用</span>  </span>  </li><li>  <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【通过……】，后面是积极的结果</span>  </span></li></ol></li><li>を問わず・は問わず<br>名詞＋を問わず・は問わず   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【不论……】</span>  </span></li><li>を除いて（は）<br>名詞＋を除いて（は）   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【除了……之外】</span>  </span></li><li>をはじめ・をはじめとして・をはじめとする<br>名詞＋をはじめ・をはじめとして・をはじめとする   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【以……为代表的】</span>  </span></li><li>を踏まえて・を踏まえ・をふまえた<br>名詞＋を踏まえて・を踏まえ・をふまえた   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【在……基础上】</span>  </span></li><li>をめぐって・をめぐり・をめぐる<br>名詞＋をめぐって・をめぐり・をめぐる   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【围绕……】，常与讨论、争论等动词连用</span>  </span></li><li>をもとに（して）<br>名詞＋をもとに（して）   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【基于……】</span>  </span></li></ul>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
      <category>N2备考文法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日语</tag>
      
      <tag>N2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>04. Z变换</title>
    <link href="/2021/10/01/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/4.%20Z%E5%8F%98%E6%8D%A2/"/>
    <url>/2021/10/01/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/4.%20Z%E5%8F%98%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="Z变换"><a href="#Z变换" class="headerlink" title="Z变换"></a>Z变换</h1><h2 id="离散傅里叶变换的局限性"><a href="#离散傅里叶变换的局限性" class="headerlink" title="离散傅里叶变换的局限性"></a>离散傅里叶变换的局限性</h2><p>对于离散傅里叶变换$X(e^{jω})=∑x[n]e^{-jωn}$，要求原离散信号$x(n)$满足狄利克雷条件，即要求变换中的求和项收敛：  </p><script type="math/tex; mode=display">∑|x[n]|<∞</script><p>有大量的信号不能满足这一条件。  </p><h2 id="Z变换原理"><a href="#Z变换原理" class="headerlink" title="Z变换原理"></a>Z变换原理</h2><p>解决办法是在变换时添加一项$r^{-n}$，以在保留原信号特征的同时改善原信号的收敛性。</p><script type="math/tex; mode=display">X_r(e^{jω})=∑x[n]r^{-n}e^{-jωn}=∑x[n](re^{jω})^{-n}</script><p>将：$re^{jω}$简记为$z$，得到Z变换的变换公式：  </p><script type="math/tex; mode=display">X(z)=∑x[n]z^{-n}</script><p>Z变换可以将输入序列转变为以指数序列构成的线性组合。  </p><h3 id="收敛域"><a href="#收敛域" class="headerlink" title="收敛域"></a>收敛域</h3><p>此时要求改善后的信号满足狄利克雷条件，有：  </p><script type="math/tex; mode=display">∑|x[n]z^{-n}|<∞</script><p>满足这个条件的$z$的取值称为这个Z变换对的收敛域。<br>可以发现$|z|$的取值决定了整个线性组合是否满足狄利克雷条件。<br>当$|z|=1$时，Z变换退化为离散傅里叶变换，满足这一条件的所有$ω$的取值在傅里叶平面内构成一个单位圆：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211001141750.png width=30%>  </p><h4 id="收敛特性"><a href="#收敛特性" class="headerlink" title="收敛特性"></a>收敛特性</h4><p>序列的Z变换是否存在与收敛域有关，下面讨论不同类型序列的收敛域特征：  </p><div class="table-container"><table><thead><tr><th style="text-align:center">序列类型</th><th style="text-align:center">收敛域</th><th style="text-align:center">图示</th></tr></thead><tbody><tr><td style="text-align:center">右边序列：$x[n]=a^nu[n]$</td><td style="text-align:center">$‖z‖&gt;‖a‖$</td><td style="text-align:center"><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211001142544.png width=50%></td></tr><tr><td style="text-align:center">左边序列：$x[n]=-a^nu[-n-1]$</td><td style="text-align:center">$‖z‖&lt;‖a‖$</td><td style="text-align:center"><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211001142726.png width=50%></td></tr><tr><td style="text-align:center">双边序列:$x[n]=a^nu[n]-b^nu[-n-1]$</td><td style="text-align:center">$‖a‖&lt;‖z‖&lt;‖b‖$</td><td style="text-align:center"><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211001142950.png width=50%></td></tr></tbody></table></div><p>由上表可以总结出Z变换的三条性质：</p><ol><li>当且仅当收敛域包括单位圆时，原信号才能同时满足稳定性和因果性，其离散傅里叶变换存在。  </li><li>收敛域以极点（指数序列的基底）、0、无穷划分边界。  </li><li>在收敛域内不存在任何极点。  </li></ol><h3 id="Z反变换"><a href="#Z反变换" class="headerlink" title="Z反变换"></a>Z反变换</h3><h4 id="定义式"><a href="#定义式" class="headerlink" title="定义式"></a>定义式</h4><p>定义Z反变换为：  </p><script type="math/tex; mode=display">x[n]=\frac{1}{2πj}∮_{ROC}X(z)z^{n-1}dz</script><p>反变换的定义式涉及到曲线积分、计算比较困难，由于LIT系统的系统方程都能够写作多项式分数的形式，因此对LIT系统方程而言通常不采用求解定义式的方式来求解反变换，而更多地采用如下方法求解反变换式： </p><h4 id="Z变换式的部分分式形式"><a href="#Z变换式的部分分式形式" class="headerlink" title="Z变换式的部分分式形式"></a>Z变换式的部分分式形式</h4><p>序列$x(n)$的z变换式$X(z)$的一般形式可以写作由两个多项式组成的分式，称为部分分式：  </p><script type="math/tex; mode=display">X(z)=\frac{N(z)}{D(z)}=\frac{∑b_mz^m}{∑a_nz^n}</script><p>其中$b_m$称为方程的零点，$a_m$称为方程的极点。<br>当极点为一阶时,对等式两边同时除以$z$以提取常系数$A$：  </p><script type="math/tex; mode=display">\frac{X(z)}{z}=∑_{i=1}^N\frac{A_i}{z-a_i}</script><p>其中$A_i=(z-a_i)\frac{X(z)}{z}|_{z=a_i}$。<br>再乘上$z$：  </p><script type="math/tex; mode=display">X(z)=∑_{i=1}^N\frac{A_iz}{z-a_i}</script><p>其中$A_i$为$x(n)$的常系数，$a_i$为底数，也是极点。<br>对应的$x(n)$：</p><script type="math/tex; mode=display">x(n)=∑_{i=0}^∞A_i(a_i)^nu[n],n≥0</script><p>需要注意的是，需要根据$z-a_i$的正负对Z变换的收敛域进行讨论:  </p><ul><li>当$|z|&lt;(a_i)_{min}$时，根据极点对应序列形式（收敛特性一小节中提到的表格），该项对应的指数序列为左边序列$-A_i(a_i)^nu[-n-1]$。对应分式项$\frac{A_iz}{z-a_i}$应写作$-\frac{A_iz}{z-a_i}$以保证$z-a_i$恒正。  </li><li>当$|z|&gt;(a_i)_{max}$时，根据极点对应序列形式，该项对应的指数序列为右边序列$A_i(a_i)^nu[n]$。 对应分式项应写作$\frac{A_iz}{z-a_i}$以保证$z-a_i$恒正。  </li><li>当$a_{min}&lt;|z|&lt;a_{max}$时，根据极点对应序列形式，该项对应的指数序列为双边序列。</li></ul><h2 id="离散系统的频率响应与传递函数"><a href="#离散系统的频率响应与传递函数" class="headerlink" title="离散系统的频率响应与传递函数"></a>离散系统的频率响应与传递函数</h2><p>离散系统的差分方程可以写作：  </p><script type="math/tex; mode=display">∑_{k=0}^Na_ky[n-k]=∑_{k=0}^Mb_kx[n-k]</script><p>求得系统的传递函数为：  </p><script type="math/tex; mode=display">H(z)=\frac{Y(z)}{X(z)}=\frac{∑b_mz^m}{∑a_nz^n}</script><p>定义系统的频率响应为输入和输出的离散时间傅里叶变换结果之比：  </p><script type="math/tex; mode=display">H(e^{jω})=\frac{Y(e^{jω})}{X(e^{jω})}</script><p>当系统的极点在单位圆内，且零点没有限制时,Z变换和离散时间傅里叶变换存在如下关系：  </p><script type="math/tex; mode=display">H(z)|_{z=e^{jω}}=H(e^{jω})</script><p><strong>即$z=e^{jω}$。</strong> 带入频率响应，得到：  </p><script type="math/tex; mode=display">H(e^{jω})=\frac{b_0}{a_0}\frac{e^{jω(N-M)}Π_{k=1}^M(e^{jω}-b_k)}{Π_{k=1}^N(e^{jω}-a_k)}</script><p>可以发现$e^{jω}-b_k$和$e^{jω}-a_k$都表示从点$(b_k,0)$或$(a_k,0)$到单位圆上一点的向量。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211220151017.png width=50%></p><p>将系统的频率响应转化为角度表示：$H(e^{jω})=|H(e^{jω})|e^{∠H(e^{jω})}$，有：  </p><ul><li>系统方程的模长/幅度值(Magnitude)：  <script type="math/tex; mode=display">|H(e^{jω})|=\frac{Π零向量的模长}{Π极向量的模长}</script>即系统方程频率响应$H(e^{jω})$的幅度值-频率响应，简称幅频响应。  </li><li>系统方程的相位：  <script type="math/tex; mode=display">∠H(e^{jω})=∑零向量的角度-∑极向量的角度</script>即系统方程频率响应$H(e^{jω})$的相位-频率响应，简称相频响应。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>数字信号处理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02. 滤波器</title>
    <link href="/2021/10/01/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%AD%90%E7%B3%BB%E7%BB%9F/2.%20Filter/"/>
    <url>/2021/10/01/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%AD%90%E7%B3%BB%E7%BB%9F/2.%20Filter/</url>
    
    <content type="html"><![CDATA[<h1 id="滤波器"><a href="#滤波器" class="headerlink" title="滤波器"></a>滤波器</h1><p>滤波器按照滤波器本身是否消耗额外的能量（由于需要额外提供能量的组件多为运算放大器，因此也可按照有无运算放大器参与滤波分类）分为无源滤波器（额外不消耗能量、无运算放大器）和有源滤波器（额外消耗能量、有运算放大器）。<br>滤波器的阶数由滤波元件（L.C）的个数决定，在实际电路中，由于电感的体积较大，在集成电路设计中通常使用电容作为滤波元件。  </p><h2 id="无源滤波器"><a href="#无源滤波器" class="headerlink" title="无源滤波器"></a>无源滤波器</h2><p>无源滤波器的截止频率由$X_c=R$给出：  </p><script type="math/tex; mode=display">f_c=\frac{1}{2πRC}</script><h3 id="一阶低通滤波器"><a href="#一阶低通滤波器" class="headerlink" title="一阶低通滤波器"></a>一阶低通滤波器</h3><p>电路图如下所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211001134003.png width=60%>   </p><p>当电压信号频率增大时，电容容抗减小最终导致电容短路，$V_{out}=0$。<br>当电压信号频率减小时，电容容抗增大最终导致电容断路，此时$V_{out}$是有数值的。  </p><p>一阶低通滤波器的频率响应特性如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211008145727.png width=50%><br>相移规律如下：  </p><script type="math/tex; mode=display">φ=-arctan(\frac{R}{X_c})=-arctan(2πfRC)</script><p>当达到滤波器的截止频率时：$X_c=R$，因此相位移动为-45°。  </p><h4 id="二阶低通滤波器"><a href="#二阶低通滤波器" class="headerlink" title="二阶低通滤波器"></a>二阶低通滤波器</h4><p>由于无源滤波器都是线性滤波器，因此其特性实际上是一阶滤波器的线性叠加。<br>二阶无源低通滤波器的电路如图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211008145038.png width=50%><br>二阶低通滤波器的截止频率：  </p><script type="math/tex; mode=display">f_c=\frac{1}{2π√(R_1R_2C_1C_2)}</script><p>其频率响应特性如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211008145535.png width=50%><br>其相移为两个一阶滤波器的相移之和，即:</p><script type="math/tex; mode=display">φ=φ_1+φ_2</script><p>因此当滤波器达到截止频率时，其相移为-90°。  </p><h3 id="一阶高通滤波器"><a href="#一阶高通滤波器" class="headerlink" title="一阶高通滤波器"></a>一阶高通滤波器</h3><p>一阶高通滤波器的电路图与一阶低通滤波器的电路图相同，只是被测目标由电容改为了电阻。因此截止频率与一阶低通滤波器相同。<br>一阶高通滤波器的频率响应特性如图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211008145626.png width=50%><br>相移规律如下：  </p><script type="math/tex; mode=display">φ=arctan(\frac{R}{X_c})=arctan(2πfRC)</script><p>当达到滤波器的截止频率时：$X_c=R$，因此相位移动为45°。  </p><h4 id="二阶高通滤波器"><a href="#二阶高通滤波器" class="headerlink" title="二阶高通滤波器"></a>二阶高通滤波器</h4><p>二阶高通滤波器的电路图如图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211008150715.png width=50%>  </p><p>其频率响应特性图如图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211008150729.png width=50%><br>因此当滤波器达到截止频率时，其相移为90°  </p><h3 id="带通滤波器"><a href="#带通滤波器" class="headerlink" title="带通滤波器"></a>带通滤波器</h3><p>带通滤波器的电路图为一个高通滤波器与一个低通滤波器并联。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211008145829.png width=50%>  </p><p>其频率响应图如图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211008145910.png width=50%><br>对于带通滤波器，其拥有两个截止频率$f_H$和$f_L$，分别对应高通滤波器和低通滤波器的截止频率。  </p><script type="math/tex; mode=display">f_H=\frac{1}{2πR_1C_1},f_L=\frac{1}{2πR_2C_2}</script><blockquote><p>注意$f_H&lt;f_L$。  </p></blockquote><p>其中心响应频率(Central resonance frequency)是这两个截止频率乘积的平方根：  </p><script type="math/tex; mode=display">f_c=√f_L×f_H=\frac{1}{2π√(R_1R_2C_1C_2)}</script><p>带通滤波器的相移在达到中心响应频率时为0。<br>定义带通滤波器的品质因数$Q$:  </p><script type="math/tex; mode=display">Q=\frac{f_c}{BW}=\frac{f_c}{f_H-f_L}</script><p>有时候为了彻底阻隔高通滤波器和低通滤波器之间的相互影响，会在分流处放置一个缓冲器，如图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211008145947.png width=50%>   </p><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">电路图</th><th style="text-align:center">被测目标</th><th style="text-align:center">截止频率</th><th style="text-align:center">下降/上升斜率</th><th style="text-align:center">达到截止频率时的相移</th></tr></thead><tbody><tr><td style="text-align:center">一阶低通滤波器</td><td style="text-align:center"><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211001134003.png width=60%></td><td style="text-align:center">C</td><td style="text-align:center">$\frac{1}{2πRC}$</td><td style="text-align:center">-20dB</td><td style="text-align:center">-45°</td></tr><tr><td style="text-align:center">一阶高通滤波器</td><td style="text-align:center"><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211008150418.png width=50%></td><td style="text-align:center">R</td><td style="text-align:center">$\frac{1}{2πRC}$</td><td style="text-align:center">20dB</td><td style="text-align:center">45°</td></tr><tr><td style="text-align:center">二阶低通滤波器</td><td style="text-align:center"><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211008145038.png width=50%></td><td style="text-align:center">C</td><td style="text-align:center">$\frac{1}{2π√(R_1R_2C_1C_2)}$</td><td style="text-align:center">-40dB</td><td style="text-align:center">-90°</td></tr><tr><td style="text-align:center">二阶高通滤波器</td><td style="text-align:center"><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211008150715.png width=50%></td><td style="text-align:center">R</td><td style="text-align:center">$\frac{1}{2π√(R_1R_2C_1C_2)}$</td><td style="text-align:center">40dB</td><td style="text-align:center">90°</td></tr><tr><td style="text-align:center">带通滤波器</td><td style="text-align:center"><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211008145829.png width=50%></td><td style="text-align:center">R、C</td><td style="text-align:center">$f_r=\frac{1}{2π√(R_1R_2C_1C_2)}$ <br> $f_H=\frac{1}{2πR_1C_1}$ <br> $f_L=\frac{1}{2πR_2C_2}$</td><td style="text-align:center"><br> 20dB <br>-20dB</td><td style="text-align:center">0° <br> 90° <br> -90°</td></tr></tbody></table></div><h2 id="有源滤波器"><a href="#有源滤波器" class="headerlink" title="有源滤波器"></a>有源滤波器</h2><p>有源滤波器中含有运算放大器，因此其最大增益必定大于0dB。<br>简单的有源滤波器电路实质是无源滤波器的输出端与运算放大器电路的输入端连接得到的电路，加入运算放大器的好处有两点：  </p><ol><li>由于理想运算放大器内部输入阻抗远大于输出阻抗，因此在输出端运算放大器可以提供低的输出阻抗。  </li><li>激励电压信号/电流，减少信号在传输过程中的损失。  </li></ol><p>由于无源滤波器电路和运算放大器电路相互独立，因此<strong>有源滤波器的截止频率，上升速率等性质仍然与无源滤波器相同</strong>。<br>与无源滤波器不同的是，此时的最大增益不再为0dB，而是按照正相/反相运算放大器提供的最大增益进行计算。  </p><h3 id="有源滤波器的电路分析要点"><a href="#有源滤波器的电路分析要点" class="headerlink" title="有源滤波器的电路分析要点"></a>有源滤波器的电路分析要点</h3><ol><li>对于高阶滤波器，从无源滤波器入手，观察电流的分流点。  </li><li>找到每个无源滤波器与放大器输入端连接的节点，假设信号频率升高或者降低，观察此点的电压变化，由此判断出滤波器的类型（高通/低通）和放大器（正相/反相）的类型。  </li><li>根据滤波器输出电压判断滤波器类型和放大器类型，进行相应的计算。  </li></ol><h3 id="有源带通滤波器"><a href="#有源带通滤波器" class="headerlink" title="有源带通滤波器"></a>有源带通滤波器</h3><p>有源带通滤波器的结构为一个高通滤波器和低通滤波器分别跨在一个放大器的两侧串联构成，如图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211010181634.png width=50%><br>简化后的有源带通滤波器电路：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211010181757.png width=60%>  </p><h3 id="有源带阻滤波器"><a href="#有源带阻滤波器" class="headerlink" title="有源带阻滤波器"></a>有源带阻滤波器</h3><p>有源带阻滤波器由带通滤波器由低通和高通滤波器与放大器并联得到：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211010182053.png width=50%>  </p><p>带阻滤波器的计算方法和带通滤波器完全相同，其各参数为各无源滤波器参数的线性叠加。带阻滤波器的中心响应频率为：  </p><script type="math/tex; mode=display">f_c=√f_L×f_H</script><p>达到中心响应频率时，同带通滤波器，其相移为0°。<br>带阻滤波器的品质因数计算方法和带通滤波器完全相同。  </p><h4 id="陷波滤波器"><a href="#陷波滤波器" class="headerlink" title="陷波滤波器"></a>陷波滤波器</h4><p>陷波滤波器（Notch Filter）是带阻滤波器的一种，由于陷波滤波器的$f_L$和$f_H$相隔很近，其阻带很窄，因此也称点阻滤波器。常常用于去除固定频率分量或阻带很窄的地方。如用于去除直流分量，去除某些特定频率分量。<br>陷波滤波器的电路图和带阻滤波器完全相同，其频率响应特性如图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211010183524.png width=50%>  </p><p>陷波器的中心响应频率记作$f_N$，计算方法同带阻滤波器。  </p><blockquote><p>陷波器的相关资料：<a href="https://zh-cn.lambdageeks.com/notch-filter-circuit/#def">https://zh-cn.lambdageeks.com/notch-filter-circuit/#def</a></p></blockquote><h2 id="Sallen-Key-滤波器结构（二阶高通滤波器）"><a href="#Sallen-Key-滤波器结构（二阶高通滤波器）" class="headerlink" title="Sallen-Key 滤波器结构（二阶高通滤波器）"></a>Sallen-Key 滤波器结构（二阶高通滤波器）</h2><p>Sallen-Key滤波器是一种滤波器的搭建结构。其二阶高通滤波器的基本结构如图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211010184723.png width=50%><br>这种构造的滤波器可以通过直接改变运算放大器的增益来改变整个滤波器的最大增益，滤波器的最大增益由如下公式给出：  </p><script type="math/tex; mode=display">Gain_{max}=A×Q</script><p>其中$A$表示运算放大器的增益。<br>该放大器的中心响应频率为：  </p><script type="math/tex; mode=display">f_C=\frac{1}{2π√R_AR_BC_AC_B}</script><p>通常所有电阻的阻值相等，所有电容的电容值相等：  </p><script type="math/tex; mode=display">f_C=\frac{1}{2πRC}</script><p>Sallen-Key 滤波器的品质因数由如下公式给出：  </p><script type="math/tex; mode=display">Q=\frac{1}{3-A}</script><blockquote><p>Sallen-Key滤波器的带宽为3dB。  </p></blockquote><p>其频率响应曲线由品质因数$Q$决定：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211010185310.png width=50%>  </p><p>按照$f = f_0$附近频率特性的特点，可将滤波器分为巴特沃斯（Butterworth）、切比雪夫（Chebyshev）和贝塞尔（Bessel）三种类型。</p><blockquote><p><a href="https://www.eet-china.com/mp/a25110.html">https://www.eet-china.com/mp/a25110.html</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>电子系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05. 模拟基带信号的线性调制方法</title>
    <link href="/2021/09/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/5.%20%E7%BA%BF%E6%80%A7%E8%B0%83%E5%88%B6/"/>
    <url>/2021/09/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/5.%20%E7%BA%BF%E6%80%A7%E8%B0%83%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="模拟基带信号的线性调制方法"><a href="#模拟基带信号的线性调制方法" class="headerlink" title="模拟基带信号的线性调制方法"></a>模拟基带信号的线性调制方法</h1><h2 id="调制"><a href="#调制" class="headerlink" title="调制"></a>调制</h2><p>简单来说调制是将原本的信号（称为基带信号）$m(t)$与另一个确知信号（称为载波）$c(t)$一同进入乘法器，输出信号的过程。  </p><script type="math/tex; mode=display">S_m(t)=m(t)c(t)</script><p>需要注意的是，由于载波是确知信号，因此调制过程不会发生任何信息的变化。<br>使用调制的目的有三个：  </p><ol><li>由于天线与传输信号的波长之间存在匹配关系，通常天线的尺寸在$\frac{λ}{10}$到$\frac{λ}{4}$之间，经过调制的信号波长会变小，因此对应的传输天线的尺寸会对应减小以便于传输。  </li><li>调制使得多频复用称为可能，多个基带信号可以与不同的载波结合，实现同时传输多个基带信号。  </li><li>扩展信号带宽，提高系统抗干扰能力。  </li></ol><h3 id="调制方法的分类"><a href="#调制方法的分类" class="headerlink" title="调制方法的分类"></a>调制方法的分类</h3><ul><li>按基带信号的类型分为：数字调制和模拟调制</li><li>按照载波信号的类型可分为：连续波调制和脉冲调制</li><li>当载波为正弦波时，按照正弦波的受调参量可分为：  </li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">调制参量</th><th style="text-align:center">模拟信号调制方法</th><th style="text-align:center">数字信号调制方法</th></tr></thead><tbody><tr><td style="text-align:center">幅度(A)</td><td style="text-align:center">AM,DSB,SSB,VSB</td><td style="text-align:center">ASK</td></tr><tr><td style="text-align:center">频率(ω/f)</td><td style="text-align:center">FM</td><td style="text-align:center">FSK</td></tr><tr><td style="text-align:center">相位(ϕ)</td><td style="text-align:center">PM</td><td style="text-align:center">PSK,DPSK,QPSK,OQPSK</td></tr></tbody></table></div><ul><li>按已调信号的频谱结构可分为：线性调制和非线性调制  </li></ul><h3 id="线性调制及其解调方法概述"><a href="#线性调制及其解调方法概述" class="headerlink" title="线性调制及其解调方法概述"></a>线性调制及其解调方法概述</h3><p>线性调制后，不会有新的频率成分产生。因此线性调制只能在受调参量为幅度时使用。<br>线性调制的方法分为：调幅（AM），双边带调制（DSB），单边带调制（SSB），残留边带调制（VSB）。这几种线性调制方法简图如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211222195912.png width=70%>  </p><p>线性调制的解调方法分为两类：相干解调和非相干解调，两者的简图如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211218213249.png width=70%> </p><h2 id="调幅"><a href="#调幅" class="headerlink" title="调幅"></a>调幅</h2><p>标准调幅系统的框图如下。基带信号与一个直流信号叠加后进行抬升，然后以正弦波为载波通过乘法器。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210930190538.png width=50%>  </p><p>标准调幅可以用数学公式表达为：  </p><script type="math/tex; mode=display">S_{AM}(t)=[A_0+m(t)]cosω_ct</script><p>已调信号可以被分解为不含信息的载波项$A_0cosω_ct$和含有信息的边带项$m(t)cosω_ct$。  </p><blockquote><p>上述公式成立暗含着$E(m(t))=0$，即基带信号本身不含直流信号这一条件。  </p></blockquote><p>在时域上表现为正弦信号的包络线实则为经过抬升后的基带信号。<br>在频域中:  </p><script type="math/tex; mode=display">S_{AM}(ω)=πA_0[δ(ω+ω_c)+δ(ω-ω_c)]+\frac{1}{2}[M(ω+ω_c)+M(ω-ω_c)]</script><p>其在频谱图上表示为两段对称的连续频谱和两个冲击频谱。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210930191355.png width=70%>  </p><h3 id="调幅后的信号参数"><a href="#调幅后的信号参数" class="headerlink" title="调幅后的信号参数"></a>调幅后的信号参数</h3><h4 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h4><p>由频谱可以看出,AM信号的频谱由载频分量、上边带（USB）、下边带(LSB)三部分组成。上边带的频谱结构与原调制信号的频谱结构相同,下边带是上边带的镜像。因此,AM信号是带有载波分量的双边带信号,它的带宽是基带信号带宽$f_H$的2倍,即:  </p><script type="math/tex; mode=display">B_{AM}=2f_H</script><h4 id="能量·调制效率"><a href="#能量·调制效率" class="headerlink" title="能量·调制效率"></a>能量·调制效率</h4><p>已调信号的平均功率可以表示为：  </p><script type="math/tex; mode=display">P_{AM}=\overline{S^2_{AM}}=\overline{A_0^2cos^2ω_ct}+\overline{m^2(t)cos^2ω_ct}+\overline{2A_0m(t)cos^2ω_0t}</script><p>经过化简可以得到：  </p><script type="math/tex; mode=display">P_{AM}=\frac{A_0^2}{2}+\frac{\overline{m^2(t)}}{2}</script><p>其中载波功率：$P_c=\frac{A_0^2}{2}$，边带功率：$P_s=\frac{\overline{m^2(t)}}{2}$<br>即<strong>调制后信号的平均功率为载波功率和边带功率之和。</strong><br>由于载波不携带任何信息，定义调制效率为边带功率与总功率之比以反映调制时信息的占比：  </p><script type="math/tex; mode=display">η_{AM}=\frac{P_s}{P_s+P_c}</script><h4 id="调幅指数"><a href="#调幅指数" class="headerlink" title="调幅指数"></a>调幅指数</h4><p>由于对标准调幅的解调实质上是求得其包络线函数，在波形图上观察，当$m(t)<A_0$时，波形图的上下包络线会发生重叠从而无法还原之前的包络线函数，导致失真。  <img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210930192908.png width=30%>  </p><p>因此要求:  </p><script type="math/tex; mode=display">|m(t)|_{max}≤A_0</script><p>定义调幅指数$β_{AM}$反映$|m(t)|_{max}$与$A_0$的关系：  </p><script type="math/tex; mode=display">β_{AM}=\frac{|m(t)|_{max}}{A_0}</script><ul><li>$β_{AM}&lt;1$： 正常调幅</li><li>$β_{AM}=1$： 满调幅</li><li>$β_{AM}&gt;1$： 过调幅</li></ul><p>当然$A_0$并不是越大越好，倘若$A_0$设置的过大，那么会导致信息含量下降，调幅效率降低。  </p><h3 id="随机信号的调幅"><a href="#随机信号的调幅" class="headerlink" title="随机信号的调幅"></a>随机信号的调幅</h3><p>当$m(t)$是一个高斯随机过程时，容易求得调幅过程的自相关函数：  </p><script type="math/tex; mode=display">R_{AM}=E[S_{AM}(t)S_{AM}(t+τ)]</script><p>其频谱仍然为：  </p><script type="math/tex; mode=display">P_{AM}(ω)=πA_0[δ(ω+ω_c)+δ(ω-ω_c)]+\frac{1}{2}[P_S(ω+ω_c)+P_S(ω-ω_c)]</script><p>对其进行积分，求得平均功率，可以发现上述有关平均功率的结论依然适用。  </p><h2 id="双边带调制-DSB"><a href="#双边带调制-DSB" class="headerlink" title="双边带调制(DSB)"></a>双边带调制(DSB)</h2><p>对于调幅，其调制效率的最大值在受调信号$m(t)$达到最大值$|m(t)|_{max}=A_m$时取得，此时的最大调制效率为：  </p><script type="math/tex; mode=display">η_{AM}=\frac{\frac{A_m^2}{2}}{A_0^2+\frac{A^2_m}{2}}=\frac{1}{3}</script><p>可以发现，$A_0$虽然抬高了受调信号，但是调制效率非常低下。<br>双边带调制改进了调幅办法，取消了用于抬高的直流信号$A_0$，其余部分与调幅相同，其调制过程框图如图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211011174430.png width=50%>  </p><p>整个调制过程的输出信号$S_{DSB}(t)$可以表示为：  </p><script type="math/tex; mode=display">S_{DSB}(t)=m(t)cosω_ct</script><p>在频域上：  </p><script type="math/tex; mode=display">S_{DSB}(ω)=\frac{1}{2}[M(ω-ω_c)+M(ω+ω_c)]</script><p>其频谱分量中不再有冲击分量。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211011175017.png width=50%>  </p><p>同调幅，其带宽仍然是原信号带宽的两倍。  </p><script type="math/tex; mode=display">B_{DSB}=B_{AM}=2f_H</script><p>由于去掉了$A_0$，双边带调制的能量为：  </p><script type="math/tex; mode=display">P_{DSB}=P_f=\frac{1}{2}\overline{m^2(t)}</script><p>最大调制效率为：  </p><script type="math/tex; mode=display">η_{max}=\frac{P_s}{P_c}=1</script><h2 id="单边带调制-SSB"><a href="#单边带调制-SSB" class="headerlink" title="单边带调制(SSB)"></a>单边带调制(SSB)</h2><p>调制过程的有效性用带宽利用率进行衡量，双边带调制的带宽比较大，因此其带宽利用率较低。同时通过对双边带调制结果的频谱分析，可以发现每个频谱成分中的半个边带（称为上边带/下边带）已经携带了受调信号的所有信息，因此考虑使用滤波器或者数学方法使得调制结果只包含单边带，以提高带宽利用率。这样的调制方法称为单边带调制。  </p><h3 id="滤波法"><a href="#滤波法" class="headerlink" title="滤波法"></a>滤波法</h3><p>滤波法使用一个滤波器$H_{SSB}(ω)$过滤出LSB或USB，其调制过程如图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211011180141.png width=50%>  </p><p>在实际运用中，由于LSB的峰值点和USB的峰值点非常接近，因此要求滤波器接近理想滤波情况，即要求滤波器在截止频率后的过滤频率剧烈变化。这样的滤波器设计在现实中是非常难实现的。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211011193413.png width=50%>  </p><h3 id="相移法"><a href="#相移法" class="headerlink" title="相移法"></a>相移法</h3><p>相移法通过数学上的希尔伯特变换使其能够将原信号变换为仅含有上边带或者下边带的部分。<br>对于正弦受调信号：$m(t)=A_mcosω_mt$，其受正弦双边带调制调制后的信号为：$S_{DSB}(t)=m(t)c(t)=A_mcosω_mtcosω_ct$。<br>利用积化和差公式可以得到：  </p><script type="math/tex; mode=display">S_{DSB}(t)=\frac{1}{2}cos(ω_c-ω_m)t+\frac{1}{2}A_mcos(ω_c+ω_m)t</script><p>其中加号连接的两项分别为上边带和下边带部分，因此下边带可以写作：   </p><script type="math/tex; mode=display">\begin{aligned}  S_{LSB}(t)&=\frac{1}{2}cos(ω_c-ω_m)t\\  &=\frac{1}{2}A_mcosω_mtcosω_ct+\frac{1}{2}A_msinω_mtsinω_ct \\  &=\frac{1}{2}m(t)cosω_ct+\frac{1}{2}\hat{m(t)}sinω_ct\end{aligned}</script><p>可以发现$sinω_mt$实际上是$cosω_mt$通过<br><strong>相移$-\frac{π}{2}$</strong>得来的。称将原信号$m(t)$在时域内相移$-\frac{π}{2}$的变换为希尔伯特变换，变换后的信号记为$\hat{m(t)}$。  </p><blockquote><p>希尔伯特变换表达式：$\hat{f(t)}=f(t)*\frac{1}{πt}$  </p></blockquote><p>同理，对上边带部分也有：  </p><script type="math/tex; mode=display">S_{USB}(t)=\frac{1}{2}m(t)cosω_ct-\frac{1}{2}\hat{m(t)}sinω_ct</script><p>因此相移法的调制结果可以表示为：  </p><script type="math/tex; mode=display">S_{SSB}=\frac{1}{2}m(t)cosω_ct ∓ \frac{1}{2}\hat{m(t)}sinω_ct</script><blockquote><p>注意上边带为“-”，下边带为“+”   </p></blockquote><p>无论哪一种调制方式，SSB结果的带宽都是DSB的一半：  </p><script type="math/tex; mode=display">B_{SSB}=\frac{1}{2}B_{DSB}=f_H</script><p>SSB调制后的能量可以表示为：  </p><script type="math/tex; mode=display">P_{SSB}=\frac{1}{2}\overline{\frac{1}{2}m^2(t)cos^2ω_ct}+\frac{1}{2}\overline{\frac{1}{2}\hat{m^2(t)}sin^2ω_ct}=\frac{1}{4}\overline{m^2(t)}</script><h2 id="残留边带调制（VSB）"><a href="#残留边带调制（VSB）" class="headerlink" title="残留边带调制（VSB）"></a>残留边带调制（VSB）</h2><p>残留边带调制VSB在双边带调制的基础上，通过设计滤波器，使信号一个边带的频谱成分原则上保留，另一个边带频谱成分只保留小部分（残留）。该调制方法既比双边带调制节省频谱，又比单边带易于解调。<br>可以理解为VSB利用过滤后残留的上边带和下边带部分拼凑出一个完整的信息。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211013085148.png width=50%>  </p><h2 id="线性调制过程的噪声"><a href="#线性调制过程的噪声" class="headerlink" title="线性调制过程的噪声"></a>线性调制过程的噪声</h2><p>由于所有的调制过程都是线性调制，而本课内默认所有噪声为高斯白噪声，根据平稳高斯随机过程通过线性系统的特点，可以得出线性调制过后的噪声应该和基带信号中的加性噪声能量相等：  </p><script type="math/tex; mode=display">N_{modulation}=N_{baseband}=n_0B</script><p>其中$n_0$表示噪声的功率谱密度，$B$表示调制后噪声的带宽。  </p><h2 id="信道衰减·输入信噪比"><a href="#信道衰减·输入信噪比" class="headerlink" title="信道衰减·输入信噪比"></a>信道衰减·输入信噪比</h2><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211211154702.png width=80%>  </p><p>经过线性调制后的信号通过发射机(TX)发送，进入信道，在信道中由于干扰和噪声，导致信号功率出现损失，使得接收机(RX)接收的信号功率与发射机发射的信号功率不同，定义信道中的衰减（ATU）为发射机发射功率与接收机接收功率之比：  </p><script type="math/tex; mode=display">ATU|dB=10lg\frac{P_{TX}}{P_{RX}}</script><p>因此，在解调模块处，接收机接收到的功率可以表示为：  </p><script type="math/tex; mode=display">P_{TX}=P_{RX} × ATU=P_{AM/DSB/SSB}</script><p><strong>在这个过程中，假设噪声通过信道时不会发生任何改变，噪声的功率仍然与基带信号中的噪声功率相同。</strong>  </p><p>定义输入信噪比($SNR_i$)为<strong>输入进解调模块的信噪比</strong>：  </p><script type="math/tex; mode=display">SNR_i=\frac{S_i}{N_i}</script><p>其中，$S_i=P_{RX}=P_{AM/DSB/SSB} / ATU$。<br>$N_i=N_{modulation}=n_0B$。  </p><h2 id="总结：线性调制方法的性质"><a href="#总结：线性调制方法的性质" class="headerlink" title="总结：线性调制方法的性质"></a>总结：线性调制方法的性质</h2><div class="table-container"><table><thead><tr><th style="text-align:center">线性调制方法</th><th style="text-align:center">输出表达式</th><th style="text-align:center">带宽</th><th style="text-align:center">调制后功率$P_{TX}$</th><th style="text-align:center">调制端噪声</th><th style="text-align:center">无衰减下的输入信噪比$SNR_i$</th></tr></thead><tbody><tr><td style="text-align:center">调幅(AM)</td><td style="text-align:center">$S_{AM}=(A_0+m(t))cosω_ct$</td><td style="text-align:center">$2f_H$</td><td style="text-align:center">$\frac{A_0^2}{2}+\frac{\overline{m^2(t)}}{2}$</td><td style="text-align:center">$2n_0f_H$</td><td style="text-align:center">$\frac{A_o^2+\overline{m^2(t)}}{4n_0f_H}$</td></tr><tr><td style="text-align:center">双边带调制(DSB)</td><td style="text-align:center">$S_{DSB}=m(t)cosω_ct$</td><td style="text-align:center">$2f_H$</td><td style="text-align:center">$\frac{\overline{m^2(t)}}{2}$</td><td style="text-align:center">$2n_0f_H$</td><td style="text-align:center">$\frac{\overline{m^2(t)}}{4n_0f_H}$</td></tr><tr><td style="text-align:center">单边带调制(SSB) <br> 残留边带调制(VSB)</td><td style="text-align:center">$S_{SSB}=\frac{1}{2} m(t)cosω_ct∓\frac{1}{2}\hat{m(t)}sinω_ct$ <br> $\hat{m(t)}$ 表示$m(t)$ 相移 $-\frac{π}{2}$ 的结果 <br> 即希尔伯特变换 <br> 保留上边带为“-”，下边带为“+”</td><td style="text-align:center">$f_H$</td><td style="text-align:center">$\frac{\overline{m^2(t)}}{4}$</td><td style="text-align:center">$n_0f_H$</td><td style="text-align:center">$\frac{\overline{m^2(t)}}{4n_0f_H}$</td></tr></tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>通信原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>讲义：什么是遗传算法（GA）？</title>
    <link href="/2021/09/30/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/%E8%AE%B2%E4%B9%89%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/"/>
    <url>/2021/09/30/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/%E8%AE%B2%E4%B9%89%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="讲义：什么是遗传算法？"><a href="#讲义：什么是遗传算法？" class="headerlink" title="讲义：什么是遗传算法？"></a>讲义：什么是遗传算法？</h1><blockquote><p>参考资料：</p><ol><li><em>Flappy Learning</em>- <a href="https://xviniette.github.io/FlappyLearning">https://xviniette.github.io/FlappyLearning</a></li><li><em>北京大兴国际机场旅客航站楼和综合换乘中心</em>, 北京市建筑设计研究院有限公司</li><li><em>Technological overview of the next generation Shinkansen high-speed train Series N700</em>, Central Japan Railway Company, Tokyo, Japan</li><li><em>Towards Safe Evolutionary Optimization</em>, Chao Qian, Nanjing University</li><li><em>‘Genshin Impact’: Building a Scalable AI System</em>, Shou Xu, miHoYo Inc., 2021</li><li><em>遗传算法在游戏开发中的应用</em>，杨科选等，中科院软件研究所，2009⋆</li><li><em>遗传算法原理及应用</em>，周明等，国防工业出版社，1999⋆</li><li><em>A genetic algorithm tutorial</em>, Darrell Whitley, 1994⋆</li><li><em>自然与人工系统中的适应:理论分析及其在生物控制和人工智能中的应用</em>,John.H.Holland ,高等教育出版社，2008⋆</li><li><em>Adaptation in Nature and Artificial Systems</em>,John.H.Holland, A Bradford Book, 2008 （9的英文版）⋆</li></ol></blockquote><div class="note note-warning">            <p>这是Brunel University London EE1619：Engineering Science, Systems and Society（工程科学、系统与社会）面向大一学生的一节Seminar的中文讲义。<br>本文中避免了对于Holland博士提出的经典遗传算法收敛性的讨论，省略了交叉、突变对于算法收敛性的改进作用；并在有效性方面只介绍了模式定理，还请读者注意。  </p>          </div><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><h3 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h3><ol><li>了解一些遗传算法的应用案例</li><li>了解经典遗传算法的运行流程</li><li>使用数学方法证明经典遗传算法的有效性</li><li>对遗传算法进行评价：知晓其优点和缺点  </li></ol><h3 id="遗传算法的定义"><a href="#遗传算法的定义" class="headerlink" title="遗传算法的定义"></a>遗传算法的定义</h3><p>遗传算法是一类将特定问题潜在的解决方案编码，然后应用进化理论对解决方案进行优胜劣汰式的反复筛选的算法。   </p><h2 id="遗传算法的应用"><a href="#遗传算法的应用" class="headerlink" title="遗传算法的应用"></a>遗传算法的应用</h2><h3 id="Github-开源项目FlappyLearning"><a href="#Github-开源项目FlappyLearning" class="headerlink" title="Github 开源项目FlappyLearning"></a>Github 开源项目FlappyLearning</h3><p>项目地址：<a href="https://xviniette.github.io/FlappyLearning/">https://xviniette.github.io/FlappyLearning/</a><br>项目通过每一代生成50个flappy bird，每一只鸟由随机的操作进行控制，通过游戏对其进行淘汰，而能够活得久，获得高分的游戏策略会有高概率继承给下一代。<br>大约在第25-50代时的鸟能够稳定地存活下去。<br>在游戏设计中，有些怪物可以应用遗传算法随机切换攻击模式，并通过进化和玩家的对抗不断地筛选出不容易被玩家打败的攻击模式，从而提升游戏可持续的难度。  </p><h3 id="大兴机场穹顶力学结构设计"><a href="#大兴机场穹顶力学结构设计" class="headerlink" title="大兴机场穹顶力学结构设计"></a>大兴机场穹顶力学结构设计</h3><p>大兴机场的穹顶设计使用了遗传算法来符合力学要求。具体而言，大兴机场的穹顶在在设计时，穹顶的主划分线被赋予了88个控制点，遗传算法可以对这88个控制点的位置进行选择，使建造出的穹顶不会倒塌。  </p><h3 id="新干线N700系车头外形"><a href="#新干线N700系车头外形" class="headerlink" title="新干线N700系车头外形"></a>新干线N700系车头外形</h3><p>高速铁路列车在通过隧道时由于列车和隧道对空气的挤压发出巨大的响声，新干线N700系列车在设计时通过遗传算法对列车的外形进行选择，最终设计出抗噪性较好的列车外形。  </p><h2 id="遗传算法的概念"><a href="#遗传算法的概念" class="headerlink" title="遗传算法的概念"></a>遗传算法的概念</h2><h3 id="举例：遗传算法面对的问题"><a href="#举例：遗传算法面对的问题" class="headerlink" title="举例：遗传算法面对的问题"></a>举例：遗传算法面对的问题</h3><p>开始之前，我们需要明确几个概念。<br>思考如下的场景：我们需要从一口井中取水，井中水的水位是由一个水阀进行控制，这个水阀有8个档位，每一个档位对应了不同的水位高度，要想更方便地取水自然水位的高度越高越好，现在我们想要找到那个最适合我们取水的档位，就可以用遗传算法解决这个问题。<br>在遗传算法中，这个水阀的8个档位实际上就是系统的八种状态，这八种状态对应了系统不同的输出，像这样的，<strong>系统的某些或全部状态的集合称为一个种群（Population）。</strong> 称这个<strong>状态集合中的一个特定状态为个体（Individual）或者染色体（Chromosome）。</strong>  </p><blockquote><p>此处要注意与生物学上个体和染色体的数量关系进行区分，遗传算法领域认为一个个体只含有一条染色体。  </p></blockquote><h2 id="经典遗传算法的流程"><a href="#经典遗传算法的流程" class="headerlink" title="经典遗传算法的流程"></a>经典遗传算法的流程</h2><p>经典遗传算法通过对当前种群的<strong>评估（Evaluation）</strong>，<strong>选择（Selection）</strong>，<strong>重组（Recombination）</strong>和<strong>突变（Mutation）</strong>  后，能够在现有种群的基础上产生下一代种群。经过数次进化之后，遗传算法能够选择出对目标问题解决的最佳方案组合。    </p><h3 id="状态编码"><a href="#状态编码" class="headerlink" title="状态编码"></a>状态编码</h3><p>当然，计算机是无法直接读懂这些状态的意义，对数学运算而言，函数的自变量也必须是一个数，因此需要对系统的所有状态进行编码（Coding）。<strong>编码的过程就是将状态用数进行编号的过程。</strong> 遗传算法中采用的编码机制是二进制编码，如上面例子当中水阀的8个档位，就可以用3个比特位（称为<strong>位串</strong>（Strings））：从000 编码到111，对这个水阀的8个档位状态进行表达。<br><strong>种群中的每一个个体都可以用位串的形式进行表达。</strong><br>编码之后的个体就能够用函数去评估它是好的还是坏的了。  </p><h3 id="原始种群"><a href="#原始种群" class="headerlink" title="原始种群"></a>原始种群</h3><p>由于实际问题中遗传算法要面临的状态编码数量非常庞大，不可能一下子对所有的状态都进行评估，因此遗传算法需要从所有个体中随机地抓取一些个体生成<strong>原始种群</strong>（Initial population）。遗传算法最开始的操作都是对原始种群进行的。  </p><h3 id="评估和适应度"><a href="#评估和适应度" class="headerlink" title="评估和适应度"></a>评估和适应度</h3><p>原始种群被生成后，每一个个体会通过评估函数和适应度函数（Fitness funtion）生成其对种群的适应度（Fitness）。  </p><p>对适应度函数的直观理解：<br>我们想要从一个班的学生中选择出优等生，最简单的方法就是考试，每个学生通过考试会得到一个分数，以衡量他们的学习水平。在这里，考试就是适应度函数，而每个学生的分数就是适应度。  </p><p>种群中个体$i$的适应度定义为：  </p><script type="math/tex; mode=display">\frac{f_i}{\overline{f}}</script><p>其中，$f_i$表示评估函数对第$i$个个体的评估结果，$\overline{f}$表示种群的平均评估。<br>个体的适应度越高，表明这个状态对应的系统结果越能够符合我们的要求。  </p><h3 id="复制·选择（轮盘赌选择）"><a href="#复制·选择（轮盘赌选择）" class="headerlink" title="复制·选择（轮盘赌选择）"></a>复制·选择（轮盘赌选择）</h3><p>选择后的每个个体的适应度格式为x.xx，即有小数部分和整数部分。适应度的整数部分表示该个体会被复制多少次。<br>复制中的选择机制：<br>这样就能直接地让优秀的个体获得更多被复制的机会，而适应度整数部分为0的个体因为不会被复制而被淘汰。<br>但是，那些适应度比较低的个体中仍然可能有对系统有益的部分，为了尽可能地保留这些部分，遗传算法在选择阶段还规定：<br>对所有的个体，适应度的小数部分表示额外被复制的概率。<br>如此，每一个个体中对系统有益的部分都能够被尽可能地复制。<br>比如，适应度2.3的个体能够获得2次复制，并且有0.3的概率能获得第三次复制的机会。<br>这样的机制能够用数学表示为：   </p><script type="math/tex; mode=display">M(H,t+1)=M(H,t)\frac{f(H,t)}{\overline{f}}</script><p>其中M表示的是种群中的一个亚种(Sub-populations)。  </p><p>总结：<br>选择的过程即为有概率地对种群中的个体进行复制，可以发现，适应度越高的个体被复制的概率就越大。  </p><p>原始种群经过复制后形成<strong>中间种</strong>（Intermediate Generation）。  </p><h3 id="重组（单点交叉）"><a href="#重组（单点交叉）" class="headerlink" title="重组（单点交叉）"></a>重组（单点交叉）</h3><p><strong>遗传算法中重组的本质是杂交（Crossover）</strong>，其过程主要有两步： </p><ol><li>随机地使得个体间两两配对。  </li><li>随机地选取一对个体，两者在某个随机且相同的比特位处断开，前后的两段基因型进行交叉互换。  </li></ol><p><img src="https://img-blog.csdnimg.cn/20191202151959116.gif#pic_center" alt=""></p><p>新生成的两个个体称为后代（Offspring），后代能够插入到下一代的概率计作$p_c$。  </p><h3 id="突变（反转突变）"><a href="#突变（反转突变）" class="headerlink" title="突变（反转突变）"></a>突变（反转突变）</h3><p>重组之后利用突变算子对后代作突变处理，对于种群中的所有比特位，其有$p_m$的概率发生比特反转。同遗传学一样，突变概率一个非常小的概率，通常小于1%。<br>中间种经过重组和突变，最终能称为新的种群。</p><p><div align="center">  <img src=https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210718132905.png width=80% />  </div></p><center>▲ 经典遗传算法的选择和重组过程</center>  <h2 id="遗传算法的有效性证明"><a href="#遗传算法的有效性证明" class="headerlink" title="遗传算法的有效性证明"></a>遗传算法的有效性证明</h2><p>上述的过程中很难直观地让我们感受到重组和突变对算法带来的实际效果，也很难感受到遗传算法的有效性，下面从数学的角度说明这两点。  </p><h3 id="采样空间"><a href="#采样空间" class="headerlink" title="采样空间"></a>采样空间</h3><p>在几何学上，称n维空间的某一个小于n维的子空间为<strong>超平面</strong>（hyperplane）， 比如二维空间的超平面是一条线，三位空间的超平面是一个面。<br><strong>在位串长度固定位$L$的前提下，种群中所有可能的编码方式所构成的空间称为搜索空间（Search space）。</strong> 如果每一种特定的编码方式在L维搜索空间中对应了一个角（Corner），那么共超平面的几个角对应的编码中必定在相同的某几个比特位上的值是相同的，此时引入通配符（Don‘t care，以*记）的概念，那么搜索空间的一个超平面就可以表示为含有Don’t care（*）的位串（比如：0****，11*****），这样的位串称为<strong>模式</strong>（Schema），每一个模式对应了一个超平面。   </p><h3 id="模式定理"><a href="#模式定理" class="headerlink" title="模式定理"></a>模式定理</h3><h4 id="适应度选择"><a href="#适应度选择" class="headerlink" title="适应度选择"></a>适应度选择</h4><p>由之前提出的经过选择后超平面$H$留存的样本（个体）数目$M(H,t+1)$：  </p><script type="math/tex; mode=display">M(H,t+1)=M(H,t)\frac{f(H,t)}{\overline{f}}</script><h4 id="重组的作用·定义距"><a href="#重组的作用·定义距" class="headerlink" title="重组的作用·定义距"></a>重组的作用·定义距</h4><p>考虑重组对选择后超平面$H$中种群样本数目的影响：</p><ol><li>重组是有概率发生的，概率为$p_c$。  </li><li>对于发生重组的种群，交叉既有可能产生出现有空间内某个模式的副本（比如100和010交叉就可能产生000，使得000的副本增加一个）即为$gains$，单位为个数，同时也有可能使得原有的样本消失，这个消失的概率记为$losses$。    </li></ol><p>那么现在后代中落在超平面$H$的样本数目：  </p><script type="math/tex; mode=display">M(H,t+1)=(1-p_c)M(H,t) \frac{f(H,t)}{\overline{f}} +p_c [M(H,t)\frac{f(H,t)}{\overline{f}}(1-losses)+gains]</script><p>模式定理认为gain发生的概率要远远小于losses。为了简化计算，忽略gain，并且假设发生在Schema上有义部分的交叉必然导致染色体破坏，记破坏概率为$disruption$，那么有：  </p><script type="math/tex; mode=display">M(H,t+1) \geq (1-p_c)M(H,t) \frac{f(H,t)}{\overline{f}} +p_c [M(H,t)\frac{f(H,t)}{\overline{f}}(1-disruption)]</script><p>定义超平面$H$的采样率表示超平面$H$的样本数目与种群中样本数目的比，以$P(H,t)$记。  </p><p><strong>定义距</strong>$Δ(H)$表示超平面$H$对应模式中第一个确定字符的位置和最后一个确定字符的位置之间的距离。如：$Δ( 011 ∗ 1 ∗ ∗ )=4$。<br>按照我们对重组的理解：<strong>对原信息的破坏只可能发生在定义距的区间段内。</strong>  </p><p>此外，如果发生重组的位串都在平面$H$内，那么重组也不可能对原本信息造成破坏，因此要想让重组破坏原有的信息，亲本中的另一条位串必定来自于其他平面，另一个位串来自其他平面的概率为$1-P(H,t)$。<br>由这上述两点可以将破坏概率定义为：  </p><script type="math/tex; mode=display">\frac{\Delta(H)}{L-1}(1-P(H,t))</script><p>由破坏的定义可以得出如下结论：<br><strong>定义距$Δ(H)$越小，模式受到破坏的概率就越小</strong>。从直观上来说，定义距越小，交叉发生在定义距内（即一定能破坏信息）的概率也越小。<br>那么下一代超平面$H$的采样率可以表示为：</p><script type="math/tex; mode=display">P(H,t+1) \geq P(H,t) \frac{f(H,t)}{\overline{f}} [1-p_c \frac{\Delta(H)}{L-1}(1-P(H,t))]</script><p>如果考虑亲代是基于适应度选择出来的：  </p><script type="math/tex; mode=display">P(H,t+1) \geq P(H,t) \frac{f(H,t)}{\overline{f}} [1-p_c \frac{\Delta(H)}{L-1}(1-P(H,t)\frac{f(H,t)}{\overline{f}})]</script><h4 id="突变的作用·模式阶"><a href="#突变的作用·模式阶" class="headerlink" title="突变的作用·模式阶"></a>突变的作用·模式阶</h4><p>最后，考虑突变的影响：记突变发生的概率为$p_m$，超平面$H$的阶数为$o(H)$，<strong>阶数表示模式中确定字符的个数，当突变发生在这些字符上时，才会对原来的位串产生破坏。</strong><br>那么表示超平面$H$的Schema不会受到突变影响的概率为：  </p><script type="math/tex; mode=display">(1-p_m)^{o(H)}</script><p>可以得出结论：<br><strong>模式的阶数$o(H)$越小,模式不会受到突变影响的概率越大</strong>。从直观上来看，模式的阶数代表着有效字符的个数，有效字符越少，在交叉过程中越容易被保留下来。<br>最终，超平面$H$在下一代中被采样到的概率可以表示为：  </p><script type="math/tex; mode=display">P(H,t+1) \geq P(H,t) \frac{f(H,t)}{\overline{f}} [1-p_c \frac{\Delta(H)}{L-1}(1-P(H,t)\frac{f(H,t)}{\overline{f}})] (1-p_m)^{o(H)}</script><h4 id="指数增长"><a href="#指数增长" class="headerlink" title="指数增长"></a>指数增长</h4><p>可以通过数学推算出，在适应度$\frac{f(H,t)}{\overline{f}}&gt;1$时：</p><script type="math/tex; mode=display">P(H,t) \frac{f(H,t)}{\overline{f}} [1-p_c \frac{\Delta(H)}{L-1}(1-P(H,t)\frac{f(H,t)}{\overline{f}})]=P(H,t) \frac{f(H,t)}{\overline{f}}(1-p_c \frac{\Delta(H)}{L-1})+[P(H,t) \frac{f(H,t)}{\overline{f}} ]^2</script><p>用$t=0$代来推算$t$代时候的采样率：  </p><script type="math/tex; mode=display">P(H,t) ≥ \{P(H,0) \frac{f(H,0)}{\overline{f}}(1-p_c \frac{\Delta(H)}{L-1})+[P(H,0) \frac{f(H,0)}{\overline{f}} ]^2\}^t(1-p_m)^{o(H)}</script><p>可以发现：<strong>在适应度$\frac{f(H,t)}{\overline{f}}&gt;1$时，采样率呈现指数型上升。</strong><br>可以总结为：<br><strong>在选择、重组、突变算子的作用下，当某个超平面的适应度大于1时，模式的阶数$o(H)$越小，定义距$Δ(H)$越小的个体越能够被保留下来，且数目成指数型上升。</strong><br>定义距和模式阶都是染色体本身的参数，通过重组和突变这两个参数被引入到进化中，并对选择起到了关键的作用。  </p><h4 id="对模式定理结论的直观理解"><a href="#对模式定理结论的直观理解" class="headerlink" title="对模式定理结论的直观理解"></a>对模式定理结论的直观理解</h4><p>定义距相当于基因的长度，基因越长，在进化过程中被破坏概率就越大，因此定义距越短的个体越容易在进化中得到保留。<br>例子：兔子的性状<br>模式阶相当于个体携带性状的个数。单纯的红眼兔显然比裂唇长耳红眼兔更容易传递给后代。因此模式阶越小，个体越容易在进化中得到保留。  </p><p>模式定理在数学上证明了重组和突变的有效性，并给出了采样率的下界，是遗传算法中重要的理论基础之一。  </p><h2 id="其他进化算法"><a href="#其他进化算法" class="headerlink" title="其他进化算法"></a>其他进化算法</h2><h3 id="Genitor-算法"><a href="#Genitor-算法" class="headerlink" title="Genitor 算法"></a>Genitor 算法</h3><blockquote><p>进化策略中细分为两种类型：$(μ+λ)-ES$和$(μ,λ)-ES$。<br>在$(μ+λ)-ES$机制中，亲代$μ$产生后代$λ$后，种群还会对亲代和后代共同进行选择，选择其中表现出色的个体生成下一代。在这种选择机制下，亲代会被保留直到被比亲代表现更出色的个体替代。<br>在$(μ,λ)-ES$机制中，后代被产生后就直接替代亲代，选择在后代中执行。这种进化机制在选择阶段与经典遗传算法近似。但是在重组阶段所采用的算子与经典遗传算法不同。<br>$(μ+λ)-ES$机制相比于$(μ,λ)-ES$机制，其被优化的后代数目一定是单调增加的。  </p></blockquote><p>传统的进化算法在进行到最后时，由于留存的都是表现的比较好的个体，因此采用适应度淘汰个体（即选择过程）的压力会随着算法运行次数的增加而不断减弱，最后甚至根本不能对个体有任何选择。Gnitor算法可以加强选择的压力，一定程度上避免这种情况的发生。<br>Genitor算法是一种使用$(μ+λ)-ES$机制的算法，其与经典遗传算法中的进化模型不同点有三处。  </p><ol><li>选择在亲代中执行，选择后的亲代产生的后代被立即投放到下一代种群中。  </li><li>后代不会替代亲代，但是每一代中适应度最差的个体被直接移除以加强选择压力。  </li><li>适应度函数通过排名算法（Ranking）而非比值来表现。排名也同样能够保持选择压力的有效性。  </li></ol><h4 id="排名算法"><a href="#排名算法" class="headerlink" title="排名算法"></a>排名算法</h4><p>设三个个体的适应度评估为：$h_1,h_2,h_3$.<br>首先对所有个体按照适应度从小到大排序，比如：$h_2,h_1,h_3$;<br>按照上面的顺序重新赋予fitness，即$f(h_2)=1,f(h_1)=2,f(h_3)=3$<br>计算选择概率:$p(h_2)=\frac{1}{1+2+3}=\frac{1}{6},p(h_1)=\frac{2}{6},p(h_3)=\frac{3}{6}$<br>排名算法能够不受制于适应度的限制，选择压力不会因为总体适应度的上升而减小，保证了选择的有效性。<br>同时排名算法的运行机制也参考了适应度，保证了选择的可靠性。  </p><h3 id="锦标赛（Tournaments）算法"><a href="#锦标赛（Tournaments）算法" class="headerlink" title="锦标赛（Tournaments）算法"></a>锦标赛（Tournaments）算法</h3><ol><li>确定每次选择的个体数量N。（二元锦标赛选择即选择2个个体）</li><li>从种群中随机选择N个个体(每个个体被选择的概率相同) ，根据每个个体的适应度值，选择其中适应度值最好的个体进入下一代种群。</li><li>重复步骤(2)多次（重复次数为种群的大小），直到新的种群规模达到原来的种群规模。<br>锦标赛算法相当于是有噪声的排序算法。<br>由于2这一步可以同时选择若干个体数量为N的组，每一组内的选择是独立的，因此通过锦标赛算法可以将遗传算法进行并行化处理，大大地节省了运算时间。  </li></ol><h2 id="遗传算法的局限性"><a href="#遗传算法的局限性" class="headerlink" title="遗传算法的局限性"></a>遗传算法的局限性</h2><h3 id="计算量问题"><a href="#计算量问题" class="headerlink" title="计算量问题"></a>计算量问题</h3><p>对于遗传算法来说评估函数的计算速度和计算量是一个问题：首先，对于现有种群的评估计算量就比较大。不仅如此，种群的后代也需要进行评估——这会导致计算量的暴增。  </p><h3 id="信息表达问题"><a href="#信息表达问题" class="headerlink" title="信息表达问题"></a>信息表达问题</h3><p>遗传算法的每个个体用位串来表示，能够存储的信息量、用于描述单个个体的精度有限。  </p>]]></content>
    
    
    <categories>
      
      <category>遗传算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04. 高斯噪声</title>
    <link href="/2021/09/26/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/4.%20%E9%AB%98%E6%96%AF%E5%99%AA%E5%A3%B0/"/>
    <url>/2021/09/26/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/4.%20%E9%AB%98%E6%96%AF%E5%99%AA%E5%A3%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="高斯噪声"><a href="#高斯噪声" class="headerlink" title="高斯噪声"></a>高斯噪声</h1><h2 id="白噪声"><a href="#白噪声" class="headerlink" title="白噪声"></a>白噪声</h2><p><strong>白噪声</strong>指噪声信号的功率谱密度函数在频域内符合均匀分布。事实上，完全意义上的白噪声是不可能存在的，因此如果噪声的功率谱密度在系统的工作频段内符合均匀分布，也认为是白噪声。  </p><h3 id="白噪声的统计特性"><a href="#白噪声的统计特性" class="headerlink" title="白噪声的统计特性"></a>白噪声的统计特性</h3><p>白噪声的谱密度函数（双边）可以表示为：  </p><script type="math/tex; mode=display">P_ξ(ω)=\frac{n_0}{2}(-∞<ω<∞)</script><p>其期望为：  </p><script type="math/tex; mode=display">E_ξ(ω)=∞</script><p>其自相关函数为：  </p><script type="math/tex; mode=display">R_ξ(τ)=\frac{1}{2π}∫_{-∞}^∞\frac{n_0}{2}e^{jωτ}dω=\frac{n_0}{2}δ(τ)</script><p>频谱中为负的部分没有任何的现实意义，因此定义白噪声的单边谱密度函数为：  </p><script type="math/tex; mode=display">P_ξ(ω)=n_0(-∞<ω<∞)</script><h2 id="高斯白噪声"><a href="#高斯白噪声" class="headerlink" title="高斯白噪声"></a>高斯白噪声</h2><p>高斯白噪声指信号的功率谱密度函数在频域内符合均匀分布、概率密度函数符合高斯分布的噪声。高斯白噪声是一种可加性噪声。    </p><h4 id="高斯白噪声的统计特性"><a href="#高斯白噪声的统计特性" class="headerlink" title="高斯白噪声的统计特性"></a>高斯白噪声的统计特性</h4><p>均值：$E_ξ(ω)=0$<br>方差：$D_ξ(ω)=0$<br>自相关函数：$R_n(τ)=\frac{n_0}{2}δ(τ)$  </p><h2 id="窄带高斯白噪声"><a href="#窄带高斯白噪声" class="headerlink" title="窄带高斯白噪声"></a>窄带高斯白噪声</h2><p>当高斯白噪声通过线性滤波器从而使得原有的谱密度函数说遵循的均匀分布被限制在了某一个频段$(-ω,ω)$，称此时的高斯白噪声为窄带高斯白噪声。  </p><h3 id="表达方式和统计性质"><a href="#表达方式和统计性质" class="headerlink" title="表达方式和统计性质"></a>表达方式和统计性质</h3><h4 id="包络相位形式"><a href="#包络相位形式" class="headerlink" title="包络相位形式"></a>包络相位形式</h4><p>窄带高斯白噪声的谱密度函数可以表示为：  </p><script type="math/tex; mode=display">n_i(t)=a(t)cos[ω_ct+ϕ(t)]</script><p>其中$a(t)$是随机包络函数，$ϕ(t)$是随机相位函数。  </p><p>随机包络和随机相位的统计特性：<br>随机包络$a(t)$：  </p><script type="math/tex; mode=display">f(a)=\frac{a}{σ^2}exp[-\frac{a^2}{2σ_n^2}],a≥0</script><p>其服从瑞利分布。<br>随机相位$ϕ(t)$：  </p><script type="math/tex; mode=display">f(ϕ)=\frac{1}{2π},0≤ϕ≤2π</script><p>其服从均匀分布，且与随机包络相互独立。  </p><h4 id="同相正交形式"><a href="#同相正交形式" class="headerlink" title="同相正交形式"></a>同相正交形式</h4><p>定义窄带高斯白噪声的<br>同相分量：$n_c(t)=a(t)cos[ϕ(t)]$<br>正交分量：$n_s(t)=a(t)sin[ϕ(t)]$<br>则窄带高斯白噪声可以分解为：  </p><script type="math/tex; mode=display">n_i(t)=n_ccosω_ct-n_s(t)sinω_ct</script><p>同相分量和正交分量的统计特性：<br><strong>一个均值为0的窄带平稳高斯过程，其同相分量和正交分量也是平稳高斯过程，且均值为0，方差和原信号相同。</strong>  </p><h3 id="高斯白噪声通过低通滤波器"><a href="#高斯白噪声通过低通滤波器" class="headerlink" title="高斯白噪声通过低通滤波器"></a>高斯白噪声通过低通滤波器</h3><p>低通滤波器的频谱是一个以$ω=0$为纵对称轴轴的门函数，其截止频率为$W$：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210926142613.png width=50%><br>按照第3讲中平稳随机过程通过线性系统的输出特性，可以得到当输入高斯白噪声到低通滤波器时，输出的窄带高斯白噪声的谱密度函数：  </p><script type="math/tex; mode=display">P_ξ(ω)=\frac{n_0}{2},-W≤ω≤W=\frac{n_0}{2}G_{2W}(ω)</script><p>其中$W$表示的是线性低通滤波器的截止频率。<br>此时的平均功率可以由谱密度函数的面积表示：  </p><script type="math/tex; mode=display">\overline{P_{ξ}}=\frac{n_0}{2}×2W=n_0W</script><p>其自相关函数可以通过傅里叶变换来获得：  </p><script type="math/tex; mode=display">R_n(τ)=\frac{n_0W}{2π}Sa(Wτ)</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210926142217.png width=80%>  </p><h3 id="高斯白噪声通过带通滤波器"><a href="#高斯白噪声通过带通滤波器" class="headerlink" title="高斯白噪声通过带通滤波器"></a>高斯白噪声通过带通滤波器</h3><p>带通滤波器的频谱是两个以$ω=ω_0$为纵对称轴轴的、且相互以$ω=0$对称的门函数，其截止频段为$W$：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210926143006.png width=50%><br>当高斯白噪声通过带通滤波器，其输出的窄带高斯白噪声的谱密度函数为：  </p><script type="math/tex; mode=display">P_n(ω)=\frac{n_0}{2}[G_W(ω+ω_0)+G_W(ω-ω_0)]</script><p>由傅里叶变换得到其自相关函数为：  </p><script type="math/tex; mode=display">R_n(τ)=\frac{n_0W}{2π}Sa(\frac{Wτ}{2})cos(ω_0τ)</script><p>其平均功率为：  </p><script type="math/tex; mode=display">Avg.Power=\frac{n_0}{2}×2×W=n_0W</script>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>通信原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TensorFlow 入门项目：训练一个VGG模型</title>
    <link href="/2021/09/25/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8tensorflow/"/>
    <url>/2021/09/25/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/%E4%BD%BF%E7%94%A8tensorflow/</url>
    
    <content type="html"><![CDATA[<h1 id="TensorFlow-入门项目：训练一个VGG模型"><a href="#TensorFlow-入门项目：训练一个VGG模型" class="headerlink" title="TensorFlow 入门项目：训练一个VGG模型"></a>TensorFlow 入门项目：训练一个VGG模型</h1><blockquote><p>代码环境建议为：Python37/38/39 Tensorflow 2.3.0/2.6.0</p></blockquote><p>同NUS的交通标志分类器项目一样，搭建一个训练器的算法思路基本相同。基本步骤为：</p><ol><li>读取数据集，加载数据集中的图像和标签</li><li>划分训练集和测试集</li><li>定义分类器，此处需要定义使用的Google的VGG模型</li><li>将训练集放入分类器训练，并用测试集输出评价</li><li>输出设定的评价标准</li><li>保存模型</li></ol><p>整个过程需要的函数库如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> cv2 <span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><span class="hljs-keyword">from</span> tensorflow.keras <span class="hljs-keyword">import</span> Model, Sequential, layers, models<br><span class="hljs-keyword">from</span> tensorflow.keras.callbacks <span class="hljs-keyword">import</span> EarlyStopping, ReduceLROnPlateau<br><span class="hljs-keyword">from</span> tensorflow.keras.preprocessing.image <span class="hljs-keyword">import</span> ImageDataGenerator<br></code></pre></td></tr></table></figure><br>在正式进行训练之前，可以利用tf中的<code>tf.config.experimental.list_physical_devices(&#39;GPU&#39;)</code>查找并选择使用GPU，写法是固定的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment">#调用GPU</span><br>gpus = tf.config.experimental.list_physical_devices(<span class="hljs-string">&#x27;GPU&#x27;</span>)<br><span class="hljs-keyword">if</span> gpus:<br>    <span class="hljs-keyword">for</span> gpu <span class="hljs-keyword">in</span> gpus:<br>        tf.config.experimental.set_memory_growth(gpu, <span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure></p><h2 id="加载数据集"><a href="#加载数据集" class="headerlink" title="加载数据集"></a>加载数据集</h2><p>这一部分的思路与NUS项目中使用Sklearn创建交通标志分类器的思路几乎完全相同：定义两个list用于分别存放图像集和标签集。遍历整个数据集。遍历数据集的方法使用<code>glob()</code>函数，数据集的文件夹层级为；<br>—dataset<br>..|-images<br>….|-cato1<br>….|-cato2<br>….|-cato3<br>….|-cato4<br>其中每一张图像以类似<code>001_photoname.jpg</code>命名，001是图像的类别标签。<br>对于图像，使用<code>cv2.imread()</code>将图像转为np.array格式后存放到list即可。对于图像所对应的标签，此处使用的是<code>split()</code>函数对文件路径、或者是文件名中含有的标签信息进行提取。如果标签在数据集中以<em>.csv或者</em>.exls的表格文件储存，则需要调用pandas函数库进行处理。<br>需要注意的是，图像需要用<code>cv2.resize()</code>保证每张图片的大小相同，即矩阵的大小是相等的。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义容器</span><br>x = []  <span class="hljs-comment"># 图像集</span><br>y = []  <span class="hljs-comment"># 标签集</span><br><br>ImgHight = <span class="hljs-number">64</span> <span class="hljs-comment"># 图片高度</span><br>ImgWidth = <span class="hljs-number">64</span> <span class="hljs-comment"># 图片宽度</span><br><br><span class="hljs-comment"># 加载数据集</span><br>dataset_root = <span class="hljs-string">&#x27;dataset/images/**/&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> glob.glob(dataset_root + <span class="hljs-string">&#x27;*.jpg&#x27;</span>, recursive=<span class="hljs-literal">True</span>):<br>    img = cv2.imread(i)<br>    img_resize = cv2.resize(img, (ImgWidth, ImgHight))  <span class="hljs-comment"># 裁剪图像</span><br>    x.append(img_resize)<br>    label = i.split(<span class="hljs-string">&quot;\\&quot;</span>)[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>:<span class="hljs-number">3</span>]  <span class="hljs-comment"># 分词找标签</span><br>    y.append(<span class="hljs-built_in">int</span>(label))<br><br><span class="hljs-comment"># 错误代码</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(x) == <span class="hljs-number">0</span>:<br>    print(<span class="hljs-string">&#x27;Missing files&#x27;</span>)<br><span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(y) == <span class="hljs-number">0</span>:<br>    print(<span class="hljs-string">&quot;missing names&quot;</span>)<br><br>print(<span class="hljs-string">&quot;reading completed&quot;</span>)<br></code></pre></td></tr></table></figure><p>由于tf只支持标签和图像都为np.array格式，因此需要将标签和图像列表都转换为np.array格式。<br>此外还需要将图像列表转为一个长向量，以便输入分类器进行拟合。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 把标签和图像转为nparry格式</span><br>x = np.array(x).reshape(-<span class="hljs-number">1</span>, ImgHight, ImgWidth, <span class="hljs-number">3</span>)  <span class="hljs-comment"># 转为1维长向量</span><br>y = np.array(y)<br></code></pre></td></tr></table></figure><br>同样地，此处使用Sklearn中的<code>train_test_split()</code>函数对数据集进行随机划分，划分为测试集和训练集两部分。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 划分训练集和测试集</span><br>x_train, x_test, y_train, y_test = train_test_split(x,<br>                                                    y,<br>                                                    test_size=<span class="hljs-number">0.4</span>,<br>                                                    shuffle=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure></p><h2 id="加载模型"><a href="#加载模型" class="headerlink" title="加载模型"></a>加载模型</h2><p>此处使用<code>tf.keras.applications.vgg16.VGG16()</code>来加载TensorFlow中预制的VGG算法模型。<br>由于数据集的量比较小，因此设置数据输入到最后的四层。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">print(<span class="hljs-string">&quot;Loading the model..&quot;</span>)<br><span class="hljs-comment"># VGG16预训练网络</span><br>covn_base = tf.keras.applications.vgg16.VGG16(weights=<span class="hljs-string">&#x27;imagenet&#x27;</span>,<br>                                              include_top=<span class="hljs-literal">False</span>)<br>covn_base.trainable = <span class="hljs-literal">True</span><br><span class="hljs-comment"># 冻结前面的层，训练最后四层</span><br><span class="hljs-keyword">for</span> layers <span class="hljs-keyword">in</span> covn_base.layers[:-<span class="hljs-number">4</span>]:<br>    layers.trainable = <span class="hljs-literal">False</span><br>    <br></code></pre></td></tr></table></figure><br>对每一层，都需要用<code>tf.keras.layers</code>中的函数指定每一层的用途和相关的参数（比如激活函数，池化方法等等）。由于采用的是预制的标准VGG16算法，因此最后4层每一层的设置遵循标准VGG16的结构。需要注意损失函数的定义，当标签以整实数形式存放时，应该使用<code>tf.keras.losses.SparseCategoricalCrossentropy()</code>，如果以二进制编码，如标签3为011，则应该使用<code>tf.keras.losses.CategoricalCrossentropy()</code>。<br>Logits表示网络的直接输出 。没经过sigmoid或者softmax的概率化。<code>from_logits=False</code>就表示把已经概率化了的输出，重新映射回原值。$log(p/(1-p))$。  当<code>from_logits=True</code>时损失函数会做softmax，并进行概率归一化操作。<br>由于有四类图像需要识别，此处<code>tf.keras.layers.Dense()</code>的第一个参数应该为4，表示样本空间的维度。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 构建模型</span><br>model = tf.keras.Sequential()<br>model.add(covn_base)<br>model.add(tf.keras.layers.GlobalAveragePooling2D())<br>model.add(tf.keras.layers.Dense(<span class="hljs-number">256</span>, activation=<span class="hljs-string">&#x27;relu&#x27;</span>))<br>model.add(tf.keras.layers.Dropout(<span class="hljs-number">0.2</span>))<br>model.add(tf.keras.layers.Dense(<span class="hljs-number">4</span>, activation=<span class="hljs-string">&#x27;softmax&#x27;</span>))<br>model.summary()<br><span class="hljs-comment"># 编译模型，初始学习率0.001</span><br><span class="hljs-comment"># 编译模型，初始学习率0.001</span><br>model.<span class="hljs-built_in">compile</span>(<br>    optimizer=tf.keras.optimizers.Adam(learning_rate=<span class="hljs-number">0.001</span>),<br>    loss=tf.keras.losses.SparseCategoricalCrossentropy(<br>        from_logits=<span class="hljs-literal">False</span>),  <span class="hljs-comment"># 标签为实数</span><br>    <span class="hljs-comment"># CategoricalCrossentropy(from_logits=False)，标签为二进制编码</span><br>    metrics=[<span class="hljs-string">&quot;accuracy&quot;</span>])<br></code></pre></td></tr></table></figure><br>对于大数据集，在训练后期，当loss不再明显时，减小学习率以加大学习的压力。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 监视&#x27;val_loss&#x27;，当两个epoch的loss不变时，学习率减小为1/10</span><br>reduce_lr = ReduceLROnPlateau(monitor=<span class="hljs-string">&#x27;val_loss&#x27;</span>,<br>                              factor=<span class="hljs-number">0.1</span>,<br>                              patience=<span class="hljs-number">2</span>,<br>                              verbose=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><br>将训练集的图像和标签输入到分类器中拟合，拟合过程指定训练的轮数epochs，批数等等。使用TensorFlow2.0特性<code>validation_data()</code>导入测试集图像和标签，训练器在每一轮训练后会使用测试集进行测试，并返回准确率、loss到<code>history</code>中。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 开始训练</span><br>history = model.fit(<br>    x_train,<br>    y_train,<br>    batch_size=<span class="hljs-number">128</span>,<br>    epochs=<span class="hljs-number">15</span>,<br>    validation_data=(x_test, y_test),<br>)<br>print(<span class="hljs-string">&quot;train complieted&quot;</span>)<br></code></pre></td></tr></table></figure></p><h2 id="读取训练参数并保存模型"><a href="#读取训练参数并保存模型" class="headerlink" title="读取训练参数并保存模型"></a>读取训练参数并保存模型</h2><p>将记录到的loss、准确率进行读取，并使用pyPlot函数库对训练结果进行可视化处理。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 记录准确率和损失值</span><br>history_dict = history.history<br>train_loss = history_dict[<span class="hljs-string">&quot;loss&quot;</span>]<br>train_accuracy = history_dict[<span class="hljs-string">&quot;accuracy&quot;</span>]<br>val_loss = history_dict[<span class="hljs-string">&quot;val_loss&quot;</span>]<br>val_accuracy = history_dict[<span class="hljs-string">&quot;val_accuracy&quot;</span>]<br><br><span class="hljs-comment"># Generate predictions (probabilities -- the output of the last layer)</span><br><span class="hljs-comment"># on new data using `predict`</span><br>print(<span class="hljs-string">&quot;Generate predictions for 3 samples&quot;</span>)<br>predictions = model.predict(x_test[:<span class="hljs-number">3</span>])<br>print(<span class="hljs-string">&quot;predictions shape:&quot;</span>, predictions.shape)<br><br>print(<span class="hljs-string">&quot;ploting..&quot;</span>)<br><span class="hljs-comment"># 绘制损失值</span><br>plt.figure()<br>plt.plot(<span class="hljs-built_in">range</span>(epochs), train_loss, label=<span class="hljs-string">&#x27;train_loss&#x27;</span>)<br>plt.plot(<span class="hljs-built_in">range</span>(epochs), val_loss, label=<span class="hljs-string">&#x27;val_loss&#x27;</span>)<br>plt.legend()<br>plt.xlabel(<span class="hljs-string">&#x27;epochs&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;loss&#x27;</span>)<br><br><span class="hljs-comment"># 绘制准确率</span><br>plt.figure()<br>plt.plot(<span class="hljs-built_in">range</span>(epochs), train_accuracy, label=<span class="hljs-string">&#x27;train_accuracy&#x27;</span>)<br>plt.plot(<span class="hljs-built_in">range</span>(epochs), val_accuracy, label=<span class="hljs-string">&#x27;val_accuracy&#x27;</span>)<br>plt.legend()<br>plt.xlabel(<span class="hljs-string">&#x27;epochs&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;accuracy&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><br>使用<code>model.save()</code>函数保存训练模型，训练模型的格式有两种：  </p><ol><li>h5，生成的是一个*.h5文件，需要使用<code>keras</code>进行读取。  </li><li>tf，生成的是一个模型文件夹，比较容易读取。  </li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">print(<span class="hljs-string">&quot;saving the model...&quot;</span>)<br><span class="hljs-comment"># 模型保存，注意：仅仅是多了一个save_format的参数而已</span><br><span class="hljs-comment"># 注意：这里的&#x27;path_to_saved_model&#x27;不再是模型名称，仅仅是一个文件夹，模型会保存在这个文件夹之下</span><br>model.save(<span class="hljs-string">&#x27;model/&#x27;</span>, save_format=<span class="hljs-string">&#x27;tf&#x27;</span>)<br>print(<span class="hljs-string">&quot;completed&quot;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tensorflow</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>03. 离散时间傅里叶变换</title>
    <link href="/2021/09/25/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/3.%20%E7%A6%BB%E6%95%A3%E6%97%B6%E9%97%B4%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"/>
    <url>/2021/09/25/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/3.%20%E7%A6%BB%E6%95%A3%E6%97%B6%E9%97%B4%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="离散时间傅里叶变换"><a href="#离散时间傅里叶变换" class="headerlink" title="离散时间傅里叶变换"></a>离散时间傅里叶变换</h1><h2 id="傅里叶变换的意义"><a href="#傅里叶变换的意义" class="headerlink" title="傅里叶变换的意义"></a>傅里叶变换的意义</h2><p>对于一个线性时不变系统，系统任意的输入的信号可以表示为一系列特征函数的线性组合。而傅里叶变换的本质在于求出这个线性组合中每一项的系数和这个线性组合本身的表示。而连续时间域中的傅里叶变换是离散域中线性组合概念的拓展。<br>离散频域中的线性时不变系统的特征函数是指数函数（序列）:$e^{jω_kn}$，因此通过傅里叶变换，任何一个满足狄利克雷条件的离散时间域中的信号都可以表示为指数序列的线性组合：  </p><script type="math/tex; mode=display">x[n]=∑_ka_ke^{jω_kn}</script><p>通过傅里叶变换，这个线性组合可以表示为：</p><script type="math/tex; mode=display">x[n]=\frac{1}{2π}∫_{-π}^πX(e^{jω})e^{jωn}</script><p>其中$X(jω)$为这个线性组合的系数，有：   </p><script type="math/tex; mode=display">X(e^{jω})=∑_{n=-∞}^∞x[n]e^{-jωn}</script><p>上述式子称为离散时间傅里叶变换。 </p><blockquote><p>由于等比数列的求和性质，变换的结果是一个连续频谱。  </p></blockquote><p>其反变换即线性组合的表达式:  </p><script type="math/tex; mode=display">x[n]=\frac{1}{2π}∫_{-π}^πX(e^{jω})e^{jωn}</script><p>由傅里叶变换，这个线性组合的特征函数$e^{jωn}$在时域内表现为正弦函数$cosωn$，因此这个线性组合在时域上表征为正弦函数的线性组合，这表示<strong>一个信号可以被分解为若干个特性不同的正弦波。</strong>  </p><p>连续和离散时间傅里叶变换的对比如下表所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210925140243.png width=80%>  </p><h2 id="离散时间傅里叶变换的共轭性质"><a href="#离散时间傅里叶变换的共轭性质" class="headerlink" title="离散时间傅里叶变换的共轭性质"></a>离散时间傅里叶变换的共轭性质</h2><h3 id="序列的分解"><a href="#序列的分解" class="headerlink" title="序列的分解"></a>序列的分解</h3><h4 id="复分解"><a href="#复分解" class="headerlink" title="复分解"></a>复分解</h4><p>同连续傅里叶变换，离散时间傅里叶变换也可以做复分解：  </p><script type="math/tex; mode=display">X(e^{jω})=X_R(e^{jω})+jX_I(e^{jω})</script><h4 id="共轭分解"><a href="#共轭分解" class="headerlink" title="共轭分解"></a>共轭分解</h4><p>定义序列$x[n]$的共轭对称序列:  </p><script type="math/tex; mode=display">x_e[n]=\frac{1}{2}(x[n]+x^*[-n])</script><p>共轭对称序列的性质：$x_e[n]=x_e^*[-n]$<br>序列$x[n]$的共轭反对称序列:  </p><script type="math/tex; mode=display">x_o[n]=\frac{1}{2}(x[n]-x^*[-n])</script><p>共轭反对称序列的性质：$x_o[n]=-x_o^*[-n]$<br>任何一个序列$x[n]$可以表示为其共轭对称和共轭反对称序列的和：  </p><script type="math/tex; mode=display">x[n]=x_e[n]+x_o[n]</script><p>共轭分解对频域序列也同样适用。  </p><h3 id="共轭信号的性质"><a href="#共轭信号的性质" class="headerlink" title="共轭信号的性质"></a>共轭信号的性质</h3><div class="table-container"><table><thead><tr><th style="text-align:center">注解</th><th style="text-align:center">时域序列</th><th style="text-align:center">频域变换</th></tr></thead><tbody><tr><td style="text-align:center">反向</td><td style="text-align:center">$x^*[n]$ <br> $x^*[-n]$</td><td style="text-align:center">$X^*(e^{-jω})$ <br> $X^*(e^{jω})$</td></tr><tr><td style="text-align:center">幅度分量为偶函数</td><td style="text-align:center">$\lvert X(e^{jω})\rvert$</td><td style="text-align:center">$\lvert X(e^{-jω}) \rvert$</td></tr><tr><td style="text-align:center">相位分量为奇函数</td><td style="text-align:center">$∠X(e^{jω})$</td><td style="text-align:center">$-∠X(e^{-jω})$</td></tr><tr><td style="text-align:center">实部分量为偶函数</td><td style="text-align:center">$X_R(e^{jω})$</td><td style="text-align:center">$X_R(e^{-jω})$</td></tr><tr><td style="text-align:center">虚部分量为奇函数</td><td style="text-align:center">$X_I(e^{jω})$</td><td style="text-align:center">$-X_I(e^{-jω})$</td></tr></tbody></table></div><h2 id="离散时间傅里叶变换的性质"><a href="#离散时间傅里叶变换的性质" class="headerlink" title="离散时间傅里叶变换的性质"></a>离散时间傅里叶变换的性质</h2><div class="table-container"><table><thead><tr><th style="text-align:center">注解</th><th style="text-align:center">时域序列</th><th style="text-align:center">频域变换</th></tr></thead><tbody><tr><td style="text-align:center">线性</td><td style="text-align:center">$ax[n]+by[n]$</td><td style="text-align:center">$aX(e^{jω})+bY(e^{jω})$</td></tr><tr><td style="text-align:center">时移</td><td style="text-align:center">$x[n-n_0]$</td><td style="text-align:center">$e^{-jωn_0}X(e^{jω})$</td></tr><tr><td style="text-align:center">频移</td><td style="text-align:center">$e^{jω_0n}x[n]$</td><td style="text-align:center">$X(e^{j(ω-ω_0)})$</td></tr><tr><td style="text-align:center">反转</td><td style="text-align:center">$x[-n]$</td><td style="text-align:center">$X(e^{-jω})$</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">频域微分</td><td style="text-align:center">$nx[n]$</td><td style="text-align:center">$j\frac{dX(e^{jω})}{dω}$</td></tr></tbody></table></div><h3 id="卷积特性"><a href="#卷积特性" class="headerlink" title="卷积特性"></a>卷积特性</h3><p>时域卷积：  </p><script type="math/tex; mode=display">x[n]*y[n]⇔X(e^{jω})Y(e^{jω})</script><p>频域卷积：  </p><script type="math/tex; mode=display">x[n]y[n]⇔\frac{1}{2π}X(e^{jω})*Y(e^{jω})=\frac{1}{2π}∫_{-π}^πX(e^{jθ})Y(e^{j(ω-θ)dθ})</script>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>数字信号处理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Unit 11~15</title>
    <link href="/2021/09/21/%E6%97%A5%E8%AF%AD/N2%E5%A4%87%E8%80%83/Unit%2011~15/"/>
    <url>/2021/09/21/%E6%97%A5%E8%AF%AD/N2%E5%A4%87%E8%80%83/Unit%2011~15/</url>
    
    <content type="html"><![CDATA[<h1 id="Unit-11-15-な行・は行"><a href="#Unit-11-15-な行・は行" class="headerlink" title="Unit 11~15 な行・は行"></a>Unit 11~15 な行・は行</h1><h2 id="Unit-11-な・に"><a href="#Unit-11-な・に" class="headerlink" title="Unit 11 な・に"></a>Unit 11 な・に</h2><ul><li>ないことにはない・ないこともない・ないではない・ないではない   <ul><li>動詞ない形・い形容詞ない形・な形容詞～で＋ないことにはない・ないこともない   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【不是不能……】消极</span>  </span></li><li>動詞ない形・い形容詞ない形・な形容詞～で＋ないではない・ないではない   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【也不是不……】</span>  </span></li></ul></li><li>ながら（も）<br>動詞ます形・な形容詞・い形容詞・名詞＋ながら（も）   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【虽然……，但是……】</span>  </span></li><li>なくはない・なくもない<br>動詞ない形・い形容詞ない形・な形容詞～で・名詞～が・は＋なくはない・なくもない   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【不是不……】</span>  </span></li><li>ならともかく<br>動詞辞書形・な形容詞・い形容詞・名詞＋ならともかく   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【如果是……那么另当别论】</span>  </span></li><li>にあたって・にあたり<br>動詞辞書形・名詞＋にあたって・にあたり   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【在……之际（重要的时刻）】</span>  </span></li><li>において・における<br>名詞＋において・における   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【在……方面，时间、地点、状况】</span>  </span></li><li>に応じて・に応じ・に応じた<br>名詞＋に応じて・に応じ・に応じだ   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【按照/根据……而变】</span>  </span></li><li>に（は）かかわらず・に（は）かかわりず<br>動詞辞書形・ない形～ない・名詞・い形容詞・な形容詞＋に（は）かかわらず・に（は）かかわりず   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【无论是……，都】</span>  </span></li><li>に限って・に限り<br>名詞＋に限って・に限り   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【只限于……】</span>  </span></li><li>に限って<br>名詞＋に限って   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【唯独……】</span>  </span></li></ul><h2 id="Unit-12-に"><a href="#Unit-12-に" class="headerlink" title="Unit 12 に"></a>Unit 12 に</h2><ul><li>にかぎる<br>動詞辞書形・ない形～ない＋に限る   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【最好是……】</span>  </span>  </li><li>にかけては・にかけても<br>名詞＋にかけては・にかけても   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【在……方面】</span>  </span>  </li><li>に決まっている<br>動詞辞書形・い形容詞・な形容詞・名詞＋に決まっている   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【一定……】确切的推测</span>  </span>  </li><li>に加えて・に加え<br>名詞＋に加えて・に加え   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【加上……】</span>  </span>  </li><li>に越したことはない<br>動詞辞書形・い形容詞・な形容詞～である・名詞～である＋に越したことはない   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【是……的话那再好不过了】</span>  </span>  </li><li>に応えて・に応え<br>名詞＋に応えて・に応え   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【应……】</span>  </span>  </li><li>に際して・に際し・に際しての<br>動詞辞書形・名詞＋に際して・に際し・に際しての   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【当……之际】</span>  </span>  </li><li>に先立って・に先立ち<br>名詞＋に先立って・に先立ち   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【在……之前】</span>  </span>  </li><li>に従って・に従い<br>動詞辞書形・名詞＋に従って・に従い <ol><li>  <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【按照……】</span>  </span>  </li><li>  <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【随着……】</span>  </span>  </li></ol></li><li>にしたら・にすれば・にしても<br>名詞＋にしたら・にすれば・にしても   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【从……的立场来看】</span>  </span>  </li></ul><h2 id="Unit-13-に"><a href="#Unit-13-に" class="headerlink" title="Unit 13 に"></a>Unit 13 に</h2><ul><li>にしては<br>動詞普通形・い形容詞・な形容詞・名詞＋にしては   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【就……而言】</span>  </span></li><li>にしても・にせよ・にしろ  <ul><li>動詞普通形・い形容詞・な形容詞・名詞（～である）＋にしても・にせよ・にしろ   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【即使是……】</span>  </span></li><li>两个にしても・にせよ・にしろ连用   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【无论是……还是……，都】，两个对立面的事物</span>  </span></li></ul></li><li>に過ぎない<br>動詞普通形・い形容詞・な形容詞（～である）・名詞（である）＋に過ぎない   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【不过是……而已】</span>  </span></li><li>に相違ない・に違いない<br>動詞普通形・い形容詞・な形容詞・名詞＋に相違ない・に違いない   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【一定是……】</span>  </span></li><li>に沿って・に沿った<br>名詞＋に沿って・に沿った   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【按照……】</span>  </span></li><li>につき<br>名詞＋につき <ol><li>  <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【每……】，表示平均每几个分得到一个</span>  </span></li><li>  <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【因为……】，郑重地告知</span>  </span></li></ol></li><li>につけ・にしけては・につけても<br>動詞辞書形＋につけ・にしけては・につけても   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【每当……，就……】</span>  </span><br>動詞辞書形・い形容詞・名詞＋につけ＋動詞普通形・い形容詞・名詞＋につけ   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【不论……还是……都……】</span>  </span></li><li>に伴って・に伴う・に伴い<br>動詞辞書形・名詞＋に伴って・に伴う・に伴い   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【随着……】</span>  </span></li><li>に反する・に反して・に反し<br>名詞＋に反する・に反して・に反し   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【与……相反】</span>  </span></li></ul><h2 id="Unit-14-に・ぬ・の・は（ば）"><a href="#Unit-14-に・ぬ・の・は（ば）" class="headerlink" title="Unit 14　に・ぬ・の・は（ば）"></a>Unit 14　に・ぬ・の・は（ば）</h2><ul><li>にほかならない  <ul><li>名詞＋にほかならない   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【正是……】，强调没有其他</span>  </span></li><li>動詞普通形・い形容詞・な形容詞～である/だ・名詞～である/だ＋にほかならない   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【正是因为……】，强调没有其他原因</span>  </span></li></ul></li><li>にもかかわらず<br>動詞普通形・い形容詞・な形容詞・名詞（～である）＋にもかかわらず   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【虽然……，但是……】</span>  </span> </li><li>に基づいて・に基づき・に基づく・に基づいた<br>名詞＋に基づいて・に基づき・に基づく・に基づいた   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【根据……】</span>  </span></li><li>にわたって・にわたり・にわたる・にわたった<br>名詞＋にわたって・にわたり・にわたる・にわたった   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【涉及……】，表示时间和空间的范围，强调时间之长、范围之广</span>  </span></li><li>抜きでは・抜きに（は）・抜きの・を抜きにして（は）・は抜きにして    <ul><li>名詞＋抜きでは・抜きに（は）・抜きの   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【省去……/如果没有……，就（不）……】</span>  </span></li><li>名詞＋を抜きにして（は）・は抜きにして   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【省去……/如果没有……，就（不）……】，除去一般情况下会有的东西</span>  </span></li></ul></li><li>抜く<br>動詞ます形＋抜く   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【终于……】，克服困难坚持最终做完了</span>  </span></li><li>のみならず<br>動詞普通形・い形容詞・な形容詞・名詞（～である）＋のみならず   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【不仅……】</span>  </span></li><li>のもとで・のもとに  <ul><li>名詞＋のもとで・のもとに   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【在……的影响下】</span>  </span></li><li>名詞＋名のもとに   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【以……的名义】</span>  </span></li></ul></li><li>はおろか<br>動詞普通形～の・名詞＋はおろか   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【不要说……，就连……也……】</span>  </span>  </li><li>ばかりか<br>動詞普通形・い形容詞・な形容詞・名詞＋ばかりか   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【不只是……】</span>  </span><br>動詞ない形＋ばかりか　  <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【不只是不……】</span>  </span>  </li></ul><h2 id="Unit-15-は（ば）・へ（べ）・ほ・ま"><a href="#Unit-15-は（ば）・へ（べ）・ほ・ま" class="headerlink" title="Unit 15 は（ば）・へ（べ）・ほ・ま"></a>Unit 15 は（ば）・へ（べ）・ほ・ま</h2><ul><li>ばかりに<br>動詞普通形・な形容詞～な・い形容詞・名詞～な/である＋ばかりに   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【正是因为……】，表示由于不好的原因造成的意料之外的结果</span>  </span> </li><li>はともかく（として）<br>名詞＋はともかく（として）   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【先不说……】</span>  </span> </li><li>は別として・は別にして<br>名詞＋は別として・は別にして<br>動詞普通形・な形容詞・い形容詞・名詞＋かどうか/か＋は別として・は別にして    <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【先不说】</span>  </span>  </li><li>はもちろん・はもとより<br>名詞＋はもちろん・はもとより   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【连……的话，更不用说……】</span>  </span> </li><li>反面・半面<br>動詞普通形・い形容詞・な形容詞～な/である・名詞～である＋半面・反面   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【另一方面……】</span>  </span>  </li><li>べき・べきだ・べきではない<br>動詞辞書形＋べき・べきだ・べきではない   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【应该……】，社会常识、义务的行为</span>  </span> </li><li>ほか（は）ない・よりほか（は）ない<br>動詞辞書形＋ほか（は）ない・よりほか（は）ない   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【只有……】，表示别无他法</span>  </span> </li><li>ほど・ほどだ・ほどの  <ul><li>ば～ほど<br>動詞ば形・い形容詞ば形＋動詞辞書形・い形容詞＋ほど<br>名詞＋であれば＋名詞＋である＋ほど<br>な形容詞＋であれば＋な形容詞＋である＋ほど    <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【越……就越……】</span>  </span>  </li><li>動詞辞書形・ない形～ない・な形容詞～な・い形容詞・名詞＋ほど・ ほどだ・ほどの   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【……的程度】</span>  </span>  </li><li>動詞辞書形・な形容詞～ない・な形容詞～な・い形容詞・名詞＋ほど   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【越……越……】</span>  </span></li></ul></li><li>まい・まいか<br>動詞辞書形＋まい・まいか＋動詞ない形＋まい・まいか  <ol><li>  <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【不想……】，否定的用法</span>  </span>  </li><li>  <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【不会……吧，也许不……】，否定的推测</span>  </span>  </li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
      <category>N2备考文法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日语</tag>
      
      <tag>N2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>02. 数字系统</title>
    <link href="/2021/09/19/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/2.%20%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F/"/>
    <url>/2021/09/19/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/2.%20%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="数字系统"><a href="#数字系统" class="headerlink" title="数字系统"></a>数字系统</h1><h2 id="系统的特性"><a href="#系统的特性" class="headerlink" title="系统的特性"></a>系统的特性</h2><h3 id="线性"><a href="#线性" class="headerlink" title="线性"></a>线性</h3><p>线性系统满足两个特点：齐次性和可加性。  </p><h4 id="齐次性"><a href="#齐次性" class="headerlink" title="齐次性"></a>齐次性</h4><p>如果$x[n]→T→y[n]$，有：  </p><script type="math/tex; mode=display">Ax[n]→T→Ay[n]</script><p>称系统具有齐次性。  </p><h4 id="可加性"><a href="#可加性" class="headerlink" title="可加性"></a>可加性</h4><p>如果$x_1[n]→T→y_1[n]$、$x_2[n]→T→y_2[n]$，有：  </p><script type="math/tex; mode=display">x_1[n]+x_2[n]→T→y_1[n]+y_2[n]</script><p>称系统具有可加性。  </p><p>同时满足齐次性和可加性的系统称为线性系统。  </p><h3 id="时不变性"><a href="#时不变性" class="headerlink" title="时不变性"></a>时不变性</h3><p>系统中如果输入的时移会导致系统输出的同步时移，这样的系统称为时不变系统：<br>如果$x[n]→T→y[n]$，有：  </p><script type="math/tex; mode=display">x[n-n_0]→T→y[n-n_0]</script><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>如果系统的输入和输出都有界，那么称系统是稳定的。  </p><script type="math/tex; mode=display">x[n]<∞,y[n]<∞</script><h3 id="无记忆性"><a href="#无记忆性" class="headerlink" title="无记忆性"></a>无记忆性</h3><p>当前系统的输出只依赖于当前的系统输入、而不依赖于之前的系统输入的系统称为无记忆系统。  </p><h3 id="因果性"><a href="#因果性" class="headerlink" title="因果性"></a>因果性</h3><p>当前系统的输出$y[n]$不会依赖于未来的系统输入:$x[n+n_0],n_0∈Z^*$，这样的系统称为因果系统。  </p><blockquote><p>无记忆系统一定是因果系统。  </p><p>非因果系统可以通过设置延时器转换为因果系统。  </p></blockquote><h2 id="卷积和"><a href="#卷积和" class="headerlink" title="卷积和"></a>卷积和</h2><p>定义离散信号的卷积称为卷积和：  </p><script type="math/tex; mode=display">∑_{k}x[k]h[n-k]=x[n]*h[n]</script><h3 id="单位采样响应"><a href="#单位采样响应" class="headerlink" title="单位采样响应"></a>单位采样响应</h3><p>对于给定的系统$T[·]$，当系统输入为单位冲击序列$δ[n]$时的系统输出$h[n]$称为单位采样响应。  </p><script type="math/tex; mode=display">h[n]=T[δ[n]]</script><p>对于线性系统：$x[n]→T→y[n]$，<br>由齐次性：$x[0]δ[n]→T→x[0]h[n]$<br>由时不变性：$x[k]δ[n-k]→T→x[k]h[n-k]$<br>由单位冲激序列的采样特性：$x[n]=∑x[k]δ[n-k]$<br>因此：  </p><script type="math/tex; mode=display">y[n]=∑x[k]h[n-k]=x[n]*h[n]</script><p>即<strong>系统输出$y[n]$可以表示为系统输入$x[n]$与单位采样响应$h[n]$的卷积</strong>。  </p><h3 id="卷积和的运算性质"><a href="#卷积和的运算性质" class="headerlink" title="卷积和的运算性质"></a>卷积和的运算性质</h3><ol><li><p>线性：$x[n]*(h_1[n]+h_2[n])=x[n]*h_1[n]+x[n]*h_2[n]$  </p><div class="note note-info">            <p>线性揭示了卷积和运算可以被并行化处理  </p>          </div></li><li><p>交换律：$x[n]*h_1[n]*h_2[n]=x[n]*h_2[n]*h_1[n]$  </p></li><li>结合律：$x[n]*h_1[n]*h_2[n]=x[n]*(h_1[n]*h_2[n])$</li></ol><h2 id="数字系统方程"><a href="#数字系统方程" class="headerlink" title="数字系统方程"></a>数字系统方程</h2><p>数字系统可以由差分方程进行描述：  </p><script type="math/tex; mode=display">∑_{k=0}^Na_ky[n-k]=∑_{k=0}^Mb_kx[n-k]</script><p>其中系统方程的阶$N$由系统最前输出$y[n-N]$决定。  </p><h3 id="数字系统的频率响应·离散时间傅里叶变换"><a href="#数字系统的频率响应·离散时间傅里叶变换" class="headerlink" title="数字系统的频率响应·离散时间傅里叶变换"></a>数字系统的频率响应·离散时间傅里叶变换</h3><p>类比于连续时间傅里叶变换，称$e^{jωn}$为特征函数（Eigenfuntion）。对于数字系统，当系统的输入为特征函数时：  </p><script type="math/tex; mode=display">y[n]=∑h[k]e^{jω(n-k)}=e^{jωn}∑h[k]e^{-jωk}</script><p>这个变换式称为<strong>离散时间傅里叶变换</strong>。<br>称$∑h[k]e^{-jωk}$为数字系统的频率响应：  </p><script type="math/tex; mode=display">H(e^{jω})=∑h[k]e^{-jωk}</script><p>其反变换：  </p><script type="math/tex; mode=display">h[n]=\frac{1}{2π}∫_{-π}^{π}H(e^{jω})e^{jωn}dω</script>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>数字信号处理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01. 数字信号</title>
    <link href="/2021/09/19/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/1.%20%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7/"/>
    <url>/2021/09/19/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/1.%20%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="数字信号"><a href="#数字信号" class="headerlink" title="数字信号"></a>数字信号</h1><p>数字信号是时间离散、幅值离散的信号。但是在本课中为了简化分析，认为时间离散、幅值连续的信号也是数字信号。<br>数字信号可以由序列进行表示：  </p><script type="math/tex; mode=display">...,x[-1],x[0],x[1],...</script><h2 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h2><p>模拟信号是时间连续、幅值连续的信号。使模拟信号转变为数字信号的过程称为采样。采样过程可由如下公式表示：  </p><script type="math/tex; mode=display">x[n]=x(t)|_{t=nT_s}=x(nT_s),n∈Z</script><p>其中$T_s$称为采样周期。  </p><h2 id="常见的数字信号"><a href="#常见的数字信号" class="headerlink" title="常见的数字信号"></a>常见的数字信号</h2><h3 id="单位冲激序列"><a href="#单位冲激序列" class="headerlink" title="单位冲激序列"></a>单位冲激序列</h3><script type="math/tex; mode=display">δ[n]=\begin{cases}    1,n=0 \\    0,others\end{cases}</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210919151509.png width=30%>  </p><h4 id="冲激序列的采样性质"><a href="#冲激序列的采样性质" class="headerlink" title="冲激序列的采样性质"></a>冲激序列的采样性质</h4><p>类比冲击信号的采样性质，可以发现任何的数字信号都可以表示为时移的单位冲激序列的线性组合。  </p><script type="math/tex; mode=display">x[n]=∑x[k]δ[n-k]</script><h3 id="单位阶跃序列"><a href="#单位阶跃序列" class="headerlink" title="单位阶跃序列"></a>单位阶跃序列</h3><script type="math/tex; mode=display">u[n]=\begin{cases}    1,n≥0 \\    0,others\end{cases}</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210919151704.png width=30%>  </p><h3 id="指数序列"><a href="#指数序列" class="headerlink" title="指数序列"></a>指数序列</h3><script type="math/tex; mode=display">x[n]=a^n</script><p>如果底数$a$是一个复数:$a=Ae^{jθ}$，此时可以表示为：  </p><script type="math/tex; mode=display">x[n]=A^n(cosθn+jsinθn)</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210919154806.png width=50%>  </p><h3 id="三角序列"><a href="#三角序列" class="headerlink" title="三角序列"></a>三角序列</h3><p>连续的三角信号可以表示为：  </p><script type="math/tex; mode=display">x(t)=Asin(Ωt+φ)</script><p>此时的角频率$Ω$称为模拟角频率，单位为rad/s。<br>对连续的三角信号进行采样，从而得到数字域的三角信号：  </p><script type="math/tex; mode=display">x[n]=Asin(2πfn/f_s+φ)=Asin(ωn+φ)</script><p>其中$f_s$是采样频率，$ω=\frac{2πf}{f_s}$，称为数字角频率，单位为rad或者rad/sample。  </p><h4 id="数字角频率的理解"><a href="#数字角频率的理解" class="headerlink" title="数字角频率的理解"></a>数字角频率的理解</h4><p>由数字角频率：  </p><script type="math/tex; mode=display">ω=\frac{2πf}{f_s}=\frac{Ω}{f_s}</script><p>数字角频率可以看做是模拟角频率对其进行归一化的结果。<br>又有角频率公式：$ω=2πf_d$，$f_d$称为数字频率。  </p><script type="math/tex; mode=display">f_d=\frac{f}{f_s}</script><p>数字频率可以看做是对模拟频率$f$进行归一化的结果。  </p><h3 id="三角序列的周期性"><a href="#三角序列的周期性" class="headerlink" title="三角序列的周期性"></a>三角序列的周期性</h3><p>定义数字信号的周期性为：  </p><script type="math/tex; mode=display">x(n)=x(n+N)</script><p>对于数字三角信号（三角序列），有：  </p><script type="math/tex; mode=display">Acos(ω_0n+φ)=Acos(ω_0(n+N)+φ)=Acos(ω_0n+ω_0N+φ),0≤ω_0≤2π</script><p>可以发现当$ω_0N=2πk,k∈Z$时上述式子成立。<br>得到：</p><script type="math/tex; mode=display">ω_0=\frac{2πk}{N},k=0,1,...,N-1</script><p>也就是说，要想三角信号呈周期性：  </p><ol><li>$ω_0$必须是π的整数倍以保证数字周期$N$是一个自然数。即存在$N=\frac{2πk}{ω_0},k=0,1,…,N-1$则该序列为周期序列。  </li><li>只有N个不同的$ω_0$使得三角信号呈周期性。  </li><li>对于复指数序列，使用欧拉公式变换为三角信号，由于cos和sin部分的数字角频率相等，因此可以按照上述判断标准进行判断。  </li></ol><h3 id="三角序列的振荡特性"><a href="#三角序列的振荡特性" class="headerlink" title="三角序列的振荡特性"></a>三角序列的振荡特性</h3><p>对于连续的三角信号：$Ω$越大，三角信号的周期越小，三角信号振荡越剧烈。<br>对于三角序列：</p><ul><li>$ω∈(0,π)$时，$ω$越大，三角序列振荡越剧烈。  </li><li>$ω∈(π,2π)$时，$ω$越大，三角序列振荡越平缓。  </li></ul><p>推理的过程如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210919154402.png width=70%></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>数字信号处理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>0. 课程简介</title>
    <link href="/2021/09/19/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/0.%20%E8%AF%BE%E7%A8%8B%E7%AE%80%E4%BB%8B/"/>
    <url>/2021/09/19/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/0.%20%E8%AF%BE%E7%A8%8B%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="课程简介"><a href="#课程简介" class="headerlink" title="课程简介"></a>课程简介</h1><p>课程： CQUPT/BUL 2021： EE2624 Digital Signal Processing<br>授课教师： Dr. Jimmy Teng（邓明亮），重庆邮电大学  </p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《数字信号处理及MATLAB实现》 第一版 余成波等编著 清华大学出版社<br>《离散时间信号处理》 第三版 奥本海姆编 电子工业出版社<br>MATLAB 帮助中心 MathWorks®</p><h2 id="笔记结构"><a href="#笔记结构" class="headerlink" title="笔记结构"></a>笔记结构</h2><p>笔记按照课程内容顺序按数字编号，内容包括课堂笔记总结、知识点总结和涉及到的MATLAB®软件例程等等。  </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>数字信号处理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03. 随机变量和随机过程</title>
    <link href="/2021/09/19/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/3.%20%E6%A6%82%E7%8E%87%E4%B8%8E%E9%9A%8F%E6%9C%BA/"/>
    <url>/2021/09/19/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/3.%20%E6%A6%82%E7%8E%87%E4%B8%8E%E9%9A%8F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="随机变量和随机过程"><a href="#随机变量和随机过程" class="headerlink" title="随机变量和随机过程"></a>随机变量和随机过程</h1><blockquote><p>由于通信原理所研究的信号是连续的模拟信号，因此本节主要复习连续随机变量/随机过程的性质。  </p></blockquote><h2 id="随机变量"><a href="#随机变量" class="headerlink" title="随机变量"></a>随机变量</h2><h3 id="概率密度和概率分布函数"><a href="#概率密度和概率分布函数" class="headerlink" title="概率密度和概率分布函数"></a>概率密度和概率分布函数</h3><p>对于随机变量$X$，<strong>概率密度函数</strong>(PDF)$f(x)$表示当$X=x$时候的概率：  </p><script type="math/tex; mode=display">f(x)=P(X=x)</script><p><strong>概率分布函数/积累分布函数</strong>（CDF）$F(x)$表示$X$小于$x$的概率，对于连续随机变量，积累分布函数可以表示为：  </p><script type="math/tex; mode=display">F(x)=P(X≤x)=∫_{-∞}^xf(u)du</script><p>积累分布函数和概率密度函数有如下关系：  </p><script type="math/tex; mode=display">f(x)=\frac{dF(x)}{dx}</script><h4 id="概率密度函数的性质"><a href="#概率密度函数的性质" class="headerlink" title="概率密度函数的性质"></a>概率密度函数的性质</h4><ul><li>正定性：$f(x)≥0$  </li><li>概率之和为1：$∫f(x)dx=1$</li><li>区间概率：$P(a&lt;X≤b)=∫_a^bf(x)dx$</li></ul><h3 id="随机变量的统计特征"><a href="#随机变量的统计特征" class="headerlink" title="随机变量的统计特征"></a>随机变量的统计特征</h3><h4 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h4><p>期望表示随机变量的均值：  </p><script type="math/tex; mode=display">E(x)=∫xf(x)dx</script><p>期望的计算性质：  </p><ul><li>$E(C)=C$</li><li>$E(X+Y)=E(X)+E(Y)$</li><li>当随机变量$X$,$Y$<strong>相互独立</strong>时，$E(XY)=E(X)E(Y)$</li></ul><h4 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h4><p>方差表示随机变量分布的离散程度:  </p><script type="math/tex; mode=display">D(X)=∫[x_i-E(X)]^2f(x)dx</script><p>更多时候，方差可由期望推导出： </p><script type="math/tex; mode=display">D(x)=E[X-E(X)]^2=E(X^2)-E^2(X)</script><blockquote><p>求方差的步骤： </p><ol><li>求出期望$E(X)$</li><li>求出均方值期望$E^2(X)$</li><li>带入公式求得$D(X)$</li></ol></blockquote><p>方差的计算性质：  </p><ul><li>$D(C)=0$</li><li>$D(X+C)=D(X)$</li><li>$D(CX)=C^2X$</li><li>当随机变量$X$,$Y$<strong>相互独立</strong>时，$D(X+Y)=D(X)+D(Y)$</li></ul><h2 id="通信原理中常见随机变量的分布"><a href="#通信原理中常见随机变量的分布" class="headerlink" title="通信原理中常见随机变量的分布"></a>通信原理中常见随机变量的分布</h2><h3 id="均匀分布"><a href="#均匀分布" class="headerlink" title="均匀分布"></a>均匀分布</h3><p>均匀分布（Uniform Distribution）指随机变量在某个区间$(a,b)$内取到某个值$x$的概率是相同的。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210919131848.png width=50%>  </p><p>均匀分布的概率密度函数：  </p><script type="math/tex; mode=display">f(x)=\begin{cases}    \frac{1}{b-a},a≤x≤b \\    0,others\end{cases}</script><ul><li>期望：$E(x)=\frac{b+a}{2}$</li><li>方差：$D(x)=\frac{(b-a)^2}{12}$</li></ul><h3 id="高斯分布-正态分布"><a href="#高斯分布-正态分布" class="headerlink" title="高斯分布/正态分布"></a>高斯分布/正态分布</h3><p>随机变量在不任何束缚前提下的总体变化规律称为高斯分布/正态分布。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210919131811.png width=50%>  </p><p>高斯分布的概率密度函数：  </p><script type="math/tex; mode=display">f(x)=\frac{1}{√(2π)σ}exp[-\frac{(x-μ)^2}{2σ^2}]</script><p>其中$μ$是随机变量$X$的均值，它影响高斯分布曲线的轴的位置。<br>$σ^2$是随机变量$X$的方差，它影响高斯分布曲线中最大值点的位置。  </p><h3 id="瑞利分布"><a href="#瑞利分布" class="headerlink" title="瑞利分布"></a>瑞利分布</h3><p>当一个随机二维向量的两个分量呈独立的、有着相同的方差、均值为0的 正态分布 时，这个向量的模呈瑞利分布。<br>瑞利分布的概率密度函数：  </p><script type="math/tex; mode=display">f(x)=\begin{cases}    \frac{x}{σ^2}exp(-\frac{x^2}{2σ^2}),x≥0 \\    0,x≤0\end{cases}</script><p>$σ^2$是瑞利分布的方差。  </p><h2 id="随机过程"><a href="#随机过程" class="headerlink" title="随机过程"></a>随机过程</h2><p>与上文所述的确知过程不同的是，在每一个时间点上的概率都不能用一个或若干个时间函数进行描述的过程称为随机过程。<br>随机过程可以有两种理解方式：  </p><ol><li>在样本空间$S$中对每一个样本$s_i$采样得到的所有采样函数的集合。  </li><li>样本空间$S$中所有随机变量随着时间的推移。<br>简单来说，随机过程可以理解为是若干随机变量的集合。<br>随机过程的阶指随机过程中含有的随机变量的个数。阶数越大，对随机过程的统计特性描述就越充分。  </li></ol><h3 id="概率密度和概率分布函数-1"><a href="#概率密度和概率分布函数-1" class="headerlink" title="概率密度和概率分布函数"></a>概率密度和概率分布函数</h3><p>随机过程$ξ(t)$在某个固定的时间$t=t_1$时是一个随机变量$ξ(t_1)$，其一阶概率积累函数可以表示为：  </p><script type="math/tex; mode=display">F_1(x_1,t_1)=P(ξ(t_1)≤x_1)</script><p>同样地：  </p><script type="math/tex; mode=display">f(ξ(t_1))=\frac{∂F_1(x_1,t_1)}{∂x_1}</script><h3 id="描述随机过程的统计特征"><a href="#描述随机过程的统计特征" class="headerlink" title="描述随机过程的统计特征"></a>描述随机过程的统计特征</h3><h4 id="期望-1"><a href="#期望-1" class="headerlink" title="期望"></a>期望</h4><script type="math/tex; mode=display">E(ξ(t))=∫ξ(t)f_1(x,t)dt=e(t)</script><p>其中$ξ(t)$是含有随机变量$x$的随机过程，$f_1(x,t)$是$x$的概率密度函数。<br>此时随机过程的期望应该是一个关于时间的函数。表示的是随机过程值的摆动中心。  </p><h4 id="方差-1"><a href="#方差-1" class="headerlink" title="方差"></a>方差</h4><script type="math/tex; mode=display">D(ξ(t))=E(ξ^2(t))-e(t)^2</script><p>随机过程的方差表示随机过程值围绕期望的摆动幅度。  </p><h4 id="自相关函数"><a href="#自相关函数" class="headerlink" title="自相关函数"></a>自相关函数</h4><p>随机过程的自相关函数用于描述随机过程在不同时间点上的随机变量之间的关联程度。  </p><script type="math/tex; mode=display">R(t,t+τ)=E[ξ(t)ξ(t+τ)]</script><p>自相关函数在$τ=0$时取得最大值，易证$R(0)=E[ξ^2(t)]$。<br>自相关函数在通信领域的一个应用是用于判断多径效应产生的时移信号与原信号之间的相关性。  </p><h3 id="平稳随机过程"><a href="#平稳随机过程" class="headerlink" title="平稳随机过程"></a>平稳随机过程</h3><p>严平稳过程要求随机变量的变化与初始值无关，只与时间间隔有关的随机过程。  </p><script type="math/tex; mode=display">f_n(x_1,...,x_n;t_1,...,t_n)=f_n(x_1,...,x_n;t_1+τ,...,t_n+τ)</script><p>宽平稳过程要求：  </p><ol><li>随机过程的均值是一个常数：$E(ξ(t))=C$</li><li>自相关函数是一个只关于时间间隔$τ$的函数：$R(t,t+τ)=R(τ)$</li></ol><h4 id="功率信号"><a href="#功率信号" class="headerlink" title="功率信号"></a>功率信号</h4><p>在通信系统中，功率信号是一个宽平稳随机过程，下面使用自相关函数研究其性质。  </p><blockquote><p>此处自变量为τ（如平均功率为τ=0）</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">功率信号</th><th style="text-align:center">自相关函数</th><th style="text-align:center">注解</th></tr></thead><tbody><tr><td style="text-align:center">平均功率</td><td style="text-align:center">$R(0)=E(ξ^2(t))$</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">直流功率</td><td style="text-align:center">$R(∞)=E^2(ξ(t))$</td><td style="text-align:center">当τ→∞时，表示为两个不相关信号的自相关函数</td></tr><tr><td style="text-align:center">交流功率</td><td style="text-align:center">$R(0)-R(∞)=σ^2$</td><td style="text-align:center">平均功率=交流功率+直流功率</td></tr></tbody></table></div><blockquote><p>求解平均功率的方式：  </p><ol><li>$R(0)$</li><li>$E(ξ^2(t))$</li><li>谱密度函数的积分<ul><li>对于角频率谱密度函数：$\frac{1}{2π}∫P_ξ(ω)dω$</li><li>对于频率密度函数：$∫P_ξ(f)df$</li></ul></li></ol></blockquote><p>由于直流功率（功率的直流分量）是一个常数而不含有任何信息，对信号处理时常常使用自相关函数分解直流功率和交流功率。  </p><h3 id="遍历随机过程"><a href="#遍历随机过程" class="headerlink" title="遍历随机过程"></a>遍历随机过程</h3><p>如果一个随机过程的任何一个样本都经历了平稳随机过程所有的可能状态，称这个随机过程是遍历随机过程（Ergodic Random Process）。遍历随机过程最大的特点是过程中的任意一个随机变量$x(t)$的在时间上的统计特性和这个随机过程$ξ(t)$的统计特性相等。<br>对于遍历随机过程的期望：  </p><script type="math/tex; mode=display">E[ξ(t)]=∫ξf(ξ,t)dt=\lim_{T→∞}\frac{1}{T}∫_{-\frac{T}{2}}^\frac{T}{2}x(t)dt=\overline{a}</script><p>遍历随机过程的自相关函数：  </p><script type="math/tex; mode=display">R(τ)=E[ξ(t)ξ(t+τ)]=\lim_{T→∞}\frac{1}{T}∫_{-\frac{T}{2}}^\frac{T}{2}x(t)x(t+τ)dt=\overline{R(τ)}</script><p>综合上述两点，遍历随机过程必然是平稳随机过程。   </p><h4 id="证明遍历性"><a href="#证明遍历性" class="headerlink" title="证明遍历性"></a>证明遍历性</h4><ol><li>计算过程中任意一个随机变量的期望：$E(x)=∫xf(t)dt$ </li><li>计算随机过程的时间均值：$\lim_{T→∞}\frac{1}{T}∫_{-\frac{T}{2}}^\frac{T}{2}f(t)dt$</li><li>证明两者相等  </li></ol><blockquote><p>对于时间均值函数：</p><script type="math/tex; mode=display">\overline{f(t)}=\lim_{T→∞}\frac{1}{T}∫_{-\frac{T}{2}}^\frac{T}{2}f(t)dt</script><p><strong>当$f(t)$是一个周期函数时，其时间均值为0。</strong></p></blockquote><h2 id="随机过程通过系统"><a href="#随机过程通过系统" class="headerlink" title="随机过程通过系统"></a>随机过程通过系统</h2><p>由于真实的信号和噪声都是随机过程，因此有必要知道对于给定的随机过程，通过系统后，系统的输出情况。  </p><h3 id="随机过程通过线性系统"><a href="#随机过程通过线性系统" class="headerlink" title="随机过程通过线性系统"></a>随机过程通过线性系统</h3><p>设系统的单位冲击响应$h(t)⇔H(ω)$，当随机过程$ξ_i(t)$通过系统后，系统的输出信号为$ξ_o(t)$，有：  </p><script type="math/tex; mode=display">ξ_o(t)=h(t)*ξ_i(t)=∫_0^∞h(τ)ξ_i(t-τ)dτ</script><h4 id="输出信号的期望"><a href="#输出信号的期望" class="headerlink" title="输出信号的期望"></a>输出信号的期望</h4><script type="math/tex; mode=display">\begin{aligned}    E[ξ_o(t)]&=E[∫_0^∞h(τ)ξ_i(t-τ)dτ]\\    &=∫_0^∞h(τ)dτE[ξ_i(t-τ)]\\    &=∫_0^∞h(τ)dτE[ξ_i(t)]\\    &=H(0)E[ξ_i(t)]\end{aligned}</script><p>因此当输入信号是一个平稳随机过程，其期望$E[ξ_i(t)]=a$时，输出信号的期望：  </p><script type="math/tex; mode=display">E[ξ_o(t)]=H(0)E[ξ_i(t)]=aH(0)</script><h4 id="输出信号的自相关函数"><a href="#输出信号的自相关函数" class="headerlink" title="输出信号的自相关函数"></a>输出信号的自相关函数</h4><script type="math/tex; mode=display">\begin{aligned}    R_o(t,t+τ)&=E[ξ_o(t)ξ_o(t+τ)]\\    &=E[∫_0^∞h(α)ξ_i(t-α)dα∫_0^∞h(β)ξ_i(t+τ-β)dβ]\\    &=∫_0^∞h(α)dα∫_0^∞h(β)dβE[ξ_i(t-α)ξ_i(t+τ-β)]\\    &=∫_0^∞h(α)dα∫_0^∞h(β)dβR_i(τ+α-β)\\\end{aligned}</script><p>因此，输出信号的自相关函数结果也必然是一个只与$τ$有关的函数：  </p><script type="math/tex; mode=display">R_o(t,t+τ)=∫_0^∞h(α)dα∫_0^∞h(β)dβR_i(τ+α-β)=R_o(τ)</script><p>综合自相关函数和期望，可以得出结论：<strong>如果线性系统的输入信号是一个平稳随机过程，那么输出信号也必然是一个平稳随机过程。</strong>  </p><h4 id="功率谱密度"><a href="#功率谱密度" class="headerlink" title="功率谱密度"></a>功率谱密度</h4><p>假设输入信号的功率谱密度为$P_{ξ_i}(ω)=∫R_i(τ)e^{-jωτ}dτ$，有：  </p><script type="math/tex; mode=display">\begin{aligned}    P_{ξ_o}(ω)&=∫R_o(τ)dτ\\    &=∫dτ∫_0^∞h(α)dα∫_0^∞h(β)dβR_i(τ+α-β)\\    &=∫_0^∞h(α)e^{jωα}dα∫_0^∞h(β)e^{-jωβ}dβ∫R_i(τ')e^{-jωτ'}dτ'\\    &=H^*(ω)H(ω)P_{ξ_i}(ω)\\    &=|H(ω)|^2P_{ξ_i}(ω)\end{aligned}</script><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210924134156.png width=60%>  </p><h3 id="随机过程通过调制系统"><a href="#随机过程通过调制系统" class="headerlink" title="随机过程通过调制系统"></a>随机过程通过调制系统</h3><p>在信号中，调制系统的实质是一个乘法器，将输入信号与一个正弦信号相乘，得到输出信号。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210924134432.png width=40%>  </p><p>调制系统的输出信号可以表示为：  </p><script type="math/tex; mode=display">ξ_o(t)=ξ_{i}(t)cosω_0t</script><p>调制系统是一个非线性系统。  </p><h4 id="输出信号的自相关函数-1"><a href="#输出信号的自相关函数-1" class="headerlink" title="输出信号的自相关函数"></a>输出信号的自相关函数</h4><script type="math/tex; mode=display">\begin{aligned}    R_o(t,t+τ)&=E[ξ_o(t)ξ_o(t+τ)]\\    &=E[ξ_i(t)ξ_i(t+τ)cosω_0tcosω_0(t+τ)]\\    &=\frac{1}{2}E[ξ_i(t)ξ_i(t+τ)][cosω_0t+cos(2ω_0t+ω_0τ)]\\    &=\frac{1}{2}R_i(τ)[cosω_0t+cos(2ω_0t+ω_0τ)]\\    &=\frac{1}{2}R_i(τ)cosω_0t+\frac{1}{2}R_i(τ)cos(2ω_0t+ω_0τ)\\\end{aligned}</script><h4 id="输出信号的功率谱密度"><a href="#输出信号的功率谱密度" class="headerlink" title="输出信号的功率谱密度"></a>输出信号的功率谱密度</h4><p>可以发现，由于$cos(2ω_0t+ω_0τ)$的存在，输出信号的自相关函数不再是一个只与$τ$相关的函数，此时如果要想通过傅里叶变换求到其频谱密度函数非常困难。<br>此时的方法是选用$cos(2ω_0t+ω_0τ)$的时间均值来近似代表其在整个时间上的变化规律。  </p><script type="math/tex; mode=display">\overline{R_o(t,t+τ)}=\frac{1}{2}R_i(τ)cosω_0t+\frac{1}{2}R_i(τ)\overline{cos(2ω_0t+ω_0τ)}</script><p>由于$cos(2ω_0t+ω_0τ)$是一个周期函数，其时间均值为0。<br>因此$\overline{R_o(t,t+τ)}=\frac{1}{2}R_i(τ)cosω_0t$。<br>对其做傅里叶变换得到输出信号的功率谱密度函数：  </p><script type="math/tex; mode=display">P_{ξ_o(ω)}=F[\frac{1}{2}R_i(τ)cosω_0t]=\frac{1}{4}[P_{ξ_i}(ω+ω_0)+P_{ξ_i}(ω-ω_0)]</script>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>通信原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02. 信号</title>
    <link href="/2021/09/13/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/2.%20%E4%BF%A1%E5%8F%B7/"/>
    <url>/2021/09/13/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/2.%20%E4%BF%A1%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><h2 id="信号的分类"><a href="#信号的分类" class="headerlink" title="信号的分类"></a>信号的分类</h2><h3 id="直流信号和交流信号"><a href="#直流信号和交流信号" class="headerlink" title="直流信号和交流信号"></a>直流信号和交流信号</h3><p>任意信号可以分解为直流信号和交流信号：  </p><script type="math/tex; mode=display">S(t)=S_{ac}(t)+S_{dc}(t)</script><p>直流信号是信号在一周期内的平均值：  </p><script type="math/tex; mode=display">S_{dc}=\lim_{T→∞}∫_{-\frac{T}{2}}^{\frac{T}{2}}S(t)dt</script><p><strong>由于直流信号是一个常量，直流信号不包含任何信息。</strong></p><h3 id="确知信号和随机信号"><a href="#确知信号和随机信号" class="headerlink" title="确知信号和随机信号"></a>确知信号和随机信号</h3><p>在任意时间上的信号参数为已知的信号为确知信号，以$f(t)$表示。<br>信号参数无法被预测的信号称为随机信号，以$p(t)$表示。  </p><h3 id="能量信号和功率信号"><a href="#能量信号和功率信号" class="headerlink" title="能量信号和功率信号"></a>能量信号和功率信号</h3><p>已知确知信号的瞬时能量函数$f(t)$，其能量可以表示为：  </p><script type="math/tex; mode=display">E=∫|f(t)|^2dt</script><p>根据绝对可积性，并将式子中的其中一个$f*(t)$替换为傅里叶反变换表达，得到：  </p><script type="math/tex; mode=display">E=\frac{1}{2π}∫|F(ω)|^2dω</script><p>其中令$E_f(ω)=|F(ω)|^2$，定义为能量谱密度函数。<br>那么能量信号可以写作：  </p><script type="math/tex; mode=display">E=\frac{1}{2π}∫E_f(ω)dω</script><p>能量信号的自相关函数：  </p><script type="math/tex; mode=display">r(τ)=∫f(t)f(t+τ)dt</script><p>其功率信号可以表示为：  </p><script type="math/tex; mode=display">P=\lim_{T→∞}\frac{1}{T}∫_{-T/2}^{T/2}|f(t)|^2dt</script><p>同样地，定义功率谱密度函数为：  </p><script type="math/tex; mode=display">P_f(ω)=\lim_{T→∞}\frac{|F_T(ω)|^2}{T}</script><p>其中$F_T$为周期函数$f(t)$的重复单位$f_t(t)$的傅里叶变换。<br>那么平均功率可以写作：  </p><script type="math/tex; mode=display">P=\frac{1}{2π}∫P_f(ω)dω</script><p>功率信号的自相关函数：  </p><script type="math/tex; mode=display">r(τ)=\lim_{T→∞}\frac{1}{T}∫_{-\frac{T}{2}}^{\frac{T}{2}}f(t)f(t+τ)dt</script><h4 id="维纳——辛钦定理"><a href="#维纳——辛钦定理" class="headerlink" title="维纳——辛钦定理"></a>维纳——辛钦定理</h4><p><strong>能量信号的自相关函数和能量谱密度函数为傅里叶变换对。</strong>  </p><script type="math/tex; mode=display">E_f(t)=∫R(f_e(t))e^{-jωt}dt</script><p><strong>功率信号的自相关函数和功率谱密度函数为傅里叶变换对。</strong>  </p><script type="math/tex; mode=display">P_f(t)=∫R(f_p(t))e^{-jωt}dt</script><p>由维纳——辛钦定理可知，当已知能量信号和功率信号时，对其求自相关函数后做傅里叶变换即可得到对应的谱密度函数。  </p><h2 id="常见的两种信号"><a href="#常见的两种信号" class="headerlink" title="常见的两种信号"></a>常见的两种信号</h2><h3 id="单位冲激信号"><a href="#单位冲激信号" class="headerlink" title="单位冲激信号"></a>单位冲激信号</h3><p>单位冲激信号的表达式：  </p><script type="math/tex; mode=display">δ(t)=\begin{cases} ∞,t=0 \\ 0,t≠0 \\ \end{cases}</script><p>冲激信号的性质：  </p><ol><li>$∫δ(t)dt=1$</li><li>$∫s(t)δ(t-t_0)dt=s(t_0)$  </li></ol><h3 id="门信号"><a href="#门信号" class="headerlink" title="门信号"></a>门信号</h3><script type="math/tex; mode=display">g(t)=u(t+\frac{\tau}{2})-u(t-\frac{\tau}{2})</script><p>其中$τ$称为门函数的宽度。  </p><h2 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h2><p>在信号与系统中定义傅里叶变换：  </p><script type="math/tex; mode=display">F[f(t)]=∫f(t)e^{-jω_1t}dt</script><p>傅里叶反变换：  </p><script type="math/tex; mode=display">f(t)=\frac{1}{2π}∫F(ω)e^{jωt}dω</script><h2 id="采样定理"><a href="#采样定理" class="headerlink" title="采样定理"></a>采样定理</h2><h3 id="模拟信号转数字信号"><a href="#模拟信号转数字信号" class="headerlink" title="模拟信号转数字信号"></a>模拟信号转数字信号</h3><p>模拟信号$f(t)$转换为数字信号经过三步：</p><ol><li>取样</li><li>量化</li><li>编码</li></ol><p>其中取样的本质是$f(t)$与一个周期信号$p(t)$相乘。</p><script type="math/tex; mode=display">f_s(t)=f(t)p(t)</script><p>在频域中：  </p><script type="math/tex; mode=display">F_s(ω)=F(ω)*P(t)</script><h3 id="理想取样"><a href="#理想取样" class="headerlink" title="理想取样"></a>理想取样</h3><p>$p(t)$是周期单位冲激信号$δ_T(t)=∑δ(t-nT_s)$。</p><script type="math/tex; mode=display">\begin{aligned}    P(ω)&=ω_s∑δ(ω-nω_s)\\    F_s(ω)&=\frac{1}{2π}F(ω)*P(t) \\    &=\frac{1}{T_s}∑F(ω-nω_s)\end{aligned}</script><p>如果取样频率$ω_s$（表现为冲激信号的间隔）非常的小，那么频域上取样后的信号可能会产生重叠。<br>如果取样频率非常的大，那么信号会丢失非常多的细节，导致失真。  </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>通信原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Unit 06~10</title>
    <link href="/2021/09/11/%E6%97%A5%E8%AF%AD/N2%E5%A4%87%E8%80%83/Unit%206/"/>
    <url>/2021/09/11/%E6%97%A5%E8%AF%AD/N2%E5%A4%87%E8%80%83/Unit%206/</url>
    
    <content type="html"><![CDATA[<h1 id="Unit-6-10-さ行・た行・な行"><a href="#Unit-6-10-さ行・た行・な行" class="headerlink" title="Unit 6~10 さ行・た行・な行"></a>Unit 6~10 さ行・た行・な行</h1><h2 id="Unit-6-さ（ざ）・し（じ）・す（ず）・せ・た"><a href="#Unit-6-さ（ざ）・し（じ）・す（ず）・せ・た" class="headerlink" title="Unit 6 さ（ざ）・し（じ）・す（ず）・せ・た"></a>Unit 6 さ（ざ）・し（じ）・す（ず）・せ・た</h2><ul><li>際（は）・際に（は）<br>動詞辞書形・た形・名詞～の＋際（は）・際に（は）   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【在……的时候/借着……的时机】</span>  </span></li><li>最中（に）・最中だ<br>動詞て形～ている・い形容詞・名詞～の＋最中（に）・最中だ   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【正在……时突然发生了……】</span>  </span></li><li>ざるを得ない<br>動詞ない形＋ざるを得ない   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【不得不……】</span>  </span></li><li>次第・次第だ・次第で  <ul><li>動詞ます形＋次第   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【刚一……，就……】</span>  </span></li><li>普通形＋次第で・次第だ   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【由于……，书面语】</span>  </span></li><li>名詞＋次第で（は）・次第だ   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【取决于/根据……】</span>  </span></li></ul></li><li>上・上は・上も<br>名詞＋上・上は・上も   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【从（公文、历史、法律、教育等）上来看】</span>  </span></li><li>末（に）・末の<br>動詞た形・名詞～の＋すえ（に）・すえの   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【经过……终于……，强调很长的过程】</span>  </span></li><li><p>ずにすむ・ないですむ・なくてすむ<br>動詞ない形＋ずにすむ・ないですむ・なくてすむ   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【不必要做……也可以/不用……就行】</span>  </span></p><blockquote><p>する→せ  </p></blockquote></li><li><p>ずにはいられない・ないではいられない<br>動詞ない形＋ずにはいられない・ないではいられない   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【情不自禁地/不能不做……】</span>  </span></p><blockquote><p>する→せ  </p></blockquote></li><li><p>せいで・せか・せいだ・せいにする  </p><ul><li>普通形＋せいで・せか・せいだ・せいにする   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【都怪……】</span>  </span></li><li>普通形＋せいか   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【可能因为……】</span>  </span></li></ul></li><li>たいばかりに・ほしいばかりに  <ul><li>動詞ます形＋たいばかりに </li><li>名詞～が＋ほしいばかりに    <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【就是因为太想要……了（而不辞辛劳地做……）】</span>  </span></li></ul></li></ul><h2 id="Unit-7-た（だ）・つ"><a href="#Unit-7-た（だ）・つ" class="headerlink" title="Unit 7 た（だ）・つ"></a>Unit 7 た（だ）・つ</h2><ul><li><p>だけあって・だけに・だけのことはある</p><ul><li>普通形＋だけあって・だけに・だけのことはある   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【不愧是……，正面评价】</span>  </span></li><li>名詞・普通形＋だけに <ol><li>  <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【正因为……，更加……】</span>  </span></li><li>  <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【正因为……，反倒是……】</span>  </span></li></ol></li></ul></li><li><p>たとえ～ても・としても・たところで</p><ul><li>たとえ＋動詞て形・い形容詞て形＋も・としても・たところで</li><li>たとえ＋な形容詞・名詞＋でも・としても・たところで  <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【即便是……也……】</span>  </span></li></ul></li><li>たところ<br>動詞た形＋ところ   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【……之后就……】</span>  </span>  </li><li>たところが<br>動詞た形＋ところが   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【然而……】</span>  </span> </li><li>たとたん（に）<br>動詞た形＋とたん（に）   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【刚……就……】*说话人自身过去的事情，客观事件</span>  </span></li><li>たばかりに<br>動詞た形＋ばかりに   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【……刚结束】</span>  </span></li><li>たびに<br>動詞辞書形・名詞～の＋ばかりに   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【每次……】</span>  </span></li><li>だらけ<br>名詞＋だらけ   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【满是/到处都是……（不好的事物）】</span>  </span><br>常用：泥だらけ　傷だらけ　間違いだらけ　血だらけ　借金だらけ  </li><li>ついでに<br>動詞辞書形・た形・名詞～の＋ついでに   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【顺便……】</span>  </span>  </li><li>っこない<br>動詞ます形＋っこない    <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【不可能……】</span>  </span>  </li></ul><h2 id="Unit-8-つ・て"><a href="#Unit-8-つ・て" class="headerlink" title="Unit 8 つ・て"></a>Unit 8 つ・て</h2><ul><li>つつ・つつも  <ul><li>動詞ます形＋つつ   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【一边……】</span>  </span>  </li><li>動詞ます形＋つつ（も）  <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【虽然……，但是……】</span>  </span></li></ul></li><li>つつある<br>動詞ます形＋つつある   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【正在……，表示不断发展】</span>  </span></li><li>っぽい<br>動詞ます形・名詞・い形容詞語幹＋っぽい   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【看上去……】</span>  </span></li><li>つもり・つもりだ  <ul><li>動詞辞書形・ない形～ない＋つもりだ   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【打算……】</span>  </span></li><li>動詞た形・て形～ている・な形容詞～な・い形容詞・名詞～の＋つもり   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【这样认为的……】</span>  </span></li></ul></li><li>つもりで  <ul><li>動詞た形＋つもりで   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【就当是……】</span>  </span></li></ul></li><li>て以来<br>動詞て形＋て以来   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【从……之后就，状态一直持续】</span>  </span></li><li>てからでないと・てからでなければ<br>動詞て形＋てあらでないと・てからでなければ   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【如果不先做……的话，就（不能）……，后项为否定】</span>  </span></li><li>てしょうがない・てしようがない<br>動詞て形・い形容詞て形・な形容詞～で＋てしょうがない・てしようがない   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【特别……，用于说话人表示感情强烈】</span>  </span></li><li>てたまらない<br>動詞て形・い形容詞て形・な形容詞～で＋てたまらない   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【……得受不了/特别……，用于说话人表示感情强烈，只能他动词】</span>  </span></li><li>てでも<br>動詞て形＋てでも   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【就算……，也要……，采取强硬的手段】</span>  </span></li></ul><h2 id="Unit-9-て・と"><a href="#Unit-9-て・と" class="headerlink" title="Unit 9　て・と"></a>Unit 9　て・と</h2><ul><li>てならない<br>動詞て形・い形容詞て形・な形容詞～で＋て（で）ならない   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【非常……，程度很高，情不自禁……】</span>  </span>  </li><li>てはいられない<br>動詞て形＋てはいられない   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【不能……，由于某种情况不能做前项，危机感】</span>  </span></li><li>てはじめて<br>動詞て形＋はじめて   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【在……之后才……】</span>  </span></li><li>てばかりはいられない・ればかりもいられない<br>動詞て形＋てばかりはいられない・ればかりもいられない   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【也不能总是……】</span>  </span></li><li>ということだ<br>普通形＋ということだ <ol><li>  <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【也就是说……】</span>  </span></li><li>  <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【听说……】</span>  </span></li></ol></li><li>というものではない・というものでもない<br>普通形＋というものではない・というものでもない   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【并非……，认为不全面】</span>  </span></li><li>というより<br>動詞普通形・な形容詞＋というより   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【虽然说……】</span>  </span></li><li>といっても<br>動詞普通形・な形容詞～な・い形容詞・名詞＋といっても   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【虽然说……】</span>  </span></li><li><p>とおり（に）・どおり（に）  </p><ul><li>動詞辞書形・た形・名詞～の＋とおり（に） </li><li>名詞＋どおりに   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【正如……那样】</span>  </span>  </li></ul></li><li><p>とか  </p><ul><li>普通形・名詞＋とか・とかいう   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【说是……什么的，不确定】</span>  </span></li><li>普通形＋とかいうことだ・とかいえ話だ   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【听说好像……】</span>  </span></li></ul></li><li>とかで<br>普通形＋とかで   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【说是因为……什么的，口语】</span>  </span></li></ul><h2 id="Unit-10-と（ど）・な"><a href="#Unit-10-と（ど）・な" class="headerlink" title="Unit 10 と（ど）・な"></a>Unit 10 と（ど）・な</h2><ul><li>どころが<br>普通形＋どころが   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">别说……，就连……也……</span>  </span> </li><li>ところだった<br>動詞辞書形＋ところだった   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【差点就……，不好的事】</span>  </span> </li><li>どころではない・どころではなく<br>動詞辞書形・て形～ている＋どころではない・どころではなく   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【不是做……的时候】</span>  </span></li><li>ところに・ところへ<br>動詞辞書形・た形・て形～ている＋ところに・ところへ   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【正当……的时候（发生了出乎意料的事情）】</span>  </span></li><li>とことを<br>動詞辞書形・た形・て形～ている＋ところを   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【正当……的时候（被阻拦了）】</span>  </span></li><li>とことを見ると<br>動詞た形・て形～ている＋とことを見ると   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【从……上来看】</span>  </span></li><li>としか言いようがない<br>普通形＋としか言いようがない   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【只能说是……】</span>  </span></li><li>としたら・とすると・とすれば<br>普通形＋としたら・とすると・とすれば   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【如果……，后为自然而然的结果】</span>  </span></li><li>とともに<br>動詞辞書形・い形容詞・名詞（～である）・な形容詞～である＋とともに   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【随着……的同时】</span>  </span></li><li>とは限らない<br>普通形＋とは限らない   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【未必……】</span>  </span></li><li>ないことには  <ul><li>動詞ない形・い形容詞ない形＋ないことには</li><li>な形容詞・名詞＋でないことには  <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【如果不……就（不）……】</span>  </span></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
      <category>N2备考文法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日语</tag>
      
      <tag>N2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01. 通信系统·信息</title>
    <link href="/2021/09/10/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/1.%20%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F%E5%8F%82%E6%95%B0%E3%80%81%E4%BF%A1%E6%81%AF/"/>
    <url>/2021/09/10/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/1.%20%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F%E5%8F%82%E6%95%B0%E3%80%81%E4%BF%A1%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="通信系统·信息"><a href="#通信系统·信息" class="headerlink" title="通信系统·信息"></a>通信系统·信息</h1><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><h3 id="模拟信号"><a href="#模拟信号" class="headerlink" title="模拟信号"></a>模拟信号</h3><p>模拟信号指时间连续，幅值连续的信号。  </p><h3 id="数字信号"><a href="#数字信号" class="headerlink" title="数字信号"></a>数字信号</h3><p>数字信号指时间连续/离散，幅值离散的信号。  </p><p>数字信号的优势：  </p><ul><li>抗噪性高：只要幅值高于某个阈值则即为1，对幅值的精度要求不如模拟信号。  </li><li>便于加密、存储、处理、传输<br>数字信号的劣势：  </li><li>需要更大的带宽需求</li><li>需要高的时协同步要求</li></ul><h2 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h2><p>信息分为连续信息（比如声音）和离散信息（比如文字）。<br><strong>以消息中包含的未确定事件的概率来衡量信息的大小，称为信息量</strong>。记信息量为：  </p><script type="math/tex; mode=display">I=log_a\frac{1}{P(x)}=-log_aP(x)</script><p>其中$P(x)$表示事件发生的概率。<br>信息量的单位取决于不同底数$a$：  </p><ul><li>$a=2$,bit  </li><li>$a=e$,nit  </li><li>$a=10$,Hartley  </li></ul><h3 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h3><p>信息熵是用来衡量消息有效率的指标，信息熵表示消息中平均含有的信息量：  </p><script type="math/tex; mode=display">H=∑_{i=1}^MP(x_i)log_2\frac{1}{P(x_i)}</script><p>对于连续信息：  </p><script type="math/tex; mode=display">H=∫P(x_i)log_2\frac{1}{P(x_i)}dx</script><p>其中$M$表示消息中的字符数量。<br>信息熵的单位是bit/符号。  </p><p>在概率相等的情况下，含有$M$个字符的最大信息熵为：  </p><script type="math/tex; mode=display">H_{max}=log_2M</script><h2 id="通信系统"><a href="#通信系统" class="headerlink" title="通信系统"></a>通信系统</h2><p>通信系统的组成大致上分为三部分：  </p><ul><li>发射机（Transmitter）：将信息转换为信号并发送</li><li>信道（Channel）：信号传输所经过的介质</li><li>接收机（Receiver）：对信号进行解调、解码、解密后复原信息  </li></ul><p>具体而言：可由如下流程大概表示：<br>信源-&gt;信源编码-&gt;信道编码-&gt;调制-&gt;时钟同步-&gt;解调-&gt;解码  </p><ul><li>信源编码：将模拟信号转化为数字信号，减少冗余以增加系统有效性  </li><li>信道编码：增加额外的冗余（例如重复的部分、校验码）以增加系统可靠性  </li><li>调制：调制过程将原信号（称为基带信号）$S(t)$与载波$C(t)$结合转为高频波$S(t)C(t)$以方便传输。这个过程中不会有新信息加入。其中载波的形式可以是正弦波$cos(ω_ct+θ)$和脉冲波$δ(t)$。当载波是正弦波时，通过载波参数中的幅度、频率、相位的变化将数字信号加入其中，具体如下表所示。  </li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">载波参数</th><th style="text-align:center">方法</th><th style="text-align:center">二进制表达</th></tr></thead><tbody><tr><td style="text-align:center">幅度</td><td style="text-align:center">ASK</td><td style="text-align:center">0-&gt;”0”<br>A-&gt;”1”</td></tr><tr><td style="text-align:center">频率</td><td style="text-align:center">FSK</td><td style="text-align:center">$f_1$-&gt;”0”<br>$f_2$-&gt;”1”<br>$f_2$=$2f_1$</td></tr><tr><td style="text-align:center">相位</td><td style="text-align:center">PSK</td><td style="text-align:center">0-&gt;”0”<br>π-&gt;”1”</td></tr></tbody></table></div><p>  上述调制方法针对的是数字信号，对于模拟信号也同样有调制方法，分为：幅度调制和角度调制，在此不展开。  </p><h3 id="通信系统的分类"><a href="#通信系统的分类" class="headerlink" title="通信系统的分类"></a>通信系统的分类</h3><p>按传输方向分类：  </p><ul><li>单工：信号只能从发射机到接收机。举例：卫星电视</li><li>半双工：信号既可以从发射机到接收机，也能从接收机到发射机，但这两个过程不能同时进行。举例：对讲机</li><li>双工：信号既可以从发射机到接收机，也能从接收机到发射机，但这两个过程可以同时进行。举例：手机  </li></ul><p>按传输序列来分：  </p><ul><li>并行传输</li><li>串行传输</li></ul><h3 id="通信系统的有效性指标"><a href="#通信系统的有效性指标" class="headerlink" title="通信系统的有效性指标"></a>通信系统的有效性指标</h3><h4 id="传输速率"><a href="#传输速率" class="headerlink" title="传输速率"></a>传输速率</h4><p>传输速率是衡量系统有效性的关键指标。传输速率既可以单位时间内的以字符计，也可以单位时间内的以信息量计。  </p><ul><li>以字符计时的速率称为波特率/符号速率，以$R_B$或者$R_S$表示，单位为Baud或者字符/s。  </li><li>以信息量计时的速率称为比特率/码率，以$R_b$计，单位为bit/s，简记为bps。  <script type="math/tex; mode=display">R_b=R_Blog_2M</script></li></ul><h4 id="频谱效率"><a href="#频谱效率" class="headerlink" title="频谱效率"></a>频谱效率</h4><p>频谱效率用于表示频谱中每一个频率能够传输的信息大小，同样也以字符或信息量计。  </p><ul><li>以字符计时的频谱效率，以$η$表示，$η=\frac{R_B}{B}$，单位为Baud/Hz。  </li><li>以信息量计时的频谱效率，以$η_b$表示，$η_b=\frac{R_b}{B}$，单位为bit/(s Hz)。  <script type="math/tex; mode=display">η_b=ηlog_2M</script></li></ul><h3 id="通信系统的可靠性指标"><a href="#通信系统的可靠性指标" class="headerlink" title="通信系统的可靠性指标"></a>通信系统的可靠性指标</h3><h4 id="误码率"><a href="#误码率" class="headerlink" title="误码率"></a>误码率</h4><p>误码率（BER）是衡量系统可靠性的关键指标。误码率表示错误信息占传输信息的比值，同样也以字符或信息量计。  </p><ul><li>以字符计时：$P_e=\frac{Error symbol}{Total Symbol}$</li><li>以信息量计时：$P_b=\frac{Errorbit}{Total bit}$</li></ul><blockquote><p>通常来说通信系统的有效性和可靠性是反比关系，当传输速率快时，通信系统的有效性高，此时信号间的保护带间隔时间小，由于噪声和干扰的存在，保护带很容易消失而导致信号在接收端混淆，此时系统的误码率高，通信系统的可靠性低。反之亦然。  </p></blockquote><h4 id="干扰·信噪比·香农公式"><a href="#干扰·信噪比·香农公式" class="headerlink" title="干扰·信噪比·香农公式"></a>干扰·信噪比·香农公式</h4><p>由于传输过程中的路径损失、多径效应、和阴影效应，信号会在传输过程中受到干扰和损失。对传输信号产生干扰的信号称为噪声（Noise），噪声分为两种：  </p><ul><li>加性噪声：强度与原信号无关，原信号消失，噪声依然存在。  </li><li>乘性噪声：强度与原信号有关，原信号消失，噪声消失。  </li></ul><p>在通信系统中使用信噪比（SNR），即系统传输信号能量与噪声能量的比值来表示传输过程的强壮性：  </p><script type="math/tex; mode=display">SNR=\frac{P_{signal}}{P_{noise}}</script><h4 id="香农容量"><a href="#香农容量" class="headerlink" title="香农容量"></a>香农容量</h4><p>科学家香农给出了信息系统传输信息有效性的上限，称为香农容量/香农上限，简称容量。在误码率为0的情况下，信息系统的最大速率称为香农容量，它由香农公式给出：  </p><script type="math/tex; mode=display">C=Blog_2(1+\frac{S}{N})=Blog_2(1+SNR)</script><p>香农容量的单位为bps。<br>定义频谱中单位带宽内的噪声能量为$n_0$，噪声能量为$N=n_0B$。<br>此时香农公式可以改写为：  </p><script type="math/tex; mode=display">C=Blog_2(1+\frac{S}{N})=Blog_2(1+\frac{S}{n_0B})</script><p>可以看出当带宽趋近于无穷时：  </p><script type="math/tex; mode=display">\lim_{B→∞}C=\lim_{B→∞}Blog_2(1+\frac{S}{n_0B})≈1.44\frac{S}{n_0}</script><p>同时，频谱效率也可以由容量和带宽给出：  </p><script type="math/tex; mode=display">η_b=\frac{C}{B}=log_2(1+SNR)</script>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>通信原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01. 运算放大器</title>
    <link href="/2021/09/08/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%AD%90%E7%B3%BB%E7%BB%9F/1.%20OpAmp/"/>
    <url>/2021/09/08/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E5%AD%90%E7%B3%BB%E7%BB%9F/1.%20OpAmp/</url>
    
    <content type="html"><![CDATA[<h1 id="运算放大器"><a href="#运算放大器" class="headerlink" title="运算放大器"></a>运算放大器</h1><h2 id="结构和特性"><a href="#结构和特性" class="headerlink" title="结构和特性"></a>结构和特性</h2><p>一个运算放大器的结构如图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210908201643.png width=80%>  </p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><h4 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h4><p>2.反相输入端$V_{(-)}$<br>3.正相输入端$V_{(+)}$<br>6.输出$V_{out}$<br>运算放大器的输入电压$V_{(in)}$可以表示为：  </p><script type="math/tex; mode=display">V_{(in)}=V_{(+)}-V_{(-)}</script><h4 id="供电"><a href="#供电" class="headerlink" title="供电"></a>供电</h4><p>4.7.为两个供电接口，一般来说运算放大器的供电电压在⨦5v~⨦15v之间。  </p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><h4 id="增益"><a href="#增益" class="headerlink" title="增益"></a>增益</h4><p>一般来说，运算放大器内部输入端的阻抗非常的大；而内部输出端的阻抗非常的小；同时运算放大器的增益非常大。<br>运算放大器的（电压）增益：  </p><script type="math/tex; mode=display">A=\frac{V_{out}}{V_{in}}</script><p>由于运算放大器的增益常常到了上万级别，而运算放大器本质上是放大两个输入端之间的差异，因此如果两个输入端之间的电压差值过大可能会导致烧坏电路。一般输入端的$V_{(-)}$和$V_{(+)}$要求：  </p><script type="math/tex; mode=display">V_{(+)}≈V_{(-)}</script><p>在理想状态下，运算放大器输入端的阻抗无限大，输出端的阻抗为0，且增益为无限大。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210908203246.png width=50%>  </p><h4 id="频率响应特性"><a href="#频率响应特性" class="headerlink" title="频率响应特性"></a>频率响应特性</h4><p>对于运算放大器而言，<strong>随着频率的升高，运算放大器的电压增益会逐渐减小</strong>，如下图所示。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210908203630.png width=50%><br>定义在某一频率时的带宽与增益的乘积为<strong>增益带宽积（GBP）</strong>：  </p><script type="math/tex; mode=display">GBP=Gain × Bandwidth</script><h4 id="理想放大器的特性"><a href="#理想放大器的特性" class="headerlink" title="理想放大器的特性"></a>理想放大器的特性</h4><p>一般认为理想放大器在反相输入端和同相输入端之间存在两个特性，方便进行电路分析：  </p><ol><li><strong>理想放大器的反相输入端和同相输入端之间的电压是相等的，称为“虚短路”。</strong>  </li><li><strong>当其中一输入端口端直接接地时，理想放大器的反相输入端和同相输入端之间的电压是为“0”的，称为“虚接地”。</strong>  </li></ol><h2 id="基本电路"><a href="#基本电路" class="headerlink" title="基本电路"></a>基本电路</h2><h3 id="反相放大器"><a href="#反相放大器" class="headerlink" title="反相放大器"></a>反相放大器</h3><p>反相放大器的电路连接如图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210908204038.png width=50%>  </p><h4 id="增益-1"><a href="#增益-1" class="headerlink" title="增益"></a>增益</h4><blockquote><p>运算放大器的推导建立在两个基本条件之上：  </p><ol><li>由于$V_{(+)}≈V_{(-)}$，因此输入端的+-输入间可以视为通路，即$V_{(+)}=V_{(-)}$。  </li><li>人为地使得电阻$R_1$和$R_2$的阻值非常大（在千欧姆级别），因此通过-输入端与$R_1$之间的电流非常小，这部分电流可以视为0。  </li></ol></blockquote><p>反相放大器的增益：  </p><script type="math/tex; mode=display">A=-\frac{R_2}{R_1}</script><p>其推导过程简写如下：  </p><script type="math/tex; mode=display">\begin{aligned}    ∵&V_{(+)}≈V_{(-)},V_{(+)}=0 \\    ∴&V_{(+)}=V_{(-)}=0 \\    ∵&I_1=I_2,I_1=\frac{V_{in}-0}{R_1},I_2=\frac{0-V_{out}}{R_2}\\    ∴&\frac{V_{in}-0}{R_1}=-\frac{V_{out}}{R_2}\\    ∴&A=\frac{V_{out}}{V_{in}}=-\frac{R_2}{R_1}\end{aligned}</script><h3 id="同相放大器"><a href="#同相放大器" class="headerlink" title="同相放大器"></a>同相放大器</h3><p>同相放大器的电路连接如图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210908205726.png width=50%>  </p><h4 id="增益-2"><a href="#增益-2" class="headerlink" title="增益"></a>增益</h4><p>同相放大器的增益：  </p><script type="math/tex; mode=display">A=1+\frac{R_2}{R_1}</script><p>其推导过程简写如下：  </p><script type="math/tex; mode=display">\begin{aligned}    ∵&V_{(+)}≈V_{(-)},V_{(+)}=V_{in}\\    ∴&V_{(-)}=V_{(+)}=V_{in}\\    ∵&I_1=I_2,I_1=\frac{V_{in}-0}{R_1},I_2=\frac{V_{out}-V_{in}}{R_2}\\    ∴&\frac{V_{in}}{R_1}=\frac{V_{out}-V_{in}}{R_2}\\    ∴&A=\frac{V_{out}}{V_{in}}=1+\frac{R_2}{R_1}\end{aligned}</script><h3 id="缓冲器"><a href="#缓冲器" class="headerlink" title="缓冲器"></a>缓冲器</h3><p>缓冲器结构如图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210908210811.png width=50%>  </p><p>其增益始终为1。<br>设置缓冲器的目的是为了在不改变电压大小的前提下，对信号的电流进行操作，以补充衰减。</p><blockquote><p>信息以电压的形式传输，而电流表征的是携带信息的信号强度  </p></blockquote><h2 id="基本电路的应用"><a href="#基本电路的应用" class="headerlink" title="基本电路的应用"></a>基本电路的应用</h2><h3 id="加法放大器（反相输入）"><a href="#加法放大器（反相输入）" class="headerlink" title="加法放大器（反相输入）"></a>加法放大器（反相输入）</h3><p>加法放大器（Summing Amplifier）的结构如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210909122946.png width=60%><br>有输入端的各支路电流总和大小等于输出端的电流大小，考虑到虚接地，有：  </p><script type="math/tex; mode=display">∑\frac{V_{in}}{R_{in}}=-\frac{V_{out}}{R_F}</script><p>推出：  </p><script type="math/tex; mode=display">V_{out}=-R_F∑\frac{V_{in}}{R_{in}}</script><p>加法放大器（反相输入）的增益为：  </p><script type="math/tex; mode=display">G=\frac{V_{out}}{∑_iV_i}</script><h3 id="积分器"><a href="#积分器" class="headerlink" title="积分器"></a>积分器</h3><p>积分器的电路如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210909123818.png width=60%>  </p><script type="math/tex; mode=display">V_{out}=-\frac{1}{R_{in}C}∫V_{in}dt</script><p>其推导过程如下：  </p><script type="math/tex; mode=display">\begin{aligned}   ∵&V_c=\frac{Q}{C}=-V_{out}\\   ∴&\frac{dV_{out}}{dt}=-\frac{dQ}{Cdt}=-\frac{I_F}{C}\\   ∴&I_F=-C\frac{dV_{out}}{dt}\\   ∵&I_{in}=\frac{V_{in}}{R_{in}}\\   ∴&-C\frac{dV_{out}}{dt}=\frac{V_{in}}{R_{in}}\\   ∴&V_{out}=-\frac{1}{R_{in}C}∫V_{in}dt\end{aligned}</script><h3 id="微分器"><a href="#微分器" class="headerlink" title="微分器"></a>微分器</h3><p>微分器的结构如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210909130230.png width=60%>  </p><script type="math/tex; mode=display">V_{out}=-R_FC\frac{dV_{in}}{dt}</script><p>其推导过程如下：  </p><script type="math/tex; mode=display">\begin{aligned}    ∵&V_c=\frac{Q}{C}=V_{in}\\    ∴&\frac{dQ}{Cdt}=\frac{I_{in}}{C}=\frac{dV_{in}}{t}\\    ∵&I_F=\frac{V_{out}}{R_F},I_F=-I_{in}\\    ∴&V_{out}=-R_FC\frac{dV_{in}}{dt}\end{aligned}</script><h3 id="差分放大器"><a href="#差分放大器" class="headerlink" title="差分放大器"></a>差分放大器</h3><p>与之前的加法器、积分器、微分器不同，差分器使用到了$V_+$和$V_-$两个输入端，结构如图所示。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210915184315.png width=50%>  </p><p>由之前的推理，放大器两个输入端的电压里仍然相等，有$V_+=V_-$。同时，根据分压定理：$V_b=V_2(\frac{R_4}{R_2+R_4})$。<br>由叠加定理，单独看两个电压源：<br>单独看$V_1$，有$V_{out1}=-V_1\frac{R_3}{R_1}$。<br>单独看$V_2$，有$V_{out2}=V_2\frac{R_4}{R_2+R_4}\frac{R_1+R_3}{R_1}$。<br>所以,  </p><script type="math/tex; mode=display">V_{out}=-V_1\frac{R_3}{R_1}+V_2\frac{R_4}{R_2+R_4}\frac{R_1+R_3}{R_1}</script><p>当$\frac{R_2}{R_1}=\frac{R_4}{R_3}$时，有：</p><script type="math/tex; mode=display">V_{out}=\frac{R_2}{R_1}(V_2-V_1)</script><p>这种设计常常在实际中应用。  </p><p>差分放大器的增益可以定义为：  </p><script type="math/tex; mode=display">G=\frac{V_{out}}{V_1-V_2}</script><h4 id="差分放大器的缺陷"><a href="#差分放大器的缺陷" class="headerlink" title="差分放大器的缺陷"></a>差分放大器的缺陷</h4><p>如上图接入的差分放大器有两个缺陷：  </p><ol><li>由于放大器内部输入端阻抗远远高于外部的两个电阻的阻值，因此实际上电流大部分会通过$R_4$流向地面而并非流入运算放大器中。  </li><li>当$\frac{R_2}{R_1}=\frac{R_4}{R_3}$时，差分放大器的增益为:<script type="math/tex; mode=display">Gain=\frac{R_2}{R_1}=\frac{R_4}{R_3}</script>要想改变差分放大器的增益，需要同时改变至少两个电阻以保证条件$\frac{R_2}{R_1}=\frac{R_4}{R_3}$依然成立，事实上通过改变至少两个电阻的阻值来改变放大器增益是非常麻烦的。  </li></ol><h4 id="仪用放大器"><a href="#仪用放大器" class="headerlink" title="仪用放大器"></a>仪用放大器</h4><p>为了减小差分放大器的缺陷，在实际运用中做了如下的改进，改进后的差分放大器称为仪用放大器。<br>对于缺陷1，改进办法是在两个输入端各连接一个缓冲放大器，由于缓冲放大器内部阻抗很高，因此电流不会大量流入接地端。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210916104115.png width=50%>  </p><p>对于缺陷2，改进办法如图所示。下图所示的结构为仪用放大器的结构。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210916104312.png width=50%><br>如图所示的电路中$R_2→R_1→R_2$（下图蓝色标注）上流过的电流是相等的：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210916104500.png width=70%>  </p><p>此处的电流为：$i=\frac{V_2-V_1}{R_1}$。<br>此时差分器输入端的电压差可表示为：$V_{o2}-V_{o1}=i(2R_2+R_1)$。<br>带入之前差分放大器的输出电压：$V_{out}=\frac{R_2}{R_1}(V_2-V_1)$，得到仪用放大器的输出电压表达式：  </p><script type="math/tex; mode=display">V_o=\frac{R_4}{R_3}(V_2-V_1)(1+2\frac{R_2}{R_1})</script><p>仪用放大器的增益：  </p><script type="math/tex; mode=display">Gain=\frac{R_4}{R_3}(1+2\frac{R_2}{R_1})</script><p>结合之前的推导可以发现，此时只需要改变$R_1$的阻值即可改变增益。<br>实际上，仪用放大器可以被集成电路化后做成一个8pin的电路元件，其中$V_k$和$V_Y$两个pin外部连接一个电阻$R_1$来改变放大器增益。  </p><h3 id="共模抑制比"><a href="#共模抑制比" class="headerlink" title="共模抑制比"></a>共模抑制比</h3><p>对于差分放大器，之前只讨论了$\frac{R_2}{R_1}=\frac{R_4}{R_3}$时的增益。<br>当$\frac{R_2}{R_1}≠\frac{R_4}{R_3}$时，对于$V_{out}=-V_1\frac{R_3}{R_1}+V_2\frac{R_4}{R_2+R_4}\frac{R_1+R_3}{R_1}$，很难直接看出差分放大器的增益。所以人为地设置两个新的变量以分离电压，便于求出增益。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210915184315.png width=50%><br>设对差模分量：$V_d=V_2-V_1$<br>共模分量：$V_{cm}=\frac{V_2+V_1}{2}$<br>有$V_1=V_{cm}-\frac{V_d}{2}$、$V_2=V_{cm}+\frac{V_d}{2}$。<br>带入原来的输出电压表达式中，得到：  </p><script type="math/tex; mode=display">V_{out}=\frac{1}{2}\frac{R_4}{R_2+R_4}[\frac{R_3+R_1}{R_1}+\frac{R_3}{R_1}]V_d+[\frac{R_3+R_1}{R_1}-\frac{R_3}{R_1}]V_{cm}</script><p>那么增益可以表示为：  </p><script type="math/tex; mode=display">Gain=\frac{V_{out}}{V_d}=A_d=\frac{1}{2}\frac{R_4}{R_4+R_2}[\frac{R_1+R_3}{R_1}+\frac{R_3}{R_1}]</script><p>这个增益称为<strong>对差模增益</strong>$A_d$。<br>同样地，定义共模增益$A_{cm}$:  </p><script type="math/tex; mode=display">A_{cm}=\frac{V_{out}}{V_{cm}}=\frac{R_4}{R_2+R_4}[\frac{R_3+R_1}{R_1}-\frac{R_3}{R_1}]</script><p><strong>放大器的差模增益是电路所需要的增益，而共模增益将放大直流噪声</strong>。共模抑制比（Common Mode Rejection Ratio，CMRR），定义为差模增益与共模增益的比值:  </p><script type="math/tex; mode=display">CMRR=\frac{A_d}{A_{cm}}</script><script type="math/tex; mode=display">CMRR(dB)=20lg\frac{A_d}{A_{cm}}</script><h2 id="频率响应特性-1"><a href="#频率响应特性-1" class="headerlink" title="频率响应特性"></a>频率响应特性</h2><p>放大器的频率响应特性曲线如图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210916105607.png width=60%>  </p><p>其中：  </p><ul><li>$f_b$是$maxgain(dB)-3dB=A_0$时所对应的频率，一般认为在这个频率后放大器增益不再稳定，随着频率的增大而下降。称$f_b$为放大器的<strong>截止频率</strong>。  </li><li>$f_t$是增益为0，即1dB时所对应的频率，称为放大器的<strong>传输频率</strong>。<br>放大器的频率响应特性表示为：  <script type="math/tex; mode=display">A(f)=\frac{A_0}{1+j(\frac{f}{f_b})}</script>当$f&gt;&gt;f_b$时，可以化简为：  <script type="math/tex; mode=display">A(f)=\frac{A_0f_b}{f}</script>当增益为1时，求得传输频率的表达式：  <script type="math/tex; mode=display">f_t=A_0f_b</script></li></ul><h3 id="压摆率"><a href="#压摆率" class="headerlink" title="压摆率"></a>压摆率</h3><p>理想的运算放大器在输入电压接入运算放大器的同时就会立即有稳定的输出电压，然而实际的运算放大器由于内部电容充电过程的存在，需要经过一小段时间才能达到稳定输出电压$V_o$，达到稳定输出电压的最大速率称为<strong>压摆率</strong>或电压转换速率（Slew Rate）。  </p><script type="math/tex; mode=display">S.R.=\frac{dV_o}{dt}|_{max}</script><p>如果输入信号的频率过高，以至于放大器的放大过程跟不上输入信号的变化，放大器的输出信号失真、幅度缩小。<br>当输出信号是一个正弦波$y=Asinωt$时，$S.R.=Aωcosωt,ωt=0$。<br>带入$ω=2πf$，得到电压转换速率与放大器输出电压信号的峰值$A$、频率$f$的关系为:  </p><script type="math/tex; mode=display">S.R.=2πAf</script><p>可以得到运算放大器所支持的某峰值下的最大信号频率为：  </p><script type="math/tex; mode=display">f_{max}=\frac{SR}{2πA}</script><p>$f_{max}$称为全功率带宽，这个表达式也暗示可以通过减小信号的峰值使得运算放大器支持更高频率的信号。  </p><h2 id="泄露和补偿"><a href="#泄露和补偿" class="headerlink" title="泄露和补偿"></a>泄露和补偿</h2><p>在真实的放大器中，输入端$V_+$和$V_-$之间是有电流的，这个电流称为泄露电流，在反相放大器中这个电流会流向$V_+$的接地端。泄露电流的存在会造成假设$V_+=V_-$不成立，因此在运算放大器的内部需要添加一个补偿电容来对$V_+$和$V_-$的电压进行补偿。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210916113332.png width=50%>  </p><p>如图所示，当第一级输出的电流$i_{id}$为高频率时，电流绕过电压放大器，对电压放大器不会产生影响。<br>当第一级输出的电流$i_{id}$为低频率时，电容断路，电流被消除，但是电压信号仍然可以被放大。  </p><p>同时在接地端需要额外增加一个补偿电阻以减小泄露电流的影响。在集成化的仪用放大器中，有两个pin：offset用于额外连接一个变阻器，调节补偿电阻的大小。  </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>电子系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Unit 01~05</title>
    <link href="/2021/09/08/%E6%97%A5%E8%AF%AD/N2%E5%A4%87%E8%80%83/Unit%201/"/>
    <url>/2021/09/08/%E6%97%A5%E8%AF%AD/N2%E5%A4%87%E8%80%83/Unit%201/</url>
    
    <content type="html"><![CDATA[<h1 id="Unit-1-5-あ行・か行"><a href="#Unit-1-5-あ行・か行" class="headerlink" title="Unit 1~5 あ行・か行"></a>Unit 1~5 あ行・か行</h1><h2 id="Unit-1-あ・い・う"><a href="#Unit-1-あ・い・う" class="headerlink" title="Unit 1 あ・い・う"></a>Unit 1 あ・い・う</h2><ul><li>あげく<br>動詞た形・名詞～の＋あげく　  <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【最后……，往往带有不好的结果】</span>  </span></li><li>あまり（に）<br>動詞辞書形・名詞～の・な形容詞～な＋あまり（に）    <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【过于……而导致】</span>  </span></li><li>以上<br>動詞普通形・名詞～の/である・な形容詞～な/である・い形容詞＋以上　  <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【既然……】</span>  </span></li><li>一方・一方で（は）<br>動詞普通形・名詞～の/である・な形容詞～な/である・い形容詞＋一方・一方で（は）   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【一边……/一方面……】</span>  </span></li><li>一方だ<br>動詞辞書形＋一方だ   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【逐渐地……/越来越……】</span>  </span></li><li>上で（は）  <ul><li>動詞辞書形・名詞～の＋上で（は）  <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【在（地图、数据等文字内容）的基础之上】</span>  </span></li><li>動詞た形・名詞～の＋上で（は）/名詞～の＋上   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【在……之后】</span>  </span></li></ul></li><li>上は<br>動詞辞書形・た形＋上は   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【既然……】</span>  </span></li><li>うちに  <ul><li>動詞普通形・名詞～の・な形容詞～な・い形容詞＋うちに   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【趁着……的时候、在……期间】</span>  </span></li><li>▴動詞て形～ている・ない形＋うちに   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【在发生……的时候同时】</span>  </span></li></ul></li><li>うちは<br>動詞普通形・名詞～の・な形容詞～な・い形容詞＋うちは   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【在（还没）……的时候】</span>  </span></li><li>ようではないか・ようじゃないか<br>動詞意向形＋ようではないか・ようじゃないか   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【让我们一起……吧，劝诱的表达】</span>  </span></li></ul><h2 id="Unit-2-え・お・か（が）"><a href="#Unit-2-え・お・か（が）" class="headerlink" title="Unit 2　え・お・か（が）"></a>Unit 2　え・お・か（が）</h2><ul><li>得る/得ない<br>動詞ます形＋得る/得ない    <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【可能/不可能……】</span>  </span></li><li><p>おかけで・おかけだ<br>動詞普通形・な形容詞～な・名詞～の・い形容詞    <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【多亏了……】</span>  </span></p><blockquote><p>おかけで用在句中，おかけだ用在句末  </p></blockquote></li><li><p>恐れがある<br>動詞辞書形・名詞～の＋恐れがある   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【恐怕会……】</span>  </span>  </p></li><li>甲斐がある/甲斐がない/甲斐もなく  <ul><li>動詞た形・名詞～の＋甲斐がある   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【……是有价值的】</span>  </span></li><li>動詞た形・名詞～の＋甲斐がない/甲斐もなく    <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【……是没价值的/白白地……】</span>  </span></li></ul></li><li>がきっかけに・なって・をきっかけに（して）・きっかけとして　<br>動詞普通形～の・名詞＋がきっかけに・あって・をきっかけに（して）・きっかけとして   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【以……为契机】</span>  </span>  </li><li><p>が契機で・が契機になって・を契機に（して）・を契機として<br>同上，がきっかけ的书面语  </p><blockquote><p>注意：が…あって・を…として/にして  </p></blockquote></li><li><p>かけだ・かけの・かける<br>動詞ます形＋かけだ・かけの・かける   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【……做到一半就……/……已经开始发生】</span>  </span>  </p></li><li>がたい<br>動詞ます形＋がたい   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【很难……，常与认知或者是表示说话的词语连用】</span>  </span>  </li><li>限り  <ul><li>動詞辞書形・可能形・名詞～の＋限り   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【最大限度地尽量……】</span>  </span>  </li><li>動詞辞書形・ている・い形容詞＋限り   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【只要……就……】</span>  </span> </li></ul></li><li>ない限り　<br>動詞ない形＋ない限り   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【只要不……就……/除非……否则就……】</span>  </span> </li><li>限り・限りでは<br>動詞辞書形・た形・ている＋限り・限りでは   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【据……的范围内/据……所】</span>  </span> </li></ul><h2 id="Unit-3-か（が）"><a href="#Unit-3-か（が）" class="headerlink" title="Unit 3　か（が）"></a>Unit 3　か（が）</h2><ul><li>がちだ・がちの・がちな<br>動詞ます形・名詞＋がちだ・がちの・がちな   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【容易……，表示容易发生负面的状态，强调发生次数多】</span>  </span>   </li><li>かというと・かといえば  <ul><li>動詞普通形・い形容詞＋（の）かというと・かといえば </li><li>な形容詞・名詞＋（なの）かというと・かといえば    <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【是否是……就……/至于是否是……】*事实上结果相反</span>  </span>   </li><li>疑問詞＋かというと・かといえば   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【要说……，自问自答】</span>  </span></li><li>固定搭配：どちらかというと   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【要说……的话，提起话题】</span>  </span></li></ul></li><li>（か）と思うと・（か）と思ったら  <ul><li>⋆動詞た形＋（か）と思うと・（か）と思ったら    <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【刚……就……，几乎同时发生，表示客观叙述，含有惊讶的情绪】</span>  </span> </li><li>動詞辞書形・た形＋（か）と思うと・（か）と思ったら   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【原以为……，却……】</span>  </span>  </li></ul></li><li>かと思えば  <ul><li>動詞辞書形・た形＋かと思えば   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【原以为……，却……】</span>  </span></li><li>⋆動詞辞書形＋かと思えば   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【既……，又……】</span>  </span></li></ul></li><li>~か~ないかのうちに<br>動詞辞書形＋か＋同じ動詞ない形＋ないかのうちに   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【还没……，就……，几乎同时发生】</span>  </span></li><li>か何か<br>名詞＋か・や・を・で+何か   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【……啊这些的，泛指】</span>  </span></li><li>かねる・かねない  <ul><li>動詞ます形＋かねる   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【想做却很难……，书面语】</span>  </span></li><li>動詞ます形＋かねない   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【可能……，负面的结果】</span>  </span></li></ul></li><li><p>かのように・かのような・かのようだ<br>動詞普通形＋かのように・かのような・かのようだ   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【就像……一样】</span>  </span></p><blockquote><p>だ用于句末，な、に用于句中修饰对应成分  </p></blockquote></li><li><p>からいいようなものの・からよっかたものの<br>普通形＋からいいようなものの・からよっかたものの　  <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【幸好……】</span>  </span>  </p></li></ul><h2 id="Unit-4-か（が）・き（ぎ）"><a href="#Unit-4-か（が）・き（ぎ）" class="headerlink" title="Unit 4　か（が）・き（ぎ）"></a>Unit 4　か（が）・き（ぎ）</h2><ul><li>からいうと・からいえば・からいって・からすると・からすれば<br>名詞＋からいうと・からいえば・からいって・からすると・からすれば   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【从……上来看，名词不能为人】</span>  </span> </li><li>から見ると・から見れば・から見ても<br>名詞＋から見ると・から見れば・から見ても   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【从……上来看，名词可以为人】</span>  </span> </li><li>からこそ<br>普通形＋からこそ   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【正是因为……，正面原因】</span>  </span>  </li><li>からして<br>名詞＋からして   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【单从……来看】</span>  </span>  </li><li>からといって<br>普通形＋からと言って   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【虽然说……】</span>  </span> </li><li><p>からには  </p><ul><li>動詞普通形・い形容詞＋からには   </li><li>な形容詞・名詞＋である＋からには     <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【既然……】</span>  </span></li></ul></li><li><p>かわりに<br>普通形＋かわりに</p><ol><li>  <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【相对地，但是……，表示转折】</span>  </span></li><li>  <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【代替】</span>  </span></li></ol></li><li>気味<br>動詞ます形＋気味   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【有点……，形容说话人自己的感觉，负面】</span>  </span></li><li>きり・きりだ  <ul><li>動詞辞書形・た形・名詞＋きり   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【只有……，表示限定】</span>  </span></li><li>動詞た形＋きり・きりだ   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【一……就再没有……】</span>  </span>  </li></ul></li></ul><h2 id="Unit-5-き・く（ぐ）・こ"><a href="#Unit-5-き・く（ぐ）・こ" class="headerlink" title="Unit 5 き・く（ぐ）・こ"></a>Unit 5 き・く（ぐ）・こ</h2><ul><li>きる・きれる・きれない  <ul><li>動詞ます形＋きる <ol><li>  <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【做完了……】</span>  </span>  </li><li>  <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【表示做动作的程度深】</span>  </span>   常用：思い切る  <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【下决心】</span>  </span>　いいきる  <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【断言】</span>  </span>　わかりきる  <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【很明白】</span>  </span>　  </li></ol></li><li>動詞ます形＋きれる   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【能做完……】</span>  </span></li><li>動詞ます形＋きれない<ol><li>  <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【做不完……】</span>  </span></li><li>  <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【怎么也……做不完】</span>  </span>   常用：死んでも死にきれない   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【死也不甘心】</span>  </span>　数え切れないほど  <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【数也数不清】</span>  </span>  　　</li></ol></li></ul></li><li>くせに・くせして<br>普通形＋くせに   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【明明……】</span>  </span></li><li>くらい・ぐらい  <ul><li>動詞辞書形・ない形～ない・な形容詞～な・名詞・い形容詞＋くらい・ぐらい   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【差不多……的程度】</span>  </span></li><li>動詞辞書形・名詞＋くらい・ぐらい～ない   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【没有比……更……的了，最高程度】*后项为否定句</span>  </span></li></ul></li><li>ことか<br>普通形＋ことか   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【多么……啊】</span>  </span></li><li>ことから<br>動詞普通形・い形容詞・な形容詞～なである・名詞～である＋ことから   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【从……来看】</span>  </span></li><li>ことだから<br>名詞＋ことだから   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【因为是……，所以……】*名词为人物名词</span>  </span></li><li>ことだ・ないことだ  <ul><li>動詞辞書形＋ことだ   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【应该做……，劝告】</span>  </span></li><li>動詞ない形＋ないことだ   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【最好不要做……，劝告】</span>  </span></li></ul></li><li>ことなく・こともなく<br>動詞辞書形＋ことなく・こともなく   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【没有……，书面语】</span>  </span></li><li>ことは～が  <ul><li>動詞普通形・い形容詞＋ことは＋動詞普通形・い形容詞＋が</li><li>な形容詞～な＋ことは＋な形容詞＋だが    <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【……是……了，但是……】*表示承认动作，否定结果</span>  </span></li></ul></li><li>ことはない<br>動詞辞書形＋ことはない   <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur ">【没必要……】</span>  </span></li></ul>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
      <category>N2备考文法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日语</tag>
      
      <tag>N2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自动词·他动词转换一览表</title>
    <link href="/2021/09/07/%E6%97%A5%E8%AF%AD/N2%E5%A4%87%E8%80%83/%E8%87%AA%E5%8A%A8%E8%AF%8D%E4%BB%96%E5%8A%A8%E8%AF%8D/"/>
    <url>/2021/09/07/%E6%97%A5%E8%AF%AD/N2%E5%A4%87%E8%80%83/%E8%87%AA%E5%8A%A8%E8%AF%8D%E4%BB%96%E5%8A%A8%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="自动词·他动词转换一览表"><a href="#自动词·他动词转换一览表" class="headerlink" title="自动词·他动词转换一览表"></a>自动词·他动词转换一览表</h1><div class="table-container"><table><thead><tr><th style="text-align:center">他动词</th><th style="text-align:center">自动词</th><th style="text-align:center">举例</th></tr></thead><tbody><tr><td style="text-align:center">〇える</td><td style="text-align:center">〇ある</td><td style="text-align:center">掛ける⇔掛かる</td></tr><tr><td style="text-align:center">〇す</td><td style="text-align:center">〇る</td><td style="text-align:center">消す⇔消える</td></tr><tr><td style="text-align:center">〇る</td><td style="text-align:center">〇れる</td><td style="text-align:center">売る⇔売れる</td></tr><tr><td style="text-align:center">〇く</td><td style="text-align:center">〇ける</td><td style="text-align:center">開く⇔開ける</td></tr></tbody></table></div><h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><ul><li>有自动词，没有对应的他动词时，需要用他动词的形式，把自动词变成：使役形，就其对应的他动词。<br>例：泣く＜自＞⇔泣かせる “让哭”（使役形）＜他＞  </li><li>有他动词，没有对应的自动词时，需要用自动词的形式，把他动词变成可能形，就是对应的自动词了。<br>例：読む ＜他＞⇔読める “能读”（可能形）＜自＞</li></ul>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
      <category>N2备考文法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日语</tag>
      
      <tag>N2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>15.1. 吴恩达：总结和感谢</title>
    <link href="/2021/08/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/15.%20%E6%80%BB%E7%BB%93%E5%92%8C%E6%84%9F%E8%B0%A2/15.1.%20%E6%80%BB%E7%BB%93%E5%92%8C%E6%84%9F%E8%B0%A2/"/>
    <url>/2021/08/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/15.%20%E6%80%BB%E7%BB%93%E5%92%8C%E6%84%9F%E8%B0%A2/15.1.%20%E6%80%BB%E7%BB%93%E5%92%8C%E6%84%9F%E8%B0%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="吴恩达：总结和感谢"><a href="#吴恩达：总结和感谢" class="headerlink" title="吴恩达：总结和感谢"></a>吴恩达：总结和感谢</h1><p>欢迎来到《机器学习》课的最后一段视频。我们已经一起学习很长一段时间了。在最后这段视频中，我想快速地回顾一下这门课的主要内容，然后简单说几句想说的话。</p><p>作为这门课的结束时间，那么我们学到了些什么呢？在这门课中，我们花了大量的时间介绍了诸如<strong>线性回归</strong>、<strong>逻辑回归</strong>、<strong>神经网络</strong>、<strong>支持向量机</strong>等等一些监督学习算法，这类算法具有带标签的数据和样本，比如$\{x^{(i)},y^{(i)}\}$。</p><p>然后我们也花了很多时间介绍无监督学习。例如 <strong>K-均值</strong>聚类、用于降维的<strong>主成分分析</strong>，以及当你只有一系列无标签数据 $\{x^{(i)}\}$ 时的<strong>异常检测算法</strong>。</p><p>当然，有时带标签的数据，也可以用于异常检测算法的评估。此外，我们也花时间讨论了一些特别的应用或者特别的话题，比如说<strong>推荐系统</strong>。以及<strong>大规模机器学习系统</strong>，包括并行系统和映射化简方法，还有其他一些特别的应用。比如，用于计算机视觉技术的滑动窗口分类算法。</p><p>最后，我们还提到了很多关于<strong>构建机器学习系统的实用建议</strong>。这包括了怎样理解某个机器学习算法是否正常工作的原因，所以我们谈到了偏差和方差的问题，也谈到了解决方差问题的正则化，同时我们也讨论了怎样决定接下来怎么做的问题，也就是说当你在开发一个机器学习系统时，什么工作才是接下来应该优先考虑的问题。因此我们讨论了学习算法的评价法。介绍了评价矩阵，比如：查准率、召回率以及F1分数，还有评价学习算法比较实用的训练集、交叉验证集和测试集。我们也介绍了学习算法的调试，以及如何确保学习算法的正常运行，于是我们介绍了一些诊断法，比如学习曲线，同时也讨论了误差分析、上限分析等等内容。</p><p>所有这些工具都能有效地指引你决定接下来应该怎样做，让你把宝贵的时间用在刀刃上。现在你已经掌握了很多机器学习的工具，包括监督学习算法和无监督学习算法等等。</p><p>但除了这些以外，我更希望你现在不仅仅只是认识这些工具，更重要的是掌握怎样有效地利用这些工具来建立强大的机器学习系统。所以，以上就是这门课的全部内容。如果你跟着我们的课程一路走来，到现在，你应该已经感觉到自己已经成为机器学习方面的专家了吧？</p><p>我们都知道，机器学习是一门对科技、工业产生深远影响的重要学科，而现在，你已经完全具备了应用这些机器学习工具来创造伟大成就的能力。我希望你们中的很多人都能在相应的领域，应用所学的机器学习工具，构建出完美的机器学习系统，开发出无与伦比的产品和应用。并且我也希望你们通过应用机器学习，不仅仅改变自己的生活，有朝一日，还要让更多的人生活得更加美好！</p><p>我也想告诉大家，教这门课对我来讲是一种享受。所以，谢谢大家！</p><p>最后，在结束之前，我还想再多说一点：那就是，也许不久以前我也是一个学生，即使是现在，我也尽可能挤出时间听一些课，学一些新的东西。所以，我深知要坚持学完这门课是很需要花一些时间的，我知道，也许你是一个很忙的人，生活中有很多很多事情要处理。正因如此，你依然挤出时间来观看这些课程视频。我知道，很多视频的时间都长达数小时，你依然花了好多时间来做这些复习题。你们中好多人，还愿意花时间来研究那些编程练习，那些又长又复杂的编程练习。我对你们表示衷心的感谢！我知道你们很多人在这门课中都非常努力，很多人都在这门课上花了很多时间，很多人都为这门课贡献了自己的很多精力。所以，我衷心地希望你们能从这门课中有所收获！</p><p>最后我想说！再次感谢你们选修这门课程！</p><p><strong>Andew Ng</strong></p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210828131429.png width=90%></p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>15. 总结和感谢</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>14.5. 上限分析</title>
    <link href="/2021/08/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/14.%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E4%BE%8B%EF%BC%9AOCR/14.5.%20%E4%B8%8B%E4%B8%80%E6%AD%A5%E9%9C%80%E8%A6%81%E5%81%9A%E4%BB%80%E4%B9%88/"/>
    <url>/2021/08/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/14.%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E4%BE%8B%EF%BC%9AOCR/14.5.%20%E4%B8%8B%E4%B8%80%E6%AD%A5%E9%9C%80%E8%A6%81%E5%81%9A%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h1 id="上限分析"><a href="#上限分析" class="headerlink" title="上限分析"></a>上限分析</h1><p>在之前的学习中已经知道，在机器学习系统设计之初就需要设计整个系统的流水线。现在在构建好整个机器学习系统之后，回顾整个流程图，使用<strong>上限分析</strong>的策略来分析现在对整个流水线中的哪些部分进行改进、哪些部分需要花费最大的资源，才能够最大化地提升系统的性能。  </p><p>最好的方法仍然是对整个系统的评估进行量化。<br>回顾之前的照片光学字符识别的流水线：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210826094605.png width=70%><br>现在构建一个评估方式量化这个系统的性能，并应用控制变量法对整个系统的每个模块进行评估。<br>这样的思路建立在人工的做法准确率为100%之上。即将某个模块的准确度拉到100%，观察其他模块或者是整个系统的上限。<br><strong>应用控制变量法，人为地除去流水线上的某一个模块，将这个模块改为由人工来进行，运行这个系统，观察人工进行这个模块后，系统整体的准确率会有多大的改变。最终转为人工后对整个系统准确率提升最大的部分将会是需要耗费更多精力改进的部分。</strong>  </p><p>比如整个系统的准确率一开始是72%，当我们不进行文字检测，而使用人工圈出图像中有文字的部分喂给流水线上的下一个模块，得到的整个系统的准确率是89%。而人工分割字符后整个系统的准确率是90%，只在上一个改进的基础上提升了1%。 这意味着需要花费更多的精力在提升文字检测的准确率上。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210828125921.png width=90%>  </p><h2 id="案例：人脸识别系统"><a href="#案例：人脸识别系统" class="headerlink" title="案例：人脸识别系统"></a>案例：人脸识别系统</h2><p>人脸识别系统的流程要比照片光学字符识别更为复杂。下图描述了人工替换系统中的每一个模块后，整个系统的准确率。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210828130357.png width=90%><br>从整体上来看，可以发现如果对脸部检测进行改进，其带来的对整个系统的提升是最大的。  </p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>14. 机器学习实例：光学字符识别（OCR）</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>14.4. 人工数据合成</title>
    <link href="/2021/08/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/14.%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E4%BE%8B%EF%BC%9AOCR/14.4.%20%E8%8E%B7%E5%BE%97%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE/"/>
    <url>/2021/08/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/14.%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E4%BE%8B%EF%BC%9AOCR/14.4.%20%E8%8E%B7%E5%BE%97%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="人工数据合成"><a href="#人工数据合成" class="headerlink" title="人工数据合成"></a>人工数据合成</h1><p>通过之前的学习，可以得出机器学习的实质是使用一个低偏差的算法学习一个相对庞大甚至是非常庞大的数据集，如何获得大量的数据集呢。实际上，有时寻找一些特定的数据集是非常困难的，通常有如下的几种思路可以获得大量数据：  </p><ul><li>人工数据合成</li><li>手动标记标签</li><li>雇佣众包来标记数据</li></ul><p>本节主要介绍一种称为<strong>人工数据合成</strong>的方法。人工数据合成可以通过<strong>生成数据集</strong>或者是<strong>对现有的数据集进行扩增</strong>以增加数据量。  </p><p>下面将以光学字符识别为例，介绍人工数据合成所采用的两种策略。  </p><h2 id="生成数据集"><a href="#生成数据集" class="headerlink" title="生成数据集"></a>生成数据集</h2><p>要获得识别光学字符识别所需要的大量数据集，一个办法是通过计算机字体库自动生成一些单独的字符图像，与任意的背景进行组合，从而人为地创造数据集。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210828122037.png width=90%><br>如上图所示的合成数据（图左），可以发现通过这种方式创造的数据集事实上和真实数据集（图右）之间的差别不大。  </p><h2 id="数据集扩增"><a href="#数据集扩增" class="headerlink" title="数据集扩增"></a>数据集扩增</h2><p>数据集扩增是建立在原有的少量数据集之上。对于光学字符识别所需要的字符图像，一种可行的办法是对图像进行各种拉伸以创造新的图像，如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210828122408.png width=50%><br>扩增的核心思想是对现有的数据人为地加入一些噪音或者变换，以制造更多的可能数据。<br>需要注意：这些噪声和变换的目的是为了增加数据集中的丰富性，从而使得算法能够应对更多的场景。因此这些噪声和变换需要是在现实中可能出现的、有意义的，以模拟识别目标的多样性和真实性。  </p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>在进行人工数据合成之前，仍然要保证算法处于低偏差状态。  </li><li>在进行人工合成之前，需要评估这样做的工作量。评估花这么多的工作量是否值得。如果以很小的代价就能够获得10倍乃至更多的数据，那么这样的工作是值得的。  </li></ol>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>14. 机器学习实例：光学字符识别（OCR）</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>14.3. 文字分离·字符识别</title>
    <link href="/2021/08/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/14.%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E4%BE%8B%EF%BC%9AOCR/14.3.%20%E6%96%87%E5%AD%97%E5%88%86%E7%A6%BB/"/>
    <url>/2021/08/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/14.%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E4%BE%8B%EF%BC%9AOCR/14.3.%20%E6%96%87%E5%AD%97%E5%88%86%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="文字分离·字符识别"><a href="#文字分离·字符识别" class="headerlink" title="文字分离·字符识别"></a>文字分离·字符识别</h1><p>照片OCR系统的流水线：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210826094605.png width=70%><br>本节将着重于“Character segmentation”文字分离和“Character recognition”字符识别的部分。<br>这一部分需要再次应用监督学习算法制作分类器。  </p><h2 id="文字分离"><a href="#文字分离" class="headerlink" title="文字分离"></a>文字分离</h2><h3 id="构建数据集"><a href="#构建数据集" class="headerlink" title="构建数据集"></a>构建数据集</h3><p>文字分离的数据集同样由正样本和负样本组成，其中正样本是图像中有两个字符分割线的图像，负样本是没有字符分割线的图像。负样本由单个的字符图像和没有字符的图像组成。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210826103727.png width=90%>  </p><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>同样地，对每一个上一步文字检测中检测到的区域，应用滑动窗口分类器检测字符分割线的位置。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210826104135.png width=50%><br>算法会在识别到分割线的位置对图像进行分割。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210826104419.png width=50%></p><h2 id="字符识别"><a href="#字符识别" class="headerlink" title="字符识别"></a>字符识别</h2><p>分割好的图像会传入一个用于识别字符的监督学习多元分类器，从而对字符进行识别。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210826104524.png width=90%>  </p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>14. 机器学习实例：光学字符识别（OCR）</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>14.2. 滑动窗口分类器</title>
    <link href="/2021/08/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/14.%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E4%BE%8B%EF%BC%9AOCR/14.2.%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <url>/2021/08/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/14.%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E4%BE%8B%EF%BC%9AOCR/14.2.%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="滑动窗口分类器"><a href="#滑动窗口分类器" class="headerlink" title="滑动窗口分类器"></a>滑动窗口分类器</h1><p>上一节中照片OCR系统的流水线：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210826094605.png width=70%><br>本节课将着重于“Text detection”文字检测的部分，这一部分的功能由一种称为<strong>滑动窗口分类器</strong>（Sliding window classifier）的算法承担。<br>滑动窗口分类器能够全局扫描整幅图像并检测图像上的有文字的部分。  </p><h2 id="案例：行人检测"><a href="#案例：行人检测" class="headerlink" title="案例：行人检测"></a>案例：行人检测</h2><p>滑动窗口的最经典应用是行人检测，相比于文字检测要简单的地方在于：行人检测所检测的目标拥有相似的长宽比。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210826095820.png width=50%>  </p><h3 id="制作分类器"><a href="#制作分类器" class="headerlink" title="制作分类器"></a>制作分类器</h3><p>为了识别行人，需要制作一个监督学习分类器，分类器需要识别图像是否是行人，具体的做法如下：<br>收集一个行人的数据集，这个数据集由正样本和负样本组成。其中正样本是行人的图片，要求行人需要占到这个图像的相当大的部分。负样本则是一些没有行人的街景图像，大小和行人相同，这些图像要求种类尽量多一些（比如房屋、树木等等）。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210826100311.png width=60%>  </p><h3 id="全幅扫描"><a href="#全幅扫描" class="headerlink" title="全幅扫描"></a>全幅扫描</h3><p>现在，给出一个有若干行人的全幅图像，算法需要在图像中选取一个矩阵块（即窗口），将这个矩阵块中的图像部分传入上一布设置好的分类器当中，并对这部分图像进行识别，判断这部分图像中是否有行人。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210826100631.png width=50%><br>接着，这个窗口会稍微移动一些，并将窗口内的新内容传递给分类器，再次识别。<br>窗口移动的大小称为<strong>步长</strong>（Stride/Step size），如果步长设置的很小，那么总计需要识别的图块数量就会增多，增加计算量。如果步长设置的很大，那么窗口可能不会覆盖到图像的某些区域。<br>常见的设置是将步长设置在4-8像素。<br>滑动窗口直到图像所有的位置都被这个窗口扫过一遍。<br>接着，设置一个面积更大的图块，再次对图像进行扫描。<br>设置更大图块的目的是为了识别更多尺寸的目标。   </p><h2 id="实例：文字检测"><a href="#实例：文字检测" class="headerlink" title="实例：文字检测"></a>实例：文字检测</h2><p>在文字检测中，同样地思路训练一个分类器。  </p><h3 id="放大算子"><a href="#放大算子" class="headerlink" title="放大算子"></a>放大算子</h3><p>同样地运用滑动窗口识别字符，但是在识别完成之后，需要应用放大算子对监测到文字的区域进行拓展。即将识别到的文字区域稍微向四周扩展一些，以便检测这些文字区域的周围是否还有未识别到的，或者是不完整的文字。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210826102506.png width=90%><br>如上图所示，左边的灰度图是一种可视化识别结果的方式：白色表示该区域滑动窗口识别到了文字，而灰色区域的灰度表示可能为文字区域的概率，黑色区域表示这些区域内没有文字。<br>右边的灰度图表示将左图应用放大算子后的结果。  </p><h3 id="检测长宽比"><a href="#检测长宽比" class="headerlink" title="检测长宽比"></a>检测长宽比</h3><p>接下来对识别到的文字区域进行排除，舍弃一些长宽比较为反常的、分类器认为是文字的区域。（比如：英语中很少有竖着写的情况，因此宽度过分大于长度的区域应当被舍弃）<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210826103154.png width=50%><br>上图的绿色区域是经过检测长宽比后被认为是文字的区域，而红色的区域是检测长宽比后被舍弃的区域。  </p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>14. 机器学习实例：光学字符识别（OCR）</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>14.1. 问题背景与框架设计</title>
    <link href="/2021/08/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/14.%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E4%BE%8B%EF%BC%9AOCR/14.1.%20%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1/"/>
    <url>/2021/08/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/14.%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E4%BE%8B%EF%BC%9AOCR/14.1.%20%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="问题背景与框架设计"><a href="#问题背景与框架设计" class="headerlink" title="问题背景与框架设计"></a>问题背景与框架设计</h1><p>本章以光学字符识别技术为实例，介绍一个机器学习系统是如何被组装起来的，以及设计机器学习系统的路线。</p><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>照片光学字符识别（Photo OCR），顾名思义，即机器学习能够自动识别照片当中包含的文字。对于给定的照片，算法会全局扫描照片，然后找出照片中的文字信息。在找出这些信息后，算法会对这些文字进行识别。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210826093941.png width=50%></p><h2 id="框架设计·流水线"><a href="#框架设计·流水线" class="headerlink" title="框架设计·流水线"></a>框架设计·流水线</h2><p>一个照片光学字符识别系统的框架设计流水线（Pipline）如下：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210826094605.png width=70%></p><ol><li>文字检测<br>全局扫描照片，找出照片中可能是文字信息的部分。  </li><li>文字分离（Character segmentation）<br>对这些文字信息的部分，将这些文字信息分割成一个个独立字符的区域。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210826094359.png width=50%>  </li><li>字符分类<br>对每个独立的字符区域进行识别。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210826094458.png width=50%>  </li></ol><p>在机器学习系统设计中，用流水线的形式来表示机器学习系统的每一个组成部分的形式非常常见，这些组成部分可能是一些部分独立的机器学习组件能够被拆分直接调用。<br>使用这样的流水线的另一个优势是在构建机器学习系统时能够快速地分配人员和开发资源，一些相互独立的部分也可以同时进行开发，加快开发速度。  </p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>14. 机器学习实例：光学字符识别（OCR）</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>13.5. 并行计算（减少映射）</title>
    <link href="/2021/08/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/13.%20%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%AD%A6%E4%B9%A0/13.5.%20%E5%87%8F%E5%B0%91%E6%98%A0%E5%B0%84/"/>
    <url>/2021/08/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/13.%20%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%AD%A6%E4%B9%A0/13.5.%20%E5%87%8F%E5%B0%91%E6%98%A0%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1 id="并行计算（减少映射）"><a href="#并行计算（减少映射）" class="headerlink" title="并行计算（减少映射）"></a>并行计算（减少映射）</h1><p><strong>减少映射</strong>（Map-reduce）是第二种能够在大规模机器学习中用于减少计算量的算法。本质上，<strong>减少映射的工作就是将机器学习算法进行并行化处理</strong>，使得多个计算机共同、同时承担梯度下降算法中的一部分计算内容以缩短计算时间和单台计算机的计算量。减少映射与随机梯度下降一样重要。<br>机器学习算法能够被减少映射的关键在于算法本身或者是其中的某些步骤能够以<strong>求和</strong>的方式表示。事实上，大规模机器学习的主要问题也来自于求和项的计算量过于庞大，并且大部分的机器学习算法都拥有求和项，因此可被减少映射。  </p><h2 id="梯度下降算法的并行化"><a href="#梯度下降算法的并行化" class="headerlink" title="梯度下降算法的并行化"></a>梯度下降算法的并行化</h2><p>减少映射的思想基础来源于批量梯度下降算法。根据批量梯度下降的更新公式：  </p><script type="math/tex; mode=display">θ_j:=θ_j-α\frac{1}{m}∑_{i=1}^m(h_θ(x^{(i)})-y^{(i)})x_j^{(i)}</script><p>此时如果用多台计算机平均负担求和项（或者说是代价函数的偏导项）$∑_{i=1}^m(h_θ(x^{(i)})-y^{(i)})x_j^{(i)}$。比如如果有4台计算机，这四台计算机分别计算数据集中$\frac{m}{4}$份数据的求和项，最后再将这些计算结果放入一个中心计算机进行更新公式的计算。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210824142914.png width=50%>  </p><h2 id="逻辑回归的并行化"><a href="#逻辑回归的并行化" class="headerlink" title="逻辑回归的并行化"></a>逻辑回归的并行化</h2><p>逻辑回归的代价函数公式：  </p><script type="math/tex; mode=display">J_{train}(θ)=-\frac{1}{m}[∑_{i=1}^m y^{(i)} log⁡(h_θ(x^{(i)} ))+(1−y^{(i)}) log(1−h_θ (x^{(i)}))]</script><p>同样地，逻辑回归的代价函数中求和项也可以分配给多台计算机承担。<br>而且逻辑回归的代价函数的偏导项和线性回归一样：  </p><script type="math/tex; mode=display">\frac{∂}{∂θ_j}J_{train}(θ)=\frac{1}{m}∑_{i=1}^m(h_θ(x^{(i)})-y^{(i)})x_j^{(i)}</script><p>其中的求和项也可以被并行化处理，最终以便于使用梯度下降算法。<br>这些求和项在不同的计算机上被计算出来后，传入中央计算机，并执行求和和求和之外的其他计算。  </p><h2 id="多核计算"><a href="#多核计算" class="headerlink" title="多核计算"></a>多核计算</h2><p>由于GPU或者CPU的多核计算功能，并行化计算也可以在单机上运行。类似地，训练集被划分然后送入CPU中不同的处理核心中进行计算，最后整合结果。  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210824144419.png width=50%>  </p><p>有些机器学习库或者线性代数库可以自动地将算法矩阵化后做并行化处理，因此不需要人为地设置减少映射。  </p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>13. 大规模机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>13.4. 在线学习</title>
    <link href="/2021/08/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/13.%20%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%AD%A6%E4%B9%A0/13.4.%20%E5%9C%A8%E7%BA%BF%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/08/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/13.%20%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%AD%A6%E4%B9%A0/13.4.%20%E5%9C%A8%E7%BA%BF%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="在线学习"><a href="#在线学习" class="headerlink" title="在线学习"></a>在线学习</h1><p>在线学习（Online learning）可以针对于连续的数据流进行学习。 今天，许多大型网站或者许多大型网络公司，使用不同版本的在线学习机制算法，从大批的涌入又离开网站的用户身上进行学习。  </p><h2 id="梯度下降的在线学习"><a href="#梯度下降的在线学习" class="headerlink" title="梯度下降的在线学习"></a>梯度下降的在线学习</h2><p>对于数据流，在线学习采用了类似于随机梯度下降/小批量梯度下降的方式进行学习。在线学习的更新方程为：   </p><script type="math/tex; mode=display">θ_j:=θ_j-α(h_θ(x)-y)x</script><p>和随机梯度下降/小批量梯度下降相同，在线学习的每一次参数迭代只会使用一个或者一小批样本$(x,y)$。<br>与随机梯度下降/小批量梯度下降不同的是，<strong>在线学习舍弃了数据集的概念，样本是一次性的：在线学习机制将数据集转化为数据流——一旦样本被学习，这些样本将被舍弃并且永远都不会使用。新的样本将更新原有的样本$(x,y)$，因此在线学习始终学习的是最新的样本。</strong><br>这样的更新机制在线学习可以变化地适应用户的偏好。算法可以针对用户的当前行为不断地更新模型以适应用户。<br>不过，在线学习要求一个源源不断拥有庞大数据量的数据流，倘若没有这么大的数据流，最好还是应用数据集的概念采用定期学习的模式。  </p><h2 id="案例：点击率预测问题（CTR-problem）"><a href="#案例：点击率预测问题（CTR-problem）" class="headerlink" title="案例：点击率预测问题（CTR problem）"></a>案例：点击率预测问题（CTR problem）</h2><p>假设一个在线商店，用户搜索关键词会自动推荐10件与关键词相关的商品。用户可能点击其中的一个链接查看（视作对这个商品感兴趣），也可能不会查看。<br>设商品的特征向量$x$，它表示这个商品具有的一些关键词在各个维度的匹配程度。<br>设用户的点击为$y$，$y=1$表示用户点击了这件商品的链接，$y=0$表示用户没有点击。<br>当用户访问网站时，会一次性得到10个样本。在线学习可以对用户点击某一个商品的概率$p(y=1|x;θ)$进行实时建模，进行连续的学习，模型会在用户点击时不断地更新以适应用户的取向。  </p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>13. 大规模机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>13.3. 小批量梯度下降算法</title>
    <link href="/2021/08/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/13.%20%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%AD%A6%E4%B9%A0/13.3.%20%E5%B0%8F%E6%89%B9%E9%87%8F%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/"/>
    <url>/2021/08/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/13.%20%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%AD%A6%E4%B9%A0/13.3.%20%E5%B0%8F%E6%89%B9%E9%87%8F%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="小批量梯度下降算法"><a href="#小批量梯度下降算法" class="headerlink" title="小批量梯度下降算法"></a>小批量梯度下降算法</h1><p><strong>小批量梯度下降算法</strong>（Mini-batch gradient descent）是另一种改善由大数据造成的计算量问题的梯度下降算法。小批量梯度下降算法的思路介于批量梯度下降算法和随机梯度下降算法之间，在一些情况下的表现比随机梯度下降算法更为出色。  </p><h2 id="小批量梯度下降算法的思路"><a href="#小批量梯度下降算法的思路" class="headerlink" title="小批量梯度下降算法的思路"></a>小批量梯度下降算法的思路</h2><p>回顾之前的梯度下降算法：  </p><ul><li>批量梯度下降算法在一次迭代中使用了数据集中所有的样本  </li><li>随机梯度下降算法在一次迭代中使用了数据集中的一个样本  </li></ul><p>而小批量梯度下降算法介于这两者之间，在一次迭代中选择使用$b$个样本，称为数据集中的一批(Batch)数据。$b$是每一批数据的批量大小（Batch-size）。通常$b$在2-100之间，常取$b=10$作为一次迭代所使用的数据量。<br>内循环的更新方程：<br>使用一个Batch的数据，求出平均梯度以更新$θ_j$。  </p><script type="math/tex; mode=display">θ_j:=θ_j-α\frac{1}{b}∑_{k=i}^{i+b-1}(h_θ(x^{(k)})-y^{(k)})x_j^{(k)}</script><p>更新指针$i$以切换到下一个batch：  </p><script type="math/tex; mode=display">i:=i+b</script><p>直到所有batch的数据都执行完这一流程，重复遍历直到找到使得$J_{train}(θ)$最小化的$θ_j$。  </p><h2 id="隐式并行性"><a href="#隐式并行性" class="headerlink" title="隐式并行性"></a>隐式并行性</h2><p>如果有合适的向量化工具，小批量梯度下降算法在内循环的部分拥有并行性，意味着能够在一次迭代内能够并行计算多个batch的梯度并更新$θ_j$。虽然随机梯度下降也具有并行性，但是如果将随机梯度下降做并行处理，同时计算每一个样本的梯度，这样消耗的并行计算资源要比小批量梯度下降算法大得多。<br>因此如果将小批量算法利用合适的向量化工具并行化，其计算速度会比批量梯度下降和随机梯度下降要快的多。  </p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>13. 大规模机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>13.2. 随机梯度下降算法</title>
    <link href="/2021/08/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/13.%20%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%AD%A6%E4%B9%A0/13.2.%20%E9%9A%8F%E6%9C%BA%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E7%AE%97%E6%B3%95/"/>
    <url>/2021/08/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/13.%20%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%AD%A6%E4%B9%A0/13.2.%20%E9%9A%8F%E6%9C%BA%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="随机梯度下降算法"><a href="#随机梯度下降算法" class="headerlink" title="随机梯度下降算法"></a>随机梯度下降算法</h1><p>在13.1. 中提到使用传统的梯度下降算法来最小化大数据集的代价函数计算量非常大，因此需要找到一种方式来改进现有的梯度下降算法。一种可行的方式是<strong>随机梯度下降算法</strong>（Stochastic gradient desent）。  </p><h2 id="回顾：线性回归的梯度下降算法"><a href="#回顾：线性回归的梯度下降算法" class="headerlink" title="回顾：线性回归的梯度下降算法"></a>回顾：线性回归的梯度下降算法</h2><p>对于假设函数：$h_θ(x)=∑_{j=0}^mθ_jx_j$<br>其训练集的代价函数为：  </p><script type="math/tex; mode=display">J_{train}(θ)=\frac{1}{2m}(h_θ(x^{(i)})-y^{(i)})^2</script><p>使用梯度下降算法找到最小化$J_{train}(θ)$的参数$θ$，其内循环为：  </p><script type="math/tex; mode=display">θ_j:=θ_j-α\frac{1}{m}∑_{i=1}^m(h_θ(x^{(i)})-y^{(i)})x_j^{(i)}</script><p>其中$\frac{∂}{∂θ}J_{train}(θ)=\frac{1}{m}∑_{i=1}^m(h_θ(x^{(i)})-y^{(i)})x_j^{(i)}$<br>梯度下降算法通过不断地迭代求梯度找寻局部最小值，最终达到算法收敛。上述的梯度下降算法对整个数据集中的所有项求和，在一次下降迭代中需要同时考虑整个数据集中所有的数据，称为<strong>批量梯度下降算法</strong>（Batch gradient desent）。  </p><h2 id="随机梯度下降的思路"><a href="#随机梯度下降的思路" class="headerlink" title="随机梯度下降的思路"></a>随机梯度下降的思路</h2><p>随机梯度下降算法在每一次迭代时不需要考虑所有的数据。<br>观察批量梯度下降算法，可以发现代价函数的本质实际上是衡量参数$θ$对每一个某个样本$(x^{(i)},y^{(i)})$的拟合程度，再取平均值。因此代价函数$J_{train}(θ)$可以被分解为：  </p><script type="math/tex; mode=display">cost(θ,(x^{(i)},y^{(i)}))=\frac{1}{2}(h_θ(x^{(i)})-y^{(i)})^2</script><p>如之前所说，这一部分衡量的是参数$θ$在某个样本$(x^{(i)},y^{(i)})$上的具体表现情况。<br>原来的代价函数可以改写为：  </p><script type="math/tex; mode=display">J_{train}(θ)=\frac{1}{m}cost(θ,(x^{(i)},y^{(i)}))</script><p>按照上文的理解方式，$J_{train}(θ)$可以看做是衡量参数$θ$对数据集整体的平均表现。<br>与批量梯度下降算法不同的是，随机梯度下降算法的每一次迭代只观察数据集中的一个样本$(x^{(i)},y^{(i)})$，根据这一个样本的评价来缩小$θ_j$直到遍历完整个数据集。然后重复这一遍历数据集，分别以每个样本的评价来缩小$θ_j$的过程，直到$θ_j$达到收敛。  </p><h3 id="随机梯度下降算法的流程"><a href="#随机梯度下降算法的流程" class="headerlink" title="随机梯度下降算法的流程"></a>随机梯度下降算法的流程</h3><ol><li>将整个数据集随机打乱排列</li><li><ul><li>对于每一个样本，以这个样本的梯度来下降迭代$θ_j$：  <script type="math/tex; mode=display">θ_j:=θ_j-α(h_θ(x^{(i)})-y^{(i)})x_j^{(i)}</script>其中$\frac{∂}{∂θ_j}cost(θ,(x^{(i)},y^{(i)})=(h_θ(x^{(i)})-y^{(i)})x_j^{(i)}$  </li><li>移动到下一个样本，重复上述过程，直到遍历完整个数据集。  </li></ul></li><li>重复整个遍历过程，直到找到使得$J_{train}(θ)$取得最小值的$θ_j$。  </li></ol><blockquote><p>注意随机梯度下降算法有两个嵌套的循环。一般来说，遍历1次数据集（最多不超过10次）能够使得算法达到收敛。  </p></blockquote><p>由于每次迭代只考虑一个样本而并非是整个数据集，因此随机梯度下降的计算量更小，收敛速度也更快。但是收敛的路径更为曲折。<br>对比批量梯度下降，由于批量梯度下降每次迭代都需要找到全局（指整个数据集的求和项）极小值，因此批量梯度下降算法迭代的路线基本上始终是向着最小值收敛的（下图红线）。然而局部梯度下降算法收敛的路线更为曲折（下图洋红色线）。<br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210822104112.png" alt="">  </p><h2 id="调试随机梯度下降算法"><a href="#调试随机梯度下降算法" class="headerlink" title="调试随机梯度下降算法"></a>调试随机梯度下降算法</h2><h3 id="绘制图像"><a href="#绘制图像" class="headerlink" title="绘制图像"></a>绘制图像</h3><p>在批量梯度下降中，可以绘制$min_θJ(θ)-batch$的图像<a href="https://l61012345.top/2021/02/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/1.%20%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/1.4.%20%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/#%E5%AD%A6%E4%B9%A0%E7%8E%87-Learning-rate">1.4. 调试方法 θ:minJ(θ)-batch图像</a>，或者是绘制$J(θ)-batch$的图像，根据图表来判断梯度下降是否收敛。但是，在大规模的训练集的情况下，要周期性地暂停学习并且求得此时的$J(θ)$或者是使得$J(θ)$最小化的$θ$的值所带来的计算量非常地大。因此需要其他的调试方法应用于大数据学习时的随机梯度下降算法。<br>对于随机梯度下降算法，在计算当前样本的$cost(θ,(x^{(i)},y^{(i)})$后,在更新$θ$之前，直接输出此时的$cost$函数值。<br>在固定周期的迭代次数（比如每1000次迭代）后，计算这个迭代周期内这些样本的$cost$函数值的平均值，通过观察绘制的图来判断梯度下降算法是否达到了收敛。  </p><h4 id="观察周期的设置"><a href="#观察周期的设置" class="headerlink" title="观察周期的设置"></a>观察周期的设置</h4><p>迭代周期设置的越大，迭代过程中的噪声就越不明显，曲线越平滑。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210822123714.png width=50%><br>如上图，蓝色线的所观察的周期要比红色线所观察的周期更短。<br>如果观察的周期设置的太短，则有可能观察不出下降的趋势，如下图所示。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210822124049.png width=50%><br>当设定比较大的周期进行观察，如果此时下降程度仍然不明显，表明算法几乎没有学习数据集，需要对算法进行进一步的调整。   </p><h3 id="学习率的影响"><a href="#学习率的影响" class="headerlink" title="学习率的影响"></a>学习率的影响</h3><p>在这两种算法中，学习率越小，算法收敛的越慢，但是最后收敛的结果可能会更小。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210822123426.png width=50%>  </p><p>如上图，图中蓝色线的学习率比红色线的学习率更大。<br>如果图像呈上升趋势，那么表明算法发散，则需要设置更小的学习率。  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210822124352.png width=50%>  </p><p>也可以令学习率随着迭代次数的增加而减小，例如令：</p><script type="math/tex; mode=display">\alpha=\frac{c_1}{IterationNumber + c_2}</script><p>其中$c_1$和$c_2$是两个常数。<br>随着不断地靠近全局最小值，通过减小学习率，迫使算法收敛而非在最小值附近徘徊。 但是通常不需要这样做便能有非常好的效果了——对$α$进行调整所耗费的计算通常不值得。  </p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>13. 大规模机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>4.3. 线性回归的正则化</title>
    <link href="/2021/08/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/4.%20%E6%AD%A3%E5%88%99%E5%8C%96/4.3.%20%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E7%9A%84%E6%AD%A3%E5%88%99%E5%8C%96/"/>
    <url>/2021/08/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/4.%20%E6%AD%A3%E5%88%99%E5%8C%96/4.3.%20%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E7%9A%84%E6%AD%A3%E5%88%99%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="线性回归的正则化"><a href="#线性回归的正则化" class="headerlink" title="线性回归的正则化"></a>线性回归的正则化</h1><h2 id="正则化的梯度下降算法"><a href="#正则化的梯度下降算法" class="headerlink" title="正则化的梯度下降算法"></a>正则化的梯度下降算法</h2><p>在线性回归中，我们使用修改后的梯度下降算法：<br>Repeat {   </p><script type="math/tex; mode=display">θ_0:=θ_0-\alpha\frac{1}{m}\Sigma_{i=1}^{m}(h_θ(x^{(i)})-y^{(i)})x_0^{(j)} \tag{1}</script><blockquote><p>$θ_0$  不需要正则化  </p></blockquote><script type="math/tex; mode=display">θ_j:=θ_j-\alpha[\frac{1}{m}\Sigma_{i=1}^{m}(h_θ(x^{(i)})-y^{(i)})x_j^{(i)}+\frac{λ}{m}θ_j] \tag{2}</script><script type="math/tex; mode=display">j=1,2,3,...,n</script><p>}<br>事实上： $\frac{1}{m}\Sigma_{i=1}^{m}(h_θ(x^{(i)})-y^{(i)})x_j^{(j)}+\frac{λ}{m}θ_j=\frac{∂J(θ)}{∂θ_j}$<br>$\Sigma_{i=1}^{m}(h_θ(x^{(i)})-y^{(i)})x_0^{(i)}=\frac{∂J(θ)}{∂θ_0}$  </p><p>如果将（2）中的$\theta_j$统一，那么就可以得到（3）：  </p><script type="math/tex; mode=display">θ_j:=θ_j（1-α\frac{λ}{m}）-\frac{α}{m}\Sigma_{i=1}^{m}(h_θ(x^{(i)})-y^{(i)})x_j^{(i)} \tag{3}</script><p>由于$1-α\frac{λ}{m}&lt;1$,且只比1小一点点，也就是说，梯度下降算法每次更新的时候$θ_j$在一开始都会比原来小一点点，再进行原来的梯度下降更新  </p><h2 id="正规方程"><a href="#正规方程" class="headerlink" title="正规方程"></a>正规方程</h2><p>在之前的讲义中，探讨过设计两个矩阵：<br>$X=\begin{bmatrix} (x^{(1)})^T \\ …\\ (x^{(m)})^T \end{bmatrix}$ 代表有m个数据的数据集 和 $y=\begin{bmatrix} y^{(1)} \\ …\\ y^{(m)} \end{bmatrix}$ 代表训练集当中的所有的标签<br>通过：</p><script type="math/tex; mode=display">θ=(X^TX)^{-1}X^Ty</script><p>（相当于对$J(θ)$中的每一个θ求偏导数，并且使其等于0）<br>可以求出最适合的θ<br>现在改变在正规方程中加入一项：</p><script type="math/tex; mode=display">θ=(X^TX+λ\begin{bmatrix}0 & 0 & 0 & ...&0 \\   0 & 1 & 0& ...&0 \\ 0 & 0 & 1& ...&0 \\ ... & ... & ...& ...&... \\ 0 & 0 & 0& ...&1\end{bmatrix})^{-1}X^Ty</script><p>来达到同样的效果  </p><blockquote><p>$\begin{bmatrix}<br>0 &amp; 0 &amp; 0 &amp; …&amp;0 \\   0 &amp; 1 &amp; 0&amp; …&amp;0 \\ 0 &amp; 0 &amp; 1&amp; …&amp;0 \\ … &amp; … &amp; …&amp; …&amp;… \\ 0 &amp; 0 &amp; 0&amp; …&amp;1<br>\end{bmatrix}$是一个(n+1)的方阵  </p></blockquote><p>如果矩阵X不可逆$（m&lt;=n）$,那么$(X^TX)^{-1}$也同样不可逆,但是经过数学证明，无论如何$(X^TX+λ<br>\begin{bmatrix}<br>0 &amp; 0 &amp; 0 &amp; …&amp;0 \\   0 &amp; 1 &amp; 0&amp; …&amp;0 \\ 0 &amp; 0 &amp; 1&amp; …&amp;0 \\ … &amp; … &amp; …&amp; …&amp;…\\ 0 &amp; 0 &amp; 0&amp; …&amp;1<br>\end{bmatrix})^{-1}$ 都是可逆的。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>04. 正则化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>4.2. 代价函数的正则化</title>
    <link href="/2021/08/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/4.%20%E6%AD%A3%E5%88%99%E5%8C%96/4.2.%20%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B0%E7%9A%84%E6%AD%A3%E5%88%99%E5%8C%96/"/>
    <url>/2021/08/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/4.%20%E6%AD%A3%E5%88%99%E5%8C%96/4.2.%20%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B0%E7%9A%84%E6%AD%A3%E5%88%99%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="代价函数的正则化"><a href="#代价函数的正则化" class="headerlink" title="代价函数的正则化"></a>代价函数的正则化</h1><p>对于代价函数：</p><script type="math/tex; mode=display">min_{θ} \frac{1}{2m} \Sigma_{i=1}^{m}(h_θ(x^{(i)})-y^{(i)})^2</script><p>增加两个惩罚项$1000\theta^2_3$和$1000\theta^2_4$，代价函数变为：  </p><script type="math/tex; mode=display">min_{θ} \frac{1}{2m} \Sigma_{i=1}^{m}(h_θ(x^{(i)})-y^{(i)})^2+1000\theta^2_3+1000\theta^2_4</script><p>如果要最小化这个函数，那么$\theta_3$与$\theta_4$就要尽可能的接近0，那么最后拟合的结果（假设函数）：$\theta_0+\theta_1x+\theta_2x^2+\theta_3x^3+\theta_4x^4$，仍然是一个类似的二次函数.<br>正则化的基本思想是<strong>如果所有的参数足够小，那么假设模型就更简单。</strong>  </p><blockquote><p>事实上，如果参数足够小，得到的函数就会越平滑，越简单，越不容易出现过拟合的问题  </p></blockquote><p>在实际上，对于大量的特征和大量的参数，比如$x_1..x_{100}$和$\theta_0…\theta_{100}$，我们无法确定哪些参数是高阶项的参数，这个时候采用的方法就是对代价函数进行修改，使得所有的参数都尽可能的小。<br>修改后的代价函数方程：  </p><script type="math/tex; mode=display">J_{\theta}=\frac{1}{2m}[\Sigma_{i=1}^{m}(h_θ(x^{(i)})-y^{(i)})^2+λ\Sigma_{j=1}^{m}\theta_j^2]</script><p>其中$λ\Sigma_{j=1}^{m}\theta_j^2$称为<strong>正则化项</strong>，它的目的是为了<strong>缩小每一项的参数</strong>。</p><blockquote><p>$\theta_0$是否正则化对结果影响不大<br>λ的作用是对“+”号的前后（前：更好的拟合训练集，后：假设函数足够简单）两项进行取舍平衡，称为正则化系数  </p></blockquote><p>如果λ被设置的太大，那么所有参数的惩罚力度被加大，这些参数最后的结构都将全部接近于0，那么最后的假设函数将会变成$h_\theta(x)=θ_0$,最终导致欠拟合。  </p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>04. 正则化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>4.1. 过拟合问题</title>
    <link href="/2021/08/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/4.%20%E6%AD%A3%E5%88%99%E5%8C%96/4.1.%20%E8%BF%87%E6%8B%9F%E5%90%88%E9%97%AE%E9%A2%98/"/>
    <url>/2021/08/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/4.%20%E6%AD%A3%E5%88%99%E5%8C%96/4.1.%20%E8%BF%87%E6%8B%9F%E5%90%88%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="过拟合问题"><a href="#过拟合问题" class="headerlink" title="过拟合问题"></a>过拟合问题</h1><p>对于模型，如果一个模型对于数据的偏差很大，不能能够很好的拟合数据的分布，称为欠拟合，或者说这个算法具有高偏差的特性。 如果一个模型虽然可以穿过所有的数据点，但是其图像波动很大，其同样也不能描述数据的分布，（其数据的分布是无法被泛化处理），称为过拟合，或者说这个算法具有高方差的特性。 在这种情况下，模型的参数过于多（有可能代价函数正好为0），以至于可能没有足够多的数据去约束它来获得一个假设函数。<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20201224205854.png" alt=""><br>过拟合现象往往会发生在<strong>参数过多，而训练样本过少的情况</strong>。减小过拟合现象的思路有两种： </p><ol><li>尽可能的去掉那些影响因素很小的变量，这种方法虽然解决了过拟合问题，但是损失了精度。  </li><li><strong>正则化</strong>（Regularization）  </li></ol>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>04. 正则化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>13.1. 大规模学习的计算问题·预学习</title>
    <link href="/2021/08/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/13.%20%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%AD%A6%E4%B9%A0/13.1.%20%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
    <url>/2021/08/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/13.%20%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%AD%A6%E4%B9%A0/13.1.%20%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="大规模学习的计算问题·预学习"><a href="#大规模学习的计算问题·预学习" class="headerlink" title="大规模学习的计算问题·预学习"></a>大规模学习的计算问题·预学习</h1><p>在机器学习中，起决定因素的往往不是最好的算法，而是谁有大量的数据。机器学习发展的近10年到近5年的时间中，社会生活所产生的数据量不断增大，机器学习更倾向于学习更大规模的数据集。<br>接下来一章将讨论如何处理大数据集。  </p><h2 id="计算问题"><a href="#计算问题" class="headerlink" title="计算问题"></a>计算问题</h2><p>大数据集学习面临的首要问题是计算问题。<br>假设训练集大小为$m=100,000,000$（这个数据是非常现实的，以美国人口为例，美国人口大约3亿，如果查询这些人的某些数据，数据量能够轻松地达到上亿规模），此时直接应用传统算法在计算量上会有很大的难度。以梯度下降算法为例：此时如果想要应用批量梯度下降来最小化代价函数，批量梯度下降的更新公式为：  </p><script type="math/tex; mode=display">θ_j:=θ_j-α\frac{1}{m}∑_{i=1}^m(h_θ(x^{(i)})-y^{(i)})x_j^{(i)}</script><p>按照$m=100,000,000$来算，梯度下降算法需要对一亿个项求和，这显然是非常不现实的工作。<br>有两种适用于大规模机器学习、处理大规模数据的算法为：  </p><ol><li>随机梯度下降 (Stochastic gradient desent)  </li><li>减少映射（Map reduce）  </li></ol><h2 id="预学习"><a href="#预学习" class="headerlink" title="预学习"></a>预学习</h2><p>不过在正式开始对大数据的学习之前，有必要弄清楚一个问题：究竟有没有必要使用这么多数据来进行训练？<br>一种有效的方法是随机选择这一亿个数据中的一小部分（比如1000个数据）进行预学习，绘制<a href="https://l61012345.top/2021/04/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/6.%20%E8%AF%8A%E6%96%AD%E4%B8%8E%E8%B0%83%E8%AF%95/6.3.%20%E5%AD%A6%E4%B9%A0%E6%9B%B2%E7%BA%BF/">6.3. 学习曲线</a>。  观察此时的学习曲线是否表征出现了高方差特性（如下图所示），由于高方差问题是可以通过增大数据量来改善的，在这种情况下才更应当增加数据集的量来学习。  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210821153002.png width=50%></p><p>倘若学习曲线未出现高方差特性，或者是出现了高偏差特性（如下图所示），此时增大数据量对机器学习的效果不会有太大改善。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210821152919.png width=50%>  </p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>13. 大规模机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>12.4. 协同过滤算法的优化</title>
    <link href="/2021/08/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/12.%20%E5%86%85%E5%AE%B9%E6%8E%A8%E8%8D%90/12.4.%20%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <url>/2021/08/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/12.%20%E5%86%85%E5%AE%B9%E6%8E%A8%E8%8D%90/12.4.%20%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="协同过滤算法的优化"><a href="#协同过滤算法的优化" class="headerlink" title="协同过滤算法的优化"></a>协同过滤算法的优化</h1><h2 id="向量化"><a href="#向量化" class="headerlink" title="向量化"></a>向量化</h2><p>设计一个大小为$n_m × n_u$的矩阵$Y$，其每一个元素表示用户$j$对电影$i$的评分$y(i,j)$。  由于预测的评分由$θ^Tx$给出，因此预测评分的矩阵能够表示为：  </p><script type="math/tex; mode=display">Y_{pre}=Θ^TX</script><p>其中$X$是所有电影的特征向量组成$x$的电影的特征矩阵，其每一行都是一部电影的特征向量。  $Θ$是所有用户倾向的特征向量$θ$组成的用户的特征矩阵，其每一行都是一个用户的特征向量。<br>协同过滤算法的向量化后的算法又称为低秩矩阵分解。  </p><h3 id="寻找相关内容"><a href="#寻找相关内容" class="headerlink" title="寻找相关内容"></a>寻找相关内容</h3><p>协同过滤算法能对每一个目标（比如电影、商品等等）都生成一个特征向量$x^{(i)}∈R^n$，两个目标$i$和$j$的类型相似在线性代数上的直观反映是两个目标的特征向量的欧氏距离很小： </p><script type="math/tex; mode=display">||x^{(i)}-x^{(j)}||</script><p>因此找到和目标$i$比较近的其他目标就能实现推荐与$i$内容相近的内容。  </p><h2 id="均值归一化"><a href="#均值归一化" class="headerlink" title="均值归一化"></a>均值归一化</h2><p>假设现在有一个用户没有对任何的电影评分，观察代价函数对其的影响：  </p><script type="math/tex; mode=display">J(θ^{(i)},x^{(j)})=\frac{1}{2}∑_{(i,j):r(i,j)=1}((θ^{(i)})^Tx^{(i)}-y^{(i,j)})^2+\frac{λ}{2}∑_{j=1}^{n_u}∑_{k=1}^n(θ_k^{(j)})^2+\frac{λ}{2}∑_{j=1}^{n_m}∑_{k=1}^n(x_k^{(i)})^2</script><p>可以发现，由于$x$是一个零向量，代价函数中只有$θ$:的正则化项$\frac{λ}{2}∑_{j=1}^{n_u}∑_{k=1}^n(θ_k^{(j)})^2$对其有影响。<br>最小化这个代价函数，最终会得到这个用户的特征向量也是一个零向量，故预测对所有电影评分的结果全是0。或者如果一个用户给所有的电影评分都为0，推荐算法将不会很好地推荐内容。<br>均值归一化能够解决上述问题，<br>现在除了生成评分矩阵$Y$之外，另外设计一个均值向量$μ$用于储存每一部电影的平均得分。<br>现在将评分矩阵$Y$的每一行（也就是每个用户对同一部电影的评分）都减去平均得分。未评分的项（以$?$记）不做处理。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210820104239.png width=50%><br>对新的评分矩阵$Y_{norm}$使用协同过滤算法：<br>现在用户$j$对电影$i$的评分需要补上之前减去的均值：  </p><script type="math/tex; mode=display">y_{pre}^{(i,j)}=(θ^{(j)})^T(x^{(i)})+μ_i</script><p>那么没有对任何电影评分的用户得到的预测评分将不再为0，而是反映所有人打分均值的$μ_i$。  </p><p>同样的思路，假设有一部新上映的电影没有被任何人评价过，则可以采用列向量均值归一的方法：生成列向量的均值（同一个用户对所有电影的平均得分），用评分矩阵$Y$的每一列减去这个均值进行处理。<br>不过关心没有评分的用户比关心没有评分的电影要更为重要。因此列向量的均值归一化并不是必须的。  </p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>12. 内容推荐</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>12.3. 协同过滤算法</title>
    <link href="/2021/08/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/12.%20%E5%86%85%E5%AE%B9%E6%8E%A8%E8%8D%90/12.3.%20%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%AE%97%E6%B3%95/"/>
    <url>/2021/08/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/12.%20%E5%86%85%E5%AE%B9%E6%8E%A8%E8%8D%90/12.3.%20%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="协同过滤算法"><a href="#协同过滤算法" class="headerlink" title="协同过滤算法"></a>协同过滤算法</h1><p>和基于内容的线性回归模型不同，协同过滤算法能够自动学习所要使用的特征，避免了需要先手动评价“爱情度”和“动作度”这样的不可理喻的事情。  </p><h2 id="整合到一起"><a href="#整合到一起" class="headerlink" title="整合到一起"></a>整合到一起</h2><p>在上一节中利用线性回归模型作出了两个算法分别用于预测用户的取向和电影的内容特征。两个算法的思路分别是；已知电影的特征$x^{(i)}$，求出用户的取向$θ^{(j)}$；已知用户的取向$θ^{(j)}$，求出电影的特征$x^{(i)}$——这看起来是一个先有鸡还是先有蛋的问题，解决办法的构想如下：  </p><ol><li>随机初始化$θ$</li><li>利用随机初始化的$θ$建立线性回归模型，预测出电影的特征向量$x$  </li><li>利用预测出电影的特征向量建立线性回归模型，预测出用户的取向$θ$  </li></ol><p>重复二三两步，$θ$和$x$在不断线性回归迭代中得到优化，最终算法将收敛并得到到合理的电影特征向量。<br>但是这种思路中包含反复建模的过程，这使得算法的计算量倍增。   </p><h2 id="应用线性回归的协同过滤算法"><a href="#应用线性回归的协同过滤算法" class="headerlink" title="应用线性回归的协同过滤算法"></a>应用线性回归的协同过滤算法</h2><h3 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h3><p><strong>协同过滤算法</strong>（Collaborative filtering）在上述思路的基础上能够同时优化$θ$和$x$，进而减小计算量。<br>之前的两个代价函数：  </p><script type="math/tex; mode=display">J(θ)=\frac{1}{2}∑_{j=1}^{n_u}∑_{i:r(i,j)=1}((θ^{(j)})^Tx^{(j)}-y^{(i,j)})^2+\frac{λ}{2}∑_{j=1}^{n_u}∑_{k=1}^n(θ_k^{(j)})^2</script><script type="math/tex; mode=display">J(x^{(j)})=\frac{1}{2}∑_{j=1}^{n_m}∑_{i:r(i,j)=1}((θ^{(i)})^Tx^{(i)}-y^{(i,j)})^2+\frac{λ}{2}∑_{j=1}^{n_m}∑_{k=1}^n(x_k^{(i)})^2</script><p>这两个代价函数中$\frac{1}{2}∑∑_{i:r(i,j)=1}((θ^{(i)})^Tx^{(i)}-y^{(i,j)})^2$的本质都是对所有用户的所有评分计算后求和，因此可以合并。<br>定义协同过滤算法的代价函数：  </p><script type="math/tex; mode=display">J(θ^{(i)},x^{(j)})=\frac{1}{2}∑_{(i,j):r(i,j)=1}((θ^{(i)})^Tx^{(i)}-y^{(i,j)})^2+\frac{λ}{2}∑_{j=1}^{n_u}∑_{k=1}^n(θ_k^{(j)})^2+\frac{λ}{2}∑_{j=1}^{n_m}∑_{k=1}^n(x_k^{(i)})^2</script><p>找到使得$J(θ^{(i)},x^{(j)})$最小化的$(θ^{(i)},x^{(j)})$。  </p><p>由于现在是在学习所有的特征，没有必要将一个特征值硬编码为1，因为如果真的有恒为1的特征，算法也能自己学习到。在此可以将$x$中的截距项$x_0$删除以统一维度为$n$。  </p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><ol><li>随机初始化小的$(θ^{(i)},x^{(j)})$  </li><li>使用梯度下降算法或者是其他的算法来最小化$J(θ^{(i)},x^{(j)})$  </li><li>给定一个特定用户的特征向量$θ$和一个特定的电影，利用：  <script type="math/tex; mode=display">y_{pre}(i,j)=(θ^{(j)})^Tx^{(i)}</script>来预测用户对某部电影的评分</li></ol><h2 id="协同过滤算法的理解"><a href="#协同过滤算法的理解" class="headerlink" title="协同过滤算法的理解"></a>协同过滤算法的理解</h2><p>协同过滤算法的“协同”体现在系统通过观察大量用户的行为同时对内容和用户进行建模，并且每一个用户的行为都在帮助系统建立更好的内容模型。反过来，优秀的内容模型也会帮助建立精准的用户行为模型，实现精准的内容推荐。  </p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>12. 内容推荐</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>12.2. 基于内容的推荐算法·内容的特征</title>
    <link href="/2021/08/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/12.%20%E5%86%85%E5%AE%B9%E6%8E%A8%E8%8D%90/12.2.%20%E5%9F%BA%E4%BA%8E%E5%86%85%E5%AE%B9%E7%9A%84%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95/"/>
    <url>/2021/08/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/12.%20%E5%86%85%E5%AE%B9%E6%8E%A8%E8%8D%90/12.2.%20%E5%9F%BA%E4%BA%8E%E5%86%85%E5%AE%B9%E7%9A%84%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="基于内容的推荐算法·内容的特征"><a href="#基于内容的推荐算法·内容的特征" class="headerlink" title="基于内容的推荐算法·内容的特征"></a>基于内容的推荐算法·内容的特征</h1><h2 id="系统参数"><a href="#系统参数" class="headerlink" title="系统参数"></a>系统参数</h2><p>沿着电影推荐的例子，在上一节中提到过内容推荐系统的相关参数：  </p><ul><li>$n_u$:用户的数量。  </li><li>$n_m$:电影的数量。  </li><li>$r(i,j)$：标记函数，如果$r(i,j)=1$则表示第$j$个用户已经对第$i$部电影进行了评分。  </li><li>$y^{(i,j)}$:评分，表示用户$i$对电影$j$的评分。当且仅当$r(i,j)=1$时$y^{(i,j)}$有值  </li></ul><p>现在设出电影的特征，假设每一部电影都有两个特征：爱情度$x_1$和动作度$x_2$分别表示某一部电影内容包含爱情片和动作片的程度，以0表示最低，1表示最高。（例如《泰坦尼克号》：$x_1=0.9$，$x_2=0.001$），再加入一个截距特征$x_0=1$。那么每一部电影的特征向量$x^{(i)}$都由上述的三个特征值组成。  </p><h2 id="寻找用户的取向"><a href="#寻找用户的取向" class="headerlink" title="寻找用户的取向"></a>寻找用户的取向</h2><p>对于评分的预测，可以看成是一个线性回归问题。规定用户$j$的参数向量$θ^{(j)}∈ R^{n+1}$，$n$表示特征的数量（不包括$x_0$）。对每一个用户都应用线性回归，用户$j$对于电影$i$的评分的预测值可以表示为：  </p><script type="math/tex; mode=display">y^{(i,j)}_{pre}=(θ^{(j)})^Tx^{(j)}</script><h3 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h3><p>如果用$m^{(j)}$表示第$j$个用户评分电影的数量，学习$θ^{(j)}$的过程就是一个基本的线性回归的代价函数：  </p><script type="math/tex; mode=display">J(θ)=\frac{1}{2m^{(j)}}∑_{i:r(i,j)=1}((θ^{(j)})^Tx^{(j)}-y^{(i,j)})^2+\frac{λ}{2m^{(j)}}∑_{k=1}^n(θ_k^{(j)})^2</script><p>由于$m^{(j)}$对于表达式中求最小$J(θ)$时的$θ^{(j)}$无影响，则可以直接去掉：  </p><script type="math/tex; mode=display">J(θ)=\frac{1}{2}∑_{i:r(i,j)=1}((θ^{(j)})^Tx^{(j)}-y^{(i,j)})^2+\frac{λ}{2}∑_{k=1}^n(θ_k^{(j)})^2</script><p>最小化代价函数即可得到最优的$θ^{(j)}$。<br>如果要找到所有用户的参数向量，则根据多元线性回归公式可以得到代价函数：  </p><script type="math/tex; mode=display">J(θ)=\frac{1}{2}∑_{j=1}^{n_u}∑_{i:r(i,j)=1}((θ^{(j)})^Tx^{(j)}-y^{(i,j)})^2+\frac{λ}{2}∑_{j=1}^{n_u}∑_{k=1}^n(θ_k^{(j)})^2</script><p>同样地，最小化的方式可以采用梯度下降算法来找到$J(θ)$的最小值。<br>这种基于内容的特征来预测用户评分的算法称为基于内容的推荐算法。  </p><h2 id="寻找内容的特征"><a href="#寻找内容的特征" class="headerlink" title="寻找内容的特征"></a>寻找内容的特征</h2><p>还是之前的电影推荐的例子，对于很多电影，很难以特征向量的方式来量化“爱情片”或者是“动作片”的程度，也很难获取全部的特征。  换一种思路，假设模型中每个用户的参数向量$θ^{(i)}$是已知的（可以看做是每个用户对于电影类型的倾向是已知的），那么就能够反推出每一部电影的“动作度”和“爱情度”：比如如果一部电影倾向于爱情片的用户给电影的评分普遍高，那么可以反推出这个电影大概率是一个爱情片。<br>用这种思路进行数学建模：即求得$x^{(i)}$使得方程：  </p><script type="math/tex; mode=display">\begin{cases}    (θ^{(1)})^Tx^{(j)}=r(1,i) \\    (θ^{(2)})^Tx^{(j)}=r(2,i) \\    ...\\    (θ^{(n_u)})^Tx^{(j)}=r(n_u,i) \\\end{cases}</script><p>成立。  </p><h3 id="代价函数-1"><a href="#代价函数-1" class="headerlink" title="代价函数"></a>代价函数</h3><p>对于已知的$θ^{(1)}…θ^{(n_u)}$，为了学习电影$i$的特征向量$x^{(i)}$，应用线性回归模型：  </p><script type="math/tex; mode=display">J(x^{()i})=\frac{1}{2}∑_{i:r(i,j)=1}((θ^{(j)})^Tx^{(i)}-y^{(i,j)})^2+\frac{λ}{2}∑_{k=1}^n(x_k^{(i)})^2</script><p>找到使得代价函数$J(θ)$最小化的$x^{(i)}$。<br>应用多元线性回归模型的代价函数公式：  </p><script type="math/tex; mode=display">J(x^{(j)})=\frac{1}{2}∑_{j=1}^{n_m}∑_{i:r(i,j)=1}((θ^{(i)})^Tx^{(i)}-y^{(i,j)})^2+\frac{λ}{2}∑_{j=1}^{n_m}∑_{k=1}^n(x_k^{(i)})^2</script><p>就能够得到所有电影的特征向量。  </p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>12. 内容推荐</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>12.1. 内容推荐问题</title>
    <link href="/2021/08/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/12.%20%E5%86%85%E5%AE%B9%E6%8E%A8%E8%8D%90/12.1.%20%E9%97%AE%E9%A2%98%E8%A7%84%E5%88%92/"/>
    <url>/2021/08/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/12.%20%E5%86%85%E5%AE%B9%E6%8E%A8%E8%8D%90/12.1.%20%E9%97%AE%E9%A2%98%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="内容推荐问题"><a href="#内容推荐问题" class="headerlink" title="内容推荐问题"></a>内容推荐问题</h1><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>通过对之前的部分的学习可以知道：特征在机器学习中扮演着重要的角色，特征的选取对于学习算法的性能有很大的影响。相比于手动编写算法，有一些算法能够自动挖掘特征，而内容推荐算法就是其中的一个典型的例子。<br>通过对内容推荐算法的学习，能够进一步体会机器学习中特征的重要性。  </p><h2 id="案例：电影推荐系统"><a href="#案例：电影推荐系统" class="headerlink" title="案例：电影推荐系统"></a>案例：电影推荐系统</h2><p>假设现在有一个电影推荐系统，这个系统允许对电影进行0分到5分的评价，这个系统有如下的量化参数：  </p><ul><li>$n_u$:用户的数量。  </li><li>$n_m$:电影的数量。  </li><li>$r(i,j)$：标记函数，如果$r(i,j)=1$则表示第$j$个用户已经对第$i$部电影进行了评分。  </li><li>$y^{(i,j)}$:评分，表示用户$i$对电影$j$的评分。当且仅当$r(i,j)=1$时$y^{(i,j)}$有值  </li></ul><p>这个推荐系统的目的是根据用户已经评分的电影进行建模，从而预测用户对其未评分的电影的评分，进而得到用户对电影类型的取向。这也是内容推荐问题的主要形式。  </p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>12. 内容推荐</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>11.5. 多元异常检测算法</title>
    <link href="/2021/08/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/11.%20%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/11.5.%20%E5%A4%9A%E5%85%83%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/"/>
    <url>/2021/08/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/11.%20%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/11.5.%20%E5%A4%9A%E5%85%83%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="多元异常检测算法"><a href="#多元异常检测算法" class="headerlink" title="多元异常检测算法"></a>多元异常检测算法</h1><h2 id="问题动机"><a href="#问题动机" class="headerlink" title="问题动机"></a>问题动机</h2><p>实际问题中的有些异常并不能直接通过一个变量指标观测出来，这时候就需要引入多个变量综合进行分析，比如如下的这个例子。<br>如图所示，在计算机状态监测中，考虑CPU负载和内存使用两个变量，正常数据在这两个变量上的分布记为红色标记，现在引入一个绿色的异常数据：如果观察绿色的异常数据在分别的两个变量指标上的分布（图右部分），发现这个异常数据很难在整个数据集中被发现，而通过综合两个变量指标，观察二维分布，则比较容易发现这个异常的数据。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210812150029.png width=50%>  </p><h2 id="多元高斯分布"><a href="#多元高斯分布" class="headerlink" title="多元高斯分布"></a>多元高斯分布</h2><p>为了进一步改进异常检测算法，需要用到多元高斯分布的相关知识。<br>假设特征变量$x∈R^n$，现在不通过为每一个特征分别建模$p(x_i)$的方法，转而对整体直接建立模型$p(x)$。<br>根据多元高斯分布的公式：  </p><script type="math/tex; mode=display">p(x;μ,Σ)=\frac{1}{(2π)^{\frac{n}{2}}|Σ|^{\frac{1}{2}}}exp(-\frac{1}{2}(x-μ)^TΣ^{-1}(x-μ))</script><p>其中$Σ∈R^{n×n}$，是$x$的协方差矩阵。$|Σ|$表示$Σ$的行列式。<br>$μ∈R^n$是一个均值向量。<br>$p(x)$在高维空间中呈现出高斯分布。<br>类比与二维高斯分布，$Σ$内的元素值控制极值点的大小，同时控制从极值点到零点各方向的变化率（同时非对角线上的元素控制着各维度之间的相关性）。$μ$控制极值点的位置。  </p><h3 id="多元高斯分布的参数估计问题"><a href="#多元高斯分布的参数估计问题" class="headerlink" title="多元高斯分布的参数估计问题"></a>多元高斯分布的参数估计问题</h3><p>假设随机变量$x∈R^n$的$m$个样本$\{x^{(1)},x^{(2)},…,x^{(m)}\}$，可以利用如下的公式对$μ$和$Σ$进行参数估计:  </p><script type="math/tex; mode=display">μ=\frac{1}{m}∑_{i=1}^mx^{(i)}</script><script type="math/tex; mode=display">Σ=\frac{1}{m}∑_{i=1}^m(x^{(i)}-μ)(x^{(i)}-μ)^T</script><h2 id="使用多元高斯分布的多元异常检测算法"><a href="#使用多元高斯分布的多元异常检测算法" class="headerlink" title="使用多元高斯分布的多元异常检测算法"></a>使用多元高斯分布的多元异常检测算法</h2><p>假设数据集有$m$个样本$\{x^{(1)},x^{(2)},…,x^{(m)}\}$，首先假设数据集的分布服从多元高斯分布，算法流程如下：  </p><ol><li>使用样本数据建立$p(x)$的模型：  <script type="math/tex; mode=display">μ=\frac{1}{m}∑_{i=1}^mx^{(i)}</script><script type="math/tex; mode=display">Σ=\frac{1}{m}∑_{i=1}^m(x^{(i)}-μ)(x^{(i)}-μ)^T</script></li><li>建立$p(x)$的模型：  <script type="math/tex; mode=display">p(x;μ,Σ)=\frac{1}{(2π)^{\frac{n}{2}}|Σ|^{\frac{1}{2}}}exp(-\frac{1}{2}(x-μ)^TΣ^{-1}(x-μ))</script></li><li>对于给定的新样本$x_{new}$，带入$p(x)$的模型中进行计算得到$p(x_{new})$</li><li>设定阈值$ɛ$,如果$p(x_{new})&lt;ɛ$则表明$x_{new}$为异常数据。  </li></ol><h2 id="多元异常检测算法与原始异常检测算法的关系"><a href="#多元异常检测算法与原始异常检测算法的关系" class="headerlink" title="多元异常检测算法与原始异常检测算法的关系"></a>多元异常检测算法与原始异常检测算法的关系</h2><p>原始模型：  </p><script type="math/tex; mode=display">p(x)=Π_{i=1}^np(x_i,μ_i,σ^2_i)</script><p>多元高斯模型：  </p><script type="math/tex; mode=display">p(x;μ,Σ)=\frac{1}{(2π)^{\frac{n}{2}}|Σ|^{\frac{1}{2}}}exp(-\frac{1}{2}(x-μ)^TΣ^{-1}(x-μ))</script><p><strong>其实原始模型是多元高斯模型的一种特殊情况：所有的特征之间都独立不相关，而多元高斯分布模型考虑到了特征之间的相关性。</strong><br>特征不相关时，协方差矩阵$Σ$是一个对角矩阵：  </p><script type="math/tex; mode=display">Σ=\begin{bmatrix}    σ^2_1 & ... &...\\    ... & σ^2_2 & ... \\    ... & ... & ... \\    ... & ... & σ^2_n \\\end{bmatrix}</script><p>带入多元高斯模型中即可推导出原始模型。  </p><h3 id="模型对比"><a href="#模型对比" class="headerlink" title="模型对比"></a>模型对比</h3><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">原始模型</th><th style="text-align:center">多元高斯模型</th></tr></thead><tbody><tr><td style="text-align:center">探测关联特征的方式</td><td style="text-align:center">手动创建一个新特征</td><td style="text-align:center">自动捕捉特征之间的关系</td></tr><tr><td style="text-align:center">计算性能</td><td style="text-align:center">计算成本低，能够适应数量巨大的特征</td><td style="text-align:center">由于需要计算协方差矩阵，计算成本高，仅能对特征数少的情况适用</td></tr><tr><td style="text-align:center">数据要求</td><td style="text-align:center">可以适用于数据少，特征多（$m&lt;n$）的情况</td><td style="text-align:center">由于协方差矩阵必须可逆，因此要求$m&gt;n$甚至是$m&gt;&gt;n$</td></tr></tbody></table></div><blockquote><p>手动创建特征的方式见<a href="https://l61012345.top/2021/08/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/11.%20%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/11.3.%20%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7/#%E5%AF%BB%E6%89%BE%E7%89%B9%E5%BE%81">9.9. 异常检测算法的评价·关键变量</a><br>原则上使用多元高斯分布时要求$m≥10n$   </p></blockquote><h3 id="奇异的协方差矩阵"><a href="#奇异的协方差矩阵" class="headerlink" title="奇异的协方差矩阵"></a>奇异的协方差矩阵</h3><p>如果在实际应用过程中协方差矩阵$Σ$不可逆，有如下两种常见的可能：  </p><ol><li>数据的量小于特征的数量</li><li>冗余的特征：存在相同的特征，或者存在某个特征是其他若干个特征的线性组合（高度线性相关）的情况。  </li></ol>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>11. 异常检测算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>11.4. 比较异常检测与监督学习算法</title>
    <link href="/2021/08/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/11.%20%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/11.4.%20%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E4%B8%8E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/08/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/11.%20%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/11.4.%20%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E4%B8%8E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="异常检测与监督学习的对比"><a href="#异常检测与监督学习的对比" class="headerlink" title="异常检测与监督学习的对比"></a>异常检测与监督学习的对比</h1><p>在上一讲：<a href="https://l61012345.top/2021/08/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/11.%20%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/11.3.%20%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7/">11.3. 异常检测算法的评价</a>中使用的原数据集是一个有标签的数据集，既然如此，那为何不使用监督学习的方法？<br>使用监督学习方法来训练并识别异常目标是一个好的办法，和异常检测算法相比，两者适用于不同的数据集条件，具体如下：  </p><div class="table-container"><table><thead><tr><th>类别</th><th>异常检测</th><th>监督学习</th></tr></thead><tbody><tr><td>数据集类型</td><td>非常少量的正向类（异常数据 $y=1$）, 大量的负向类（$y=0$）</td><td>同时有大量的正向类和负向类</td></tr><tr><td>异常的类型</td><td>异常的类型非常多。根据非常少量的正向类数据来训练算法。</td><td>异常的类型比较少且固定。有足够多的正向类实例，足够用于训练算法。</td></tr><tr><td>新产生的异常</td><td>未来遇到的异常可能与已掌握的异常、非常的不同。</td><td>未来遇到的正向类实例可能与训练集中的非常近似。</td></tr><tr><td>应用</td><td>欺诈行为检测 生产（例如飞机引擎）检测数据中心的计算机运行状况</td><td>邮件过滤器 天气预报 肿瘤分类</td></tr></tbody></table></div><p>其中最根本依据是：<strong>如果数据集中的异常样本太少以至于无法完成监督学习时，就应当考虑异常检测算法</strong>。<br>另外由于正态分布的统计性质，一般采用异常检测算法时，数据量应该在万级单位左右。  </p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>11. 异常检测算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>11.3. 异常检测算法的评价·关键变量</title>
    <link href="/2021/08/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/11.%20%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/11.3.%20%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7/"/>
    <url>/2021/08/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/11.%20%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/11.3.%20%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="异常检测算法的评价·关键变量"><a href="#异常检测算法的评价·关键变量" class="headerlink" title="异常检测算法的评价·关键变量"></a>异常检测算法的评价·关键变量</h1><h2 id="异常检测算法的实数评价"><a href="#异常检测算法的实数评价" class="headerlink" title="异常检测算法的实数评价"></a>异常检测算法的实数评价</h2><h3 id="实数评价"><a href="#实数评价" class="headerlink" title="实数评价"></a>实数评价</h3><p>评估学习算法的重要方法是实数评价，即对评价的指标返回一个实数，通过实数的大小来直观表示学习算法在这一指标上的优劣性。<br>假设有一系列带标签（标记正常或者异常）的数据集用于异常检测算法，从数据集中分离出一个无标签的训练集（其中绝大部分的数据都应该是正常/异常的），使用训练集来建立数据集的概率密度模型$p(x)$。<br>接着建立有标签的交叉验证集和测试集来评估这个算法。  </p><blockquote><p>在实际训练中，数据集中正常样本的数量应该比异常样本数量要多得多。推荐的数据划分比例：训练集：测试集：交叉验证集=60:20:20  </p></blockquote><p>将测试集和验证集的数据放入模型$p(x)$，模型给出预测的结果。<br>由于该数据集是一个偏斜类数据集，因此单纯的使用算法准确率指标对其评估并不是一个好的选择。在偏斜类问题中，常采用的指标有：  </p><ul><li>真阳性/真阴性/假阳性/假阴性率</li><li>查准率和召回率</li><li>F值</li></ul><blockquote><p>偏斜类问题/查准率、召回率/F值的知识见：<a href="https://l61012345.top/2021/04/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/7.%20%E5%AD%A6%E4%B9%A0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E5%AE%9E%E9%99%85%E9%97%AE%E9%A2%98/7.2.%20%E6%9F%A5%E5%87%86%E7%8E%87%E5%92%8C%E5%8F%AC%E5%9B%9E%E7%8E%87/">7.2. 查准率和召回率</a></p></blockquote><h2 id="关键变量的选取"><a href="#关键变量的选取" class="headerlink" title="关键变量的选取"></a>关键变量的选取</h2><h3 id="阈值（-e-）的选取"><a href="#阈值（-e-）的选取" class="headerlink" title="阈值（$ɛ$）的选取"></a>阈值（$ɛ$）的选取</h3><p>阈值$ɛ$很大程度上会影响算法的性能：  </p><script type="math/tex; mode=display">y=\begin{cases}    1,p(x_{test})<ɛ \\    0,p(x_{test})≥ɛ  \end{cases}</script><p>通常设定一系列的$ɛ$值，取能够使得F值最大的$ɛ$作为最终阈值。也可以使用交叉验证集来选择$ɛ$。  </p><h2 id="特征的选取"><a href="#特征的选取" class="headerlink" title="特征的选取"></a>特征的选取</h2><h3 id="特征变换"><a href="#特征变换" class="headerlink" title="特征变换"></a>特征变换</h3><p>由于异常检测的关键在于利用高斯分布的概率密度函数进行计算，因此在将数据输入进算法前有必要绘制数据在某些特征上的分布以检验是否符合高斯分布的特性。<br>虽然数据不符合高斯分布，算法也能够正常运行，但是算法性能会有所损失。常见的做法是使用一些变换将这类数据变为类似于高斯分布的形式，比如下图对数据进行的对数变换。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210809110548.png width=50%><br>常用的特征变换：  </p><ul><li>对数变换：$x→log(x+c)$  </li><li>分数幂指数变换：$x→x^{\frac{1}{c}}$  </li></ul><h3 id="寻找特征"><a href="#寻找特征" class="headerlink" title="寻找特征"></a>寻找特征</h3><p>基本思路是用误差分析：观察测试集和验证集中识别错误的数据，再想出另外的特征加入到原来的算法中。<br>如果异常的样本和正常的样本给出的$p(x)$值差异不大，则应当观察数据在其他新特征上的分布规律，这些新特征应该能够明显的区分异常样本和正常样本。<br>通常可以通过将一些线性相关的特征进行非线性组合，来打破线性相关性。从而获得一些新的更好的特征（异常数据的该特征值异常地大或小从而能够更明显地被区分开）。<br>例如，在检测数据中心的计算机状况的例子中，一般情况下网络通信量$x_1$越高，CPU负载$x_2$越高，这样的两个特征有可能不容易区分异常的服务器（网络通信量正常，但CPU负载高）。此时可以用CPU负载与网络通信量的比:</p><script type="math/tex; mode=display">\frac{x_2}{x_1}</script><p>作为一个新的特征，以放大CPU负载在网络通信量正常时的效果。新的特征能够很好的凸显上述问题：如果该值异常地大，有可能意味着该服务器是陷入了一些问题中。  </p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>11. 异常检测算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>11.2. 异常检测算法的原始模型</title>
    <link href="/2021/08/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/11.%20%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/11.2.%20%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83%E5%92%8C%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/"/>
    <url>/2021/08/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/11.%20%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/11.2.%20%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83%E5%92%8C%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="异常检测算法的原始模型"><a href="#异常检测算法的原始模型" class="headerlink" title="异常检测算法的原始模型"></a>异常检测算法的原始模型</h1><h2 id="高斯分布"><a href="#高斯分布" class="headerlink" title="高斯分布"></a>高斯分布</h2><p>随机变量$x$的均值为$μ$方差为$σ^2$，如果$x$的概率密度函数服从</p><script type="math/tex; mode=display">P(x;μ,σ^2)=\frac{1}{√{2π}}exp(-\frac{(x-μ)^2}{2σ^2})</script><p>则称$x$服从高斯分布（或者称为正态分布,Gaussian distribution/Normal distribution），将$x$记作$x∿N(μ,σ^2)$。<br>高斯分布的概率密度函数图像如下图所示：<br><img src="https://img.mianfeiwendang.com/pic/0b1df5c172c3e5197756b634/1-786-png_6_0_0_465_676_166_142_892.979_1262.879-924-0-1451-924.jpg" alt=""><br>高斯分布在$x$取到均值时的概率最大。  </p><h3 id="参数估计"><a href="#参数估计" class="headerlink" title="参数估计"></a>参数估计</h3><blockquote><p>参数估计的相关内容：  <a href="https://l61012345.top/2021/04/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/#%E6%A0%B7%E6%9C%AC%E7%9A%84%E7%82%B9%E4%BC%B0%E8%AE%A1%E6%B3%95">概率论与数理统计：样本的点估计法</a>  </p></blockquote><p>假设随机变量$x$的$m$个样本：$\{x^{(1)},..,x^{(m)}\}$，已知$x$服从$x∿N(μ,σ^2)$的高斯分布，通过样本数据估计随机变量$x$总体的$μ$与$σ$，它们服从如下的估计规则（即最大似然估计法）：  </p><script type="math/tex; mode=display">μ=\frac{1}{m}∑x^{(k)}</script><script type="math/tex; mode=display">σ^2=\frac{1}{m}∑(x^{(k)}-μ)^2</script><h2 id="使用高斯分布的异常检测算法"><a href="#使用高斯分布的异常检测算法" class="headerlink" title="使用高斯分布的异常检测算法"></a>使用高斯分布的异常检测算法</h2><p>假设$i$维的数据集$X=\{x^{(1)},..,x^{(m)}\}$，假设数据集$X$的特征$x_i$都服从高斯分布：$x_i∿N(μ_i,σ_i^2)$，那么$X$的概率密度模型$p(x)$可以理解为所有特征的概率密度模型的乘积：  </p><script type="math/tex; mode=display">p(x)=Π_{i=1}^mp(x_i;μ_i,σ_i^2)</script><blockquote><p>这个模型建立的假设基于$\{x^{(1)},..,x^{(m)}\}$相互独立，事实上大多数时候这些变量仍然是独立的，并且在即是有相关性的前提下算法性能仍然比较好。    </p></blockquote><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><ol><li>选取$n$个能够识别出异常的特征  </li><li>通过已知数据集构建数据集$X=\{x^{(1)},..,x^{(m)}\}$  </li><li>利用参数估计计算出每一个特征的均值$μ_i$和方差$σ_i^2$：  <script type="math/tex; mode=display">μ_i=\frac{1}{m}∑_{k=1}^mx^{(k)}_i</script><script type="math/tex; mode=display">σ_i^2=\frac{1}{m}∑_{k=1}^m(x^{(k)}_i-μ_i)^2</script></li><li>计算$X$的概率密度模型：  <script type="math/tex; mode=display">p(x)=Π_{i=1}^np(x_i;μ_i,σ_i^2)=Π_{i=1}^n\frac{1}{√{2π}}exp(-\frac{(x-μ_i)^2}{2σ_i^2})</script></li><li>给定一个新的$x$，带入到$p(x)$中，判断$p(x)$与阈值$ɛ$的大小，给出结论。  <script type="math/tex; mode=display">y=\begin{cases} 1（异常）,p(x_{test})<ɛ \\ 0（正常）,p(x_{test})≥ɛ\end{cases}</script></li></ol>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>11. 异常检测算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>11.1. 异常检测问题</title>
    <link href="/2021/08/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/11.%20%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/11.1.%20%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/"/>
    <url>/2021/08/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/11.%20%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/11.1.%20%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="异常检测问题"><a href="#异常检测问题" class="headerlink" title="异常检测问题"></a>异常检测问题</h1><p>异常检测(Anomaly detection)算法是另一种常在非监督学习中使用的算法。这种算法虽然常常用于非监督学习，但与监督学习有许多相似之处。<br>对于一个非监督学习的数据集，假定数据集里的数据都是正常或异常的，此时加入一个新的数据，判断其在空间内的分布是否异常（符合现有数据集的分布规律）的问题称为异常检测问题。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210804145801.png width=50%>  </p><p>解决这类问题，基本思路是对现有数据集的分布概率进行建模：设数据集$X$的分布概率模型为$p(x)$，然后检测新数据$x_{test}$的分布概率为$p(x_{test})$，通过设定一个阈值$ɛ$来检测$x_{test}$是否异常：如果$p(x_{test})&lt;ɛ$，则判定$x_{test}$的数据出现了异常。  </p><blockquote><p>概率分布模型$p(x)$在数据密集的中心区域位置的值很高，越疏离中心，$p(x)$的值越低。  </p></blockquote><h3 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h3><ul><li>用户欺诈行为检测  </li><li>产品质量检测  </li><li>生产监控  </li><li>…  </li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>11. 异常检测算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>10.3. 主成分分析算法的优化</title>
    <link href="/2021/08/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/10.%20%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/10.3.%20PCA%E4%BC%98%E5%8C%96/"/>
    <url>/2021/08/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/10.%20%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/10.3.%20PCA%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="PCA算法优化"><a href="#PCA算法优化" class="headerlink" title="PCA算法优化"></a>PCA算法优化</h1><h2 id="主成分数量的选取"><a href="#主成分数量的选取" class="headerlink" title="主成分数量的选取"></a>主成分数量的选取</h2><p>$K$称作主成分的数量，通常$K$的选取与如下的两个参数有关：<br>平均投影误差的平方：  </p><script type="math/tex; mode=display">\frac{1}{m}∑_{i=1}^m|x^{(i)}-x^{(i)}_{approx}|^2</script><p>$x_{approx}=U_{reduce}z$，是通过$z$复原后得到的向量。<br>反应每一个数据到投影的距离之和。<br>数据的方差：  </p><script type="math/tex; mode=display">\frac{1}{m}∑_{i=1}^m|x^{(i)}|^2</script><p>反应每一个数据到原点的距离之和。<br>$K$的选取通常遵循以下规律：<br>满足最小的$K$,使得：  </p><script type="math/tex; mode=display">\frac{\frac{1}{m}∑_{i=1}^m|x^{(i)}-x^{(i)_{approx}}|^2}{\frac{1}{m}∑_{i=1}^m|x^{(i)}|^2}≤ 0.1(1\%)</script><p>表示99%的数据中的特征被保留，仅有1%的数据特征被压缩。<br>如果希望这个比例小于1%，就意味着原本数据的偏差有99%都保留下来了，如果选择保留95%的偏差，便能非常显著地降低模型中特征的维度了。  </p><blockquote><p>理解： </p><ol><li>投影误差对应的是被放弃的$n-k$个特征值$λ$之和，而均方值对应的是所有的$n$之和，因此从这一点来看，$\frac{∑_{i=1}^k λ_i}{∑_{i=1}^n λ_i}≥99\%$的说法与此处的解释并无冲突。  </li><li>1%其实是一个容错的区间，从5%到15%的区间内选取都是比较合理的，取决于具体问题。  </li></ol></blockquote><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p>从$k=1$开始应用PCA，计算出$U_{reduce}$和$z$，然后计算比例是否小于1%。如果不是的话再令$k=2$，如此类推，直到找到可以使得比例小于1%的最小$k$值（原因是各个特征之间通常情况存在某种相关性）。<br>这样做的问题在于奇异值分解的过程计算量非常的大。<br>实际上，在Octave中应用时，奇异值分解：<code>svd()</code>函数会返回三个矩阵U,S,V，其中U即为前文中提到的一个含有$n$个方向向量（也是特征向量）的矩阵（所有的列向量是方向向量/特征向量）。S是一个对角矩阵，对角线上的元素$s_{ii}$为特征值。<br>$\frac{\frac{1}{m}∑_{i=1}^m|x^{(i)}-z^{(i)}|^2}{\frac{1}{m}∑_{i=1}^m|x^{(i)}|^2}≤ 0.1(1\%)$可以等价为：  </p><script type="math/tex; mode=display">1-\frac{∑_{i=1}^ks_{ii}}{∑_{i=1}^ns_{ii}}≤0.01</script><p>如此则只需要应用一次<code>svd()</code>函数通过返回的特征值矩阵$S$得到所有的特征值，尝试前$k$个特征值，直到找到符合条件的最小$k$即可。  </p><blockquote><p>事实上，$k$的选取还与应用PCA的目的有关，如果应用PCA的目的是为了减小计算量、加速算法的学习，则应当按照上述流程选取$k$。如果应用PCA的目的只是为了可视化数据集，那么$k=2$或$k=3$。  </p></blockquote><h2 id="重建的压缩表示"><a href="#重建的压缩表示" class="headerlink" title="重建的压缩表示"></a>重建的压缩表示</h2><p>PCA是一个数据压缩算法，那么如何将压缩后的数据复原回原来的维度？<br>应用公式：</p><script type="math/tex; mode=display">x_{approx}=U_{reduce}z</script><p>可以看出$U_{reduce}$是$n × k$的矩阵，$z$是$k × 1$的向量，根据矩阵乘法的性质可以推导出$x_{approx}$是$n × 1$的向量。重构的数据$x_{approx}$在原始空间中的分布是共低维平面的。  </p><h2 id="加速监督学习"><a href="#加速监督学习" class="headerlink" title="加速监督学习"></a>加速监督学习</h2><p>如果对于高维的数据，通过应用PCA的降维效果能够显著的降低监督学习的计算量。<br>对于数据集$(x^{(i)},y^{(i)})$，先抽取所有的数据:$x^{(i)}$，然后应用PCA得到这些数据的低维表示$z^{(i)}$，现在新的数据集变为$(z^{(i)},y^{(i)})$进行训练。同样的对预测的数据$x$也需要将$x$映射到$z$再进行预测。  </p><blockquote><p>$U_{reduce}$只能通过训练集来进行定义，再将$U_{reduce}$应用到交叉验证集或者是测试集。  </p></blockquote><h2 id="不恰当的应用案例"><a href="#不恰当的应用案例" class="headerlink" title="不恰当的应用案例"></a>不恰当的应用案例</h2><h3 id="使用PCA来防止过拟合"><a href="#使用PCA来防止过拟合" class="headerlink" title="使用PCA来防止过拟合"></a>使用PCA来防止过拟合</h3><p>合理性： 由于PCA能够降维、减小数据的特征量，因此认为使用PCA来防止过拟合是合理的，但是并不是一个好的应用。<br>由于PCA不关心数据的标签$y$来降维，因此可能会在降维过程中丢失一些非常有用的特征信息。而正则化会考虑数据的标签$y$，因此正则化比PCA更不容易损失有用的信息。  </p><h3 id="滥用PCA"><a href="#滥用PCA" class="headerlink" title="滥用PCA"></a>滥用PCA</h3><p>另一个常见的错误是，默认地将主要成分分析作为学习过程中的一部分。应当先尝试使用原始数据作为机器学习算法的输入，当计算量非常大、计算速度非常慢、硬盘空间不足时，才应该应用PCA对数据进行压缩。  </p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>10. 主成分分析</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>10.2. 算法思路和流程</title>
    <link href="/2021/08/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/10.%20%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/10.2.%20PCA/"/>
    <url>/2021/08/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/10.%20%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/10.2.%20PCA/</url>
    
    <content type="html"><![CDATA[<h1 id="主成分分析算法的思路和流程"><a href="#主成分分析算法的思路和流程" class="headerlink" title="主成分分析算法的思路和流程"></a>主成分分析算法的思路和流程</h1><p>主成分分析,PCA,是最流行的降维方法之一。  </p><h2 id="主成分分析问题"><a href="#主成分分析问题" class="headerlink" title="主成分分析问题"></a>主成分分析问题</h2><p>PCA会找一个低维平面，将所有的数据投影到这个平面内，并使得的所有数据点到这个地维平面的距离（称为投影误差）之和最短。<br>在应用PCA之前，通常会将数据归一化和特征缩放，使得所有的数据在可比的范围之内。<br>具体而言，PCA会在$n$维的数据空间中寻找到$K$个能够代表这个低维平面的方向向量$u^{(1)},…,u^{(K)}$，使得这$K$个向量所定义的低维平面，即线性代数中这些向量的张成空间$Span[u^{(1)},…,u^{(K)}]$。<br>根据线性代数的相关知识，这$K$个向量应当是线性不相关且两两正交的。  </p><h3 id="PCA与线性回归的区别"><a href="#PCA与线性回归的区别" class="headerlink" title="PCA与线性回归的区别"></a>PCA与线性回归的区别</h3><p>需要注意的是，尽管看上去比较相似，但是PCA并不是线性回归。在线性拟合中需要寻找的是数据点到直线的垂直距离，而在PCA需要找到的是数据点到直线的最短距离，如图所示。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210802143928.png width=50%><br>而且线性回归的目的是寻找给定某个$x$的预测值$y$，而PCA只是单纯的在$x_1,..x_n$的$n$维特征空间中寻找一个低维平面。但是PCA和线性拟合运用的思想是相似的。    </p><h2 id="主成分分析流程"><a href="#主成分分析流程" class="headerlink" title="主成分分析流程"></a>主成分分析流程</h2><blockquote><p>新加坡国立大学讲义中关于PCA的部分：<a href="https://l61012345.top/2021/01/28/Machine%20Learning-NAU/5.%20%E7%89%B9%E5%BE%81/#PCA">NUS-Machine Learning:5.特征-PCA</a></p></blockquote><p>对于训练集：$x^{(1)},..,x^{(m)} ∈ \mathbb{R}^n$，首先对其进行归一化处理或者是特征缩放，使得所有的特征都具有可比性。<br>然后计算训练集的协方差矩阵$\Sigma$：  </p><script type="math/tex; mode=display">Σ=\frac{1}{m}∑_{i=1}^{n}(x^{(i)})(x^{(i)})^T</script><p>Σ是一个$n × n$的矩阵。<br>对协方差矩阵应用奇异值分解，得到协方差矩阵的所有特征向量所组成的矩阵$U$。  </p><script type="math/tex; mode=display">U=[u^{(1)}|u^{(2)}…|u^{(k)}…|u^{(n)}]</script><p>$U$是一个$n × n$的矩阵。<br>现在将这些特征向量按照分别所对应的特征值从大到小的顺序排列，选择其中$k$的最大的特征向量构成主成分矩阵$U_{reduce}$。<br>新的降维后的数据集$z^{(1)},..,z^{(m)}∈ \mathbb{R}^k$可以通过投影（即乘上转置矩阵）：  </p><script type="math/tex; mode=display">z^{(i)}=U_{reduce}^Tx^{(i)}</script><p>这样每一个$z$都是一个$k$维的向量。  </p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>10. 主成分分析</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>10.1. 降维的目的</title>
    <link href="/2021/08/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/10.%20%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/10.1.%20%E9%99%8D%E7%BB%B4/"/>
    <url>/2021/08/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/10.%20%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/10.1.%20%E9%99%8D%E7%BB%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="降维的目的"><a href="#降维的目的" class="headerlink" title="降维的目的"></a>降维的目的</h1><p>降维是非监督学习中常用的一种算法，使用降维的目的有如下两个：  </p><h2 id="压缩数据"><a href="#压缩数据" class="headerlink" title="压缩数据"></a>压缩数据</h2><p>使用降维的其中一个目的是压缩数据，压缩数据能够减小算法的计算量的同时提高计算速度。<br>降维的手段是合并一些高度相关的特征。<br>具体而言，如果两个特征在二维空间内呈现出线性相关，那么则可以设定一个新的特征，将所有数据在这个二维空间上的分布投射至一维数轴上，如图所示。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210730163758.png width=20%><br>对于三个特征，如果数据都分布在这个三维空间的一个平面上，那么同理能够将数据的分布投射至一个二维的平面上。  </p><h2 id="可视化数据"><a href="#可视化数据" class="headerlink" title="可视化数据"></a>可视化数据</h2><p>高维的数据很难用可视化的方法来表现它们的数据分布，这时可以将数据降维到可视化的维度（&lt;=3维）以便观察它们的分布特性。  </p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>10. 主成分分析</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>标记说明</title>
    <link href="/2021/08/21/%E6%97%A5%E8%AF%AD/%E6%A0%87%E8%AE%B0%E8%AF%B4%E6%98%8E/"/>
    <url>/2021/08/21/%E6%97%A5%E8%AF%AD/%E6%A0%87%E8%AE%B0%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="标记说明"><a href="#标记说明" class="headerlink" title="标记说明"></a>标记说明</h1><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section">## 语法主干</span><br><span class="hljs-bullet">-</span> 词性接续1<br>  【翻译1】[用法类型1]，解释1。特殊说明1。<br>  固定搭配1  <br>  例：例句1  <br><span class="hljs-bullet">-</span> 词性接续2<br>  【翻译2】[用法类型2]，解释2。特殊说明2。<br>  固定搭配2  <br>  例：例句2<br></code></pre></td></tr></table></figure><p>特别说明：  </p><ol><li>[用法类型]表示该用法使用的场合，标记有：  <ul><li>[口]：口语。  </li><li>[书]：书面语。  </li><li>[正式]：只能在正式场合使用。  </li></ul></li><li>如果形如以下的情形：   <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"> ## 语法主干<br><span class="hljs-bullet">-</span> 词性接续1<br><span class="hljs-bullet">-</span> 词性接续2<br> 【翻译】[用法类型]，解释。特殊说明。<br> 固定搭配  <br> 例：例句  <br></code></pre></td></tr></table></figure> 若无特殊说明，表明词性接续1和词性接续2所对应的用法和含义是相同的。  </li><li>固定搭配的描述以“常与……连用。”的格式给出，“……”中的变形以语法接续为准。  </li></ol><h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><ul><li>讲义中以上标来表示之前汉字或单词的假名。例如：漢字<sup>かんじ</sup>  </li><li>以符号~表示接续中的变形或者是词性应当加上随后的假名，再与语法进行接续。例如：名詞～の＋恐れがある  </li><li>以符号·表示并列：可以是语法的并列，也可以是接续词的并列。  </li></ul><h2 id="用词"><a href="#用词" class="headerlink" title="用词"></a>用词</h2><p>讲义使用动词分类而不以体言和用言进行区分。下面给出具体的名词解释：  </p><ul><li>動詞辞書形：又称动词字典形。  </li><li>動詞ない形：又称动词未然形。  </li><li>動詞普通形：包括動詞辞書形・動詞た形・動詞ない形  </li><li>い形容詞：<ul><li>讲义中的い形容詞默认后面带有い。  </li><li>て形：即い形容詞去掉い加上くて。  </li></ul></li><li>な形容詞：<ul><li>な形容詞默认不带な。  </li><li>て形：即な形容詞加で。</li></ul></li><li>前项：指包含接续词的部分。  </li><li>后项：指语法结束后，跟在语法之后的部分。  </li></ul>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>十级别语法</title>
    <link href="/2021/07/31/%E6%97%A5%E8%AF%AD/%E6%A8%B1%E8%8A%B1%E6%95%99%E6%9D%90/%E5%8D%81%E7%BA%A7%E5%88%AB/"/>
    <url>/2021/07/31/%E6%97%A5%E8%AF%AD/%E6%A8%B1%E8%8A%B1%E6%95%99%E6%9D%90/%E5%8D%81%E7%BA%A7%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="十级别语法"><a href="#十级别语法" class="headerlink" title="十级别语法"></a>十级别语法</h1><h2 id="意志和判断（Unit-1）"><a href="#意志和判断（Unit-1）" class="headerlink" title="意志和判断（Unit 1）"></a>意志和判断（Unit 1）</h2><h3 id="までだ"><a href="#までだ" class="headerlink" title="までだ"></a>までだ</h3><ul><li>動詞辞書形＋までだ・までのことだ  </li></ul><ol><li>【只好做……】，用于表示觉悟，表示没有其他办法的情况下只能这样做。  </li><li>【只是……】，表示辩解，表示没有别的意图。<br>例：これだけ頑張っても合格できないなら、あきらめるまでです。（觉悟）<br>例：私はこの点を考えるまでだ。（辩解）  </li></ol><h3 id="にはない"><a href="#にはない" class="headerlink" title="にはない"></a>にはない</h3><ul><li>動詞辞書形・名詞＋にはあたらない<br>【以……来说，不值得……】，评价由于某个人的能力等出众，所以用不着（惊讶，称赞等等）。通常表示对对方能力的肯定，也可用于挖苦。<br>常与：感謝、驚く、褒める、称賛等连用。<br>例：山田さんの体力からすれば、三時間走るにはあたらない。　   </li></ul><h3 id="でなくてなんで"><a href="#でなくてなんで" class="headerlink" title="でなくてなんで"></a>でなくてなんで</h3><ul><li>名詞＋でなくてなんで<br>【如果说不是……的话，那又是什么呢】[书]，言下之意表示就是这个。是主观的判断。前面的名词是抽象性名词。<br>例：これは恋でなくてなんでしょう。  </li></ul><h3 id="まい"><a href="#まい" class="headerlink" title="まい"></a>まい</h3><ul><li>動詞辞書形＋まい</li><li>二、三類動詞＋まい・すまい<br>【绝对不是……】，表示第一人称的强烈否定。<br>常与：ある连用<br>例：これはただのミスじゃあるまい。  </li></ul><h3 id="にほかない"><a href="#にほかない" class="headerlink" title="にほかない"></a>にほかない</h3><ul><li>名詞＋にほかない<br>【绝对是……】[书]，表示断言，说话人有百分之百的确信。<br>例：あんな成績を取って、彼女の努力あらわれにほかありません。  </li></ul><h3 id="にきまっている"><a href="#にきまっている" class="headerlink" title="にきまっている"></a>にきまっている</h3><ul><li>名詞～である・な形容詞～である＋にきまっている  </li><li>い形容詞・動詞普通形＋にきまっている<br>【……一定会……】[口]，表示说话人相信的事情/结果一定会发生。<br>例：暗い部屋で勉強するのは、目に悪いにきまっていません。  </li></ul><h3 id="に過ぎない"><a href="#に過ぎない" class="headerlink" title="に過ぎない"></a>に過ぎない</h3><ul><li>名詞～である・な形容詞～である＋にすぎない  </li><li>い形容詞・動詞普通形＋にすぎない<br>【只不过是……罢了】，表示说话人主观的判断。<br>例：幽霊なんで、現代科学は説明できない部分であるにすぎない。  </li></ul><h3 id="しかない"><a href="#しかない" class="headerlink" title="しかない"></a>しかない</h3><ul><li>名詞・動詞辞書形＋しかない<br>【不得不/只好……】，没有更好的解决方法了，强调唯一性。<br>例：逃げるしかない。  </li></ul><h3 id="というものだ"><a href="#というものだ" class="headerlink" title="というものだ"></a>というものだ</h3><ul><li>名詞～である・な形容詞～である＋というものだ  </li><li>動詞辞書形・い形容詞＋というものだ<br>【就是……的】，表示主观地、理所当然地认为。前项为事实，后项为常识性的评价和判断。<br>例：爆弾は爆物処理班に回収されだ後、起爆するというものだ。  </li></ul><h2 id="劝诱和禁止（Unit-2）"><a href="#劝诱和禁止（Unit-2）" class="headerlink" title="劝诱和禁止（Unit 2）"></a>劝诱和禁止（Unit 2）</h2><h3 id="べからず"><a href="#べからず" class="headerlink" title="べからず"></a>べからず</h3><ul><li>動詞辞書形＋べからず<br>【禁止……】[书]，是一种老旧的表达。<br>例：仕事中サボるべからず。  </li></ul><h3 id="ようにではない"><a href="#ようにではない" class="headerlink" title="ようにではない"></a>ようにではない</h3><ul><li>動詞意向形＋ようにではない<br>【让我们一起……吧】，是一种劝诱和提出建议的方式。说话场景是一对多的情况下使用，不能用于一对一的对话中。<br>例：この社会を改造しようにではない。  </li></ul><h3 id="こと"><a href="#こと" class="headerlink" title="こと"></a>こと</h3><ul><li>動詞辞書形・ない形・名詞～の＋こと<br>【请……】，多用于提醒别人注意。<br>例：英語の成績を上げたいと思ったら、まず単語量を増やすことです。  </li></ul><h3 id="ことだ"><a href="#ことだ" class="headerlink" title="ことだ"></a>ことだ</h3><ul><li>動詞辞書形・ない形＋ことだ<br>【最好……】，主观地给对方忠告和建议。只能用于身份高的对身份低的人使用。<br>例：受験前に遊ばないことだ。  </li></ul><h3 id="ことはない"><a href="#ことはない" class="headerlink" title="ことはない"></a>ことはない</h3><ul><li>動詞辞書形・ない形＋ことはない  </li></ul><ol><li>【没必要……】，表示劝告。   </li><li>【不需要考虑……】，由于没有发生的可能性而不需要考虑。<br>例：君は復習したから、慌てることはない。  </li></ol><h3 id="ものではない"><a href="#ものではない" class="headerlink" title="ものではない"></a>ものではない</h3><ul><li>動詞辞書形＋ものではない<br>【不应该……】，在社会常识的角度上出发对对方进行劝诫。<br>例：君は公務員として、賄賂に受けるものではない。  </li></ul><h3 id="べき・はず"><a href="#べき・はず" class="headerlink" title="べき・はず"></a>べき・はず</h3><ul><li>動詞辞書形＋べき<br>【理应……】，是主观的表示说话人认为的义务<br>例：やるべきことはたくさんいる。  </li><li>動詞辞書形＋はず<br>【理应……】，表示客观地判断。<br>例：この時間で、小林さんは仕事しているはずです。  </li></ul><h2 id="话题提起（Unit-3）"><a href="#话题提起（Unit-3）" class="headerlink" title="话题提起（Unit 3）"></a>话题提起（Unit 3）</h2><h3 id="とは"><a href="#とは" class="headerlink" title="とは"></a>とは</h3><ul><li>名詞＋とは  </li></ul><ol><li>【所谓……，就是……】[书]，表示解释前项的名词。<br>例：神経ネットワークとは、人脳の神経を模擬して、作った人工知能です。  </li><li>【意外地……】，表示意外的情绪<br>例：京都とはこんなに住みごこちがよいところだとは思わなかった。（住着意外的舒服）  </li></ol><h3 id="というものは"><a href="#というものは" class="headerlink" title="というものは"></a>というものは</h3><ul><li>名詞＋とうものは<br>【所谓……】，后项用于对该抽象名词进行说明。说明的内容是一般性质或者是本质。往往包含着某种感情。<br>例：人間というものは一人生きていくことはできません。  </li></ul><h3 id="といえば"><a href="#といえば" class="headerlink" title="といえば"></a>といえば</h3><ul><li>名詞＋と言えば<br>【说到……的话】，表示提起一个由前述话题联想得到的新话题。<br>例：センター試験と言えば、もうすぐ模擬テストが来るでしょう。  </li></ul><h3 id="というと"><a href="#というと" class="headerlink" title="というと"></a>というと</h3><ul><li>名詞・動詞辞書形＋というと  </li></ul><ol><li>【一提到……，就会想到……】，表示一提到某个话题就会想起与之相关联的某个事物。<br>例：先生というと，李先生を思い出す。  </li><li>【你的意思是……吧】，表示对前述内容的确认。<br>例：田中さんというと，あの中国語の先生ですか。  </li></ol><ul><li>名詞＋はというと<br>表示与前项对比后，提出新的话题<br>例：難関校を受験するということは並大抵（一般的）のことではありません。  </li></ul><h3 id="といったら"><a href="#といったら" class="headerlink" title="といったら"></a>といったら</h3><ul><li>名詞＋と言ったら<br>【说起……那真是……】，表示提起话题，含有惊讶的语气。<br>例：あの学校の英語の難しさといったら言葉では言い表せません。  </li></ul><h3 id="にかけては"><a href="#にかけては" class="headerlink" title="にかけては"></a>にかけては</h3><ul><li>名詞＋にかけては<br>【说起……，那可就……】，表示提出一个话题，后项的内容是一些褒义的、称赞性的句子。有表示主语对于话题提到的事物很擅长的意思。可以用于自己和他人，用于自己时表自信。<br>例：数学にかけては、彼女はクラスでいつも一番だった。  </li></ul><h3 id="ときたら"><a href="#ときたら" class="headerlink" title="ときたら"></a>ときたら</h3><ul><li>名詞＋ときたら<br>【说起……，就……】，后项是贬义句子，有不满和挖苦之意。<br>例：彼女ときたら,最近おしゃれのことにばっかり気をつけている。 （说到她，最近光是注意打扮。有挖苦之意）  </li></ul><h2 id="强调心情（Unit-4）"><a href="#强调心情（Unit-4）" class="headerlink" title="强调心情（Unit 4）"></a>强调心情（Unit 4）</h2><h3 id="てやまない"><a href="#てやまない" class="headerlink" title="てやまない"></a>てやまない</h3><ul><li>動詞て形＋てやまない<br>【由衷地……】[正式]，表带强烈的愿望和一种心情。通常用于关照和忠告。一直都有认为是这样的情况时使用。<br>常与「祈る」、「期待する」、「願う」、「愛する」、「尊敬する」等动词一起使用。<br>例：二人の幸せを祈ってやみません。  </li></ul><h3 id="かぎりだ"><a href="#かぎりだ" class="headerlink" title="かぎりだ"></a>かぎりだ</h3><ul><li>な形容詞～な・名詞～の・い形容詞＋かぎりだ（です）<br>【从心底上……】，表示说话人自己现在有非常强烈的意愿。只能对说话人自己使用。<br>例：成績が上がって、嬉しいかぎりだ。  </li></ul><h3 id="といったらない・といったらありはしない"><a href="#といったらない・といったらありはしない" class="headerlink" title="といったらない・といったらありはしない"></a>といったらない・といったらありはしない</h3><ul><li>い形容詞・程度に表示する名詞＋といったらない<br>【……极了】，表示程度已经到了用语言无法表达的程度。是一种极端的叙述。对于好的和坏的事物都可以用。  </li><li>い形容詞・程度に表示する名詞＋といったらありはしない<br>例：災害の規模は大きさといったらなかった。  </li></ul><h3 id="仕方ない・しょうがない・てたまらない・てならない"><a href="#仕方ない・しょうがない・てたまらない・てならない" class="headerlink" title="仕方ない・しょうがない・てたまらない・てならない"></a>仕方ない・しょうがない・てたまらない・てならない</h3><ul><li>自動詞て形・い形容詞て形・な形容詞て形＋しかたない  </li><li><p>自動詞て形・い形容詞て形・な形容詞て形＋しょうがない [口]<br>【难以抑制地/情不自禁地……】，表示自发性的、难以抑制的心情或者行为。しょうがない为口语。<br>例：クラスで一番になって嬉しくてしかたない。  </p></li><li><p>動詞て形・い形容詞て形・な形容詞て形＋てたまらない<br>【怎么都不能……】，也表示难以抑制的，但是不能用于自发性的词语。<br>例：徹夜続きで眠くてたまりません。  </p></li><li><p>動詞て形・い形容詞て形・な形容詞て形＋てならない<br>【情不自禁地……/……得不得了】，表示自然而然涌上心头的心情或行为，多用于表达负面情绪。<br>例：大学の時もっと勉強しておけば良かったと悔やんでならない。（后悔的不得了）  </p></li></ul><h2 id="强制（Unit-5）"><a href="#强制（Unit-5）" class="headerlink" title="强制（Unit 5）"></a>强制（Unit 5）</h2><h3 id="ないではすまい・ずにはすまない"><a href="#ないではすまい・ずにはすまない" class="headerlink" title="ないではすまい・ずにはすまない"></a>ないではすまい・ずにはすまない</h3><ul><li>動詞ない形＋ないではすまい・ずにはすまない<br>常识上的强制。表示考虑到社会的常识、规则而必须要做。<br>常与：謝る等连用。<br>例：社会に謝まないではすまい。  </li></ul><h3 id="わけにはいかない"><a href="#わけにはいかない" class="headerlink" title="わけにはいかない"></a>わけにはいかない</h3><ul><li>動詞普通形＋わけにはいかない  </li></ul><ol><li>常识上的强制。表示心里面想做，但是因为社会的常识而必须不能做的事情。<br>例：あの人を殺すわけにはいかない。  </li><li>心理上的强制。表示因为内心抵触而不做的事情。<br>例：横島屋の倒産は三条さんに責任があると言わざるを得ない。  </li></ol><h3 id="ないではおかない"><a href="#ないではおかない" class="headerlink" title="ないではおかない"></a>ないではおかない</h3><ul><li>動詞ない形＋ないではおかない<br>心理上的强制。有一种强烈的愿望一定要做。<br>例：あのパン屋さんのケーキを買わないではおかない。  </li></ul><h3 id="禁じえない"><a href="#禁じえない" class="headerlink" title="禁じえない"></a>禁じえない</h3><ul><li>名詞＋禁じ得ない<br>【禁不住……】，心理上的强制。看到事物的样子，心中自然而然地就会产生无法压抑的情绪。<br>常与：怒り、涙、悲しみ　连用。<br>例：地震に破壊された建物を見ると、悲しみ禁じ得ない。  </li></ul><h3 id="ずにはいられない・ないではいられない"><a href="#ずにはいられない・ないではいられない" class="headerlink" title="ずにはいられない・ないではいられない"></a>ずにはいられない・ないではいられない</h3><ul><li>動詞ない形＋ずにはいられない・ないではいられない<br>心理上的强制。表示看到某种情况，身体上就不能自主地做出某种行为。<br>例：美味しそうなケーキを目の前にして、買わないではいられませんでした。  </li></ul><h3 id="ざるを得ない"><a href="#ざるを得ない" class="headerlink" title="ざるを得ない"></a>ざるを得ない</h3><ul><li>動詞ない形＋ざるをえない<br>外力的强制。心理想做，但由于不可避免地情况出现而不得不做。<br>常与：諦めない 连用。<br>例：悪天候が続ければ登頂は断念せざるを得ない。  </li></ul><h3 id="余儀なくされる"><a href="#余儀なくされる" class="headerlink" title="余儀なくされる"></a>余儀なくされる</h3><ul><li>名詞＋を余儀なくされる<br>外力的强制。表示因为外力的强大和个人的弱小而不得不做。<br>例：一人暮らしを余儀なくされる高齢者の数も増えてくるというわけである。（这导致不得不独居的空巢老人也在增加。）  </li></ul><h2 id="传闻·推测（Unit-6）"><a href="#传闻·推测（Unit-6）" class="headerlink" title="传闻·推测（Unit 6）"></a>传闻·推测（Unit 6）</h2><h3 id="ということで"><a href="#ということで" class="headerlink" title="ということで"></a>ということで</h3><ul><li>動詞普通形＋ということです  </li><li>動詞普通形＋とのことです[书]<br>【据说……/听说……】，表示前项的内容是一个传闻。とのことです是书面语。<br>例：かれは彼女がいるということです。  </li></ul><h3 id="とか"><a href="#とか" class="headerlink" title="とか"></a>とか</h3><ul><li>動詞普通形＋とか<br>【听说……】，与ということで相比，带有更加不确定的语气。常用于委婉的表达当中。<br>例：あの子は先生に怒られるとか。  </li></ul><h3 id="まい·まいか"><a href="#まい·まいか" class="headerlink" title="まい·まいか"></a>まい·まいか</h3><ul><li>動詞辞書形＋まい·まいか  </li><li>二・三グループ動詞ない形＋まい·まいか  </li><li>三グループ動詞の名詞＋すまい·まいか  </li><li>い形容詞～くある・名詞～ではある・な形容詞～ではある＋まい·まいか<br>【不会……吧】，是ない的变体，比动词未然形而言有不确定的语气。<br>まいか是一种委婉的表达。<br>例：横島屋は倒産すまい。  </li></ul><h3 id="恐れがある"><a href="#恐れがある" class="headerlink" title="恐れがある"></a>恐れがある</h3><ul><li>動詞普通形・名詞～の＋おそれがある<br>【恐怕会……】[正式]，用于描述可能会发生的不好的事情。常用于天气预报、报告书等正式的场合。<br>例：今日は大雪のおそれがあります。  </li></ul><h3 id="かねない"><a href="#かねない" class="headerlink" title="かねない"></a>かねない</h3><ul><li>動詞ます形＋かねない<br>【可能会导致……】，用于描述不好的结果。含有担心的情感。<br>例：ちょっとした間違いが命取りになりかねない。  </li></ul><h3 id="に違いない・に相違ない"><a href="#に違いない・に相違ない" class="headerlink" title="に違いない・に相違ない"></a>に違いない・に相違ない</h3><ul><li>動詞普通形・名詞・な形容詞・い形容詞＋に違いない・に相違<sup>そうい</sup>ない<br>【觉得一定是……】[正式]，表示说话人根据事实做出的肯定的判断。<br>例：この本は内容が豊富でおもしろい。きっと売れるに違いない。  </li></ul><h3 id="と見える"><a href="#と見える" class="headerlink" title="と見える"></a>と見える</h3><ul><li>動詞普通形・名詞・な形容詞・い形容詞＋と見える・と見えて<br>【看上去好像……】，前项是看到的事实，后项是基于前项的判断。也可以单独使用前项。<br>例：人類はよほど戦争が好きと見える。  </li></ul><h2 id="否定（Unit-7）"><a href="#否定（Unit-7）" class="headerlink" title="否定（Unit 7）"></a>否定（Unit 7）</h2><h3 id="ことなしに"><a href="#ことなしに" class="headerlink" title="ことなしに"></a>ことなしに</h3><ul><li>動詞辞書形・名詞（～とさせ）＋ことなしに<br>【没有做……，就做……】，表示在没有做前项事情的条件下，就进行了后项的行为。<br>例：委員会は詳しい調査を行うことなしに、早急に結論を出してしまった。</li></ul><h3 id="ことなく"><a href="#ことなく" class="headerlink" title="ことなく"></a>ことなく</h3><ul><li>動詞辞書形＋ことなく<br>【没有做……，而做……】[正式]，前项通常是日常会做的事情，后项是反常的事情。用于表达与日常不同的事情。<br>例：忙しいので、休日にも休むことなく、ずっど働きます。  </li></ul><h3 id="までもない"><a href="#までもない" class="headerlink" title="までもない"></a>までもない</h3><ul><li>動詞辞書形＋までもない<br>【没有必要做……】，表示不必要的行为。<br>例：誰も知っていることだから、今さら調べるまでもない。  </li></ul><h3 id="わけがない・はずがない"><a href="#わけがない・はずがない" class="headerlink" title="わけがない・はずがない"></a>わけがない・はずがない</h3><ul><li>動詞辞書形・い形容詞・な形容詞～な・名詞～の＋わけがない<br>【当然不能……】，表示说话人根据充足的客观事实推断所述事情不成立。<br>例：こんな難しい問題、解けるわけがない。  </li><li>動詞辞書形・い形容詞・な形容詞～な・名詞～の＋はずがない<br>【当然不可能……】，对可能形的否定。表示说话人主观判断事情没有发生的可能。<br>例：あの温厚な人がそんなひどいことをするはずがない。  </li></ul><h3 id="っこない"><a href="#っこない" class="headerlink" title="っこない"></a>っこない</h3><ul><li>動詞ます形＋っこない<br>【根本不可能……】[口]，表示对可能性的强烈否定。体现出说话人的主观判断。<br>例：そんなことは子供にできっこない。  </li></ul><h3 id="ものか"><a href="#ものか" class="headerlink" title="ものか"></a>ものか</h3><ul><li>動詞辞書形・い形容詞・な形容詞～な・名詞～の＋ものか<br>【绝不……】，表示对事实的强烈否定。体现说话人的排斥和拒绝。<br>例：あの店は店員の態度が悪すぎる。二度と行くものか。  </li></ul><h3 id="どころではない"><a href="#どころではない" class="headerlink" title="どころではない"></a>どころではない</h3><ul><li>動詞辞書形・名詞＋どころではない<br>【没有做……的时间/余地】[口]，表示没有做某事的时间或者余地。<br>例：忙しくて映画を見に行くどころではない。  </li></ul><h2 id="部分否定（Unit-8）"><a href="#部分否定（Unit-8）" class="headerlink" title="部分否定（Unit 8）"></a>部分否定（Unit 8）</h2><h3 id="ないものでもない・ないでもない"><a href="#ないものでもない・ないでもない" class="headerlink" title="ないものでもない・ないでもない"></a>ないものでもない・ないでもない</h3><ul><li>動詞ない形＋ないものでもない・ないでもない<br>【……也不是不可能的/也不是不可以】，是消极的表达。常常是针对说话人自己的事发表意见。<br>例：今から頑張って、合格できないものでもありません。  </li></ul><h3 id="ないこともない"><a href="#ないこともない" class="headerlink" title="ないこともない"></a>ないこともない</h3><ul><li>動詞ない形・名詞～で・な形容詞～で・い形容詞て形＋ないこともない<br>【也能……】，表示在某种条件下也能达成所述事物，通常是不能达成的。是消极的表达。<br>例：実際に読まないことには、この小説のおもしろさはわからないだろう。</li></ul><h3 id="というものではない"><a href="#というものではない" class="headerlink" title="というものではない"></a>というものではない</h3><ul><li>動詞普通形＋というものではない<br>表示按常理应当发生的事情，最终没有发生。<br>例：勉強すれば合格できるというものではない。  </li></ul><h3 id="わけではない"><a href="#わけではない" class="headerlink" title="わけではない"></a>わけではない</h3><ul><li>動詞普通形・な形容詞～な・名詞～の・い形容詞＋わけではない<br>【并不是只……】，表示某一个范围内的某个事物并不是完全占据了整个范围，还有其他的事物。<br>例：中澤先生も学生時代、勉強ばかりしていたわけだはない。  </li></ul><h3 id="ことは"><a href="#ことは" class="headerlink" title="ことは"></a>ことは</h3><ul><li>動詞普通形・い形容詞・な形容詞～な・名詞～な＋ことは＋同じ単語＋が・けど<br>【……是……了，但是……】，表示姑且承认所述的行为，但是后项的结果是预期的相反结果。<br>例：単語は覚えることは覚えるが、すっぐ忘れてしまいました。  </li></ul><h2 id="过程（Unit-9）"><a href="#过程（Unit-9）" class="headerlink" title="过程（Unit 9）"></a>过程（Unit 9）</h2><h3 id="っぱなし"><a href="#っぱなし" class="headerlink" title="っぱなし"></a>っぱなし</h3><ul><li>動詞ます形＋っぱなし<br>【一直……】/【放任不管……】，表示对象一直进行的动作或者状态。<br>例：電気は徹夜でつけっぱなし。  </li></ul><h3 id="にいたっては"><a href="#にいたっては" class="headerlink" title="にいたっては"></a>にいたっては</h3><ul><li>動詞辞書形・名詞＋に至っては<br>【甚至到了……的地步，以至于……】，表示过程到了一个极端的状态，并导致了后项的结果。<br>例：テレビ報道が過熱するに至っては、報道管制はできません。  </li></ul><h3 id="たところ"><a href="#たところ" class="headerlink" title="たところ"></a>たところ</h3><ul><li>動詞た形＋たところ<br>【刚……后就……】，表示在前项刚刚结束时就进行了后项的行为。<br>例：先生が行ったところ、教室は静かにしました。  </li></ul><h3 id="あげく・末に"><a href="#あげく・末に" class="headerlink" title="あげく・末に"></a>あげく・末に</h3><ul><li>動詞た形・名詞～の＋あげく<br>【最终……】，表示在经历了一个漫长的过程后得到了消极的结果。<br>例：抵抗したあげく、残った人たちは全部投降した。  </li><li>動詞た形・名詞～の＋末<sup>すえ</sup>に<br>【最终……】，表示在经历了一个漫长的过程后的得到了一个结果。结果既可以是消极的也可以是积极的。强调过程是漫长的。<br>例：勉強した末に、大学に採用された。　  </li></ul><h3 id="きりで"><a href="#きりで" class="headerlink" title="きりで"></a>きりで</h3><ul><li>動詞た形＋きりで<br>【……之后就一直……】，表示前项的状态结束后就一直持续后项的状态，后项是意料之外的状态。<br>例：忘年会であったきりで、彼を連絡取れなかった。  </li></ul><h2 id="结局（Unit-10）"><a href="#结局（Unit-10）" class="headerlink" title="结局（Unit 10）"></a>结局（Unit 10）</h2><h3 id="始末だ"><a href="#始末だ" class="headerlink" title="始末だ"></a>始末だ</h3><ul><li>動詞普通形・名詞～の・な形容詞～な・い形容詞＋始末だ<br>【到了……的地步】，表示经历了某种不好的事件，最后变成了更坏的结局（前项）。<br>常用表达：この始末，表示变成了这样不好的境地。<br>例：何度も注意しているのに遅刻するし、宿題も忘れる始末だ。  </li></ul><h3 id="に至る"><a href="#に至る" class="headerlink" title="に至る"></a>に至る</h3><ul><li>動詞辞書形・名詞＋に至る<br>【以至于……】[正式]，表示在经历了许多事情之后，变成了前项的程度、结果、范围。<br>例：彼女とは10年交際して結婚に至りました。  </li></ul><h3 id="まで"><a href="#まで" class="headerlink" title="まで"></a>まで</h3><ul><li>動詞た形＋までだ・（のことだ）<br>【只是……而已】，强调说话人没有别的意图。<br>例：近くまで来る用事あったから、ちょっと寄ったまでだ。（因为有事要到附近来，顺便去了一下而已。）  </li><li>動詞辞書形＋までだ・（のことだ）<br>【只能做……】，表示在没有其他办法的情况下做出的选择。用于陈述理由。<br>例：彼が言わないから、私が言うまでです。  </li></ul><h3 id="切る・抜く"><a href="#切る・抜く" class="headerlink" title="切る・抜く"></a>切る・抜く</h3><ul><li><p>動詞ます形＋きる<br>【完全/直到最后……】，表示将前项的动作彻底做完。强调“完全”。<br>例：練習はやりきりました。  </p></li><li><p>動詞ます形＋ぬく<br>【完全/直到最后……】，表示将前项动作彻底做完。前项动作是一个很困难的或者需要下功夫的事情。<br>例：考えぬいた結果、地元の大学に進学することにしました。  </p></li></ul><h3 id="次第だ"><a href="#次第だ" class="headerlink" title="次第だ"></a>次第だ</h3><ul><li>動詞普通形・名詞～の・な形容詞～な・い形容詞＋次第だ<br>【所以……】[正式]，表示成为了某种结果，用于表示理由、说明结果。<br>例：以上の理由で、御社の求人に応募する次第です。  </li></ul><h3 id="わけだ・ことになる"><a href="#わけだ・ことになる" class="headerlink" title="わけだ・ことになる"></a>わけだ・ことになる</h3><ul><li>動詞普通形・名詞～の・な形容詞～な＋わけだ  </li><li>動詞辞書形・動詞ない形・い形容詞＋ことになる<br>【理应就会……】，表示理所应当的结果。<br>例：運動すれば、瘦せられるわけです。  </li></ul><h3 id="ことになっている"><a href="#ことになっている" class="headerlink" title="ことになっている"></a>ことになっている</h3><ul><li>動詞辞書形・動詞ない形・い形容詞＋ことになっている<br>【就会……】[书]，用于表示约定、规则、习惯。<br>表示规则时多与许可或者禁止的表达连用。<br>例：国立大学は二回まで受けていいことになっています。   </li></ul><h3 id="ということだ"><a href="#ということだ" class="headerlink" title="ということだ"></a>ということだ</h3><ul><li>動詞普通形＋ということだ<br>【就是……的意思】，表示解释和说明。<br>例：「駐車禁止」ということは、車ををめてはいけないということです。  </li></ul><h3 id="ところだった"><a href="#ところだった" class="headerlink" title="ところだった"></a>ところだった</h3><ul><li>動詞辞書形・動詞ない形＋ところだった<br>【差点就变成了……】，表示差点就变成了某个结果，但是这个结果实际上并未发生。<br>例：朝雨ので、遅刻するところだった。  </li></ul><h3 id="っけ・たっけ"><a href="#っけ・たっけ" class="headerlink" title="っけ・たっけ"></a>っけ・たっけ</h3><ul><li>動詞普通形＋っけ・でしたっけ・ましたっけ<br>【好像是……吧】，用于说话人向对方确认某个内容，或者是自言自语表示自己确认某个内容。<br>例：彼の名前なんだっけ。  </li></ul><h2 id="让步·意外·转折（Unit-11）"><a href="#让步·意外·转折（Unit-11）" class="headerlink" title="让步·意外·转折（Unit 11）"></a>让步·意外·转折（Unit 11）</h2><h3 id="と思いきや"><a href="#と思いきや" class="headerlink" title="と思いきや"></a>と思いきや</h3><ul><li>動詞普通形＋と思いきや<br>【意外地】[口]，表示意外的情绪。前项为推测，后项为和推测不一样的结果。<br>例：不合格するかと思いきや、合格していました。  </li></ul><h3 id="ものを"><a href="#ものを" class="headerlink" title="ものを"></a>ものを</h3><ul><li>動詞普通形・な形容詞～な・名詞～の＋ものを<br>【要是……就……了】，不满现实未按照期待的方向发展。前句为想象的符合期望的行为，ものを之前为这个期望行为的结果。<br>例：覚えれば、この問題をとけたものを。  </li></ul><h3 id="ところ"><a href="#ところ" class="headerlink" title="ところ"></a>ところ</h3><ul><li>動詞普通形・な形容詞～な・名詞～の・い形容詞＋ところ<br>【虽然是……，却还是做了……】[正式]，前项通常是描述对方的情况，后项是和情况反常的行为。是站在对方立场上进行考虑的表达。常用于寒暄、感谢。<br>常与：忙しい、休み、足元の悪い等连用。<br>例：お忙しいところ、ご協力でいただきます。  </li></ul><h3 id="とはいえ"><a href="#とはいえ" class="headerlink" title="とはいえ"></a>とはいえ</h3><ul><li>動詞普通形・名詞＋とは言え<br>【也不完全是……/虽然说是……】，否定前项的一部分属性、印象，并说明实际情况，后项是说话人的主观意见和判断。<br>例：彼は劣等生とは言え、心は優しいです。  </li></ul><h3 id="いえとも"><a href="#いえとも" class="headerlink" title="いえとも"></a>いえとも</h3><ul><li>動詞普通形・名詞＋いえとも<br>【即使是……，也……】，提出一个极端的情况或者是身份，陈述和这个极端情况反常的事说明话题本身的反常。<br>例：この問題は、先生いえとも、解けられない。  </li></ul><h3 id="からといって"><a href="#からといって" class="headerlink" title="からといって"></a>からといって</h3><ul><li>動詞普通形＋からと言って<br>【作为……而言，却……】，表示从某个人的立场出发而做出不符合立场的反常行为。句末经常与というわけではない、とは限らない等部分否定的表达连用。后项多为批判、判断。<br>例：先生からと言って、賄賂を受けた。　 </li></ul><h3 id="といっても"><a href="#といっても" class="headerlink" title="といっても"></a>といっても</h3><ul><li>動詞普通形・名詞＋と言っても<br>【虽然说……，实际上是……】，前项为说话人推测的依据，后项为与推测相反的结果，多用于解释现在的情况。<br>例：先生と言っても、高級車を持ている。  </li></ul><h3 id="にしても・にしろ・にせよ"><a href="#にしても・にしろ・にせよ" class="headerlink" title="にしても・にしろ・にせよ"></a>にしても・にしろ・にせよ</h3><ul><li>動詞普通形・名詞～である・な形容詞～である＋にしても・にしろ  </li><li>動詞普通形・名詞～である・な形容詞～である＋にせよ [正式]<br>【即是……，但是也……】，表示难以接受的心情。后项为主观意见、判断、评价，多为否定。<br>例：若いにしても責任を免れるわけにはいかない。  </li></ul><h3 id="にもかかわらず"><a href="#にもかかわらず" class="headerlink" title="にもかかわらず"></a>にもかかわらず</h3><ul><li>動詞普通形・名詞（～である）・な形容詞（～である）＋にもかかわらず<br>【明明……，结果却是……】，表示根据前项的推测，后项的结果与推测的结果相反。强调吃惊、意外、不满。表示转折。<br>例：彼は、夏休み中にもかかわらず、毎日図書館で勉強している。  </li></ul><h3 id="ものの・ながら"><a href="#ものの・ながら" class="headerlink" title="ものの・ながら"></a>ものの・ながら</h3><ul><li>動詞普通形・名詞（～である）・な形容詞（～である）＋ものの　<br>【明明……，却……】，承认前项是事实，但是实际上与之关联的后项是无法按预想进行的，或者是与从前项的推断相反。<br>例：大学時代はフランス文学専攻だった。とはいうものの、フランス語はほとんどしゃべれない。  </li></ul><h3 id="つつ"><a href="#つつ" class="headerlink" title="つつ"></a>つつ</h3><ul><li>動詞ます形＋つつ<br>【虽然……，却……】，表示说话人后悔、表白、袒露真言的心情。前项常常是一个不好的事情。<br>例：母親は口では子どもを叱りつつも、心の中では子供がかわいくてたまらないのです。  </li></ul><h3 id="くせに・くせして"><a href="#くせに・くせして" class="headerlink" title="くせに・くせして"></a>くせに・くせして</h3><ul><li>動詞普通形・名詞～である/の・な形容詞～である/な＋くせに・くせして<br>【明明……，却……】，多用于人，强调谴责、蔑视对方、意外和不满的心情。<br>例：あいつ男のくせに、よく泣くよなぁ。　　  </li></ul><h3 id="ながら"><a href="#ながら" class="headerlink" title="ながら"></a>ながら</h3><ul><li>動詞ます形・い形容詞・名詞～でありの・な形容詞～であり/な＋ながら<br>【虽然……，却……】，表示转折，后项是与前项相反的事实。<br>例：狭いながらも楽しいわが家。  </li></ul><h2 id="举例（Unit-12）"><a href="#举例（Unit-12）" class="headerlink" title="举例（Unit 12）"></a>举例（Unit 12）</h2><h3 id="であれ・にしろ・にしても・にせよ"><a href="#であれ・にしろ・にしても・にせよ" class="headerlink" title="であれ・にしろ・にしても・にせよ"></a>であれ・にしろ・にしても・にせよ</h3><ul><li><p>名詞＋であれ<br>【不管是……，还是……】，表示例子都适用于后项。是复数的举例。<br>例：論文であれ、試験であれ、私立大学の問題は難しいです。  </p></li><li><p>動詞辞書形・名詞＋にしろ<br>【不管是……，还是……】，表示例子都适用于后项。是复数的举例。但是举例的前后两个例子是相反的例举。<br>例：東京の大学へ通うにしても、地方へ行くにしても、自分の好き環境を優先させて決めたいです。  </p></li><li><p>動詞辞書形・名詞・な形容詞・い形容詞＋にしても・にせよ<br>【不管是……，还是……】，表示例子都适用于后项。是复数的举例。但是举例的前后两个例子是相反的例举。<br>例：好きにせよ嫌いにせよ、彼女が優れた歌手であることはみんなが認めている。  </p></li></ul><h3 id="といわず"><a href="#といわず" class="headerlink" title="といわず"></a>といわず</h3><ul><li>名詞＋といわず<br>【不管是……，还是……】，举例的事物是同一范围内的。或者是同一事物的两个部分。<br>例：子供たちは手といわず足といわず全身砂だらけだ。  </li></ul><h3 id="といい"><a href="#といい" class="headerlink" title="といい"></a>といい</h3><ul><li>名詞＋といい<br>【无论……也好，还是……也好】，对同一个话题的多个部分进行举例。表示无论从那个方面看都是相同的属性。后项是说话人的主观判断。<br>例：あの店の服は、品質といい、デザインといい、申し分ない。  </li></ul><h3 id="なり"><a href="#なり" class="headerlink" title="なり"></a>なり</h3><ul><li>動詞辞書形・名詞＋なり<br>【……或者……】，用于两个并列的举例。常用于建议。不能对上级使用。不能用过去式。<br>例：書面でなり口頭でなり申し込むこと</li></ul><h3 id="やら"><a href="#やら" class="headerlink" title="やら"></a>やら</h3><ul><li>動詞普通形・い形容詞・名詞＋やら<br>【……呀，……呀之类的】，表示从同类事物中选取一个两个具有代表性的事物作为例子举出。或者其他的暂未想到。多用于描述不好的事情。<br>例：最近、勉強やらバイトやらで毎日忙しい。  </li></ul><h3 id="とか・や・など"><a href="#とか・や・など" class="headerlink" title="とか・や・など"></a>とか・や・など</h3><ul><li>動詞普通形・名詞＋とか・や・等<br>【……呀，……呀之类的】，用于同类型的举例，但是暗含有还有其他例子之意。<br>例：梅とか桃とか桜とか、いろいろな花があった。<br>例：その事は国会等で問題になった。（不只是在国会，在其他机关也成为了问题）  </li></ul>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
      <category>樱花教材</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日语</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九级别语法</title>
    <link href="/2021/07/27/%E6%97%A5%E8%AF%AD/%E6%A8%B1%E8%8A%B1%E6%95%99%E6%9D%90/%E4%B9%9D%E7%BA%A7%E5%88%AB/"/>
    <url>/2021/07/27/%E6%97%A5%E8%AF%AD/%E6%A8%B1%E8%8A%B1%E6%95%99%E6%9D%90/%E4%B9%9D%E7%BA%A7%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="九级别语法"><a href="#九级别语法" class="headerlink" title="九级别语法"></a>九级别语法</h1><h2 id="假定（Unit-1）"><a href="#假定（Unit-1）" class="headerlink" title="假定（Unit 1）"></a>假定（Unit 1）</h2><h3 id="さえ"><a href="#さえ" class="headerlink" title="さえ"></a>さえ</h3><ul><li>名詞・な形容詞～で・い形容詞～く＋さえあれば  </li><li>動詞ます形＋さえすれば<br>【如果……了的话，就会……】，表示条件假设<br>例：私は家庭さえあれば、幸せです。  <h3 id="としたら"><a href="#としたら" class="headerlink" title="としたら"></a>としたら</h3></li><li>普通形＋としたら<br>【如果……了的话，就会……】，和さえ相同。<br>后面既可以跟主观意见，也可以是客观的事情<br>例：お金持ちになれるとしたら、世界旅行に行きます。</li><li>普通形＋とすれば<br>后面跟主观的评价、判断<br>例：アンドロイドが人間に代わりなるとしたら、世界は終わるかもしれません。</li><li>普通形＋とすると<br>后面跟客观的，自然发生的事件<br>例：飛行機が五時間ほど遅くなるとすると、到着するのは明日の朝になるな。  </li></ul><h3 id="ないには"><a href="#ないには" class="headerlink" title="ないには"></a>ないには</h3><ul><li>名詞～で＋ないには  </li><li>動詞ない形＋ないことには<br>【如果不……就不会……】，后面通常跟可能性的否定：られない，不能用意志形。<br>例：資格外活動許可証がないには、アルバイトができない。  </li></ul><h3 id="ものなら"><a href="#ものなら" class="headerlink" title="ものなら"></a>ものなら</h3><ul><li><p>可能動詞、変化動詞辞書形＋ものなら<br>【如果能……，就……】，后项常常表示期待和愿望，但是通常有无法实现之意。<br>例：あんな悲しい思い出、忘れるものなら、早く忘れたい。  </p></li><li><p>名詞・動詞意向形＋ものなら<br>【如果……，就……】，描述如果前项发生的话，就会导致后项灾难性的结果。强调说话人担心和恐惧的心情。<br>例：あの二人が会おうものなら、殺し合いが始まる。  </p></li><li><p>動詞可能形＋ものなら<br>【如果能……，就……】，描述如果能够达成前项，就能够完成后项。强调说话人内心的愿望。<br>例：国に帰れるものなら、帰りたい。  </p></li></ul><h3 id="が最後、たら最後"><a href="#が最後、たら最後" class="headerlink" title="が最後、たら最後"></a>が最後、たら最後</h3><ul><li>動詞ます形＋が最後、たら最後<br>【如果……，就……】，描述如果能够达成前项，就会导致灾难性的后果。强调客观的事实。比ものなら的确信度更高。<br>例：海外で財布を失くしたら最後、絶対戻ってこない。  </li></ul><h3 id="抜きにしては"><a href="#抜きにしては" class="headerlink" title="抜きにしては"></a>抜きにしては　　</h3><ul><li>名詞＋抜きにしては<br>【如果没有……的话，……就难以实现】，以前项为前提，强调如果没有前项的话后项难以实现。<br>例：先生のご指導抜きにしては、試験が合格できない。  </li></ul><h3 id="とあれば"><a href="#とあれば" class="headerlink" title="とあれば"></a>とあれば</h3><ul><li>名詞・動詞辞書形＋とあれば　<br>【如果是……的话，……就能接受】，前项如果发生的话，后项所发生的结果就可以被接受、是合乎情理的。<br>例：病気になるとあれば、欠勤もやむを得ない。  </li></ul><h2 id="评价（Unit-2）"><a href="#评价（Unit-2）" class="headerlink" title="评价（Unit 2）"></a>评价（Unit 2）</h2><h3 id="割りに"><a href="#割りに" class="headerlink" title="割りに"></a>割りに</h3><ul><li>名詞～の・動詞普通形・い形容詞普通形・な形容詞～な＋割りに<br>【……，然而是……】，表示后项的结果不符合前项事物发展的规律，或者和预想完全不一样。用于与想象/常识相反的事实评价。可以对自己使用。<br>例：彼は勉強した割りに、成績が全然悪い。</li></ul><h3 id="にしては"><a href="#にしては" class="headerlink" title="にしては"></a>にしては</h3><ul><li>名詞～の・動詞普通形＋にしては<br>【……，然而是……】，意思同割りに。带有说话人怀疑的语气。不能用于评价自己的事物。<br>例：彼は日本人にしては、漢字が読めない。（有怀疑是否是日本人的语气）<blockquote><p>前面不能为表示程度的名词（比如高さ、長さ），也不能为形容词。  </p></blockquote></li></ul><h3 id="向く"><a href="#向く" class="headerlink" title="向く"></a>向く</h3><ul><li>名詞＋向けの・向きに<br>【面向……的】，向け通常表示事物最初的使用目标对象，向き表示事物适合于的对象。<br>例：この本は子供向けだたか、日本語を勉強している外国人向きでもある。  </li></ul><h3 id="ともなると"><a href="#ともなると" class="headerlink" title="ともなると"></a>ともなると</h3><ul><li>名詞＋ともなると<br>【进入到……后，变得……】，表示进入到前项的阶段后，后项就会理所应当的发生。后项是自然而然的结果。<br>例：結婚ともなると、二人の問題は家族の問題になりました。  </li></ul><h3 id="ともあろ"><a href="#ともあろ" class="headerlink" title="ともあろ"></a>ともあろ</h3><ul><li>名詞＋ともあろ人・団体・会社・組織<br>【原本是……，然而……】，表示后项的行为与前项的身份不符合。带有批评的语气。<br>例：警察官ともあろ人が、ヤクザに繋がる。  </li></ul><h3 id="まじき"><a href="#まじき" class="headerlink" title="まじき"></a>まじき</h3><ul><li>動詞辞書形＋まじき＋名詞<br>【绝对不……】，描述绝对不能允许的行为。通常有固定搭配あるまじき、許すまじき。<br>例：轢<sup>ひ</sup>き逃げ（肇事逃逸）するなんで、許すまじき行為だ。  </li></ul><h3 id="に足る"><a href="#に足る" class="headerlink" title="に足る"></a>に足る</h3><ul><li>動詞辞書形＋に足る<br>【值得/足以……】，表示对前项事情的评价。<br>例：危険をかえりみず乗客の生命を救った彼の行為は、称賛に足るものだ。  </li></ul><h3 id="にたえる"><a href="#にたえる" class="headerlink" title="にたえる"></a>にたえる</h3><ul><li>動詞辞書形・名詞＋にたえる<br>【值得……】，表示前项的某事、某物具有一定的价值。<br>例：最近のCDは品質がよく、厳しい音楽家の耳にも十分にたえるだろう。  </li></ul><h2 id="陈述理由，原因（Unit-3-4）"><a href="#陈述理由，原因（Unit-3-4）" class="headerlink" title="陈述理由，原因（Unit 3,4）"></a>陈述理由，原因（Unit 3,4）</h2><h3 id="こととて"><a href="#こととて" class="headerlink" title="こととて"></a>こととて</h3><ul><li>動詞普通形・名詞＋の＋こととて<br>【由于……】[正式]，通常用于陈述道歉的理由。是正式的表达。<br>例：材料が足りないこととて、販売中止してございます。　　</li></ul><h3 id="とあって"><a href="#とあって" class="headerlink" title="とあって"></a>とあって</h3><ul><li>名詞・動詞辞書形＋とあって　<br>表示前项已经发生了十分特殊的情况，后项因此发生了。<br>例：ボーナス後の週末とあって、デパートはすごい人出だ。  </li></ul><h3 id="故に"><a href="#故に" class="headerlink" title="故に"></a>故に</h3><ul><li>名詞・動詞普通形＋故<sup>ゆえ</sup>に<br>【由于……】[书]，后项通常是常识、真理。多用于新闻报道，论文中。<br>例：日本は島国故に、四季が分明です。  </li></ul><h3 id="ことから"><a href="#ことから" class="headerlink" title="ことから"></a>ことから</h3><ul><li>名詞・動詞普通形＋ことから<br>【由于……】，表示基于事实的理由、判断。前项是事实。<br>例：現場に残った指紋か一致したことから、彼は犯人を特定された。</li></ul><h3 id="からこそ"><a href="#からこそ" class="headerlink" title="からこそ"></a>からこそ</h3><ul><li>名詞・動詞普通形＋からこそ<br>【正是因为……】，强调前项的条件，后项一般是积极的结果。<br>例：あの時期苦労したからこそ、今幸せな生活があるのです。  </li></ul><h3 id="につき"><a href="#につき" class="headerlink" title="につき"></a>につき</h3><ul><li>名詞＋につき<br>【由于……】[书]，用于通知和看板表示原因。<br>例：業務拡大につき、解放碑<sup>ひ</sup>で新しい支店を開けます。  </li></ul><h3 id="おかけで"><a href="#おかけで" class="headerlink" title="おかけで"></a>おかけで</h3><ul><li>名詞＋お掛けで<br>【多亏了……】，常用于表示感激，也可以用于挖苦。<br>例：先生のお掛けで、病気がすぐ治りました。（感激）<br>例：貴様のお掛けで、働き時間が長くにしました。（挖苦）  </li></ul><h3 id="せいで"><a href="#せいで" class="headerlink" title="せいで"></a>せいで</h3><ul><li>名詞～の・動詞普通形＋せいで<br>【都怪……】，用于描述不好的事情。<br>例：寝坊したせいで、遅刻した。  </li></ul><h3 id="ものですから"><a href="#ものですから" class="headerlink" title="ものですから"></a>ものですから</h3><ul><li>名詞～の・動詞普通形＋ものですから・もので・ものでして<br>【因为……】[正式]，用于在道歉时描述不好的事情的原因，有迫不得已，无法避免的含义。<br>例：人身事故か起きたものですから、遅刻したの件がすみませんでした。  </li></ul><h3 id="ばかりに"><a href="#ばかりに" class="headerlink" title="ばかりに"></a>ばかりに</h3><ul><li>動詞普通形＋ばかりに　<br>【明明……】，表示做了前项的事情，但是没有得到理应的结果。<br>例：ちゃんと告白したばかりに、彼女は他の人と付き合いました。  </li></ul><h3 id="だけに"><a href="#だけに" class="headerlink" title="だけに"></a>だけに</h3><ul><li>名詞・い形容詞・な形容詞～な・動詞普通形＋だけに<br>【由于……】，陈述客观原因，含有惊叹的语气。<br>例：故宮<sup>こきゅう</sup>は広いだけに、一日だけは参れません。  </li></ul><h3 id="だけあって"><a href="#だけあって" class="headerlink" title="だけあって"></a>だけあって</h3><ul><li>動詞普通形＋だけあって<br>【由于……】，后接理所应当的结果。<br>例：海外で育たちだけあって、英語がペラペラで喋ってきます。  </li></ul><h3 id="あまりに"><a href="#あまりに" class="headerlink" title="あまりに"></a>あまりに</h3><ul><li>い形容詞・動詞普通形・名詞～の＋あまりに<br>【由于太……了】，表示前项超出了应有的范围而导致后项的结果出现。<br>例：緊張するあまりに、頭中の内容は全部忘れでしまいました。  </li></ul><h3 id="こそ"><a href="#こそ" class="headerlink" title="こそ"></a>こそ</h3><ul><li>名詞＋であればこそ・がいればこそ<br>【只有……，才能……】，强调前项理由的唯一性。多用于好的评价上。<br>例：皆は社会に奉献の気持ちにあれば、未来が光れる。  </li></ul><h2 id="既然（Unit-5）"><a href="#既然（Unit-5）" class="headerlink" title="既然（Unit 5）"></a>既然（Unit 5）</h2><h3 id="以上、上は"><a href="#以上、上は" class="headerlink" title="以上、上は"></a>以上、上は</h3><ul><li>動詞普通形＋以上<br>【既然/鉴于……】，后面跟说话者的判断或者是命令。<br>例：この件は君に担当である以上、責任をとってください。（命令）<br>例：お金がない以上、買わないべきです。（判断）  </li><li>動詞普通形＋上<sup>うえ</sup>は<br>【既然/鉴于……】[书]，后面跟说话者的决定，日常上不常用。<br>例：相手を倒すと決めた上は、全力で戦かいます。  </li></ul><h3 id="からには"><a href="#からには" class="headerlink" title="からには"></a>からには</h3><ul><li>動詞普通形＋からには<br>【既然/鉴于……】，后面跟说话人的推测或者是对对方的义务进行描述。<br>例：やったからには、最後までやろう。  </li></ul><h3 id="ことだから"><a href="#ことだから" class="headerlink" title="ことだから"></a>ことだから</h3><ul><li>名詞（名前・身元・人）＋のことだから<br>【既然是……，那……也……】，主语名詞（名前・身元）是现在对话中双方都熟悉的人。表示后项的事情是符合主语的特征的。<br>例：山田さんはいつもゆらゆらですね。彼のことだから、遅刻するかもしれません。  </li></ul><h3 id="ところを見ると"><a href="#ところを見ると" class="headerlink" title="ところを見ると"></a>ところを見ると</h3><ul><li>動詞て形＋ているところを見ると<br>表示根据看到的事实进行的判断。<br>例：彼の憂鬱<sup>ゆううつ</sup>な顔をしているところをみると、きっとテストをやってきませんね。  </li></ul><h3 id="あるまいし"><a href="#あるまいし" class="headerlink" title="あるまいし"></a>あるまいし</h3><ul><li>名詞（名前・身元・人）＋じゃ・では＋あるまいし<br>【又不是……，……】，表示对方的行为不符合某种身份。通常用于忠告。描述坏的事情。<br>例：子供じゃあるまいし、めとめそ（抽泣）泣<sup>な</sup>くな。  </li></ul><h2 id="倾向（Unit-6）"><a href="#倾向（Unit-6）" class="headerlink" title="倾向（Unit 6）"></a>倾向（Unit 6）</h2><h3 id="嫌いがある"><a href="#嫌いがある" class="headerlink" title="嫌いがある"></a>嫌いがある</h3><ul><li>動詞辞書形・動詞ない形・名詞～の＋嫌いがある<br>【……不太好】，表示前项这件事有着不好的倾向。对不好的事情呈批评的态度。不能用于自然现象和发生次数多的事件上。<br>例：彼女は人の言葉を安く信じる嫌いがある。</li></ul><h3 id="まみれ・だらけ"><a href="#まみれ・だらけ" class="headerlink" title="まみれ・だらけ"></a>まみれ・だらけ</h3><ul><li>名詞＋まみれ<br>【一身都是……】，表示令人不快的物体弄得全身都是。<br>例：油まみれ、泥まみれ  </li><li>名詞＋だらけ<br>【到处都是……】，表示令人不快的物体附着在物体表面。<br>例：ゴミだらけ  </li></ul><h3 id="ずくめ"><a href="#ずくめ" class="headerlink" title="ずくめ"></a>ずくめ</h3><ul><li>名詞＋ずくめ<br>【全……】，表示全部都是某种状态。<br>例：工藤新一は黒ずくめの男たちに小さくされてしまった。  </li></ul><h3 id="めく"><a href="#めく" class="headerlink" title="めく"></a>めく</h3><ul><li>名詞＋めく<br>【没有完全、但是也有……的感觉】<br>例：春めく、謎めく  </li></ul><h3 id="がち"><a href="#がち" class="headerlink" title="がち"></a>がち</h3><ul><li>動詞ます形・名詞＋がち<br>【容易……】，表示有容易进入某种状态的倾向。多用于不好的事情。<br>例：社会人になると、運動不足にありがちだから、とても心配です。  </li></ul><h3 id="ぽい"><a href="#ぽい" class="headerlink" title="ぽい"></a>ぽい</h3><ul><li>名詞・い形容詞～<del>い</del>+っぽい<br>【有……的感觉】，表示感觉具有另一种事物的本质特性。<br>例：男っぽい</li><li>名詞＋っぽい<br>表示大量的含有某种液体。<br>例：水っぽい</li><li>動詞ます形＋っぽい<br>【容易……的】，形容人的性格。<br>例：忘れっぽい</li></ul><h3 id="気味"><a href="#気味" class="headerlink" title="気味"></a>気味</h3><ul><li>動詞ます形・名詞＋気味<br>【多少有一点……的样子】，程度不深，多用于不好的事情。<br>例：風邪気味で最近、調子が悪い。  </li></ul><h2 id="事情完成的可能（Unit-7）"><a href="#事情完成的可能（Unit-7）" class="headerlink" title="事情完成的可能（Unit 7）"></a>事情完成的可能（Unit 7）</h2><h3 id="がたい"><a href="#がたい" class="headerlink" title="がたい"></a>がたい</h3><ul><li>動詞ます形・名詞＋がたい<br>【难以……】，表示由于心理方面的主观因素而难以做某事。<br>例：テロリストに攻撃されたなんで、信じがたい。　 </li></ul><h3 id="兼ねる"><a href="#兼ねる" class="headerlink" title="兼ねる"></a>兼ねる</h3><ul><li>動詞ます形＋かねる<br>【难以……】</li></ul><ol><li>因为情绪上抵触而不能做。  </li><li>[正式]由于公司的规章制度等不能办到。<br>例：会社のルールありかねますので、このお金、私は受けられない。  </li></ol><h3 id="はけにはいけない"><a href="#はけにはいけない" class="headerlink" title="はけにはいけない"></a>はけにはいけない</h3><ul><li>動詞辞書形＋はけにはいけない<br>【难以……】，表示因为常识性的原因而不能做。<br>例：受験する前に遊ぶわけにはいけません。  </li></ul><h3 id="ようがない"><a href="#ようがない" class="headerlink" title="ようがない"></a>ようがない</h3><ul><li>動詞ます形＋ようがない<br>【想去尝试，但不能……】，表示有想要尝试做的意愿，但是由于条件的不允许而不能做。<br>例：世界旅行へ行きようがない。（虽然想去，但由于各种时间、金钱等而不能去旅行。）  </li></ul><h3 id="得る"><a href="#得る" class="headerlink" title="得る"></a>得る</h3><ul><li>動詞ます形＋得る<br>【有可能做到……】  </li><li>動詞ます形＋得ない<br>【没有可能做到……】<br>例：これははたしが合格し得る最高の大学です。  </li></ul><h3 id="ようがない-1"><a href="#ようがない-1" class="headerlink" title="ようがない"></a>ようがない</h3><ul><li>動詞ます形＋ように＋同じ動詞のます形＋ようがない<br>【想做……但不能做……】，表示消极的、不可能做到的愿望。<br>例：京大に合格しように合格しようがありますせん。  </li></ul><h3 id="に難くない"><a href="#に難くない" class="headerlink" title="に難くない"></a>に難くない</h3><ul><li>名詞＋にかたくない<br>【不难做到……】，前面所说的事情是心理因素。表示从现实考虑不难做到。<br>例：想像にかたくない。  </li></ul><h2 id="假定转折（Unit-8）"><a href="#假定转折（Unit-8）" class="headerlink" title="假定转折（Unit 8）"></a>假定转折（Unit 8）</h2><h3 id="たとえ"><a href="#たとえ" class="headerlink" title="たとえ"></a>たとえ</h3><ul><li>たとえ＋動詞て形＋ても<br>【即使/就算……，也……】，假定前项发生了，也不考虑后项。<br>例：たとえお腹が空いても、他の人からの食べ物を受けません。  </li></ul><h3 id="ところで"><a href="#ところで" class="headerlink" title="ところで"></a>ところで</h3><ul><li>動詞た形＋ところで<br>【即便是……，也……】，假定前项发生，也无法满足后项的预期结果。后项是不可能完成的状况。后项不能用过去式。<br>例：頑張したところで、合格できない。  </li></ul><h3 id="としても"><a href="#としても" class="headerlink" title="としても"></a>としても</h3><ul><li>動詞普通形＋としても<br>【就算是……，也……】，现在不能达成某种结果，但是即使是这样也没有关系，也当做结果达成的状态进行后项。后项为程度比较低的事情，与前项有相反性。<br>例：叶わぬ恋だとしても、自分の気持ちを伝えたいです。  </li></ul><h3 id="にしろ"><a href="#にしろ" class="headerlink" title="にしろ"></a>にしろ</h3><ul><li>い形容詞・動詞普通形・な形容詞～である・名詞～である＋にしろ<br>【即使……】[口]，即是是前项那样，也不会影响到后项。后面跟主观的评价、判断、责备。后项常常是坏的。<br>常用：いずれにしろ  </li><li>A にしろ　B にしろ<br>【无论是……，还是……，都……】，是举例无论是A还是B都对后项不会有影响，后项常常是负面的、否定的用法。A和B的接续同单独的にしろ。<br>例：結果は失敗するにしろ、何もしないで諦めるは嫌いです。  </li></ul><h3 id="といえども"><a href="#といえども" class="headerlink" title="といえども"></a>といえども</h3><ul><li>名詞・動詞普通形＋といえども<br>【即使……】[正式]，即便是发生了前项的极端情况、立场、人物身份，后项也会进行。后项的结果与前项相反。<br>例：失恋といえども、自分を成長させてくれるはずです。（情况）<br>例：警察といえども、被害者の身元をはんめいできない。（人物身份）  </li></ul><h3 id="であれ"><a href="#であれ" class="headerlink" title="であれ"></a>であれ</h3><ul><li>名詞＋であれ<br>【不论……，也……】，不管前项如何，都与后项无关。用于举例，举例说明在……的情况下都不能做的事情。后面常常跟主观的判断、表现。<br>例：どんな結果であれ、自分の気持ちを伝えたいです。  </li></ul><h3 id="ようが"><a href="#ようが" class="headerlink" title="ようが"></a>ようが</h3><ul><li><p>意向形＋ようが＋動詞意向形＋ようが<br>【不论是不是……，也……】，后项是与前项相似的，或者相对的事物。  </p><blockquote><p>此处可以是動詞、い形容詞（～かろう）・な形容詞（～だろう）・名詞（～だろう）的意向形。  </p></blockquote><p>例：嫌われようが、笑われようが、はたし気になっていません。  </p></li></ul><h3 id="がまいが"><a href="#がまいが" class="headerlink" title="がまいが"></a>がまいが</h3><ul><li><p>動詞意向形＋が＋動詞辞書形＋まいが<br>【不论……，也……】，不管前项是否成立，后项都成立。与ようが不同的是，前后项必须对立。  </p><blockquote><p>する→しまい・するまい・すまい　来る→くるまい・こまい</p></blockquote><p>例：相手はいこうが来るまいが、はたしはここで待っています。  </p></li></ul><h2 id="关联（Unit-9）"><a href="#关联（Unit-9）" class="headerlink" title="关联（Unit 9）"></a>关联（Unit 9）</h2><h3 id="如何で"><a href="#如何で" class="headerlink" title="如何で"></a>如何で</h3><ul><li><p>名詞～の＋如何で<br>【依照……，来……】[正式]，表示根据前项的变化来做出后项对应的反应。<br>例：首都圏内新カタログの感染規模の如何で、五輪の観衆数を決めてます。  </p></li><li><p>名詞～の＋如何では<br>【依照……，来……】[正式]，比名詞～の＋如何で的用法来说，后项通常是更加具有对立性的事件。<br>例：首都圏内新カタログの感染規模の如何で、五輪は中止するかもしれません。  </p></li></ul><h3 id="によって"><a href="#によって" class="headerlink" title="によって"></a>によって</h3><ul><li>名詞＋によって<br>【依据……的不同，而……】，表示依据前面的标准来划分，依据前项的不同而后项不同。<br>例：センター試験の成績によって、学校が振り分けられます。</li><li>名詞＋によっては<br>【在……情况下，而……】，表示依据前面的主题，后项为前项条件下的多个可能发生的事件。<br>例：大学によっては、社会ではなく、数学でも受験できます。  </li></ul><h3 id="次第で"><a href="#次第で" class="headerlink" title="次第で"></a>次第で</h3><ul><li>名詞＋次第で<br>【依据……，有可能会……】，表示依据前项的变化而导致后项有出现的可能性。  </li><li>名詞＋次第では<br>[口]，前者的口语化表达。<br>例：能力次第で、給料は高すぎることができます。  </li></ul><h3 id="応じて"><a href="#応じて" class="headerlink" title="応じて"></a>応じて</h3><ul><li>名詞＋おうじて<br>【与……相对应地，……】，表示后项的行为与前项相呼应。<br>例：自分の興味応じて、専門を選ぶ。  </li></ul><h3 id="たびに"><a href="#たびに" class="headerlink" title="たびに"></a>たびに</h3><ul><li>動詞辞書形・名詞～の＋たびに<br>表示每次前项的事情发生，后项的事情也会发生。<br>例：雨降るたびに、たくさんの生徒は遅刻する。  </li></ul><h3 id="にっけても"><a href="#にっけても" class="headerlink" title="にっけても"></a>にっけても</h3><ul><li>動詞辞書形＋にっけても<br>处于同一情况下的时候，总会带着某种心情做某事。<br>例：中村は何事にっけても、一生懸命にやる人ですね。  </li></ul><h3 id="きっかけに"><a href="#きっかけに" class="headerlink" title="きっかけに"></a>きっかけに</h3><ul><li>名詞＋をきっかけに<br>【以……为契机】，表示以前项的事情为契机，开始做后项的事情。<br>例：彼は国会議事堂前の講演をきっかけに、革命活動をやります。  </li></ul><h2 id="例外·不论（Unit-10）"><a href="#例外·不论（Unit-10）" class="headerlink" title="例外·不论（Unit 10）"></a>例外·不论（Unit 10）</h2><h3 id="如何に"><a href="#如何に" class="headerlink" title="如何に"></a>如何に</h3><ul><li>名詞（～の）＋いかんによらず・いかんにかかわらず・いかんを聞<sup>と</sup>わず<br>【与……没有关系/不论……】，表示后项在前项不管是怎么样子的前提下都能够进行。常用于说教。是一种老旧的说话方式。<br>常与：目的、理由连用。<br>例：目的のいかんによらず、そのやり方は違反行為です。   </li></ul><h3 id="にかかわらず"><a href="#にかかわらず" class="headerlink" title="にかかわらず"></a>にかかわらず</h3><ul><li>名詞＋にかかわらず・に（は）かかわりなく<br>【不管……】，表示后项在前项不管是什么样子的前提下都保持某种状态。后接种类、程度。<br>例：この店は曜日にかかわらず、いつも空いています。  </li></ul><h3 id="いざしらず"><a href="#いざしらず" class="headerlink" title="いざしらず"></a>いざしらず</h3><ul><li>名詞～は・なら・だったら＋いざしらず  </li><li>動詞普通形～なら・い形容詞～なら・な形容詞～なら＋いざしらず<br>【暂且不论……】，表示先不考虑前项，以后项为话题进行陈述。前项为不知道的问题，后项为已知的问题。<br>例：遅刻したならいざしらず、宿題を全部で間違ってしたのは、どうゆうことですか。  </li></ul><h3 id="よそに"><a href="#よそに" class="headerlink" title="よそに"></a>よそに</h3><ul><li>名詞＋をよそに<br>【不顾……】，贬义。表示对前项的事情漠不关心的态度来进行后项。<br>例：両親の心配をよそに、彼は遊んでばかりいます。  </li></ul><h3 id="ものともせず"><a href="#ものともせず" class="headerlink" title="ものともせず"></a>ものともせず</h3><ul><li>名詞＋をものともせず<br>【不顾……】，褒义。前项通常是已知的问题、困难。用于称赞他人，不能对自己使用。<br>例：自分の命をものともせず、彼は火事に数人を助けた。  </li></ul><h3 id="もかまわず"><a href="#もかまわず" class="headerlink" title="もかまわず"></a>もかまわず</h3><ul><li>名詞・な形容詞～な・動詞普通形・い形容詞＋もかまわず<br>【不在乎……】，表示不在乎前项的事情来做后项，前项通常是平常会在意的事情。<br>例：人目もかまわず、電車の中で化粧している女子高生をよく見かけます。  </li></ul><h3 id="ともかく"><a href="#ともかく" class="headerlink" title="ともかく"></a>ともかく</h3><ul><li>名詞＋はともかく（として）<br>【虽然……是不得不考虑的，但是当下应当优先考虑……】，表示在前项和后项的问题中进行对比后选择做后项。前后两项都是不得不考虑的事情，后项更紧急。<br>例：近くの便利さはともかく、家賃は耐えられません。  </li></ul><h3 id="さておき"><a href="#さておき" class="headerlink" title="さておき"></a>さておき</h3><ul><li>名詞＋はさておき<br>【先不考虑……，更理应考虑……】，表示先不考虑前项，后项的事情更为重要。<br>例：勉強はさておき、体の回復するのが先決です。  </li></ul><h2 id="程度强调（Unit-11）"><a href="#程度强调（Unit-11）" class="headerlink" title="程度强调（Unit 11）"></a>程度强调（Unit 11）</h2><h3 id="からある・からする・からの"><a href="#からある・からする・からの" class="headerlink" title="からある・からする・からの"></a>からある・からする・からの</h3><ul><li>程度を表示する名詞・量詞＋からある  </li><li>人数＋からの  </li><li>価額＋からする<br>【超过……以上】，强调数量之多、长度之长、人数之多、价格之高等等。总之就是强调前项名词的上限。<br>与「以上」・「以上ある」用法相同。<br>例：開店日は八万人からのお客様が来店しました。  </li></ul><h3 id="というもの"><a href="#というもの" class="headerlink" title="というもの"></a>というもの</h3><ul><li>動詞普通形・名詞～の・な形容詞～な＋というもの<br>【真是这么……啊】，强调说话人的感想，后项为说话人的判断或者是批判。<br>例：彼女が愛国の心を持っていないというものはきっと世間に批判されるよう。  </li><li>時間を表示する名詞＋というもの<br>【……这么长】，强调时间非常的长。<br>例：ここ一ヶ月というもの、仕事に追われて全く余裕がない。</li><li>動詞普通形＋というものではない<br>【不完全是……】，同「とは言えない」。<br>例：お金があれば幸せになれるというものではない。  </li></ul><h3 id="にして"><a href="#にして" class="headerlink" title="にして"></a>にして</h3><ul><li>名詞＋にして<br>【到……的程度才能/就连……的程度都不能】，两种意思取决于后项是否为否定。强调到达一定高的程度才能或者是都不能做。<br>例：アインシュタインさんみたいなに物理学者して量子論に関する問題を解けできるね。（正向的程度：只有像爱因斯坦那样的物理学家才能把量子物理学相关的问题解开。）<br>例：この問題は、先生にして解けないはずです。（反向的程度：这道题就连老师也解不出来。）  </li></ul><h3 id="あっての"><a href="#あっての" class="headerlink" title="あっての"></a>あっての</h3><ul><li>名詞１＋あっての＋名詞２  </li><li>名詞＋あっての….<br>【只有……才能有……】，表示只有前项（名词1）存在，后项（名词2）才可能成立。<br>例：両親あっての私です。</li></ul><h3 id="極まる・極まりない・の極み"><a href="#極まる・極まりない・の極み" class="headerlink" title="極まる・極まりない・の極み"></a>極まる・極まりない・の極み</h3><ul><li>な形容詞＋極<sup>きわ</sup>まる・極まりない  </li><li>名詞＋の極み<br>【没有比这更……的了/……之极】，描述某种程度说话人认为到了极点。表示说话人主观的、激动的心情，对于好的和坏的事物都可以描述。<br>例：店員の態度が失礼きわまるな。  </li></ul><h3 id="の至り"><a href="#の至り" class="headerlink" title="の至り"></a>の至り</h3><ul><li>名詞＋の至り<br>【……之至】，描述某种程度说话人认为到了极点。只能描述好的事物。<br>常用表达：光栄の至り、感激の至り<br>例：ご客様は弊店を訪れるのことはさすが弊店の光栄の至りです。</li></ul><h3 id="くらい・ぐらい"><a href="#くらい・ぐらい" class="headerlink" title="くらい・ぐらい"></a>くらい・ぐらい</h3><ul><li>動詞普通形・名詞・な形容詞～な＋くらい・ぐらい  </li></ul><ol><li>【……点程度的小事】，表示说话人认为十分简单。是轻视的说法。<br>常用表达：これぐらい　どれぐらい<br>例：この程度ぐらいで諦めるは笑えるな。  </li><li>【十分……】，强调程度的极端。<br>例：やっと車が一台通れるぐらい狭い道だった。  </li></ol><h3 id="など・なんか・なんて"><a href="#など・なんか・なんて" class="headerlink" title="など・なんか・なんて"></a>など・なんか・なんて</h3><ul><li>名詞＋など・なんか・なんて</li></ul><ol><li>【这样……】，表示厌恶、轻视的情绪。后项用否定的表达。<br>对自己的事情进行表述时，表示自谦。<br>例：スキーなんて簡単ですよ。だれでもすぐできるようになります。  </li><li>【像……样的】，表示举例。<br>例：お見舞いならカーネーションなんてどうしたら。  </li></ol><h3 id="こそ-1"><a href="#こそ-1" class="headerlink" title="こそ"></a>こそ</h3><ul><li>名詞＋こそ<br>【正是……】，强调主体与其他事物关键性的区别。表示正是由于这样的区别才使得主体独特起来。对好的主体使用，用于称赞。<br>例：これこそ本当の日本料理です。  </li></ul><h3 id="までして"><a href="#までして" class="headerlink" title="までして"></a>までして</h3><ul><li>動詞て形・名詞＋までして<br>【连……都做】，表示举出一个说话人认为极端低下的例子，强调连这种程度的事情都要做。有轻蔑和批判的感情。<br>例：借金までしてパチンコをするなんて、どうも理解できない。  </li></ul><h2 id="极端程度（Unit-12）"><a href="#极端程度（Unit-12）" class="headerlink" title="极端程度（Unit 12）"></a>极端程度（Unit 12）</h2><h3 id="たりとも（ない）"><a href="#たりとも（ない）" class="headerlink" title="たりとも（ない）"></a>たりとも（ない）</h3><ul><li>一＋量詞＋たりとも  </li><li>名詞＋たりとも<br>【即是一点……，也（不能）……】，后项是否定的用法。强调在前项的最低程度下也不能完成。是全面否定的表达方式。<br>常用表达：何人たりとも～ない，表示是谁都不例外。<br>例：一分たりとも遅刻は許さない。  </li></ul><h3 id="といえども（ない）"><a href="#といえども（ない）" class="headerlink" title="といえども（ない）"></a>といえども（ない）</h3><ul><li><p>一＋量詞＋といえども<br>【即是……，也（不能）……】[书]，后项是否定的用法。意思和用法同たりとも（ない）。是一种相当古老的表达。  </p></li><li><p>動詞普通形・名詞＋といえども<br>见Unit 9。表示在极端场合、人物、身份的条件下也不能完成。  </p></li></ul><h3 id="として（ない）・も（ない）"><a href="#として（ない）・も（ない）" class="headerlink" title="として（ない）・も（ない）"></a>として（ない）・も（ない）</h3><ul><li>一＋量詞＋として＋動詞ない形＋ない  </li><li>一＋量詞＋も＋動詞ない形＋ない<br>【完全没有……】[书]，全部否定的用法。强调完全没有。<br>例：一日として、ゆっくり休めた日はありません。  </li></ul><h3 id="すら・ですら"><a href="#すら・ですら" class="headerlink" title="すら・ですら"></a>すら・ですら</h3><ul><li>名詞＋（で）すら<br>【甚至连……也……】[口]，举出一个极端的事例说明连这样的事物都……，其他的事物也自然不例外。<br>例：この問題は先生ですら、解けないでしょう。  </li></ul><h3 id="だに"><a href="#だに" class="headerlink" title="だに"></a>だに</h3><ul><li>動詞辞書形・ます形・三類動詞名詞・名詞＋だに<br>【就连……也不能……/完全不能……】[书]，表示形容事件的程度让说话人完全不能做（想象，思考等等）。<br>常与：思う、考えろ、聞く、想像等连用。<br>例：受験の日を想像だに、とても緊張してきます。  </li></ul><h3 id="さえ-1"><a href="#さえ-1" class="headerlink" title="さえ"></a>さえ</h3><ul><li>名詞＋（で）さえ<br>【就连……也……】，后面是否定的用法。表示说话的对象连最低的限度都不能完成。<br>例：日本人なのに、平仮名さえ書けない。  </li></ul>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
      <category>樱花教材</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日语</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>卷积神经网络简介</title>
    <link href="/2021/07/27/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%80%E4%BB%8B/"/>
    <url>/2021/07/27/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="卷积神经网络简介"><a href="#卷积神经网络简介" class="headerlink" title="卷积神经网络简介"></a>卷积神经网络简介</h1><blockquote><p>针对用于图像识别的卷积神经网络而言  </p></blockquote><h2 id="卷积神经网络的识别"><a href="#卷积神经网络的识别" class="headerlink" title="卷积神经网络的识别"></a>卷积神经网络的识别</h2><p>卷积神经网络的结构分为输入层，隐含层和输出层。其中隐含层包括了卷积层（矩阵通过卷积层后还需要经过激活函数处理），池化层和全连接层。图像依次通过这三个层，然后通过softmax函数输出最终的概率。  </p><h3 id="输入层"><a href="#输入层" class="headerlink" title="输入层"></a>输入层</h3><p>彩色图像在输入层被分离为RGB三通道的三个大矩阵。  </p><h3 id="隐含层"><a href="#隐含层" class="headerlink" title="隐含层"></a>隐含层</h3><h4 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h4><p>卷积的实质是图滤波，通过卷积核参数的设定为图像的像素赋予权重，达到增强并削弱图像中特定像素点的效果。卷积层的作用是通过预设好的卷积核对三通道矩阵进行照射，起到提取图像特征的作用。  </p><h5 id="卷积层的参数"><a href="#卷积层的参数" class="headerlink" title="卷积层的参数"></a>卷积层的参数</h5><p>卷积层的参数为：卷积核大小，步长，填充，三者称为卷积层的超参数，共同决定卷积层输出图像的尺寸。  </p><ul><li><p>卷积核大小<br>卷积核的大小通常是奇数，主要原因是根据卷积公式，最终得到的图像长宽均与卷积核的基数倍有关，如果设置卷积核大小为偶数维度则最终得到的图像长宽可能不是一个整数。此外还有便于强调中心，奇数卷积核对边沿、对线条更加敏感，可以更有效的提取边沿信息等优点。  </p></li><li><p>步长（Step）<br>指一次照射结束后，卷积核移动的像素单位数，通常以$\alpha$表示。  步长过大可能导致图像的某些位置未被处理，步长过小则被重叠滤波的像素面积增多。  </p></li><li><p>填充(Padding)<br>由于卷积过程是一个降维过程（直观来看图像会被缩小），有时为了保证卷积输出的图像不被降维，需要在图像外围添加像素值为0的像素点，填充反映了像素点添加的多少。 填充的方式有非常多种。  </p></li></ul><h4 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h4><p>激活函数为卷积神经网络建立了非线形的建模能力，使得神经网络能够表达非线性映射关系，能够非线形分类。 图像通过卷积层后，需要通过激活函数对这一层的结果进行非线性化，使得模型具有复杂的建模能力。   </p><h5 id="常见的激活函数"><a href="#常见的激活函数" class="headerlink" title="常见的激活函数"></a>常见的激活函数</h5><ul><li><p>Sigmoid 函数</p><script type="math/tex; mode=display">f(x)=\frac{1}{1+e^{-x}}</script><p>Sigmoid函数是最简单的非线形二分类函数，能够把连续实数进行放缩，使得函数输出值在0-1的范围内。  缺点是当输入非常大或者非常小的时候梯度容易消失。  </p></li><li><p>ReLU 函数</p><script type="math/tex; mode=display">f(x)=max(0,x)</script><p>输入信号<0时，输出都是0，输入>0 的情况下，输出等于输入。 好处是过滤了负值像素的同时提供了一种极其简便的计算方式，使得计算量小，收敛速度比较快。 缺点是一个非常大的梯度通过一个 ReLU 神经元，更新过参数之后，这个神经元再也不会对任何数据有激活现象了，这个神经元的梯度永远都是0。 尤其是学习率设置的比较大的时候，可能大部分神经元都会出现这类问题。  </p></li></ul><h4 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h4><p>池化层的作用是通过对卷积图的降维过程进一步加强提取到的特征，具体的实现方式是通过预设的卷积核照射卷积图，得到能够表征整个照射区域的数值（比如最大值，均值，中值），这些数值组成新的矩阵。  常见的池化方法是最大值池化（用照射区域的最大值表征整个照射区域）和均值池化（用照射区域的均值表征整个照射区域）。   </p><h3 id="全连接层"><a href="#全连接层" class="headerlink" title="全连接层"></a>全连接层</h3><p>全连接层的作用是把隐含层的输出结果向量化以减小分类函数的计算量，具体而言全连接层的作用就是首先按顺序把最后一个隐含层的所有神经元输出的特征图按顺序展开并拼接为一个特征向量。 这个特征向量会被投入到激活函数当中，最终输出为一个位置表示tag，值表示评分的标签向量。  最终这个标签向量被投入到softmax函数中，求出目标属于每一类的概率，并返回最大的概率值和类别。  </p><h4 id="softmax-函数"><a href="#softmax-函数" class="headerlink" title="softmax 函数"></a>softmax 函数</h4><script type="math/tex; mode=display">p(y|x)=\frac{e^{X_i}}{\sum_{i=1} e^{X_i}}</script><p>通过softmax函数的归一化作用，将输出映射成为(0,1)的值，而这些值的累和为1，满足概率的性质。最后选取输出时，选取概率最大的结果，输出为预测目标。softmax函数使用指数作为表达的原因是一是归一化操作满足概率性质，二是可以将负值输出正值化。    </p><h2 id="神经网络的训练"><a href="#神经网络的训练" class="headerlink" title="神经网络的训练"></a>神经网络的训练</h2><h3 id="前向传播"><a href="#前向传播" class="headerlink" title="前向传播"></a>前向传播</h3><p>对于一组数据和其标签$(x,y)$，去掉标签后投入到神经网络中，得到每一个神经单元的输出和最终的预测结果$(x,a)$的过程叫做前向传播。   </p><h3 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h3><p>执行反向传播的目的是为了求出每一个神经单元的误差$\delta=y-a$进而求出$\frac{\partial J}{\partial \Theta}$ 的值，以此来带入到梯度下降算法当中求得梯度并更新参数。  </p><h4 id="从池化层的误差推导卷积层的误差"><a href="#从池化层的误差推导卷积层的误差" class="headerlink" title="从池化层的误差推导卷积层的误差"></a>从池化层的误差推导卷积层的误差</h4><p>以最大值池化为例，对于池化前特征图中每一个被池化卷积核照射到的区域，由于只有最大值所处的位置才会有误差，其余区域由于最大池化过滤而不会对误差有任何影响，因此原特征图被照射区域中只有最大值对应的位置（需要在前向传播时记录下来）有误差$\delta$，其余位置的误差为0.<br>对均值池化，原特征图被照射区域的所有位置上对误差均等的贡献造成了整体误差$\delta$，因此每个位置上的误差都是$\frac{\delta}{N}$.<br>通用的解决办法为：<br>当第$l$层为卷积层，第$l+1$层为池化层时，第$l$层某一个像素（神经元）的误差为第$l+1$层与其相关的所有像素（神经元）的误差与权重的乘积之和。由于激活函数的影响，当前层激活之前的特征图矩阵$X$每一个位置通过激活函数的导数处理，再将处理后的矩阵与第$l+1$层的神经元误差矩阵对应位置相乘。此处神经元误差矩阵需要做上采样处理以统一维度进行运算，该过程表示为：  </p><script type="math/tex; mode=display">\delta_j^l=w_j^{l+1}(f’(x_j^l) \odot up(\delta_j^{l+1}))</script><p>$w_j^{l+1}$:$l+1$层第$j$神经元的权重，$up$：上采样，$\odot$：对应位置相乘。<br>记激活函数$f(x)=z$,矩阵化后有第$l$层的误差向量$\delta^l$：  </p><script type="math/tex; mode=display">\delta^l=w_j^{l+1}（ z’^{l} \odot up(\delta^{l+1}))</script><h4 id="卷积层的反向传播"><a href="#卷积层的反向传播" class="headerlink" title="卷积层的反向传播"></a>卷积层的反向传播</h4><p>从卷积层推导池化层，$l$层的误差$δ^{l-1}$，等于卷积后结果的$δ^{l}$误差经过零填充后，与卷积核旋转180度后的卷积。如图所示：<br><img src="https://grzegorzgwardys.files.wordpress.com/2016/01/screenshot-from-2016-04-17-212043.png" alt=""></p><script type="math/tex; mode=display">\delta^{l-1} =  (\frac{\partial z^{l}}{\partial z^{l-1}})^T\delta^{l} = \delta^{l}*rot180(W^{l}) \odot  \sigma^{'}(z^{l-1})</script><p>已知$δ^{l-1}$，求损失函数$C$对该层参数的导数$\frac{∂C}{∂w^l}$:  </p><script type="math/tex; mode=display">\frac{∂C}{∂w^l}=δ^l*σ(z^{l-1})</script><h3 id="卷积神经网络的训练过程"><a href="#卷积神经网络的训练过程" class="headerlink" title="卷积神经网络的训练过程"></a>卷积神经网络的训练过程</h3><ol><li>对神经网络进行初始化，定义好网络结构，设定好激活函数，对卷积层的卷积核$W$、偏置$b$进行随机初试化，对全连接层的权重矩阵$W$和偏置$b$进行随机初始化。<br>设置好训练的最大迭代次数，每个训练batch的大小，学习率$η$。  </li><li>从训练数据中取出一个batch的数据</li><li>从该batch数据中取出一个数据，包括输入$x$以及对应的正确标签$y$</li><li>将$x$放入CNN的输入端利用前向传播得到$z^l$，$a^l$</li><li>结合$z^l$，$a^l$和$y$，算出神经网络的损失函数</li><li>计算损失函数对输出层的误差$δ^L$</li><li>利用反向传播，计算前一层的误差$δ^l-1$：<ul><li>全连接层：$δ^l=(W^{l+1})^Tδ^{l+1}⊙ \sigma^{‘}(z^{l})$</li><li>卷积层：$\delta^{l-1} =  (\frac{\partial z^{l}}{\partial z^{l-1}})^T\delta^{l} = \delta^{l}*rot180(W^{l}) \odot  \sigma^{‘}(z^{l-1})$  </li><li>池化层：$\delta^l=w_j^{l+1}（ z’^{l} \odot up(\delta^{l+1}))$  </li></ul></li><li>利用误差求出损失函数对该层参数的导数：  <ul><li>全连接层：$\frac{∂C}{∂W^l}=δ^l(a^{l-1})^T$  </li><li>卷积层：$\frac{∂C}{∂w^l}=δ^l*σ(z^{l-1})$</li></ul></li><li>将求得的导数加到该batch数据求得的导数之和上(初始化为0)，跳转到步骤3，直到该batch数据都训练完毕</li><li>利用一个batch数据求得的导数之和，根据梯度下降法对参数进行更新</li><li>跳转到步骤2，直到达到指定的迭代次数</li></ol>]]></content>
    
    
    <categories>
      
      <category>技术杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>卷积神经网络</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9.3. K均值算法的优化</title>
    <link href="/2021/07/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/9.%20K-Means%E7%AE%97%E6%B3%95/9.3.%20Kmeans%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96/"/>
    <url>/2021/07/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/9.%20K-Means%E7%AE%97%E6%B3%95/9.3.%20Kmeans%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="K均值算法的优化"><a href="#K均值算法的优化" class="headerlink" title="K均值算法的优化"></a>K均值算法的优化</h1><h2 id="多次随机初始化"><a href="#多次随机初始化" class="headerlink" title="多次随机初始化"></a>多次随机初始化</h2><p>初始化的状态不同，可能最后得到的结果是不一样的。<br>随机初始化聚类中心的其中一种方法为：<br>随机选择K个样本$μ_1…μ_k$作为$K$个聚类中心。<br>但是按如上的随机初始化方式可能导致最后的分类的结果不同，并且有可能使得代价函数$J$落入局部最优解而不是最小值。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210729123016.png width=50%><br>解决这个问题的方法是多次（比如50-100次）随机初始化聚类中心并运行K-Means算法，每运行一次都会得到代价函数的值 $J$，最后从这些代价函数的值中挑选最小的一个。<br>实验说明，当$K$的取值比较小（2-10）时，多次随机初始化能够有效改善出现局部最优解的情况，而$K$的取值很大时，这种方法不会起到比较好的改善。  </p><h2 id="正确选取-K-的数量"><a href="#正确选取-K-的数量" class="headerlink" title="正确选取$K$的数量"></a>正确选取$K$的数量</h2><h3 id="肘部法则"><a href="#肘部法则" class="headerlink" title="肘部法则"></a>肘部法则</h3><p>通常在数据集中有多少个类是不清楚的，因此用一个自动化的算法内选择聚类的数量是困难的。但是仍然有一些法则能够帮助设置聚类数量，其中一个法则称为肘部法则（Elbow method），具体方法如下：<br>通过不断改变K的值运行K-Means算法，计算出不同的代价函数值$J$，如图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210729125538.png width=50%><br>图示的拐点常常被用于设置聚类数据。<br>但是在实际中，往往曲线的拐点并不明确，比如如下所示，因此通过肘部法则来选取聚类数量的方法具有局限性。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210729125729.png width=50%>  </p><h3 id="根据后续目的选择-K"><a href="#根据后续目的选择-K" class="headerlink" title="根据后续目的选择$K$"></a>根据后续目的选择$K$</h3><p>很多时候运行K-Means算法是为了一些后续的目的，比如市场划分等等。如果后续的目的能够给出一个评估标准，那么决定聚类数量的最好方法是看那个聚类数量更适合这个评估标准。<br>比如要分出衣服的尺寸，可以根据衣服的尺寸：S，M，L，将K设置为3；或者根据XS,S,M,L,XL将K设置为5，如下图所示。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210729130236.png width=50%>  </p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>09. K均值算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>9.2. K均值算法的过程与实现</title>
    <link href="/2021/07/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/9.%20K-Means%E7%AE%97%E6%B3%95/9.2.%20Kmeans%E7%AE%97%E6%B3%95/"/>
    <url>/2021/07/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/9.%20K-Means%E7%AE%97%E6%B3%95/9.2.%20Kmeans%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="K均值算法的过程与实现"><a href="#K均值算法的过程与实现" class="headerlink" title="K均值算法的过程与实现"></a>K均值算法的过程与实现</h1><p><strong>K均值算法</strong>（K-Means）是一种流行的聚类算法。  </p><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><p>以如下数据集的例子来说明K均值算法的执行过程：  </p><p><img src="https://gitee.com/l61012345/Pic/raw/master/%5Cimage/20210629111841.png" alt=""></p><p>对于如图所示的数据集，使用K均值算法将其分成两类数据。<br>K均值算法的第一步是在数据集中随机生成两点，称为<strong>聚类中心</strong>（Cluster Centroid）。（要分为多少类，就要生成多少个聚类中心）<br>K均值算法是一个迭代算法，每一次迭代过程分为两部分：  </p><ol><li>簇分配<br>K均值算法会遍历每一个数据，计算该点与每一个聚类中心的距离，该点会被归属到最近的聚类中心。  </li><li>移动聚类中心<br>移动聚类中心到当前集群的平均位置。<br><img src="https://gitee.com/l61012345/Pic/raw/master/%5Cimage/20210629113257.png" alt="">  </li></ol><p>之后K均值算法会重复上述两步，直到聚类中心不再移动，此时可以认为聚类已经实现。    </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="算法输入"><a href="#算法输入" class="headerlink" title="算法输入"></a>算法输入</h3><ul><li>簇的数量： $K$</li><li>训练集: $\{x^{(1)},x^{(2)},…,x^{(m)} \}$<br>对每一个数据而言，$x^{(i)}$都是一个n维的向量。  </li></ul><h3 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h3><p>K均值算法首先会随机初始化聚类中心$μ_i$：<br>Repeat{   </p><pre><code class="hljs"># 计算每个聚类中心到该点的距离，并返回最近距离的聚类中心标签  for $i=1$ to $m$  $c^&#123;(i)&#125;$:=index(from 1 to $K$)  of cluster centroid closest to $x^&#123;(i)&#125;$ 或者  $c^&#123;(i)&#125;$:=$min||x^&#123;(i)&#125;-μ_k||^2$  # 移动聚类中心  for $k=1$ to $K$    $μ_k$:=arverage of points assigned to cluster $k$  </code></pre><p>}  </p><blockquote><p>如果此时出现所有点都不属于某一个聚类中心的情况，则可以直接移除这个聚类中心，或者重新随机初始化这个聚类中心  </p></blockquote><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>K-Means算法的代价函数会重点跟踪如下的两个参数的变化规律：<br>$c^{(i)}$：当前每一个样本$x^{(i)}$所属的聚类中心$μ_c^{(i)}$对应的标签<br>$μ_k$: 聚类中心的位置<br>代价函数以如下形式表示：  </p><script type="math/tex; mode=display">J(c^{(1)}...c^{(m)},μ_1...μ_K)=\frac{1}{m}∑_{i=1}^{m}||x^{(i)}-μ_c^{(i)}||^2</script><p>代价函数的目标是找到使得$J(c^{(1)}…c^{(m)},μ_1…μ_K)$最小化的$c^{(1)}…c^{(m)},μ_1…μ_K$。  </p><p>重回K-Means算法的执行过程：<br>计算每个聚类中心到该点的距离，并返回最近距离的聚类中心标签的实质是保持$μ_1…μ_K$固定，而找到使得$J$最小化的$c^{(i)}$。<br>移动聚类中心的实质是保持$c^{(1)}…c^{(m)}$不变，找到使得$J$最小化的$μ_k$。  </p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>09. K均值算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>9.1. 非监督学习的概念</title>
    <link href="/2021/07/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/9.%20K-Means%E7%AE%97%E6%B3%95/9.1.%20%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
    <url>/2021/07/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/9.%20K-Means%E7%AE%97%E6%B3%95/9.1.%20%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="非监督学习的概念"><a href="#非监督学习的概念" class="headerlink" title="非监督学习的概念"></a>非监督学习的概念</h1><h2 id="非监督学习"><a href="#非监督学习" class="headerlink" title="非监督学习"></a>非监督学习</h2><ul><li><p>回顾： 监督学习<br>数据集有一系列的标签，监督学习的目的是找到空间中不同类数据标签之间的决策边界。<br>数据集的表示：$\{(x^{(i)},y^{(i)}),…\}$  </p></li><li><p>非监督学习<br>在非监督学习中，数据集没有事先预设好的标签。非监督学习的目的是先要自动根据数据的特征对数据进行分类，再找到不同类数据之间的决策边界。<br>数据集的表示：$\{(x^{(i)})..\}$  </p></li></ul><h2 id="聚类算法"><a href="#聚类算法" class="headerlink" title="聚类算法"></a>聚类算法</h2><p>根据数据分布的聚集情况自动将数据分为多类/簇，或者是多个子集的算法称为<strong>聚类算法</strong>（Clustering Algorithm）。  </p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>09. K均值算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>遗传算法（GA）导论</title>
    <link href="/2021/07/18/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    <url>/2021/07/18/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="遗传算法导论"><a href="#遗传算法导论" class="headerlink" title="遗传算法导论"></a>遗传算法导论</h1><blockquote><p>A genetic algorithm tutorial, Darrell Whitley, 1994</p></blockquote><h2 id="遗传算法的概念"><a href="#遗传算法的概念" class="headerlink" title="遗传算法的概念"></a>遗传算法的概念</h2><p>遗传算法是一类将特定问题潜在的解决方案编码并组织到形如染色体（chromosome）结构的数据结构（下文直接称之为染色体）上，然后应用推荐算子(recommend operators)对数据结构中的特定信息进行保留的算法。<br>遗传算法的操作对象是一组这样的染色体，称之为<strong>种群</strong>（population）。遗传算法会针对这样的种群进行评价，然后筛选：对于目标问题有更优解的染色体会被赋予更高的机会进行复制和重组，称为”繁殖”（Reproduce）。</p><h2 id="优化问题"><a href="#优化问题" class="headerlink" title="优化问题"></a>优化问题</h2><p>遗传算法遇到的问题大多可以归结为两类：编码问题和评估函数的问题。  </p><h3 id="编码（Encoding）问题"><a href="#编码（Encoding）问题" class="headerlink" title="编码（Encoding）问题"></a>编码（Encoding）问题</h3><p>对于参数的选取，通常认为参数之间应该具备线形不相关的特性，但事实上很难保证参数的这一性质，在遗传算法中，参数之间的关联称为基因关联（Epistasis）。<br>遗传算法对与参数的编码建立在一个基本的假设上：<strong>代表系统参数的变量可以用字节串（位串，Bit string）来进行表达</strong>，这也意味着这些变量能够以某种方式被离散化。离散化的范围以$2^n$表示，例如如果每个参数都用10bit来表示，那么经过离散化后，我们能至多得到1024个离散值（1024种01的组合）。对参数作离散化处理是为了在保证精度的前提下，给系统输出提供尽可能大的分辨率（Resolution）以便调整系统输出。<br>字节化编码的问题在于离散值的冗余，如果变量离散化后有1200个（介于1024和2048之间）离散值，那么需要用11个字节才能表示完全，但是如此会有2048-1200=848个无用的离散值，这些无用的离散值可能会导致没有评估，或者是出现不好的评估结果。   </p><h3 id="评估函数（Evaluation-function）问题"><a href="#评估函数（Evaluation-function）问题" class="headerlink" title="评估函数（Evaluation function）问题"></a>评估函数（Evaluation function）问题</h3><p>评估函数能够对系统的输出进行评估。构建评估函数的过程是一个模拟（仿真）系统的过程，这样的仿真相比与真实系统必然只能给出近似解或者是部分解。因此评估函数对系统输出的结果只是近似的，或是部分的评价。   </p><p>对于遗传算法来说评估函数的计算速度是一个问题：首先，对于现有种群的评估计算量就比较大。不仅如此，种群的后代也需要进行评估。   </p><h4 id="搜索空间（Search-space）"><a href="#搜索空间（Search-space）" class="headerlink" title="搜索空间（Search space）"></a>搜索空间（Search space）</h4><p>假设参数之间的关系是非线形的，如果用于表示参数的比特数为L，那么参数空间的大小是$2^L$,<strong>遗传算法在这样的一个$L$维的超空间（Hypercube）中采样</strong>。这个超空间的大小随着L指数型增长，将带来巨大的采样难度和计算量。  </p><h2 id="经典遗传算法"><a href="#经典遗传算法" class="headerlink" title="经典遗传算法"></a>经典遗传算法</h2><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>经典遗传算法通过对当前种群的<strong>评估（Evaluation）</strong>，<strong>选择（Selection）</strong>，<strong>重组（Recombination）</strong>和<strong>突变（Mutation）</strong>  后，能够在现有种群的基础上产生下一代种群。 </p><h4 id="原始种群（Initial-population）"><a href="#原始种群（Initial-population）" class="headerlink" title="原始种群（Initial population）"></a>原始种群（Initial population）</h4><p>在遗传算法中，定义<strong>种群中编码后的一条固定长度为L的字节串称为一个个体，这样的个体称为基因型（Genotype）或者是染色体（Chromosome）</strong>。  在大多数情况下，原始种群被随机的产生出来。    </p><blockquote><p>此处的随机指在空间内随机的取出一些编码的组合（当然也受制于编码机制等）。  </p></blockquote><h4 id="评估和适应度"><a href="#评估和适应度" class="headerlink" title="评估和适应度"></a>评估和适应度</h4><p>原始种群被生成后，每一个个体会通过评估函数和适应度函数（Fitness funtion）生成其对种群的适应度（Fitness）。  </p><blockquote><p>评估函数和适应度函数两个概念一般来说是可以替换的。事实上，评估函数是通过一组参数来实现对个体表现的衡量，而适应度函数是通过增殖（Reproductive）概率来衡量个体表现的。  评估函数的衡量不依赖于种群中的其他个体，适应度函数的衡量与种群中其他个体有关。     </p></blockquote><p>种群中个体$i$的适应度定义为：  </p><script type="math/tex; mode=display">\frac{f_i}{\overline{f}}</script><p>其中，$f_i$表示评估函数对第$i$个个体的评估结果，$\overline{f}$表示种群的平均评估。  </p><h4 id="选择-轮盘赌选择"><a href="#选择-轮盘赌选择" class="headerlink" title="选择(轮盘赌选择)"></a>选择(轮盘赌选择)</h4><p>定义在<strong>现种群经过选择后保留的种群称为中间种（Imermediate population），中间种经过突变和重组后会成为下一代种群。</strong><br>在遗传算法中，<strong>选择的本质是概率性地将现种群中的个体进行复制，最终得到中间种的过程。</strong><br>具体而言，对于适应度大于1的个体，适应度的整数部分表示该个体会被复制多少次。对所有的个体，适应度的小数部分表示额外被复制的概率。  比如，适应度2.3的个体能够获得2次复制，并且有0.3的概率能获得第三次复制的机会。<br>更加形象化的表述为轮盘赌：如果整个轮盘表示整个种群，每个个体所占面积与适应度成正比，每一次转动就能随机地抽取一个个体复制，更高效的办法是轮盘外围上均匀地分布着N个均等间距的指针，每一次转动就能随机抽取N个个体进行复制。  经过若干次转动后，结果的集合构成中间种。  </p><h4 id="重组（单点交叉）"><a href="#重组（单点交叉）" class="headerlink" title="重组（单点交叉）"></a>重组（单点交叉）</h4><p><strong>遗传算法中重组的本质是杂交（Crossover）</strong>，其过程主要有两步： </p><ol><li>随机地使得个体间两两配对。  </li><li>随机地选取一对个体，两者在某个随机且相同的比特位处断开，前后的两段基因型进行交叉互换。  </li></ol><p><img src="https://img-blog.csdnimg.cn/20191202151959116.gif#pic_center" alt=""></p><p>新生成的两个个体称为后代（Offspring），后代能够插入到下一代的概率计作$p_c$。  </p><h4 id="突变"><a href="#突变" class="headerlink" title="突变"></a>突变</h4><p>重组之后利用突变算子对后代作突变处理，对于种群中的所有比特位，其突变的概率计作$p_m$，这是一个非常小的值，通常小于1%。  <strong>突变有可能随机地产生一些比特（并且有50%的可能性改变原本的比特值），也有可能反转原有的比特（一定能改变原本的比特值）。</strong><br>中间种经过重组和突变，最终能称为新的种群。</p><p><div align="center">  <img src=https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210718132905.png width=40% />  </div></p><center>▲ 经典遗传算法的选择和重组过程</center><p><div align="center">  <img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220118134224.png width=80%>  </div></p><center>▲ 整个经典遗传算法的运行图</center><h3 id="可行性分析"><a href="#可行性分析" class="headerlink" title="可行性分析"></a>可行性分析</h3><p>经典遗传算法的鲁棒性和复杂性建立在样本空间中有偏向性的超平面采样之上。   </p><h4 id="搜索空间和超平面"><a href="#搜索空间和超平面" class="headerlink" title="搜索空间和超平面"></a>搜索空间和超平面</h4><p>在几何学上，称n维空间的某一个小于n维的子空间为超平面（hyperplane）， 比如二维空间的超平面是一条线，三位空间的超平面是一个面。<br><strong>在位串长度固定位$L$的前提下，种群中所有可能的编码方式所构成的空间称为搜索空间（Search space）。</strong> 如果每一种特定的编码方式在L维搜索空间中对应了一个角（Corner），那么共超平面的几个角对应的编码中必定在相同的某几个比特位上的值是相同的，此时引入通配符（Don‘t care，以*记）的概念，那么搜索空间的一个超平面就可以表示为含有Don’t care（*）的位串（比如：0****，11*****），这样的位串称为模式（Schema），每一个模式对应了一个超平面。   </p><h4 id="复制：偏向性地采样"><a href="#复制：偏向性地采样" class="headerlink" title="复制：偏向性地采样"></a>复制：偏向性地采样</h4><p>对于一个$K$维的搜索空间：***…***，该空间能够被分割为1**…***和0**…***两个超平面，对这两个超平面分别计算平均适应度，采样过程总是有高概率地采集适应度更高的超平面内的样本。在下一次采样中，这个超平面再度被等距划分为多个子部分，采样会更倾向于平均适应度更高的子部分，重复若干次采样后，<strong>采样总是更倾向于采集整个搜索空间中适应度最高的部分</strong>。因此通过这样的采样能够在搜索空间中找到适应度最高的部分。换句话说，遵循这样规律的复制总是能够有高概率地选择到种群中适应度更高的个体。  </p><blockquote><p>采样过程的本质是一个在搜索空间中不断寻找局部最大值的过程。  </p></blockquote><p>其次，定义选择后某一特定超平面$H$内留存的样本的期望数目为该超平面现有的样本数目$M（H,t）$与该超平面适应度均值$f(H,t)$的乘积：</p><script type="math/tex; mode=display">E=M(H,t) \times f(H,t)</script><p>这样的采样方法会使得采样后在特定超平面的样本数与其期望大致相符合,事实上经过选择后$H$留存的样本数目$M(H,t+1)$可以被公式化为：  </p><script type="math/tex; mode=display">M(H,t+1)=M(H,t)\frac{f(H,t)}{\overline{f}}</script><p>其中$\overline{f}$表示整个种群的平均适应度，近似为1。   </p><h4 id="重组：产生新的样本的同时带来破坏"><a href="#重组：产生新的样本的同时带来破坏" class="headerlink" title="重组：产生新的样本的同时带来破坏"></a>重组：产生新的样本的同时带来破坏</h4><p>由于复制不会产生新的样本，而选择可能会减少种群中的样本数目，<strong>为了避免最终种群的个体数目过小，同时产生新的可能性</strong>，因此在每一次采样后需要用染色体重组（交叉）来产生新的样本。 不仅如此，染色体重组（交叉）还可以起到部分地保留当前的采样超平面倾向的作用，下面来讨论染色体重组对原来染色体中信息的破坏（Disruption）程度：<br>对于一组一阶染色体，其染色体中的信息必不可能受到染色体重组的影响。<br>对于二阶和二阶以上的染色体组，其破坏程度和交叉点的数目有关：<br>如果只有一点发生染色体重组，染色体组在一点交叉后发生比特变换（破坏）的概率受Schema中确定字符（该位置上的值不是通配符）的位置决定。<br>如果有两点发生染色体重组，则在互补位置发生交叉时对染色体组的破坏最大。<br>总而言之，<strong>染色体中的原本信息在重组中受到破坏的程度与模式中确定字符的位置有着密切的关系。</strong><br>不管是一点交叉还是两点交叉，可以发现Schema中相邻的既定比特位受到重组带来的破坏最小。    </p><h5 id="定义距"><a href="#定义距" class="headerlink" title="定义距"></a>定义距</h5><p>称在交叉过程中被整体保留下来的确定字符称为适应性等位基因（Coadapted alleles）。在某一个模式当中，两个确定字符之间的距离称为两个字符的联系（Linkage），第一个确定字符的位置和最后一个确定字符的位置之间（这个部分称为有义部分（Significant Portion of Schema））的距离称为模式的定义距（Defining length），以$\Delta(H)$记。</p><blockquote><p>两点及两点以上的交叉中需要将Schema组织为首尾相连的环状形式，才能得出其定义距。  </p></blockquote><p>通过之前对重组破坏的推演可以得出结论：破坏程度与定义距的长度有关：定义距的长度越长，在交叉过程中原本染色体信息被破坏的可能性就越大。不仅如此，定义距直接反映了交叉发生在有义部分的概率，对于一点交叉而言，一点交叉发生在有义部分的概率为： $\frac{\Delta(H)}{L-1}$。   </p><h5 id="倒换"><a href="#倒换" class="headerlink" title="倒换"></a>倒换</h5><p>除了交叉和变异之外，遗传算法中还会用到的对染色体的基本操作是倒换（Inversion）。 倒换是随机的将染色体中的某一段序列进行镜像翻转。倒换可以改变染色体上确定字符之间的连接，这样具有更大非线性的确定字符在染色体上的间隔距离可能会被缩小。<br> 倒换的前提是比特以一种位置无关的方式进行编码（否则倒换就等同于大规模变异）。一种可行的编码方式是染色体上的每一个基因以（位置，值）的形式表示。比如对于010010110而言，染色体为((9,0)(6,0)(2,1)(7,1)(5,1)(8,1)(3,0)(1,0)(4,0))。 对于倒换和如此表示所带来的问题，在此不做过多叙述。<br><img src= https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210718133527.png width=40% /> </p><h2 id="模式定理"><a href="#模式定理" class="headerlink" title="模式定理"></a>模式定理</h2><h3 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h3><p>模式定理（Schema theorem）提供了进化时采样率的下界，推导过程如下：<br>由之前提出的经过选择后超平面$H$留存的样本（个体）数目$M(H,t+1)$：  </p><script type="math/tex; mode=display">M(H,t+1)=M(H,t)\frac{f(H,t)}{\overline{f}}</script><p>考虑重组对选择后超平面$H$中种群样本数目的影响：</p><ol><li>重组是有概率发生的，概率为$p_c$。  </li><li>对于发生重组的种群，交叉既有可能产生出现有空间内某个模式的副本（比如100和010交叉就可能产生000，使得000的副本增加一个），同时也有可能使得原有的样本消失。    </li></ol><p>那么现在后代中落在超平面$H$的样本数目：  </p><script type="math/tex; mode=display">M(H,t+1)=(1-p_c)M(H,t) \frac{f(H,t)}{\overline{f}} +p_c [M(H,t)\frac{f(H,t)}{\overline{f}}(1-losses)+gains]</script><p>为了简化计算，忽略gain，并且假设发生在Schema上有义部分的交叉必然导致染色体破坏，记破坏概率为$disruption$，那么有：  </p><script type="math/tex; mode=display">M(H,t+1) \geq (1-p_c)M(H,t) \frac{f(H,t)}{\overline{f}} +p_c [M(H,t)\frac{f(H,t)}{\overline{f}}(1-disruption)]</script><p>定义超平面$H$的采样率表示超平面$H$的样本数目与种群中样本数目的比，以$P(H,t)$记。<br>由之前对定义距的理解，对原信息的破坏只可能发生在定义距的区间段内。此外，如果发生重组的位串都在平面$H$内，那么重组也不可能对原本信息造成破坏，因此要想让重组破坏原有的信息，亲本中的另一条位串必定来自于其他平面。<br>由这上述两点可以将破坏概率定义为：  </p><script type="math/tex; mode=display">\frac{\Delta(H)}{L-1}(1-P(H,t))</script><p>由破坏的定义可以得出如下结论：<br><strong>定义距$Δ(H)$越小，模式受到破坏的概率就越小。</strong>从直观上来说，定义距越小，交叉发生在定义距内（即一定能破坏信息）的概率也越小。<br>那么下一代超平面$H$的采样率可以表示为：</p><script type="math/tex; mode=display">P(H,t+1) \geq P(H,t) \frac{f(H,t)}{\overline{f}} [1-p_c \frac{\Delta(H)}{L-1}(1-P(H,t))]</script><p>如果考虑亲代是基于适应度选择出来的：  </p><script type="math/tex; mode=display">P(H,t+1) \geq P(H,t) \frac{f(H,t)}{\overline{f}} [1-p_c \frac{\Delta(H)}{L-1}(1-P(H,t)\frac{f(H,t)}{\overline{f}})]</script><p>最后，考虑突变的影响：记突变发生的概率为$p_m$，超平面$H$的阶数为$o(H)$，那么表示超平面$H$的Schema不会受到突变影响的概率为：  </p><script type="math/tex; mode=display">(1-p_m)^{o(H)}</script><p>可以得出结论：<br><strong>模式的阶数$o(H)$越小,模式不会受到突变影响的概率越大。</strong>从直观上来看，模式的阶数代表着有效字符的个数，有效字符越少，在交叉过程中越容易被保留下来。<br>最终，超平面$H$在下一代中被采样到的概率可以表示为：  </p><script type="math/tex; mode=display">P(H,t+1) \geq P(H,t) \frac{f(H,t)}{\overline{f}} [1-p_c \frac{\Delta(H)}{L-1}(1-P(H,t)\frac{f(H,t)}{\overline{f}})] (1-p_m)^{o(H)}</script><p>可以通过数学推算出，在适应度$\frac{f(H,t)}{\overline{f}}&gt;1$时：</p><script type="math/tex; mode=display">P(H,t) \frac{f(H,t)}{\overline{f}} [1-p_c \frac{\Delta(H)}{L-1}(1-P(H,t)\frac{f(H,t)}{\overline{f}})]=P(H,t) \frac{f(H,t)}{\overline{f}}(1-p_c \frac{\Delta(H)}{L-1})+[P(H,t) \frac{f(H,t)}{\overline{f}} ]^2</script><p>用$t=0$代来推算$t$代时候的采样率：  </p><script type="math/tex; mode=display">P(H,t) ≥ \{P(H,0) \frac{f(H,0)}{\overline{f}}(1-p_c \frac{\Delta(H)}{L-1})+[P(H,0) \frac{f(H,0)}{\overline{f}} ]\}^t(1-p_m)^{o(H)}</script><p>可以发现：<strong>在适应度$\frac{f(H,t)}{\overline{f}}&gt;1$时，采样率呈现指数型上升。</strong><br>可以总结为：<br><strong>在选择，重组，突变算子的作用下，当某个超平面的适应度大于1时，模式的阶数$o(H)$越小，定义距$Δ(H)$越小的个体越能够被保留下来，且数目成指数型上升。</strong><br>模式定理在数学上证明了重组和突变的有效性，并给出了采样率的下界，是遗传算法中重要的理论基础之一。  </p><h3 id="突变和收敛问题"><a href="#突变和收敛问题" class="headerlink" title="突变和收敛问题"></a>突变和收敛问题</h3><p>显然，模式定理最强调交叉和超平面采样在遗传搜索中的作用。为了在选择后最大限度地保存超平面样本，应尽量减少交叉和突变的破坏。这表明突变可能根本不应该使用，或者至少应该在非常低的水平上使用。<br>突变的积极作用是突变可以防止任何特定位点或等位基因的永久丢失（尤其是对种群中个体数目非常小的时候而言）， 同时突变也增加了种群的基因多样性。<br>随着代数的增加，选择有可能使得在某些位置上的比特全部变成相同的值，表明算法收敛。但是与此同时，个体之间适应度的差别会越来越小，选择的影响也会越来越小，最终可能导致提前收敛。可以通过对适应度的缩放来改善这一问题。     </p><blockquote><p>关于算法的收敛：遗传算法的收敛性一直是一个问题，简单而言，当选择的代数达到一定程度后，选择压力减弱，导致种群中适应度优秀的个体数始终处于一个水平上而不发生变化，此时称遗传算法达到收敛。和深度学习不同的是，如果在收敛后继续学习，那么优秀个体的数目在理论上并不会下降。  </p></blockquote><h3 id="重组的采样方式·均匀交叉"><a href="#重组的采样方式·均匀交叉" class="headerlink" title="重组的采样方式·均匀交叉"></a>重组的采样方式·均匀交叉</h3><h4 id="交叉点数目问题"><a href="#交叉点数目问题" class="headerlink" title="交叉点数目问题"></a>交叉点数目问题</h4><p>在某个范围内，交叉点的数目多一些，破坏的影响随之减弱。但是过多的交叉点数目会导致出现非常大的破坏。    </p><h4 id="均匀交叉（Uniform-crossover）"><a href="#均匀交叉（Uniform-crossover）" class="headerlink" title="均匀交叉（Uniform crossover）"></a>均匀交叉（Uniform crossover）</h4><p>均匀交叉的流程是首先随机对种群中的染色体进行两两配对，和单点交叉不同的是，均匀交叉随机地选择亲代染色体中的某些位置，然后对换亲代染色体上这一位置上的比特值。 与单点交叉相比，均匀交叉的破坏概率不受定义距的影响，均匀交叉的破坏概率为：  </p><script type="math/tex; mode=display">1-（\frac{1}{2}）^{o(H)-1}</script><p>虽然相比于单点交叉均匀交叉的破坏概率更大，但是对于个体数目小的种群，更大的破坏概率能解除信息量小的限制。<br>同时，在采样方式上，相比与单点交叉，理论上均匀交叉能够采集到更多的样本，具体的可由Fig 4 说明。 如果把两个位串中同一位置上的比特值不相同的位置数称为海明距离（Hamming distance），记作$\mathcal{H}$，那么理论上均匀交叉可以产生$2^\mathcal{H}-2$种不同的位串，而单点交叉只能产生$2(\mathcal {H}-1)$种不同的位串。<br><img src="https://img-blog.csdnimg.cn/2019120215430277.gif#pic_center" alt="">  </p><h3 id="简化取代表示"><a href="#简化取代表示" class="headerlink" title="简化取代表示"></a>简化取代表示</h3><p>对于两个位串，将同一位置上比特值相同的地方用“-”表示，不同部分保留的表示方法称为简化取代表示（Reduced surrogates）法。 例如，对于0001111011010011和0001001010010，就可以表示为——11—-1——-1和——00—-0——-0，如图所示。<br><img src= https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210718134138.png width=40% /><br>这样的表示法好处是可以方便的理解这两个位串的重组其实是发生在一个4维空间中的，由于均匀交叉的距离无关性，可以发现对亲代的破坏就发生在这些点上，因此可以将均匀交叉简化为在这种表示方法下的一点交叉。  其次，如果至少一个交叉点存在于这种表示方法的第一个确定字符和最后一个确定字符之间，那么能够保证交叉结果绝对不同于亲代，这意味着能够在这个空间内采到新的样本。   </p><h3 id="种群大小"><a href="#种群大小" class="headerlink" title="种群大小"></a>种群大小</h3><p>低阶的超平面拥有比较高的采样率。一个采样空间可被划分为$2^iC_L^i$个$i$阶的超平面。超平面的数量与研究种群大小$N$和遗传算法能够采样到的超平面数有关。通常认为超平面的数量与一开始的随机种群中的个体数量是一个指数关系：在$N$大小的种群里，$i$阶的超平面大约会被采集到$(\frac{1}{2})^i N$个样本。  </p><h4 id="N-3-理论"><a href="#N-3-理论" class="headerlink" title="$N^3$理论"></a>$N^3$理论</h4><p>$N^3$理论认为，当种群大小为$N$时，遗传算法处理的有效超平面个数为$N^3$。  记$\theta$为至少复制$\phi$次后种群中超平面的最高阶数，$\theta=log_2(\frac{N}{\phi})$，那么有采样空间中$\theta$阶的超平面总数一定大于等于遗传算法处理的超平面个数：  </p><script type="math/tex; mode=display">2^\theta C_L^\theta \geq N^3</script><p>长度为$L$的模式总数为$3^L$。根据上述理论，如果选用$N=3^L$，那么至多有$N$个超平面可以被遗传算法处理。  因此种群大小要根据$L$进行选择。  </p><h3 id="模式理论的局限性"><a href="#模式理论的局限性" class="headerlink" title="模式理论的局限性"></a>模式理论的局限性</h3><ol><li>忽略了gains和低估了losses的影响。  </li><li>当搜索逐渐聚拢在一些特定的超平面的子空间内时，观察到的超平面$H$的适应度会有巨大变化。因此取平均适应度为分母的方法仅在前几代可行。  </li><li>字符串采样的偏差使得用模式理论计算并预测结果并不可行。  </li></ol><p>总而言之，模式定理没有为遗传算法的行动轨迹提供确切的描述，也无法预测特定超平面是如何随着时间的推移而处理的。</p><h2 id="具体的标准遗传算法模型"><a href="#具体的标准遗传算法模型" class="headerlink" title="具体的标准遗传算法模型"></a>具体的标准遗传算法模型</h2><p>下述内容中提出了一种利用标准遗传算法思路的算法模型，这种算法模型解决模式理论的局限性，并对模式理论进行一些定量计算。<br>还原模式定理推导的第一步：  </p><script type="math/tex; mode=display">M(H,t+1)=(1-p_c)M(H,t) \frac{f(H,t)}{\overline{f}} +p_c [M(H,t)\frac{f(H,t)}{\overline{f}}(1-losses)+gains]</script><p>现在从个体的视角来看，设某一个位串$Z$在下一代中被留下的概率为$P(Z,t+1)$，上述式子可以改写成：  </p><script type="math/tex; mode=display">P(Z,t+1)=P(Z,t)\frac{f(Z,t)}{\overline{f}}(1-\{p_c losses\})+\{p_c gains\}</script><p>如果将这个式子应用于搜索空间中的每一个个体，那么就能够将遗传算法进行定性的计算。  </p><h3 id="损失和增益"><a href="#损失和增益" class="headerlink" title="损失和增益"></a>损失和增益</h3><p>在交叉的过程中，损失来源于两个亲本在交叉后子代为现有种群中没有的新位串，（此时认为由于交叉后亲本没有被保留，因此原有的亲本信息受到了损失），而增益来源于两个亲本在交叉后产生的子代与现有种群中的另一亲本相同（相当于现有种群中的某一个位串被复制了一次）。<br>对于某一个个体而言，损失和增益都是可以被计算的，下述一例：<br>令$Z=000$，其损失可以按照如下方式计算：  </p><script type="math/tex; mode=display">losses=P_{I0}\frac{f(111,t)}{\overline{f}}P(111,t)+P_{I0}\frac{f(101,t)}{\overline{f}}P(101,t)+P_{I1}\frac{f(110,t)}{\overline{f}}P(110,t)+P_{I2}\frac{f(011,t)}{\overline{f}}P(011,t)</script><p>$P_{I0}$:表示在与000进行交叉时，任何一位中出现交叉的概率，$P_{I0}=1$<br>$P_{Ii}$:第$i$位与第$i+1$位之间发生交叉的概率。  </p><p>增益也可以用同样的方式进行计算。  </p><p>这种计算方式可以由采样空间$S$中的每一个位串$S_i$与目标位串$Z$做异或运算求得。  </p><blockquote><p>$S_i$表示$S$中的位串按照特定顺序进行排列后的第$i$个位串，未作特殊说明时，这个排列顺序为从0依次+1。即：$S_0=0_{2(二进制)}$，$S_i=i_2$。</p></blockquote><h3 id="标准形式下单点交叉的损失"><a href="#标准形式下单点交叉的损失" class="headerlink" title="标准形式下单点交叉的损失"></a>标准形式下单点交叉的损失</h3><p>形如：0000000000与0010000100，如果两个位串$B$,$B’$满足如下条件：  </p><script type="math/tex; mode=display">B:相同-b-相同-b-相同</script><script type="math/tex; mode=display">B':相同-b'-相同-b'-相同</script><p>相同：$B$和$B’$在这些位置上的比特是相同的。  </p><p>如果$Z$与$S_i$满足这样的关系，那么在第二个相同部分发生的交叉必然会导致亲本信息的损失。因此$Z$与某个特定的$S_i$进行单点交叉发生损失概率可以写作：</p><script type="math/tex; mode=display">\frac{δ(S_i)}{L-1}</script><p>$δ(S_i)$:表示$Z$与$S_i$的最大连续相同部分的比特数。  </p><p>$Z$在搜索空间$S$中由单点交叉产生的损失（总概率）可以描述为：  </p><script type="math/tex; mode=display">losses=∑\frac{δ(S_i)}{L-1}\frac{f(S_i,t)}{\overline{f}}P(S_i,t)</script><h3 id="单点交叉的增益"><a href="#单点交叉的增益" class="headerlink" title="单点交叉的增益"></a>单点交叉的增益</h3><p>要想让两个位串通过交叉产生位串$Z$，那么以位串中的某一个位置为断点，其中一个位串在这个断点之前的部分与$Z$完全相同，另一个位串在这个断点之后的部分与$Z$完全相同。   </p><p>具体而言：如果两个位串$S_{α+x}$和$S_{ω+y}$，其中$S_{α+x}$在第$α-1$位置之前与$Z$连续相同，$S_{ω+y}$在第$L-ω$位置之后与$Z$连续相同，记$ρ(S_{α+x},S_{ω+y})$表示$S_{α+x}$和$S_{ω+y}$重叠部分的长度，那么两个位串在重叠部分发生交叉则必然会生成$Z$，因此这两个位串交叉产生$Z$的概率为：  </p><script type="math/tex; mode=display">\frac{ρ(S_{α+x},S_{ω+y})}{L-1}</script><p>所以$Z$在$S$中由单点交叉产生的增益（总概率）可以描述为：  </p><script type="math/tex; mode=display">gain=∑\frac{ρ(S_{α+x},S_{ω+y})}{L-1}\frac{f(S_{α+x},t)}{\overline{f}}P(S_{α+x},t)\frac{f(S_{ω+y},t)}{\overline{f}}P(S_{ω+y},t)</script><h3 id="概率矩阵"><a href="#概率矩阵" class="headerlink" title="概率矩阵"></a>概率矩阵</h3><p>Vose和Liepins将$S$中两个位串$S_i$与$S_j$生成$S_0$的概率进行了矩阵化，下面是其矩阵化的步骤：<br>设$s^t$为一个向量，这个向量表示第$t$代$S$空间中每一个位串被选择的概率，$s_i^t$表示第$t$代中位串$S_i$被选择的概率，通常认为这个概率与适应度和前一次选择的概率之积成正比：  </p><script type="math/tex; mode=display">s_i^t = kP(S_i,t)f(S_i),k>0</script><p>那么$S_k$被选择出来的概率的期望值可以用如下公式来表示：  </p><script type="math/tex; mode=display">E(p_k^{t+1})=∑s^t_is_j^tr_{i,j}(k)</script><p>$r_{i,j}(k)$:$S_i$与$S_j$交叉产生$S_k$的概率。<br>$r_{i,j}(0)$可以用概率矩阵$M$表示，其中行表示$S_i$，列表示$S_j$，$m_{i,j}=r_{i,j}(0)$，即$S_i$与$S_j$产生$S_0$的概率。  </p><h4 id="M-的特性"><a href="#M-的特性" class="headerlink" title="$M$的特性"></a>$M$的特性</h4><ol><li>$M$的第0行和第0列表示的概率都是损失发生的概率</li><li>$M$除了$m_{0,0}=1$在对角线上的其它值都为0  </li><li>$M$是一个对称矩阵</li></ol><h4 id="向量化"><a href="#向量化" class="headerlink" title="向量化"></a>向量化</h4><p>$s^{t+1}$可以用$M$进行表示： </p><script type="math/tex; mode=display">E(s^{t+1})=s^TMs</script><p>将$M$的上三角部分全部归零，得到矩阵$M’$，通过之前的分析，$M’$的第一列表示$s_0$的损失，而$s_i=P(S_i,t)\frac{f(S_i,t)}{\overline{f}}$，有：  </p><script type="math/tex; mode=display">S^TM'(:,1)s_0=P(S_0,t)\frac{f(S_0,t)}{\overline{f}}(1-losses)</script><p>记向量$\sigma$有：  </p><script type="math/tex; mode=display">σ_j<s_0,...s_{2^L-1}^T>=<s_{j⊕0},...s_{j⊕2^L-1}^T></script><p>记$\mathcal{M}(s)$：  </p><script type="math/tex; mode=display">\mathcal{M}(s)=<(σ_0s)^TMσ_0s,...,(σ_{V-1}s)^TMσ_{V-1}s>^T</script><p>矩阵$F$为对角线是$f(i)$的对角矩阵，有：  </p><script type="math/tex; mode=display">s^{t+1}=kFM(s^t),k>0</script><h2 id="其他进化模型"><a href="#其他进化模型" class="headerlink" title="其他进化模型"></a>其他进化模型</h2><p>除了标准进化模型之外，还有一些其他的进化模型。大致可分为进化策略(Evolutionary Strategies,ES)和进化编程(Evolutionary Programming,EP)两种。<br>进化编程中每一个个体是一个有限状态机（Finit-state machine），在此不做过多叙述。<br>进化策略中细分为两种类型：$(μ+λ)-ES$和$(μ,λ)-ES$。<br>在$(μ+λ)-ES$机制中，亲代$μ$产生后代$λ$后，种群还会对亲代和后代共同进行选择，选择其中表现出色的个体生成下一代。在这种选择机制下，亲代会被保留直到被比亲代表现更出色的个体替代。<br>在$(μ,λ)-ES$机制中，后代被产生后就直接替代亲代，选择在后代中执行。这种进化机制在选择阶段与经典遗传算法近似。但是在重组阶段所采用的算子与经典遗传算法不同。<br>$(μ+λ)-ES$机制相比于$(μ,λ)-ES$机制，其被优化的后代数目一定是单调增加的。  </p><h3 id="Genitor-算法"><a href="#Genitor-算法" class="headerlink" title="Genitor 算法"></a>Genitor 算法</h3><p>Genitor算法是一种使用$(μ+λ)-ES$机制的算法，其与经典遗传算法中的进化模型不同点有三处。  </p><ol><li>选择在亲代中执行，选择后的亲代产生的后代被立即投放到下一代种群中。  </li><li>后代不会替代亲代，但是每一代中适应度最差的个体被直接移除以加强选择压力。  </li><li>适应度函数通过排名算法（Ranking）而非比值来表现。排名也同样能够保持选择压力的有效性。  <blockquote><p>排名算法：<br>设三个个体的适应度评估为：$h_1,h_2,h_3$.<br>首先对所有个体按照适应度从小到大排序，比如：$h_2,h_1,h_3$;<br>按照上面的顺序重新赋予fitness，即$f(h_2)=1,f(h_1)=2,f(h_3)=3$<br>计算选择概率:$p(h_2)=\frac{1}{1+2+3}=\frac{1}{6},p(h_1)=\frac{2}{6},p(h_3)=\frac{3}{6}$  </p></blockquote></li></ol><h3 id="CHC-算法"><a href="#CHC-算法" class="headerlink" title="CHC 算法"></a>CHC 算法</h3><p>CHC算法是另一种能够单调选择位串的算法，CHC指Cross-generational elitist selection, Heterogenous recombination, Cataclysmic mutation。<br>Genitor算法是一种使用$(μ+λ)-ES$机制的算法，具体的执行过程为：<br>在重组之后，亲代和子代中最好的$N$个个体生成中间种群，由于这样的选择已经能够制造足够的压力，因此CHC直接采用随机选择的方式从这个中间种群中进行挑选。同时，选择后的中间种中，海明距离远的两个个体才被允许进行繁殖。<br>在突变阶段，除了选择出来的优秀个体外，其余所有的个体都要经历相当大的突变，再进行交叉。   </p><h3 id="Hybrid-算法"><a href="#Hybrid-算法" class="headerlink" title="Hybrid 算法"></a>Hybrid 算法</h3><p>Hybrid算法在个体编码时直接用实数进行编码，而非二进制数。其次，每个个体都在进行局部爬山算法（Local hill-climbing）来改善自身，产生后代之后，后代做爬山算法。<br>Hybrid算法通过这种多点局部搜索的方式使得搜索变得高效，局部爬山算法能够帮助改善染色体，但是不会对后代有太大的变化。基于上述特性，Hybrid算法在优化问题中的表现比较出色。  </p><blockquote><p>局部爬山算法：从当前的节点开始，和周围的邻居节点的值进行比较。 如果当前节点是最大的，那么返回当前节点，作为最大值 ( 既山峰最高点 ) ；反之就用最高的邻居节点来，替换当前节点，从而实现向山峰的高处攀爬的目的。如此循环直到达到最高点。</p></blockquote><h2 id="并行遗传算法"><a href="#并行遗传算法" class="headerlink" title="并行遗传算法"></a>并行遗传算法</h2><p>使用锦标赛算法（Tournaments）对现有种群进行选择就可以实现经典遗传算法的并行化。</p><blockquote><p>锦标赛算法：  </p><ol><li>确定每次选择的个体数量N。（二元锦标赛选择即选择2个个体）</li><li>从种群中随机选择N个个体(每个个体被选择的概率相同) ，根据每个个体的适应度值，选择其中适应度值最好的个体进入下一代种群。</li><li>重复步骤(2)多次（重复次数为种群的大小），直到新的种群规模达到原来的种群规模。<br>锦标赛算法相当于是有噪声的排序算法。  </li></ol></blockquote><p>具体的实现方法有两种模型：岛模型（island，图左）和细胞模型（cellular，图右）。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210718134422.png width=50%>  </p><h3 id="岛模型"><a href="#岛模型" class="headerlink" title="岛模型"></a>岛模型</h3><p>岛模型将一个大种群均分为多个小种群，称为亚种（Sub-population），每个小种群中进行选择，并且每隔几代就将小种群中的一部分个体与另外的小种群中的个体进行交换，这个过程称为迁徙（migration）。<br>迁徙的目的是为了让小种群之间能够部分地交换基因信息。通过迁徙，岛模型更能挖掘每一个亚种内部的信息差异。  </p><h3 id="细胞模型"><a href="#细胞模型" class="headerlink" title="细胞模型"></a>细胞模型</h3><p>细胞模型将若干个简单处理元（processor）放在网格中，每一个处理单元处理一个位串，并且选择其相邻的单元中最优的位串，或者以一定概率选择相邻的某个位串与其进行配对，并且产生新的位串。  两个距离远的位串是无法进行配对的，这样的设定模拟了生物学上的地理隔离。  在几代之后，网格中会出现许多适应度接近的团块，随着进化的推进和选择的压力，这些团块的规模会随着适应度变大或者变小。</p>]]></content>
    
    
    <categories>
      
      <category>遗传算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>天线知识点总结</title>
    <link href="/2021/07/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%A9%E7%BA%BF%E4%B8%8E%E9%80%9A%E4%BF%A1%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86/%E5%A4%A9%E7%BA%BF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <url>/2021/07/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%A9%E7%BA%BF%E4%B8%8E%E9%80%9A%E4%BF%A1%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86/%E5%A4%A9%E7%BA%BF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a>知识点总结</h1><blockquote><p>author: Kigha Oreki/ Hikari Kobayashi （<a href="https://www.zhenglinblog.top/">Hikari Kobayashi的博客</a>）</p></blockquote><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220407141913.png width=100%></p><h2 id="基本理论"><a href="#基本理论" class="headerlink" title="基本理论*"></a>基本理论*</h2><h3 id="传输线模型"><a href="#传输线模型" class="headerlink" title="传输线模型"></a>传输线模型</h3><p>传输线模型中的幅值电压反射系数$Γ$：</p><script type="math/tex; mode=display">Γ=\frac{Z_L-Z_0}{Z_L+Z_0}</script><p>其中$Z_L$为天线负载的阻抗，$Z_0$为传输线上的阻抗。<br>驻波比：  </p><script type="math/tex; mode=display">SWR=\frac{V_{max}}{V_{min}}</script><h3 id="麦克斯韦方程组·平面波理论"><a href="#麦克斯韦方程组·平面波理论" class="headerlink" title="麦克斯韦方程组·平面波理论"></a>麦克斯韦方程组·平面波理论</h3><p>真空中的特征阻抗：$η_0=√\frac{μ_0}{ϵ_0}=120π$<br>波数：$k=\frac{2π}{λ}=ω√{μ_0ϵ_0}$<br>E和H的关系:$H=\frac{1}{2η}|E|$  </p><h2 id="天线基础知识"><a href="#天线基础知识" class="headerlink" title="天线基础知识"></a>天线基础知识</h2><h3 id="天线的方向图"><a href="#天线的方向图" class="headerlink" title="天线的方向图"></a>天线的方向图</h3><p>HPBW(Half-Power Beamwidth)： $U(2θ_{HPBW})=0.707U$（对应下降3dB）<br>FNBW(First-Null Beamwidth): $U(2θ_{FNBW})=0$</p><h3 id="天线的远场区"><a href="#天线的远场区" class="headerlink" title="天线的远场区"></a>天线的远场区</h3><script type="math/tex; mode=display">\frac{2D^2}{λ}</script><h3 id="天线的能量"><a href="#天线的能量" class="headerlink" title="天线的能量"></a>天线的能量</h3><ul><li>平均能量密度<script type="math/tex; mode=display">W_(av)=\frac{1}{2}Re[E×H^*]=\frac{1}{2η}|E|^2</script></li><li>平均辐射强度<script type="math/tex; mode=display">U=r^2W_{av}</script></li><li>平均能量<script type="math/tex; mode=display">P_{rad}=∯W_{rad}ds=∯UdΩ=∫_0^{2π}∫_0^{π}W_{rad}r^2sinθdθdφ</script></li></ul><div class="note note-warning">            <p>注意积分的上下限，题目没有给出的情况下： $θ:0-π,φ:0-2π$  </p>          </div><ul><li><p>方向性</p><script type="math/tex; mode=display">D=\frac{U}{U_0}=\frac{4πU}{P_{rad}}</script></li><li><p>有效面积</p><script type="math/tex; mode=display">A_{em}=\frac{λ^2}{4π}D_{max}</script></li></ul><ul><li><p>辐射阻抗</p><script type="math/tex; mode=display">P_{rad}=\frac{1}{2}I^2R_r</script></li><li><p>输入阻抗</p><script type="math/tex; mode=display">\frac{1}{2}I_{in}^2R_{in}=\frac{1}{2}I^2R_r+P_{waste}</script><p>当$P_{waste}=0$时，对偶极子天线有$I_{in}=I_0sin(\frac{kl}{2})$。<br>$R_{in}=\frac{R}{sin^2(\frac{kl}{2})}$。<br>当偶极子天线长度$l=\frac{λ}{2}$时，输入转发射的效率最高。  </p></li></ul><h3 id="天线的效率"><a href="#天线的效率" class="headerlink" title="天线的效率"></a>天线的效率</h3><script type="math/tex; mode=display">e=e_re_{cd}</script><p>$e_r$：由传输线模型反射（reflection）所造成的损失产生的效率：$e_r=1-|Γ|^2=\frac{P_{avg}}{P_{input}}$<br>天线的增益：</p><script type="math/tex; mode=display">G=e_{cd}D</script><p>考虑传输线模型中的反射：  </p><script type="math/tex; mode=display">G_{realize}=e_re_{cd}D=(1-|Γ|^2)G</script><h3 id="天线的极化"><a href="#天线的极化" class="headerlink" title="天线的极化"></a>天线的极化</h3><p>单个天线的极化方式：a) 线极化 b) 圆极化 c) 椭圆极化<br>极化适配：如果波的极化方向$\hat{ρ_w}$和天线的极化方向$\hat{ρ_a}$不相同，波的接收会有损失，定义<strong>极化损失因子</strong>（PLF）或<strong>极化效率</strong>：</p><script type="math/tex; mode=display">PLF=|cosφ_p|^2</script><p>$φ_p$为$\hat{ρ_w}$与$\hat{ρ_a}$的夹角，如图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220407135201.png width=50%><br>当两天线正交时，理论上接收不到任何电磁波。当两天线重合时，极化效率最高。  </p><div class="note note-info">            <p>天线的互易性*：同一个天线在作为发射或接收天线时所有性质不变。   </p>          </div>  <h2 id="偶极子天线"><a href="#偶极子天线" class="headerlink" title="偶极子天线"></a>偶极子天线</h2><h3 id="辅助位函数"><a href="#辅助位函数" class="headerlink" title="辅助位函数"></a>辅助位函数</h3><script type="math/tex; mode=display">A=\frac{μ_0Il}{4πr}e^{-jkr}\hat{e_z}</script><p>由$A=\hat{e_r}A_r+\hat{e_θ}A_θ+\hat{e_φ}A_φ$，有：<br>$\begin{cases}<br>    A_r=A_zcosθ \\<br>    A_θ=-A_zsinθ \\<br>    A_ϕ=0 \\<br>\end{cases}$</p><h3 id="远场区辐射"><a href="#远场区辐射" class="headerlink" title="远场区辐射"></a>远场区辐射</h3><p>由$H=\frac{1}{μ_0}▿×A$：  </p><script type="math/tex; mode=display">H_ϕ=j\frac{Il}{2λr}sinθe^{-jkr}</script><p>由$E=\frac{1}{jωɛ}▿×H$：    </p><script type="math/tex; mode=display">E_θ=j\frac{60πIl}{λr}sinθe^{-jkr}</script><h3 id="能量和方向性"><a href="#能量和方向性" class="headerlink" title="能量和方向性"></a>能量和方向性</h3><script type="math/tex; mode=display">W=\frac{1}{2}Re[E×H^*]=\frac{1}{2η}|E|^2=\frac{15πI_A^2l^2}{λ^2r^2}sin^2θ\hat{e_r}</script><script type="math/tex; mode=display">P=∯WdS=40π^2I^2(\frac{l}{λ})^2</script><script type="math/tex; mode=display">D_0=4π\frac{U_{max}}{P_r}=\frac{3}{2}</script><h2 id="天线阵列"><a href="#天线阵列" class="headerlink" title="天线阵列"></a>天线阵列</h2><h3 id="各向同性天线阵列的参数"><a href="#各向同性天线阵列的参数" class="headerlink" title="各向同性天线阵列的参数"></a>各向同性天线阵列的参数</h3><p>各向同性天线阵列如图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220407135242.png width=50%>    </p><ul><li>阵列因子<br>如图，由$E=∑E_i$:  <script type="math/tex; mode=display">E=\frac{E_0}{r^2}[C_01+C_1e^{-jkr_1}+...]</script><script type="math/tex; mode=display">AF_{norm}=∑_{n}^NC_ne^{j(n-1)(kdcosθ+β)}</script><script type="math/tex; mode=display">AF_{norm}=\frac{sin(\frac{N}{2}φ)}{sin(\frac{1}{2}φ)}</script></li></ul><div class="note note-warning">            <p>n=0的天线（参考天线）位于原点，如果负半轴有天线，n应当从负数开始加起。  </p>          </div><p>$d$:两个天线的间距，$β$:两个天线的相位差(对偶极子天线来说为0)，$C_n$为激活常数（默认为1）  </p><ul><li><p>平均辐射强度（归一化）</p><script type="math/tex; mode=display">U_{norm}=AF_{norm}^2</script></li><li><p>最大方向性</p><script type="math/tex; mode=display">D_0=2N(\frac{d}{λ})</script></li></ul><h3 id="天线阵列的方向图"><a href="#天线阵列的方向图" class="headerlink" title="天线阵列的方向图"></a>天线阵列的方向图</h3><p>方向图的最大点：  $AF(θ)=AF(θ)_{max}$时的$θ$<br>方向图的零点：  $AF(θ)=0$时的$θ$<br>方向图的半波宽度： $AF_{norm}|θ_{3db}=0.707,Θ_{hpbw}=2|θ_{max}-θ_{3dB}|$</p><h2 id="线天线"><a href="#线天线" class="headerlink" title="线天线"></a>线天线</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><h4 id="环形天线"><a href="#环形天线" class="headerlink" title="环形天线"></a>环形天线</h4><p>环形天线根据电尺寸分为两类： 电大天线和电小天线。<br>电大天线的周长近似于波长，电小天线的波长小于0.1个波长。    </p><h4 id="螺旋天线"><a href="#螺旋天线" class="headerlink" title="螺旋天线"></a>螺旋天线</h4><ul><li><p>正常模式（Normal）<br>当每一节螺旋的长度$L_0&lt;&lt;λ$时，螺旋天线可以视作是偶极子天线和环形天线的组合。<br>螺旋天线的轴比：   </p><script type="math/tex; mode=display">AR=\frac{|E_θ|}{|E_ϕ|}=\frac{2λs}{(πD)^2}</script><p>$s$:相邻螺旋的高度差，$D$:螺旋天线一个螺旋（圆部分）的直径。<br>当螺旋天线的轴比为0时，螺旋天线是线极化的。<br><strong>正常模式下，整个螺旋线长度上的电流是恒定大小和相位的。由于其尺寸决定了天线的辐射特性，其辐射阻值$R_r$非常大，容易造成阻抗不匹配，且带宽很窄，辐射效率低下，方向性也比较差。</strong></p></li><li><p>端射模式（End-fire）<br>螺旋天线一个螺旋（圆部分）的周长为$C$，当$C≈λ,S≈\frac{λ}{4}$时，螺旋天线视为端射模式。  <strong>端射模式的带宽比较宽，因此端射模式的辐射效率比较高。在端射模式下，天线的方向性非常的好。</strong>  </p></li></ul><h4 id="八木天线"><a href="#八木天线" class="headerlink" title="八木天线"></a>八木天线</h4><p>八木天线的结构和方向图如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220407142225.png width=50%>   </p><p>八木天线的结构：<br>反射子：反射电磁波。<br>驱动子： 发射电磁波，其长度通常略小于$0.5λ$(0.45-0.49)，通常是一个环形天线用于阻抗匹配。<br>方向子： 通过感性电流扩大辐射，其长度通常略小于$0.5λ$（0.4-0.45）。<br>通常方向子的间距在$0.3λ-0.4λ$之间。   </p><h2 id="非频变天线"><a href="#非频变天线" class="headerlink" title="非频变天线"></a>非频变天线</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>非频变天线指电磁波频率对其辐射性质（方向图，前后比，输入阻抗等）变化不大的一类天线。<br>天线的一系列物理边缘$r$可以与一系列频率的电磁波产生谐振。对于非频变天线，如果其第一个边缘$r$的表达式为$r=F(θ,ϕ)$，当后续边缘的表达式满足：  </p><script type="math/tex; mode=display">KF(θ,ϕ)=F(θ,ϕ+C)</script><p>其中K表示为第一个K倍大的电尺寸，C为第二个边缘旋转C角，如此旋转角度C取决于K而不取决于$θ$或者是$ϕ$，进而实现频率无关。<br>对其两边求微分后解得$r=e^{aϕ}f(θ)$，所有边缘满足该表达式的天线是非频变天线。  </p><h3 id="类型-1"><a href="#类型-1" class="headerlink" title="类型"></a>类型</h3><ul><li>平面等角螺旋天线(Planar Spiral Antenna)  </li><li>锥形等角螺旋天线(Conical Spiral Antenna)  </li><li>阿基米德螺旋天线  </li><li>对数周期天线  </li></ul><h4 id="等角螺旋天线"><a href="#等角螺旋天线" class="headerlink" title="等角螺旋天线"></a>等角螺旋天线</h4><p>因为等角螺旋的表面几何形状可以用$f(\theta)$来表示，所以它可以被设计为一个频率无关天线。<br>对于等角螺旋天线，取特殊值时，它的半径为：  </p><script type="math/tex; mode=display">r = \rho = Ae^{a\phi}=\rho_0 e^{a(\phi-\phi_0)}</script><p>以波长记时，  </p><script type="math/tex; mode=display">\rho_\lambda = Ae^{a[\phi + \ln(\lambda)/a]}</script><p>所以，改变$\lambda$即改变$\phi_0$，结果方向图只是单纯的旋转而其它不变，所以我们得到的时频率无关天线。</p><p>螺旋总长的计算式*  </p><script type="math/tex; mode=display">L=(\rho_1 - \rho_0)\sqrt{1+\frac{1}{a^2}}</script><p>等角螺旋辐射的波的极化由臂长来控制，全臂长和波长相比很小时，辐射场是线极化的，全臂长与波长相比不断增高时会从椭圆极化最终变成圆极化。实际应用中大多数会选轴比等于或小于$2:1$的点，它发生在全臂长约一个波长的时候。  </p><h4 id="对数周期天线"><a href="#对数周期天线" class="headerlink" title="对数周期天线"></a>对数周期天线</h4><p>另一个频率无关的天线时对数周期天线，但是，它的形状不能由角度来描述，所以其实它不是真正的频率无关。<br>对数周期的结构形状可以写成：  </p><script type="math/tex; mode=display">\theta = \theta_0 \sin [b\ln(\frac{r}{r_0})]</script><p>只要角频率的对数相差$2\pi/b$，那么$\theta$就会重复，所以叫做对数周期天线。<br>虽然它不是严格频率无关，但是实际应用中把振幅变化设计的很小，所以看成是频率无关的。<br>最后，对数周期天线是线极化的。  </p><h2 id="微带天线"><a href="#微带天线" class="headerlink" title="微带天线"></a>微带天线</h2><h3 id="辐射原理"><a href="#辐射原理" class="headerlink" title="辐射原理"></a>辐射原理</h3><p>当微带天线的贴片宽度$W$与基底高度$h$之比$\frac{W}{h}&gt;&gt;1$，并且$ɛ_r&gt;&gt;1$时，磁场从基底溢出（微带天线通过这样的磁场泄漏来发射电磁波），因此微带天线的电尺寸要大于实际尺寸，称之为边界效应。<br>在计算时，将电池溢出的部分和天线的基底一同视作新的基底，其等效介电常数为$ɛ_{reff}$。   </p><script type="math/tex; mode=display">1<ɛ_{reff}<ɛ_r</script><h3 id="馈电方式"><a href="#馈电方式" class="headerlink" title="馈电方式"></a>馈电方式</h3><p>微带天线有四种馈电方式:  </p><ul><li>微带传输线馈电（Microstrip line feed） </li><li>探针馈电（Probe feed）  </li><li>耦合孔馈电（Aperture-coupled feed）  </li><li>耦合馈电（Proximity-coupled feed）  </li></ul><p>如下图所示：  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220407135926.png width=50%><br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220407135951.png width=50%>   </p><p>四种馈电方式的等效电路为：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220407140048.png width=50%>  </p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>微带天线的结构如下图所示：<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220407140125.png width=50%>  </p><h2 id="孔径天线"><a href="#孔径天线" class="headerlink" title="孔径天线"></a>孔径天线</h2><p>由于直接求解孔径天线是非常复杂的，所以需要用等效方法和惠更斯原理来进行求解。  </p><h3 id="等效"><a href="#等效" class="headerlink" title="等效"></a>等效</h3><p>等效是指用一个封闭的平面将原来的辐射场包围起来，然后在封闭面上放置满足边界条件的适当的电流和磁流密度（电流元和磁流元）。这时边界上的电流和磁流可以唯一确定边界内的场，得到一个等效。  <img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220407140226.png width=50%>  </p><p>具体而言，如上图所示，假设孔径天线的波导处电场方向$E_a$向$z$轴方向，根据惠更斯原理假设电流元向$-x$轴方向，那么$J_s=0$。考虑镜像原理，$M_s=-2\hat{n}×E_a$。<br>因此口径天线的电流密度和磁流密度可以等效为：   </p><script type="math/tex; mode=display">\begin{cases}  J_s=0 \\  M_s=-2\hat{n}×E_a \\\end{cases}</script><p>$\hat{n}$: 如图的$y$方向上的单位向量</p><h3 id="惠更斯原理"><a href="#惠更斯原理" class="headerlink" title="惠更斯原理"></a>惠更斯原理</h3><p>波前上每一点都可以看成是一个次级波的新波源。所以在等效过后，就可以通过惠更斯原理求出原辐射源在封闭面外的辐射。  </p><h2 id="喇叭天线"><a href="#喇叭天线" class="headerlink" title="喇叭天线"></a>喇叭天线</h2><h3 id="相移"><a href="#相移" class="headerlink" title="相移"></a>相移</h3><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220407140343.png width=50%>  </p><p>如图为喇叭天线的侧视图，到达$x’$的平面波之间的相位差是由距离的不同$δ$产生的，$δ$与高度$y’$有关，记为$δ(y’)$，称为波程差（Spherical phase term）。<br>根据如图的几何关系，有：  </p><script type="math/tex; mode=display">[ρ_1+δ(y')]^2=ρ_1^2+y'^2</script><p>化简得到$δ(y’)=\frac{1}{2}(\frac{y’}{ρ_1})^2$。<br>则波的相位差为：<br>$ΔΦ=kδ(y’)$<br>其中$k$为相位常数，在数值上等于波数。  当$y’=\frac{1}{2}b_1$时$δ(y’)$取最大值。  </p><h2 id="反射天线"><a href="#反射天线" class="headerlink" title="反射天线"></a>反射天线</h2><h3 id="抛物面天线"><a href="#抛物面天线" class="headerlink" title="抛物面天线"></a>抛物面天线</h3><p>由于抛物面有从焦点到抛物面上任意一点的长度与该点到准线的长度之和始终为定值的特性，因此以焦点为馈电点，到准线的所有电磁波都是平面波。<br>前馈的抛物面天线有两种：抛物柱面（Parabolic cylinder）天线和抛物面天线（Paraboloid）。  </p><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">振幅函数</th><th style="text-align:center">馈电源</th><th style="text-align:center">极化方式</th></tr></thead><tbody><tr><td style="text-align:center">抛物柱面天线</td><td style="text-align:center">与$\frac{1}{ρ}$ 呈正比</td><td style="text-align:center">线形（通常是偶极子天线）</td><td style="text-align:center">只有线极化</td></tr><tr><td style="text-align:center">抛物面天线</td><td style="text-align:center">与$\frac{1}{r^2}$呈正比</td><td style="text-align:center">点</td><td style="text-align:center">任何极化</td></tr></tbody></table></div><p>与抛物面天线相比，抛物柱面天线的机械结构简单，能提供较大的口径阻挡，没有抛物面天线的吸引特性。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220407140704.png width=50%>  </p><h3 id="透镜天线"><a href="#透镜天线" class="headerlink" title="透镜天线"></a>透镜天线</h3><p>透镜天线的使用频率在1000MHz以上，在3000MHz以上工作效果会更好。  </p><ul><li><p>优点  </p><ul><li>馈电点和支撑不妨碍传播 </li><li>更大的设计公差（Design tolerance）  </li><li>可以处理比抛物面天线更多的波  </li></ul></li><li><p>缺点  </p><ul><li>笨重 </li><li>设计复杂  </li><li>比同尺寸的抛物面天线贵  </li></ul></li></ul><ul><li>应用  <ul><li>宽带天线  </li><li>微波传输 </li></ul></li></ul><h2 id="传输基本原理"><a href="#传输基本原理" class="headerlink" title="传输基本原理"></a>传输基本原理</h2><h3 id="传输过程的基本参数"><a href="#传输过程的基本参数" class="headerlink" title="传输过程的基本参数"></a>传输过程的基本参数</h3><p>真空中的特征阻抗：$η_0=\sqrt{\frac{μ_0}{ϵ_0}}=120π$<br>波数：$k=\frac{2π}{λ}=ω\sqrt{μ_0ϵ_0}$<br>通信链路公式：  </p><script type="math/tex; mode=display">P_L=(\frac{λ}{4πr})^2P_{in}G_rG_t</script><h3 id="自由空间传播损耗"><a href="#自由空间传播损耗" class="headerlink" title="自由空间传播损耗"></a>自由空间传播损耗</h3><script type="math/tex; mode=display">L_{fb}=10lg\frac{P_t}{P_r}=-20lg\frac{4πd}{λ}</script><script type="math/tex; mode=display">L_{fb}|_{dB}=32.4+20lgf[MHz]+20lgd[km]</script><p>$d$：传输距离，$f$：电磁波频率  </p><h3 id="菲涅尔区"><a href="#菲涅尔区" class="headerlink" title="菲涅尔区"></a>菲涅尔区</h3><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220407141002.png width=50%>  </p><p>如图，第n菲涅尔区满足条件：  </p><script type="math/tex; mode=display">l-d=n\frac{λ}{2}</script><p>当$d_1,d_2&gt;&gt;λ$时，原式可以化简为： </p><script type="math/tex; mode=display">F_n=\sqrt{\frac{nd_1d_2λ}{d_1+d_2}}</script><p><strong>菲涅尔区允许最大的侵占体积为整个菲涅尔区的40%，侵占体积最好不要超过整个菲涅尔区的20%。</strong>  </p><h2 id="移动通信"><a href="#移动通信" class="headerlink" title="移动通信"></a>移动通信</h2><p>移动通信面临的问题是动态且多变的，具体表现为：  </p><ul><li>环境和信号都随着时间不断变化  </li><li>这样的变化是毫无规律的  </li></ul><h3 id="衰落"><a href="#衰落" class="headerlink" title="衰落"></a>衰落</h3><p>移动通信中的衰落主要有两种：  </p><ul><li>长期衰落：在传播中的微小变化通过时间积累后被放大。  </li><li>短期衰落：传播过程中多次反射/多径效应造成的衰落。<br>短期衰落主要来源于: 障碍物的直接遮挡（阴影效应，Shadow）、接收者的移动、地形（Terrain）、链路的不平衡传输（下行数据速率大于上行）等等。  </li></ul><p>因此即使是在同一个点，不同时间接收到的信号的能量和场强等也会变化，其变化规律符合正态分布。接收信号的场强可以用$E_q(dBμV/m)$表示： </p><script type="math/tex; mode=display">E_q=E_m+Q_iσ_L</script><p>$E_m$:该点场强的中值，$Q_i$:指定信号需要覆盖$q\%$的衰落储备(Fade Margin)所对应的指数分布系数，可通过查表找到$q_i$对应$Q_i$，$σ_L(dB)$:标准差。<br>其中定义：  </p><script type="math/tex; mode=display">FM=Q_iσ_L</script><p>称为衰落储备(Fade Margin)。<br>接收端移动天线所接收的能量$P_{rM}$和敏感度$P_{rS}$，衰落储备之间的关系：  </p><script type="math/tex; mode=display">P_{rM}=P_{rS}+FM</script><h3 id="多径效应和多普勒效应"><a href="#多径效应和多普勒效应" class="headerlink" title="多径效应和多普勒效应"></a>多径效应和多普勒效应</h3><p>由于障碍物的存在，实际上接收的电磁波来源有两类：  </p><ul><li>直接接收到的电磁波  </li><li>通过障碍物和地面的反射接收到的电磁波  </li></ul><p>由同一传输信号沿两个或多个路径传播，以微小的时间差到达接收机的信号相互干涉所引起的衰落称之为多径衰落。多径效应对信号的幅值、频率、相位都有很大的影响。<br>多径效应的模型分为三类：静态（接收和发射都静止），半动态（接收运动），动态（接收和发射都运动）。  </p><p>在动态模型中，需要考虑多普勒效应对观察频率$f_d$的影响：  </p><script type="math/tex; mode=display">f_d=f_mcosθ</script><p>$f_m=\frac{V}{λ}$：最大多普勒频率，$θ$:波和运动方向的夹角。  </p><p>多普勒效应会对信号产生频移，不同的多径信号上存在时变的多普勒频移，如果信号由于多普勒效应产生的频移大于信道的时分复用周期，用户将接收不到信号。  </p><h3 id="通信链路"><a href="#通信链路" class="headerlink" title="通信链路"></a>通信链路</h3><p><strong>简单来说，接收的能量等于发射的能量加上传输增益、减去传输损失。</strong><br>通信链路分为上行链路和下行链路，由于上行和下行设备的不同因此需要分开计算。<br>传输损失小的一方覆盖更大，最终链路的覆盖由损失更大的一方决定。  </p><h4 id="上行链路"><a href="#上行链路" class="headerlink" title="上行链路"></a>上行链路</h4><p><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/%5Cimg20210624132416.png" width=60%>  </p><p>如图所示：  </p><script type="math/tex; mode=display">P_{rB}=P_{tM}-L_d-L_p-L_{fM}-L_{fB}+G_t+G_r</script><script type="math/tex; mode=display">P_{rB}+FM=P_{tM}-L_d-L_p-L_{fM}-L_{fB}+G_t+G_r</script><h4 id="下行链路"><a href="#下行链路" class="headerlink" title="下行链路"></a>下行链路</h4><p><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/%5Cimg20210624132502.png" width=60%>  </p><p>下行链路需要用多路耦合器（Multi coupler）将多个用户的信息进行整合，此处会有传输损失$L_c$。<br>如图所示：  </p><script type="math/tex; mode=display">P_{rM}=P_{tB}-L_c-L_d-L_{fB}-L_{fM}+G_t+G_r</script><script type="math/tex; mode=display">P_{rS}+FM=P_{tB}-L_c-L_d-L_{fB}-L_{fM}+G_t+G_r</script><h3 id="区域覆盖预测模型"><a href="#区域覆盖预测模型" class="headerlink" title="区域覆盖预测模型"></a>区域覆盖预测模型</h3><p>区域覆盖预测模型有三种：经验模型（Empirical model）、确定性模型（Deterministic model）、和射线追踪模型/半确定性模型（Physical-statistical/Ray-tracing model）。  </p><div class="table-container"><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">特点</th></tr></thead><tbody><tr><td style="text-align:left">经验模型</td><td style="text-align:left">1.基于实验测量<br> 2.结果通常是基于有限的频率和一些特定的介质 <br> 3.缺乏对无线电波传播机制的物理观点(Physical view)</td></tr><tr><td style="text-align:left">确定性模型/射线追踪模型</td><td style="text-align:left">1.应用十分有限，主要应用于特殊几何结构的情况 <br> 2.对不同情况需要不同的传输路径特性(如ɛ和σ) <br> 3.由于考虑了直射、折射和衍射，因此模型十分复杂 <br> 4.考虑了不同地形的电参数</td></tr><tr><td style="text-align:left">半确定性模型</td><td style="text-align:left">两者的折中方案</td></tr></tbody></table></div><h2 id="电磁波在介质中的实际传输"><a href="#电磁波在介质中的实际传输" class="headerlink" title="电磁波在介质中的实际传输"></a>电磁波在介质中的实际传输</h2><p>在实际情况下，根据电磁波的传输介质，电磁波可以分为：空间波、天波、地表面波三类，其频率、传播环境和应用如下表所示。  </p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">频率</th><th style="text-align:center">传播环境</th><th style="text-align:center">应用</th></tr></thead><tbody><tr><td style="text-align:center">空间波</td><td style="text-align:center">30MHz</td><td style="text-align:center">视距无线传输(Line of sight)</td><td style="text-align:center">微波通信、广播、导航</td></tr><tr><td style="text-align:center">天波</td><td style="text-align:center">3-30MHz</td><td style="text-align:center">电离层(Ionosphere)</td><td style="text-align:center">长距离通信、广播</td></tr><tr><td style="text-align:center">地表面波</td><td style="text-align:center">2MHz</td><td style="text-align:center">地表面</td><td style="text-align:center">短距离通信、报时信号</td></tr></tbody></table></div><h3 id="地表面波"><a href="#地表面波" class="headerlink" title="地表面波"></a>地表面波</h3><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul><li>水平极化的地表面波衰减很大，并没有实用价值。因此基于地表面波的大部分应用都是基于地表面波的垂直极化。 </li><li>向前传输<br>地表面波可以分解为$E_z$和$E_ρ$两个方向上的波，由于$E_z&gt;E_ρ$，因此两者的矢量和始终是向前的。<br>地面以上部分的地表面波是椭圆极化：地表面波由径向分量和垂直分量组成。径向分量相对较小，相位差近似为零，形成椭圆偏振。  </li></ul><h4 id="地表面电参数"><a href="#地表面电参数" class="headerlink" title="地表面电参数"></a>地表面电参数</h4><ul><li>土质  </li><li>湿度  </li><li>温度  </li><li>能量吸收的能力  </li><li>地表面类型对传播的影响</li><li>地表面的导电性越好，传输过程中的衰落就越小。 </li><li>波的频率越高，传输过程中的衰落越大。  </li></ul><h3 id="天波"><a href="#天波" class="headerlink" title="天波"></a>天波</h3><h4 id="大气层结构"><a href="#大气层结构" class="headerlink" title="大气层结构"></a>大气层结构</h4><ul><li>对流层（Troposphere）<br>这一层主要对电波有 吸收、衰减、折射、反射、极化改变、散射等等影响。  </li><li>电离层（Ionosphere）<br>这一层内部有许多的等离子体（plasma）/电离气体（Ionized gas）以防护宇宙射线。<br>电离层能够极大的改变电磁波的电性质。<br>电离层自身处于动态且周期性的变化中。<br>天波主要在这一层进行传播。天波的内部分为多个小层：  </li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">距离</th><th style="text-align:center">注解</th></tr></thead><tbody><tr><td style="text-align:center">D</td><td style="text-align:center">50-70km</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">E</td><td style="text-align:center">70-100km</td><td style="text-align:center">等离子体密度达到最大相对值 <br> 对电波传输的影响白天比晚上强，夏天比冬天强</td></tr><tr><td style="text-align:center">F</td><td style="text-align:center">1000km</td><td style="text-align:center">等离子体密度再次达到相对最大值</td></tr></tbody></table></div><ul><li>在白天F层会分成$F_1$和$F_2$两个子层，在晚上这两层又会重新合并。<br>在白天，D层的下部对中频电波的损失非常的大，因此在中频和高频通信中往往选用频率比较高的电磁波（Lower frequency in MF band）。由于F层在白天分层的特性，中频通信中使用的较低频率的电磁波只能在晚上传输，白天通常传输中频/高频通信中的较高频率的电磁波（Higher frequency in MF band）。  </li></ul><h4 id="电离层中的传播"><a href="#电离层中的传播" class="headerlink" title="电离层中的传播"></a>电离层中的传播</h4><p>定义电离层中的等离子体谐振角频率、频率$ω_p$、$f_p$，那么电离层的介电常数可以由如下公式界定：  </p><script type="math/tex; mode=display">ɛ_r=1-\frac{f_p}{f}</script><p>电离层中的传输常数$k_c$:$k_c=k_0√{1-(\frac{f_p}{f})^2}$  </p><ul><li>垂直发射<br>电离层中的平面波电场可以简化为：$E=E_0e^{-jk_cz}$<br>垂直发射电磁波，当电磁波频率小于$f_c=9√N,N$：等离子体密度时，电磁波将无法穿过电离层并且反射回地球。  </li><li>斜向发射<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220407141555.png width=50%><br>斜向发射电磁波时，这一最大频率取决于电磁波的入射角$Φ$(上图中的$ϕ_i$)和$f_c$，定义斜向发射时的最大可用频率MUF:  <script type="math/tex; mode=display">MUF=f_c×secΦ</script>在发射矢量与地球相切（发射仰角$Δ=0$）时，认为$Φ=74°$<script type="math/tex; mode=display">MUF=f_c×secΦ=3.6f_c</script>由于各种因素的影响，定义最佳电磁波频率OUF：<script type="math/tex; mode=display">OUF=MUF×(50\%-80\%)</script><div class="note note-info">            <p>如果题目中没有告诉百分比，默认取80%  </p>          </div></li></ul><p>实际上，电磁波的斜向传输是通过在地面和电离层之间来回多次反射进行的，每一次反射能跨越的距离主要受三个因素影响：  </p><ul><li>发射频率  </li><li>电磁波的仰角（Elevation angle）  </li><li>电离层中多个小层的变化  </li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>天线与通信传输原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信工程</tag>
      
      <tag>无线通信</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常考知识点总结</title>
    <link href="/2021/06/22/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%80%83%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2021/06/22/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%80%83%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="常考知识点总结"><a href="#常考知识点总结" class="headerlink" title="常考知识点总结"></a>常考知识点总结</h1><blockquote><p>针对Brunel University 2021: EE2622 Fundamentals of Signals and Systems 的期末复习笔记<br>Lecturer: Dr. Ruiheng Wu (武瑞恒)  </p></blockquote><h2 id="信号的基本分类"><a href="#信号的基本分类" class="headerlink" title="信号的基本分类*"></a>信号的基本分类*</h2><p>连续信号：x轴，y轴都连续<br>离散信号：x轴连续的信号<br>数字信号：x轴，y轴都连续的信号</p><ul><li>三角离散信号的采样周期和周期<br>对于离散信号$sin(ω_0n)$，如果其连续信号角频率为$Ω$，其取样为$sin(ω_0n)=sin(ΩTn)$，其周期：<script type="math/tex; mode=display">\frac{2π}{ω_0}=\frac{N_{dis}}{T_{con}}</script>其中$N_{dis}$为离散信号的周期，$T_{con}$为连续信号的周期。  <blockquote><p>如果两者的比值不是一个有理数，那么其离散信号不是一个周期函数。  </p></blockquote></li></ul><h2 id="冲激函数的特性"><a href="#冲激函数的特性" class="headerlink" title="冲激函数的特性"></a>冲激函数的特性</h2><h3 id="冲激函数的特性-1"><a href="#冲激函数的特性-1" class="headerlink" title="冲激函数的特性"></a>冲激函数的特性</h3><div class="table-container"><table><thead><tr><th style="text-align:center">特性</th><th style="text-align:center">公式</th></tr></thead><tbody><tr><td style="text-align:center">赋值性</td><td style="text-align:center">$∫δ(t)f(t)dt=f(0)$</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">$f(t)δ(t)=f(0)δ(t)$</td></tr><tr><td style="text-align:center">偶函数</td><td style="text-align:center">$δ(t)=δ(-t)$</td></tr><tr><td style="text-align:center">缩放</td><td style="text-align:center">$δ(at)=\frac{1}{ ⃒  a ⃒ }δ(t)$</td></tr></tbody></table></div><h3 id="冲激函数的应用"><a href="#冲激函数的应用" class="headerlink" title="冲激函数的应用"></a>冲激函数的应用</h3><p>单位冲激函数可以描述带有间断点函数的倒数。   </p><p>单位冲激函数可以描述门函数的导数。  </p><h3 id="冲激偶函数的特性"><a href="#冲激偶函数的特性" class="headerlink" title="冲激偶函数的特性"></a>冲激偶函数的特性</h3><div class="table-container"><table><thead><tr><th style="text-align:center">特性</th><th style="text-align:center">公式</th></tr></thead><tbody><tr><td style="text-align:center">赋值性</td><td style="text-align:center">$∫δ’(t)f(t)dt=-f’(0)$</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">$f(t)δ’(t)=f(0)δ’(t)-f’(0)δ(t)$</td></tr><tr><td style="text-align:center">奇函数</td><td style="text-align:center">$δ’(t)=-δ’(t)$</td></tr></tbody></table></div><h2 id="信号的表示"><a href="#信号的表示" class="headerlink" title="信号的表示"></a>信号的表示</h2><ol><li>有限重复非周期的信号： 利用时移进行表示  </li><li>“/-”信号（斜坡和阶跃信号的组合）是门信号的积分结果。  </li></ol><h3 id="信号的微分关系"><a href="#信号的微分关系" class="headerlink" title="信号的微分关系"></a>信号的微分关系</h3><script type="math/tex; mode=display">tu(t)→u(t)→δ(t)→δ'(t)</script><div class="note note-info">            <p>$δ(t)$有关的性质都用积分相等进行证明。  </p>          </div><script type="math/tex; mode=display">/-信号→G(t)→δ(t)的组合</script><p><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/%5Cimg20210622105802.png" alt=""></p><h2 id="信号的基本操作"><a href="#信号的基本操作" class="headerlink" title="信号的基本操作"></a>信号的基本操作</h2><h3 id="时移和尺度变换"><a href="#时移和尺度变换" class="headerlink" title="时移和尺度变换"></a>时移和尺度变换</h3><p><strong>对$f(at+b)$，其化为$f(a(t+\frac{b}{a}))$后对$f(t)$的图像先缩放$\frac{1}{a}$，再向左平移$\frac{b}{a}$个单位。</strong>  </p><h3 id="信号的分解"><a href="#信号的分解" class="headerlink" title="信号的分解*"></a>信号的分解*</h3><p>奇偶分解：$f(t)=\frac{1}{2}[f(t)+f(-t)]_{even}+\frac{1}{2}[f(t)-f(-t)]_{odd}$<br>复数分解：$f(t)=\frac{1}{2}[f(t)+f^*(t)]_{real}+\frac{1}{2}[f(t)-f^*(t)]_{img}$<br>直流分解： $f(t)=[\frac{1}{T}∫_{t_0}^{T+t_0}f(t)dt]_{dc}+f_A(t)$  </p><h3 id="信号的能量（帕塞瓦尔定理）"><a href="#信号的能量（帕塞瓦尔定理）" class="headerlink" title="信号的能量（帕塞瓦尔定理）"></a>信号的能量（帕塞瓦尔定理）</h3><p>信号$f(t)$的总能量可以用如下公式表示：  </p><script type="math/tex; mode=display">P=∫|f(t)|^2dt=\frac{1}{2π}|F(jω)|^2dω</script><div class="note note-warning">            <p>注意：|F(jω)|指模长  </p>          </div><h3 id="信号的频谱"><a href="#信号的频谱" class="headerlink" title="信号的频谱"></a>信号的频谱</h3><p><strong>周期信号的频谱是离散频谱，非周期信号的频谱是连续频谱。</strong><br>通过傅里叶级数写出信号频谱的办法：  </p><ol><li>将傅里叶级数转化为cos的形式： $f(t)=∑A_ncos(nω+ϕ_n)$  </li><li>对于单边频谱，根据nω直接写出$A_n$或者$ϕ_n$的频谱  </li></ol><div class="note note-info">            <p>双边频谱的幅值谱是$\frac{A_n}{2}$。  </p>          </div><h3 id="门信号的傅里叶系数-频谱"><a href="#门信号的傅里叶系数-频谱" class="headerlink" title="门信号的傅里叶系数/频谱"></a>门信号的傅里叶系数/频谱</h3><p>门信号的傅里叶系数$F(nω)=\frac{1}{2}a_n$<br>其频谱最重要的三个参数:<br>幅值:$F(nω)max$<br>谐波宽度:$ω_0=\frac{2π}{T}$，只与$T$有关。<br>主瓣宽度，$F(nω)=0$，$\frac{2π}{τ}$，只与$τ$有关。  </p><h2 id="系统的性质"><a href="#系统的性质" class="headerlink" title="系统的性质"></a>系统的性质</h2><h3 id="因果性"><a href="#因果性" class="headerlink" title="因果性"></a>因果性</h3><p>$t_0$时刻，系统输出只与$f(t_0)$和$f(t&lt;t_0)$有关。  </p><div class="note note-info">            <p>也就是说输出的$f(t)$和输入的$t_0$相比，$t_0&gt;t$。（例如$x(-t)$ 输入$t=-4$时，输出为$x(4)$，$4&gt;-4$因此不是因果系统）  </p>          </div>  <h3 id="线性"><a href="#线性" class="headerlink" title="线性"></a>线性</h3><p>满足：</p><script type="math/tex; mode=display">H[C_1f_1(t)+C_2f_2(t)]=C_1H[f_1(t)]+C_2H[f_2(t)]</script><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>满足：</p><script type="math/tex; mode=display">\lim_{t→∞}f(t)<∞</script><div class="note note-info">            <p>通常判断系统稳定性从系统方程入手，判断s域下极点是否在左半轴或者z域中极点是否在单位圆内。  </p>          </div><h3 id="时不变性"><a href="#时不变性" class="headerlink" title="时不变性*"></a>时不变性*</h3><p>先变换，后时移与先时移，后变换的结果相同。  </p><h2 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h2><h3 id="周期信号的傅里叶级数"><a href="#周期信号的傅里叶级数" class="headerlink" title="周期信号的傅里叶级数"></a>周期信号的傅里叶级数</h3><script type="math/tex; mode=display">f(t)=a_0+∑_{n=1}^∞[a_n cos(nω_1t)+b_nsin(nω_1t)]</script><p>组成成分：<br>直流分量：$a_0=\frac{1}{T}∫_0^Tf(t)dt$，表示<strong>一周期内信号的平均值</strong>。<br>基波分量：$a_n=\frac{2}{T}∫_0^Tf(t)cos(nω_1t)dt$<br>谐波分量：$b_n=\frac{2}{T}∫_0^Tf(t)sin(nω_1t)dt$  </p><div class="note note-warning">            <p>注意当$f(t)$是一个奇函数时，$a=0$;$f(t)$是一个偶函数时，$b=0$。  </p>          </div><p>指数形式的傅里叶级数：  </p><script type="math/tex; mode=display">f(t)=∑F(nω_1)e^{jnω_1t}</script><p>$F(nω_1)=\frac{1}{2}(a_n-jb_n)$<br>幅度：$|F(nω_1)|=\frac{1}{2}√{a_n^2+b_n^2}$<br>相位：$φ_n=arctan(-\frac{b_n}{a_n})$  </p><h3 id="非周期函数的傅里叶变换"><a href="#非周期函数的傅里叶变换" class="headerlink" title="非周期函数的傅里叶变换"></a>非周期函数的傅里叶变换</h3><script type="math/tex; mode=display">F(ω)=∫f(t)e^{-jωt}dt=F[f(t)]</script><p>复数形式：$F(ω)=|F(ω)|e^{jφ(ω)}$<br>傅里叶反变换：  </p><script type="math/tex; mode=display">f(t)=\frac{1}{2π}∫F(ω)e^{jωt}dω</script><h3 id="周期信号的傅里叶变换"><a href="#周期信号的傅里叶变换" class="headerlink" title="周期信号的傅里叶变换"></a>周期信号的傅里叶变换</h3><p>如果周期函数$f_T(t)$一个周期内的子函数为$f(t)$，那么$f_T(t)$的傅里叶变换可以写作：  </p><script type="math/tex; mode=display">F_T(ω)=2π∑F(nω_1)δ(ω-nω_1)</script><p>其中$F(nω_1)=\frac{1}{T}F(ω)|_{ω=nω_1}$<br>因此上式可以化简为：  </p><script type="math/tex; mode=display">F_T(ω)=ω_1∑F(ω)|_{ω=nω_1}δ(ω-nω_1)</script><h3 id="傅里叶变换的运算性质"><a href="#傅里叶变换的运算性质" class="headerlink" title="傅里叶变换的运算性质"></a>傅里叶变换的运算性质</h3><div class="table-container"><table><thead><tr><th style="text-align:center">注解</th><th style="text-align:center">时域</th><th style="text-align:center">频域</th></tr></thead><tbody><tr><td style="text-align:center">对偶性</td><td style="text-align:center">$2πf(-ω)$</td><td style="text-align:center">$F(t)$</td></tr><tr><td style="text-align:center">尺度变换</td><td style="text-align:center">$f(at)$</td><td style="text-align:center">$\frac{1}{\lvert a\rvert}F(\frac{ω}{a})$</td></tr><tr><td style="text-align:center">时移</td><td style="text-align:center">$f(t-t_0)$</td><td style="text-align:center">$F(ω)e^{-jωt_0}$</td></tr><tr><td style="text-align:center">频移</td><td style="text-align:center">$f(t)e^{-jω_0t}$</td><td style="text-align:center">$F(ω+ω_0)$</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">时域微分</td><td style="text-align:center">$f’(t)$</td><td style="text-align:center">$jωF(ω)$</td></tr><tr><td style="text-align:center">频域微分</td><td style="text-align:center">$-jtf(t)$</td><td style="text-align:center">$F’(ω)$</td></tr><tr><td style="text-align:center">时域积分</td><td style="text-align:center">$∫f(t)dt$</td><td style="text-align:center">$πF(0)δ(ω)+\frac{F(ω)}{jω}$</td></tr></tbody></table></div><h3 id="常见信号的傅里叶变换"><a href="#常见信号的傅里叶变换" class="headerlink" title="常见信号的傅里叶变换"></a>常见信号的傅里叶变换</h3><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">时域函数$f(t)$</th><th style="text-align:center">频域函数$F(ω)$</th></tr></thead><tbody><tr><td style="text-align:center">门函数</td><td style="text-align:center">$E[u(t+\frac{τ}{2})-u(t-\frac{τ}{2})]$ <br>$E,-\frac{τ}{2}&lt;t&lt;\frac{τ}{2}$</td><td style="text-align:center">$\frac{2Esin(ω\frac{τ}{2})}{ω}=EτSa(\frac{ωτ}{2})$</td></tr><tr><td style="text-align:center">直流信号/常函数</td><td style="text-align:center">$E$</td><td style="text-align:center">$2πEδ(ω)$</td></tr><tr><td style="text-align:center">冲激函数</td><td style="text-align:center">$δ(t)$</td><td style="text-align:center">$1$</td></tr><tr><td style="text-align:center">冲激偶函数</td><td style="text-align:center">$δ’(t)$</td><td style="text-align:center">$jω$</td></tr><tr><td style="text-align:center">阶跃函数</td><td style="text-align:center">$u(t)$</td><td style="text-align:center">$\frac{1}{jw}+πδ(ω)$</td></tr><tr><td style="text-align:center">单侧指数函数</td><td style="text-align:center">$Ee^{-at}u(t)$</td><td style="text-align:center">$\frac{E}{jω+a}$</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">周期冲激序列</td><td style="text-align:center">$δ_T(t)$</td><td style="text-align:center">$ω_1δ(ω-nω_1)$</td></tr><tr><td style="text-align:center">周期方波/门函数序列</td><td style="text-align:center">-</td><td style="text-align:center">$EτSa(\frac{ωτ}{2})ω_1δ(ω-nω_1)$</td></tr><tr><td style="text-align:center">正弦函数</td><td style="text-align:center">$sin(ω_0t)$</td><td style="text-align:center">$-jπδ(ω-ω_0)+jπδ(ω+ω_0)$</td></tr><tr><td style="text-align:center">余弦函数</td><td style="text-align:center">$cos(ω_0t)$</td><td style="text-align:center">$πδ(ω-ω_0)+πδ(ω+ω_0)$</td></tr></tbody></table></div><h2 id="采样定理"><a href="#采样定理" class="headerlink" title="采样定理"></a>采样定理</h2><p>奈奎斯特采样率：$f_n=2f_m$， 采样频率$f_n$是输入信号的频率的两倍。  </p><h2 id="时域分析方法"><a href="#时域分析方法" class="headerlink" title="时域分析方法"></a>时域分析方法</h2><h3 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h3><p>定义：</p><script type="math/tex; mode=display">∫f(t)h(τ-t)dt=f(t)*h(t)</script><p>称为信号的卷积运算。  </p><p>运算性质： </p><ol><li>$f(t)*δ(t)=f(t)$  </li><li>$f(t)*δ(t-t_0)=f(t-t_0)$</li><li>$f(t)*δ’(t)=f’(t)$</li></ol><ul><li>图解法解卷积运算<br>对于简单的信号，可以采取翻转其中一个信号，将这个信号图像平移，平移过程中观察与另一个信号图像的重叠面积的变化。  </li></ul><h3 id="冲激响应和阶跃响应"><a href="#冲激响应和阶跃响应" class="headerlink" title="冲激响应和阶跃响应"></a>冲激响应和阶跃响应</h3><p>当输入信号为$δ(t)$时，系统的输出为$h(t)$，称为单位冲激响应。<br>当输入信号为$u(t)$时，系统的输出为$g(t)$，称为单位阶跃响应。<br>冲激响应和阶跃响应满足如下关系：  </p><script type="math/tex; mode=display">g(t)=∫_{-∞}^th(t)dt</script><p>由于卷积运算中$f(t)h(τ-t)≠0$，因此阶跃响应可以用于决定积分的上下限。  </p><h3 id="零状态和零响应"><a href="#零状态和零响应" class="headerlink" title="零状态和零响应"></a>零状态和零响应</h3><p>零输入响应：没有任何输入时系统的响应，对应系统的特征微分方程输入为0的情况。<br><div class="note note-info">            <p>初始状态的值会直接影响到零状态响应：如果初始状态$x(0)=c$对应的零输入响应为$r_{zs}^i$，那么初始状态为$x(0)=2c$对应的零输入响应为$r_{zs}^{ii}=2r_{zs}^i$</p>          </div></p><p>零状态响应：不考虑系统的初始状态，系统输入对系统造成的响应。<br><strong>系统的零状态响应</strong>可以表示为输入信号为$δ(t)$时的系统响应与系统输入信号的卷积：  </p><script type="math/tex; mode=display">r_{zs}=h(t)*e(t) ↔ R_{zs}(s)=H(s)E(s)</script><p>系统的全响应： 系统的零状态响应和系统的零输入响应之和。  </p><script type="math/tex; mode=display">R(s)=H(s)E(s)+R_{zi}(s)</script><h3 id="时域分析法解系统微分方程"><a href="#时域分析法解系统微分方程" class="headerlink" title="时域分析法解系统微分方程"></a>时域分析法解系统微分方程</h3><h4 id="求齐次解（零输入响应）"><a href="#求齐次解（零输入响应）" class="headerlink" title="求齐次解（零输入响应）"></a>求齐次解（零输入响应）</h4><p>系统的齐次解方程：  </p><script type="math/tex; mode=display">f[y(t)]=0</script><ol><li>将特征方程转化为多项式并求解。<br>对于微分方程的特征方程，其$n$阶微分项可以被换元为$α^n$项，最终将特征方程转化为关于$α$的$n$阶多项式。<br>对于差分方程的特征方程，其0阶差分项$y(n)$可以被换元为关于$α$的最高幂项，如此类推，最终将特征方程转化为关于$α$的$n$阶多项式。  </li><li><p>根据多项式的解的个数和是否有重根，可以在下表中找到齐次解的形式，并带入多项式的解。  </p><p>不同特征根所对应的齐次解（微分方程）  </p></li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">特征根</th><th style="text-align:center">齐次解$y_p(t)$</th></tr></thead><tbody><tr><td style="text-align:center">单实根</td><td style="text-align:center">$e^{αk}$</td></tr><tr><td style="text-align:center">r重实根</td><td style="text-align:center">$∑C_{r-1}t^{r-1} e^{αk}$</td></tr></tbody></table></div><p>   不同特征根所对应的齐次解（差分方程）  </p><div class="table-container"><table><thead><tr><th style="text-align:center">特征根</th><th style="text-align:center">齐次解$y_p(k)$</th></tr></thead><tbody><tr><td style="text-align:center">单实根</td><td style="text-align:center">$Cα^k$</td></tr><tr><td style="text-align:center">r重实根</td><td style="text-align:center">$∑C_{r-1}k^{r-1} α^k$</td></tr></tbody></table></div><h4 id="求系统特解（单位冲激响应）"><a href="#求系统特解（单位冲激响应）" class="headerlink" title="求系统特解（单位冲激响应）"></a>求系统特解（单位冲激响应）</h4><ol><li>带入具体的激励$e(t)=δ(t)$到系统的微分/差分方程。</li><li>通过0阶项$r(t)$与激励中最高次数项之间系数的关系，用待定系数法猜想系统响应$r(t)$的结构。</li><li>将$r(t)$的结构代回微分/差分方程，利用对应阶数项系数相等建立方程，解出$r(t)$结构中的常系数。  </li></ol><p>如果已知了一些特解，求另一些特解，可以使用<strong>迭代法</strong>。<br>即从$h(0)$开始列出微分方程，直到列到所求的特解对应的微分方程，将已知的特解带入，从而求出未知的特解。  </p><h2 id="拉普拉斯变换"><a href="#拉普拉斯变换" class="headerlink" title="拉普拉斯变换"></a>拉普拉斯变换</h2><h3 id="傅里叶变换的局限性"><a href="#傅里叶变换的局限性" class="headerlink" title="傅里叶变换的局限性"></a>傅里叶变换的局限性</h3><ol><li>对不满足狄利克雷条件的函数无法变换</li><li>难以求解无穷积分</li></ol><h3 id="拉普拉斯变换对"><a href="#拉普拉斯变换对" class="headerlink" title="拉普拉斯变换对"></a>拉普拉斯变换对</h3><p>拉普拉斯变换：$F(s)=L[f(t)]=∫f(t)e^{-st}dt$<br>拉普拉斯反变换：$f(t)=\frac{1}{2πj}∫F(s)e^{st}ds$<br>拉普拉斯变换通过向傅里叶变换中添加衰减系数$e^{-σ}$来改善$f(t)$的收敛性，使其更可能满足狄利克雷条件。  </p><p>实际上对于反变换，更多的是利用多项式除法，观察多项式的结构来进行反变换：<br>$F(s)=∑\frac{k}{s-p}↔f(t)=∑ke^{pt}$ （一阶实极点）<br><div class="note note-info">            <p>如果分子是含有s的表达式，尝试用$A-\frac{C}{f(s)}$的形式进行表达，常数部分转化为冲激函数。  </p>          </div></p><h3 id="拉普拉斯变换的运算性质"><a href="#拉普拉斯变换的运算性质" class="headerlink" title="拉普拉斯变换的运算性质"></a>拉普拉斯变换的运算性质</h3><div class="table-container"><table><thead><tr><th style="text-align:center">注解</th><th style="text-align:center">时域</th><th style="text-align:center">频域</th></tr></thead><tbody><tr><td style="text-align:center">时移</td><td style="text-align:center">$f(t-t_0)$</td><td style="text-align:center">$F(ω)e^{-t_0s}$</td></tr><tr><td style="text-align:center">频移</td><td style="text-align:center">$f(t)e^{-at}$</td><td style="text-align:center">$F(s+a)$</td></tr><tr><td style="text-align:center">尺度变换</td><td style="text-align:center">$f(at)$</td><td style="text-align:center">$\frac{1}{\lvert a\rvert}F(\frac{s}{a})$</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">时域微分（一阶）</td><td style="text-align:center">$f’(t)$</td><td style="text-align:center">$sF(s)-f(0)$</td></tr><tr><td style="text-align:center">时域微分（二阶）</td><td style="text-align:center">$\frac{df^2(t)}{dt}$</td><td style="text-align:center">$s[sF(s)-f(0)]-f’(0)$</td></tr><tr><td style="text-align:center">频域微分</td><td style="text-align:center">$t^nf(t)$</td><td style="text-align:center">$(-1)^n\frac{d^nF(s)}{ds^n}$</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">时域积分</td><td style="text-align:center">$∫f(t)dt$</td><td style="text-align:center">$\frac{F(s)}{s}+\frac{f’(0)}{s}$</td></tr><tr><td style="text-align:center">频域积分</td><td style="text-align:center">$\frac{f(t)}{t}$</td><td style="text-align:center">$∫F(s)ds$</td></tr></tbody></table></div><p>初值定理: $f(0_+)\lim_{s→∞}sF(s)$<br>终值定理：$\lim_{t→∞}f(t)=\lim_{s→0}sF(s)$<br>卷积理论：$L[f(t)h(t)]=\frac{1}{2πj}F(s)*H(s)$  </p><h3 id="常见信号的拉普拉斯变换"><a href="#常见信号的拉普拉斯变换" class="headerlink" title="常见信号的拉普拉斯变换"></a>常见信号的拉普拉斯变换</h3><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">时域函数$f(t)$</th><th style="text-align:center">频域函数$L(s)$</th></tr></thead><tbody><tr><td style="text-align:center">阶跃函数</td><td style="text-align:center">$u(t)$</td><td style="text-align:center">$\frac{1}{s}$</td></tr><tr><td style="text-align:center">冲激函数</td><td style="text-align:center">$δ(t)$</td><td style="text-align:center">$1$</td></tr><tr><td style="text-align:center">单侧指数函数</td><td style="text-align:center">$Ee^{-at}u(t)$</td><td style="text-align:center">$\frac{E}{s+a}$</td></tr><tr><td style="text-align:center">斜坡函数</td><td style="text-align:center">$tu(t)$</td><td style="text-align:center">$\frac{1}{s^2}$</td></tr><tr><td style="text-align:center">正弦函数</td><td style="text-align:center">$sin(ω_0t)$</td><td style="text-align:center">$\frac{ω_0}{s^2+ω_0^2 }$</td></tr><tr><td style="text-align:center">余弦函数</td><td style="text-align:center">$cos(ω_0t)$</td><td style="text-align:center">$\frac{s}{s^2+ω_0^2}$</td></tr></tbody></table></div><h3 id="利用拉普拉斯变换求微分方程"><a href="#利用拉普拉斯变换求微分方程" class="headerlink" title="利用拉普拉斯变换求微分方程"></a>利用拉普拉斯变换求微分方程</h3><ol><li>以时域函数$f(t)$的拉普拉斯变换$F(s)$的微分特性：  <div class="note note-info">            <p>一阶微分：$\frac{df(t)}{dt}→sF(s)-f(0_ )$<br>二阶微分：$\frac{df^2(t)}{dt}→s[sF(s)-f(0_ )]-f’(0_ )$  </p>          </div></li></ol><p>   可以将微分方程以拉普拉斯变换从时域变换至频域。<br>   对于描述系统的微分方程将其做拉普拉斯变换：</p><script type="math/tex; mode=display">F_{out}(R(s),s)=F_{in}(E(s),s)</script><ol><li>带入初始条件和给定的题目条件中的一些$r(t)$在特定时刻下的值，得到方程  </li><li>解出频域内的$R(s)$  </li><li>用待定系数法展开多项式分式并用拉普拉斯反变换得到$r(t)$</li></ol><div class="note note-warning">            <p>注意初始条件  </p>          </div><p>对于全响应方程$R(s)$，$R(s)$可以分解为两部分，一部分只与初始状态$r(0)$相关（零输入响应），另一部分方程只与输入$E(s)$有关(零状态响应)。对这两部分分别进行拉普拉斯反变换得到零输入响应和零状态响应。  </p><h2 id="Z变换"><a href="#Z变换" class="headerlink" title="Z变换"></a>Z变换</h2><h3 id="Z变换对"><a href="#Z变换对" class="headerlink" title="Z变换对"></a>Z变换对</h3><p>Z变换：$X(z)=∑x(n)z^{-n}$<br>收敛域：$∑|x(n)z^{-n}&lt;∞|$<br>Z反变换：$X(z)=z(\frac{A}{z-p_i})⟷x(n)=∑A(p_i)^n$(一阶单极点)  </p><h3 id="收敛域"><a href="#收敛域" class="headerlink" title="收敛域*"></a>收敛域*</h3><script type="math/tex; mode=display">∑∣x(n)z^{-n}∣<∞</script><h3 id="Z变换的运算性质"><a href="#Z变换的运算性质" class="headerlink" title="Z变换的运算性质"></a>Z变换的运算性质</h3><div class="table-container"><table><thead><tr><th style="text-align:center">注解</th><th style="text-align:center">时域</th><th style="text-align:center">频域</th></tr></thead><tbody><tr><td style="text-align:center">双侧时移</td><td style="text-align:center">$x(n+m)$</td><td style="text-align:center">$z^mX(z)$</td></tr><tr><td style="text-align:center">右侧时移</td><td style="text-align:center">$x(n-m)$</td><td style="text-align:center">$z^{-m}[X(z)+∑_{k=-m}^{-1}x(k)z^{-k}]$</td></tr><tr><td style="text-align:center">尺度变换（时域）</td><td style="text-align:center">$nx(n)$</td><td style="text-align:center">$-z\frac{dX(z)}{dz}$</td></tr><tr><td style="text-align:center">尺度变换(z域)</td><td style="text-align:center">$a^nx(n)$</td><td style="text-align:center">$X(\frac{z}{a})$</td></tr></tbody></table></div><p>初值定理: $x(0_+)\lim_{x→∞}X(z)$<br>终值定理：$\lim_{n→∞}x(n)=\lim_{z→1}(z-1)X(z)$<br>卷积理论：$Z[x(n)*h(n)]=X(z)H(z)$  </p><h3 id="常见信号的Z变换"><a href="#常见信号的Z变换" class="headerlink" title="常见信号的Z变换"></a>常见信号的Z变换</h3><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">时域序列$x(n)$</th><th style="text-align:center">频域序列$X(z)$</th><th style="text-align:center">收敛域</th></tr></thead><tbody><tr><td style="text-align:center">单位冲激序列</td><td style="text-align:center">$δ(n)$</td><td style="text-align:center">$1$</td><td style="text-align:center">整个z域</td></tr><tr><td style="text-align:center">单位阶跃序列</td><td style="text-align:center">$u(n)$</td><td style="text-align:center">$\frac{z}{z-1}$</td><td style="text-align:center">$⃒ z ⃒ &lt;1$</td></tr><tr><td style="text-align:center">斜坡序列</td><td style="text-align:center">$nu(n)$</td><td style="text-align:center">$\frac{z}{(z-1)^2}$</td><td style="text-align:center">$⃒ z ⃒ &lt;1$</td></tr><tr><td style="text-align:center">单侧指数序列</td><td style="text-align:center">$a^nu(n)$</td><td style="text-align:center">$\frac{z}{z-a}$</td><td style="text-align:center">$⃒ z ⃒ &gt;⃒ a ⃒$</td></tr><tr><td style="text-align:center">单侧正弦序列</td><td style="text-align:center">$sin(ω_0n)u(n)$</td><td style="text-align:center">$\frac{zsinω_0}{z^2-2zcosω_0+1}$</td><td style="text-align:center">$⃒ z ⃒ &gt;1$</td></tr><tr><td style="text-align:center">单侧余弦序列</td><td style="text-align:center">$cos(ω_0n)u(n)$</td><td style="text-align:center">$\frac{z(z-cosω_0)}{z^2-2zcosω_0+1}$</td><td style="text-align:center">$⃒ z ⃒ &gt;1$</td></tr></tbody></table></div><h3 id="利用Z变换求差分方程"><a href="#利用Z变换求差分方程" class="headerlink" title="利用Z变换求差分方程"></a>利用Z变换求差分方程</h3><div class="note note-info">            <p>利用Z变换的单边右时移特性：<br>$x(n-1)=z^{-1}X(z)+x(-1)$<br>$x(n-2)=z^{-2}X(z)+z^{-1}x(-1)+x(-2)$<br>注意初始条件  </p>          </div>  <ol><li>将差分方程改写成Z变换的形式  </li><li>确定初始状态，解出差分方程  </li><li>反变换得到$y(n)$  </li></ol><h2 id="系统方程"><a href="#系统方程" class="headerlink" title="系统方程"></a>系统方程</h2><p>描述系统的方程$H(s)=\frac{R(s)}{E(s)}$<br><strong>$H(s)$的分母为系统微分方程输入侧的特征方程，分子为系统输出侧的特征方程。</strong>   </p><p>系统输入和输出在s域内都以多项式表示，系统方程自然是两个多项式的比值：</p><script type="math/tex; mode=display">H(s)=\frac{R(s)}{E(s)}=K\frac{Π(s-z_i)}{Π(s-p_k)}</script><p>其中$p_i$称为系统方程的极点，$z_k$称为系统方程的零点。   </p><h3 id="系统稳定性"><a href="#系统稳定性" class="headerlink" title="系统稳定性"></a>系统稳定性</h3><p>在s域图像中，如果极点分布在s域的左半轴，表明系统是稳定的。<br>在z域图像中，如果极点分布在z域的单位圆内，表明系统是稳定的。  </p><h3 id="反馈系统的方程"><a href="#反馈系统的方程" class="headerlink" title="反馈系统的方程"></a>反馈系统的方程</h3><p>如图：<br><img src="https://gitee.com/l61012345/Pic/raw/master/%5Cimage/20210614142459.png" alt=""><br>系统的闭环传递函数：  </p><script type="math/tex; mode=display">\frac{C(s)}{R(s)}=\frac{G(s)}{1+G(s)H(s)}</script><p>其中：系统的开环传递函数为$G(s)H(s)$。  </p><h3 id="根轨迹图"><a href="#根轨迹图" class="headerlink" title="根轨迹图"></a>根轨迹图</h3><p>系统的开环传递函数加入了一个根轨迹增益$K$以衡量闭环极点对开环传递函数的影响。<br>得到根轨迹图的步骤：  </p><ol><li>通过闭环传递函数的特征方程$1+G(s)H(s)=0$解出s与参数$K$之间的关系。  </li></ol><div class="note note-info">            <p>注意开环传递函数的特征方程是$1+G(s)H(s)=0$<br>二阶多项式方程的根：$\frac{-b⨦√Δ}{2a}$  </p>          </div><ol><li>在s域中标出零点。  </li><li>在s域中标出极点，即$K=0$的位置。  </li><li>增加K的值，在S域中标出一系列的s的位置，并以（$K=x$）在每个点上方进行标注。  </li><li>判断$k→∞$时，s的移动方向，并用箭头标注。  </li></ol><h2 id="切比雪夫滤波器"><a href="#切比雪夫滤波器" class="headerlink" title="切比雪夫滤波器"></a>切比雪夫滤波器</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>过渡带很小</li><li>有波纹</li></ol><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>实际的滤波器波形如图表示：<br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210531161932.png" alt=""><br>滤波器波形的四个参数：</p><ol><li>通带边缘（Passband edge,$ω_p$）</li><li>最大允许变化（Maximum allowed variation,$A_{max}$）  </li><li>阻带边缘（Stopband edge,$ω_s$）</li><li>最小阻带衰减要求（Minimum required stopband attenuation,$A_{min}$）  </li></ol><h3 id="传递函数（低通）"><a href="#传递函数（低通）" class="headerlink" title="传递函数（低通）"></a>传递函数（低通）</h3><script type="math/tex; mode=display">|T(jω)|=\frac{1}{√1+ɛ^2C^2_n(ω/ω_p)}</script><p>其中：$n≥\frac{cosh^{-1}M}{cosh^{-1}Ω}$为电路阶数，$ɛ=√{10^{\frac{A_{max}}{10}}-1}$<br>$Ω=\frac{ω_s}{ω_p}$（称为选择因子（Select Factor）），$M=√{\frac{\frac{1}{K_A}-1}{\frac{1}{K_r-1}}}$  </p><h3 id="切比雪夫高通滤波器"><a href="#切比雪夫高通滤波器" class="headerlink" title="切比雪夫高通滤波器"></a>切比雪夫高通滤波器</h3><p>将电感和电容对换就可以得到高通滤波器。<br>和原来的低通滤波器相比，新的高通滤波器$ω_p$相同，$ω_s’=\frac{ω_p^2}{ω_s}$。  </p><h3 id="设计方法"><a href="#设计方法" class="headerlink" title="设计方法"></a>设计方法</h3><ol><li>确定使用的滤波器类型  </li><li>找到能够拟合要求的转换方程（巴特沃斯/切比雪夫）  </li><li>根据波形图求出电路的最小阶数$n$  </li><li>查表找到CL的数值，并作反归一化  </li><li>连接电路  </li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>信号与系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机接口程序（C语言）</title>
    <link href="/2021/06/16/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84%E4%B8%8E%E6%8E%A5%E5%8F%A3/2.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8E%A5%E5%8F%A3%E7%A8%8B%E5%BA%8F/"/>
    <url>/2021/06/16/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84%E4%B8%8E%E6%8E%A5%E5%8F%A3/2.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8E%A5%E5%8F%A3%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机接口程序（C语言）"><a href="#计算机接口程序（C语言）" class="headerlink" title="计算机接口程序（C语言）"></a>计算机接口程序（C语言）</h1><blockquote><p>讲义复习<br>BUL EE2623 Computer Architecture and Interface<br>Dr. Hongying Meng   </p></blockquote><h2 id="单片机程序概要"><a href="#单片机程序概要" class="headerlink" title="单片机程序概要"></a>单片机程序概要</h2><h3 id="程序的主要结构"><a href="#程序的主要结构" class="headerlink" title="程序的主要结构"></a>程序的主要结构</h3><p>单片机程序的主要结构：<br>对于任何的单片机程序，其算法结构由三部分组成：  </p><ol><li>重置（Reset）：清空单片机现有的内容并重置单片机设置。  </li><li>初始化（Initialise）：声明变量，初始化变量值，指定寄存器的地址或初始化特殊寄存器的值等，用于初始化单片机和接口。  </li><li>主程序（Main Program）:单片机执行的主要内容。<br><strong>单片机的主程序必须写在一个死循环内（<code>while(1) &#123;&#125;</code>）</strong></li></ol><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>编译器只支持三种数据类型： Unsigned integers, char, int</p><blockquote><p>单片机不支持float 和 double 两种数据类型, PIC系列也不支持Signed integers.<br>int 和 char的区别在于：编译器只支持两个int变量做数学/逻辑运算，而支持多个char变量做数学/逻辑运算。</p></blockquote><h3 id="单片机语法"><a href="#单片机语法" class="headerlink" title="单片机语法"></a>单片机语法</h3><p>除了C语言常见的语法之外，单片机还支持如下的特殊表达：  </p><div class="table-container"><table><thead><tr><th style="text-align:center">表达</th><th style="text-align:left">说明</th><th style="text-align:center">举例</th></tr></thead><tbody><tr><td style="text-align:center"><code>&gt;&gt;</code></td><td style="text-align:left">比特位右移</td><td style="text-align:center"><code>var&gt;&gt;2</code></td></tr><tr><td style="text-align:center"><code>&lt;&lt;</code></td><td style="text-align:left">比特位左移</td><td style="text-align:center"><code>var&lt;&lt;1</code></td></tr><tr><td style="text-align:center"><code>set_bit(file,bit)</code></td><td style="text-align:left">将制定寄存器（File）的制定比特位（bit）设置为1</td><td style="text-align:center"><code>set_bit(porta,0)</code></td></tr><tr><td style="text-align:center"><code>clear_bit(file,bit)</code></td><td style="text-align:left">将制定寄存器（File）的制定比特位（bit）设置为0</td><td style="text-align:center"><code>clear_bit(porta,4)</code></td></tr><tr><td style="text-align:center"><code>for(init;cond;mod)&#123;&#125;</code></td><td style="text-align:left">循环，内部依次是循环变量的初始值、执行循环的条件、对循环变量的操作</td><td style="text-align:center"><code>for(int i=0; i&lt;10 ; i++)&#123;&#125;</code></td></tr><tr><td style="text-align:center"><code>asm&#123;&#125;</code></td><td style="text-align:left">汇编语言指令（Boost C）</td><td style="text-align:center"><code>asm &#123; movlw 0 &#125;</code></td></tr><tr><td style="text-align:center"><code>void interrupt()&#123;&#125;</code></td><td style="text-align:left">中断程序</td><td style="text-align:center"><code>void interrupt()&#123;if(portb==0)&#123;set_bit&#123;porta,3&#125;&#125;&#125;</code></td></tr></tbody></table></div><h3 id="时间控制"><a href="#时间控制" class="headerlink" title="时间控制"></a>时间控制</h3><p>对Boost C编译器，执行一次循环（不含循环内的操作）大约需要12条汇编指令，<strong>执行一次循环大约需要12us</strong>.</p><h2 id="开关"><a href="#开关" class="headerlink" title="开关"></a>开关</h2><p>开关的种类和连接方式有非常多种：<br>对于简单电路连接的开关，需要对其进行电路分析以判断输入进单片机（pin）的电压是5v（1）还是0v（0）。<br>对于旋钮式开关，每一个档位对应了一种比特的情况。比如假设有0-F共16个档位，开关需要连接一个port的4个pin（即需要用4个比特位来反馈），每一个档位都对应了0000到1111的一种情况。  </p><h3 id="Switch-Bounce"><a href="#Switch-Bounce" class="headerlink" title="Switch Bounce"></a>Switch Bounce</h3><p>开关被按下后弹起的瞬间，其开关的值处于不确定状态，这种情况称为Switch Bounce，通常是$10^{-3}s$ 到 $2 × 10^{-3}s$左右。<br>避免Switch Bounce的方法：  </p><ol><li>在pin前加入一个由RC组成的低通滤波器。  </li><li>在pin前使用两个交叉连接的NAND门。  </li><li>在程序中用一个delay跨过Switch Bounce的时间。  </li></ol><h2 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h2><h3 id="物理原理"><a href="#物理原理" class="headerlink" title="物理原理"></a>物理原理</h3><p>当某个键被按下的时候，该按键所在的行列由键盘的按下被导通。  </p><h3 id="程序思路"><a href="#程序思路" class="headerlink" title="程序思路"></a>程序思路</h3><ol><li>将行作为port的输入/输出，列作为port的输出/输入（用tris进行控制）</li><li><strong>初始化port内所有比特位的值为1，当按键被按下，该按键所对应的两个比特位的值被清零。</strong></li><li>先检查每一行/列是否有按键被按下（if &amp;），如果该行/列有按键被按下，转而检测该行/列的每一列/行。</li></ol><h2 id="LED灯-发光二极管"><a href="#LED灯-发光二极管" class="headerlink" title="LED灯/发光二极管"></a>LED灯/发光二极管</h2><h3 id="物理原理-1"><a href="#物理原理-1" class="headerlink" title="物理原理"></a>物理原理</h3><p>发光二极管处于正向偏置时，其两端电压处于不同值，发光二极管会发出不同颜色的光（比如红色是1.6V，白色是3.5V）。<br>发光二极管通常支持的最大电压在3.5V左右，而单片机的输出电压最大可到5V，为了防止二极管被击穿，应该在二极管前加一个电阻以分压。<br>此外，PIC开发板上的单个pin的供电可到25mA，但是所有pin上的最大电流不能超过200mA，因此需要用BJT晶体管等方法在二极管的输出端限流。<br>在PIC开发板上，8个LED灯连接到PortA上，对应了PortA从PA0到PA7的8个比特位。<br><strong>当比特位为1时，对应的LED灯亮起。</strong>  </p><h3 id="程序思路-1"><a href="#程序思路-1" class="headerlink" title="程序思路"></a>程序思路</h3><p>只需要使用<code>trisa</code>将指定LED灯对应的比特位设置为输出后，设定该比特位的值为1即可控制该LED灯亮起。  </p><h2 id="7-8-位数码管"><a href="#7-8-位数码管" class="headerlink" title="7(8)位数码管"></a>7(8)位数码管</h2><h3 id="物理原理-2"><a href="#物理原理-2" class="headerlink" title="物理原理"></a>物理原理</h3><p>八位数码管的每一个显示笔划（Segment）（7位数码管不包括小数点显示）对应了一个比特位，<strong>当该比特位的值为0时，该笔画亮起</strong>。 </p><h3 id="程序思路-2"><a href="#程序思路-2" class="headerlink" title="程序思路"></a>程序思路</h3><p>创建一个数组其对应位置上的值为该数字应当亮起的显示笔画的比特值，检测输入的值$x$，然后将数组第$x$位上的值传出到port即可。<br>对于多个数码管组成的阵列：</p><ol><li>用另一个port来控制使用哪些数码管，当比特位为1时，对应的八位数码管亮起。  </li><li>每一个数码管会在很短的时间亮起熄灭，然后下一个数码管重复，当循环闪亮的频率快到人眼无法识别的时候，表现为所有的数码管都同时亮起。  </li><li>在一次循环之后，微控制器被释放然后计算新的显示值。  </li></ol><h2 id="LCD-液晶显示面板"><a href="#LCD-液晶显示面板" class="headerlink" title="LCD/液晶显示面板"></a>LCD/液晶显示面板</h2><h3 id="结构与原理"><a href="#结构与原理" class="headerlink" title="结构与原理"></a>结构与原理</h3><h4 id="针脚（Pin）"><a href="#针脚（Pin）" class="headerlink" title="针脚（Pin）"></a><strong>针脚（Pin）</strong></h4><p>液晶显示面板共有11个pin，其中8个用于传输8 bit数据，3个用于控制，这三个pin为:   </p><ul><li>RS: Register select，选择寄存器为指令寄存器还是d数据寄存器。  </li><li>R/W：Read/Write， 控制数据流的方向是从单片机到LED（通常）还是从LED到单片机。  </li><li>E：Enable，控制数据发送的速度：E对应的值每发生一次变化（10），就会发生1bit的数据传输。  </li></ul><h4 id="显示面板"><a href="#显示面板" class="headerlink" title="显示面板"></a><strong>显示面板</strong></h4><p>显示面板被划分为8x2个区域，每个区域可以显示一个字符。 每个区域所对应了一个地址，<strong>第一排显示区域的地址是00到07，第二排显示区域的地址是从40到47</strong>。<br>在显示时需要指定显示的起始位置。<br>由于DDRAM，因此bit7始终为1，<strong>操作码为0xC0+起始区域的地址。</strong>  </p><h4 id="显示与控制"><a href="#显示与控制" class="headerlink" title="显示与控制"></a><strong>显示与控制</strong></h4><p>每一个常用字符（字母，数字，常用符号，片假名）和指令都对应了一个8bit值，这8bit被拆分为两段：MSB和LSB分两次发送，但是先发送哪一段取决于LED的型号。（课程中为先发送MSB，再发送LSB）<br><strong>注意在发送字符/指令时，需要将操作码的头四位清零，发送MSB时，需要将MSB移动到操作码的后四位，再清零其头四位。</strong>  </p><p><strong>发送指令也是8bit，其结构： 0010 | MSB/LSB</strong><br>发送指令的第一段为固定值0x20，后一段为指令的MSB或LSB。  </p><p>发送字符时，发送字符的指令结构：<br><strong>发送MSB： 0011 |MSB</strong><br><strong>发送LSB： 0010 |LSB</strong>  </p><h3 id="程序思路-3"><a href="#程序思路-3" class="headerlink" title="程序思路"></a>程序思路</h3><p>LCD在使用前需要对其进行唤醒（初始化显示），唤醒方法为不断的向portb发送两个不同的任意非零比特值。<br>整个LCD的初始化流程为：   </p><ol><li>设置adcon1接收来自portA的所有pins的数字信号。  </li><li>设置portA的PA0,PA1,PA2为输出。  </li><li>设置portB为输出。  </li><li>清除显示。  </li><li>唤醒LED。</li><li>设置显示模式：显示n行，8bit数据接口，5x7或0.5x7点阵</li><li>开启显示，并设置显示/不显示指针</li><li>设置字符的显示模式:从左到右/从右到左</li><li>设置指针的起始位置。</li><li>清除显示。<br>固定代码为:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">adcon1 = <span class="hljs-number">0x06</span>; <span class="hljs-comment">//设置adcon1接收来自portA的所有pins的数字信号</span><br>trisa = <span class="hljs-number">0xf8</span>; <span class="hljs-comment">//设置portA的PA0,PA1,PA2为输出</span><br>trisb = <span class="hljs-number">0x00</span>; <span class="hljs-comment">//设置PortB为输出</span><br>lcd_cmd(<span class="hljs-number">1</span>); <span class="hljs-comment">//清除显示</span><br>lcd_init(); <span class="hljs-comment">//初始化LCD</span><br>lcd_cmd(<span class="hljs-number">0x38</span>); <span class="hljs-comment">//设置两行，8比特，5x7点阵</span><br>lcd_cmd(<span class="hljs-number">0x0c</span>); <span class="hljs-comment">//设置打开显示，不显示光标</span><br>lcd_cmd(<span class="hljs-number">0x06</span>); <span class="hljs-comment">//设置光标右移</span><br>lcd_cmd(<span class="hljs-number">1</span>); <span class="hljs-comment">//清除显示</span><br></code></pre></td></tr></table></figure>将发送的字符串视为一个数组，每一个字符都要进行：“清零，MSB移位，清除头四位，发送MSB，清除头四位，发送LSB”的操作。  </li></ol><h2 id="ADC-模数转换器"><a href="#ADC-模数转换器" class="headerlink" title="ADC/模数转换器"></a>ADC/模数转换器</h2><h3 id="测量原理"><a href="#测量原理" class="headerlink" title="测量原理"></a>测量原理</h3><p>ADC的基本原理为其测量范围内的每一个可测的电压值都对应了一个二进制数。 例如8bit ADC量程为0-5V时，0-5V对应了0000 0000到1111 1111的8bit二进制数。<br>ADC的精度表示为：$\frac{测量范围}{2^n}$。   </p><blockquote><p>注意电压转换为二进制数时，不能整除的情况下，应当只保留整数部分。  </p></blockquote><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a><strong>类型</strong></h4><p>ADC根据实现原理分类为三种类型：</p><ol><li>Flash ADC：每一个可以测量的电压值对应了一个比较器连接，是一种非常低下的ADC。</li><li>逐次逼近式ADC：<br>下图中8bit Register的值的从MSB开始0-&gt;1，每一个比特位0-&gt;1的变化都会由DAC转换为电压与输入电压进行对比，比较器将两个电压进行对比，判断DAC的电压是否高于输入电压：如果输入电压高于DAC的电压，那么Register中这一比特位的值为1，如果低于DAC的电压，那么Register中这一位比特位的值恢复为0。<br>调整8bit Register的每一个比特位，直到LSB调整完毕，ADC的转换结束。<br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210529140131.png" alt="">  </li><li>Dual slope ADC：由于不同电压下在固定充电时间内充入的电子数不同，通过测量电容放电的时间即可测量不同的电压。这种ADC测量速度慢，但是相比于上面两者价格相对便宜。  </li></ol><h3 id="寄存器结构"><a href="#寄存器结构" class="headerlink" title="寄存器结构"></a>寄存器结构</h3><h4 id="ADRESH-ADRESL"><a href="#ADRESH-ADRESL" class="headerlink" title="ADRESH/ADRESL"></a><strong>ADRESH/ADRESL</strong></h4><p>两个8bit寄存器用于存放10bit的转换结果，又两种存放方式：<br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210529143926.png" alt=""><br>这两种方式由ADCON1中的bit7：ADFM进行控制。  </p><h4 id="ADCON1"><a href="#ADCON1" class="headerlink" title="ADCON1"></a><strong>ADCON1</strong></h4><div class="table-container"><table><thead><tr><th style="text-align:center">bit</th><th style="text-align:center">7</th><th style="text-align:center">6</th><th style="text-align:center">5</th><th style="text-align:center">4</th><th style="text-align:center">3</th><th style="text-align:center">2</th><th style="text-align:center">1</th><th style="text-align:center">0</th></tr></thead><tbody><tr><td style="text-align:center">Function</td><td style="text-align:center">ADFM</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">PCFG3</td><td style="text-align:center">PCFG2</td><td style="text-align:center">PCFG1</td><td style="text-align:center">PCFG0</td></tr></tbody></table></div><p>bit7：ADFM，选择寄存模式：  </p><ul><li>为1时10bit转换结果的bit10和bit9放入ADRESH，剩下比特放入ADRESL。  </li><li>为0时10bit转换结果的bit0和bit1放入ADRESL，剩下比特放入ADRSH。<br>bit6-bit4：Don’t Care<br>bit3-bit0: PCFG3-PCFG0，选择ADC的4个pins哪些接收模拟信号（0），哪些接收数字信号（1）。  <h4 id="ADCON0"><a href="#ADCON0" class="headerlink" title="ADCON0"></a><strong>ADCON0</strong></h4></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">bit</th><th style="text-align:center">7</th><th style="text-align:center">6</th><th style="text-align:center">5</th><th style="text-align:center">4</th><th style="text-align:center">3</th><th style="text-align:center">2</th><th style="text-align:center">1</th><th style="text-align:center">0</th></tr></thead><tbody><tr><td style="text-align:center">Function</td><td style="text-align:center">ADCS1</td><td style="text-align:center">ADCS0</td><td style="text-align:center">CHS2</td><td style="text-align:center">CHS1</td><td style="text-align:center">CHS0</td><td style="text-align:center">GO/DONE</td><td style="text-align:center">x</td><td style="text-align:center">ADON</td></tr></tbody></table></div><p>bit7-bit6： ADCS1-ADCS0，选择转换速度<br>bit5-bit3: CHS2-CHS0，选择当前接受portA的哪一个pin的信号进行转换<br>bit2： GO/DONE，转换开始和结束的flag，设定其为1使ADC转换开始，转换结束后会自动复位为0.<br>bit1: Don’t care<br>bit0: ADON，ADC的总开关，1表示开，0表示关。  </p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>ADC需要通过给定adcon1和adcon0的值来进行初始化。<br>转换过程的思想思路为，设置GODONE的值为1，开始转换，等到GODONE的值恢复到0时，获取adresh和adresl中的10比特信息（注意移位的问题）。  </p><h2 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>计时器的结构如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210529144418.png" alt=""><br>RA4/T0CK1: PortA的pin4，用于接收输入信号<br>T0SE：选择下降沿还是上升沿触发计数器计数<br>Fosc: 单片机内部的时钟信号频率 （Fosc/4表示$\frac{1}{4}$时钟信号频率）<br>T0CS： 复用器，选择用RA4还是时钟信号作为输入<br>PS2-PS0: Pre-scaler（相当于另一个计数器），用于倍数放大。<br>PSA： 复用器，选择是否使用Pre-scaler。<br>TMR0: 计数器。  </p><h3 id="寄存器结构-1"><a href="#寄存器结构-1" class="headerlink" title="寄存器结构"></a>寄存器结构</h3><h4 id="TMR0"><a href="#TMR0" class="headerlink" title="TMR0"></a><strong>TMR0</strong></h4><p>8bit 计数器，每一个计数信号（1us）会计数一次，8bit计数器每256次计数（也就是每个256us）会发生一次溢出。    </p><h4 id="INTCON"><a href="#INTCON" class="headerlink" title="INTCON"></a><strong>INTCON</strong></h4><p>计数器的状态寄存器。  </p><div class="table-container"><table><thead><tr><th style="text-align:center">bit</th><th style="text-align:center">7</th><th style="text-align:center">6</th><th style="text-align:center">5</th><th style="text-align:center">4</th><th style="text-align:center">3</th><th style="text-align:center">2</th><th style="text-align:center">1</th><th style="text-align:center">0</th></tr></thead><tbody><tr><td style="text-align:center">Function</td><td style="text-align:center">O</td><td style="text-align:center">O</td><td style="text-align:center">O</td><td style="text-align:center">O</td><td style="text-align:center">O</td><td style="text-align:center">T0IF</td><td style="text-align:center">O</td><td style="text-align:center">O</td></tr></tbody></table></div><p>bit2： TMR0溢出标志，T0IF=1表明TMR0发生了溢出。  </p><h4 id="OPTION"><a href="#OPTION" class="headerlink" title="OPTION"></a><strong>OPTION</strong></h4><p>用于控制计时器：  </p><div class="table-container"><table><thead><tr><th style="text-align:center">bit</th><th style="text-align:center">7</th><th style="text-align:center">6</th><th style="text-align:center">5</th><th style="text-align:center">4</th><th style="text-align:center">3</th><th style="text-align:center">2</th><th style="text-align:center">1</th><th style="text-align:center">0</th></tr></thead><tbody><tr><td style="text-align:center">Function</td><td style="text-align:center">O</td><td style="text-align:center">O</td><td style="text-align:center">T0CS</td><td style="text-align:center">T0SE</td><td style="text-align:center">PSA</td><td style="text-align:center">PS2</td><td style="text-align:center">PS1</td><td style="text-align:center">PS0</td></tr></tbody></table></div><p>bit7-bit6: 其他功能<br>bit5: T0CS，选择用RA4还是时钟信号作为输入<br>bit4: T0SE，选择下降沿还是上升沿触发计数器计数<br>bit3: PSA， 选择是否开启pre-scaler<br>bit2-bit0： 选择pre-scaler的倍率  </p><h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><p>TMR0发生一次overflow的时间：</p><script type="math/tex; mode=display">时钟周期 × 放大倍率 × (256 × 单次计数所需要的时间 - \text{TMR0}初始值)</script><h3 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h3><p>可通过给定tmr0的初始值和重置T0IF为0来实现一个精准的delay。  </p><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>通常，Programm Counter（PC）负责指向下一条运行指令的地址，IR执行这个地址对应的指令，PC移动到下一条指令。<br>如果中断程序存在，当前的PC，W register 和 STATUS register中的内容会被保存到内存中，然后PC跳转到中断程序所处的位置（固定为<code>PC=4</code>），执行完中断程序后内存中PC，W register 和 STATUS register的内容被复原。  </p><p><strong>每运行一行主循环中的代码，<code>void interrupt&#123;&#125;</code>中的程序就会被执行一次。</strong>  </p><p>程序框图如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210529152258.png" alt=""></p><h3 id="应用：-PWM-控制马达"><a href="#应用：-PWM-控制马达" class="headerlink" title="应用： PWM 控制马达"></a>应用： PWM 控制马达</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a><strong>原理</strong></h4><p>马达转速的调节是由输入马达的电压来进行控制的，电压越高，马达转速越快。然而单片机只能输出5v或者0v两种电压，PWM提供了一种解决思路，即在如图所示的一个周期$T$内，有一部分时间输入马达的电压为0，另一部分时间输出马达的电压为1，当$T$非常小时，输入到马达的电压近似为一个周期内电压的平均值：   </p><script type="math/tex; mode=display">V_{out}=\frac{1}{T}∫_0^TV_{in}dt=\frac{t}{T}V</script><p>$t$为一个周期内电压为$V$时的时间。<br><img src="https://gitee.com/l61012345/Pic/raw/master/%5Cimage/20210610144853.png" alt="">  </p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h4><p>在中断程序中需要有两个计数器cycle（周期计时器） 和 pulse（马达开启状态的计时器）用于控制时间，他们每运行一次中断都会自动-1，当计数器为0时表明对应的阶段已经结束。<br>在程序实现上 cycle自减1后，首先需要判断cycle的值是否为0： 如果为0，表明当前的周期已经结束，应当为cycle赋值以初始化下一个周期。  同时为pulse赋值，并使马达处于工作状态以进入下一个周期的开始（马达工作）。<br>当cycle不为0时，需要判断pulse是否为0：如果pulse的值为0，表明应当进入该周期内马达关闭的阶段，因此关闭马达。如果pulse的值不为0，那么pulse自减1。  </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>计算机结构与接口</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机结构-知识点与题型总结</title>
    <link href="/2021/06/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84%E4%B8%8E%E6%8E%A5%E5%8F%A3/4.%20%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    <url>/2021/06/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84%E4%B8%8E%E6%8E%A5%E5%8F%A3/4.%20%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="知识点与题型总结"><a href="#知识点与题型总结" class="headerlink" title="知识点与题型总结"></a>知识点与题型总结</h1><blockquote><p>针对Brunel University： 2021 EE2623    Computer Architecture and Interfacing 的期末复习笔记<br>Lecturer: Dr. Itagaki Takebumi（板垣　剛文）/Dr.Hongying Meng（孟鸿鹰）<br>总结 本课程常考到的题型、相关知识点和回答模板</p></blockquote><h2 id="二进制数的表达和运算"><a href="#二进制数的表达和运算" class="headerlink" title="二进制数的表达和运算"></a>二进制数的表达和运算</h2><h3 id="整数的表达方式"><a href="#整数的表达方式" class="headerlink" title="整数的表达方式"></a>整数的表达方式</h3><p>分为Signed和Unsigned两种，两者之间的转换是将源码进行翻转后+1得到其二补码。  </p><h3 id="加法运算"><a href="#加法运算" class="headerlink" title="加法运算"></a>加法运算</h3><p>加法运算时注意进位和溢出的问题，当进位值的前两位数值不同（为10或01）时代表运算符发生了溢出。  </p><h3 id="浮点数的表达方式"><a href="#浮点数的表达方式" class="headerlink" title="浮点数的表达方式"></a>浮点数的表达方式</h3><p>浮点数有两种表达规定：IEEE754和IBM。<br><strong>同一精度下，IBM能够表达的范围更大，最小值也更小，精度更高。</strong>  </p><h4 id="IEEE754的例外"><a href="#IEEE754的例外" class="headerlink" title="IEEE754的例外"></a><strong>IEEE754的例外</strong></h4><ul><li>NaN：Not a Number，是运算错误的表示，通常有如下几种情况运算结果是NaN：  <ol><li>$⨦0 ÷ ⨦0$  </li><li>$∞-∞$  </li><li>$⨦∞÷⨦∞$  </li><li>$⨦∞ × 0$  </li></ol></li><li>无穷:当指数部分全为1，小数部分不为0时，运算接过是无穷。规定如下的情况结果会是无穷：<ol><li>$∞ × ∞$  </li><li>$∞ + ∞$  </li><li>$nonezero ÷ 0$</li></ol></li><li>0：IEEE754中有正零和负零之分：两者的符号位不同，其余比特位全都是0，规定$n ÷ ∞=0$。  <h4 id="最大值和最小值-表示范围-精度"><a href="#最大值和最小值-表示范围-精度" class="headerlink" title="最大值和最小值/表示范围/精度"></a><strong>最大值和最小值/表示范围/精度</strong></h4>其最大值和最小值的求法是相同的。<br>最小数：  <script type="math/tex; mode=display">base^{-bias} × base^{-fraction}</script>最大数：  <script type="math/tex; mode=display">(base-base^{-fraction})×base^{(2^{exponent}-bias)}</script>fraction： 小数部分的总位数，bias：偏置，base：基数  exponent：指数部分的总位数<br>注：IEEE754中由于非正规数的要求，应当写作：$(base-base^{-fraction})×base^{(2^{exponent}-bias-1)}$</li></ul><h4 id="通信"><a href="#通信" class="headerlink" title="通信"></a><strong>通信</strong></h4><p>两者之间的通信数据需要经过转换，转换步骤为：  </p><ol><li>改变指数部分和小数部分的基底  </li><li>指数部分转化为不同的偏置下的新指数部分  </li></ol><p>由于IBM规定的精度大于IEEE754，因此从IBM转到IEEE754时数据的精度会有所损失。  </p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><h3 id="分级存储"><a href="#分级存储" class="headerlink" title="分级存储"></a>分级存储</h3><p>由于访问性和成本的限制，需要对内存进行分级：<br>Level 1： 需要和CPU同步工作，每一个时钟内要确保被CPU完全读取一次，因此储存容量非常的小。<br>Level 2： 需要和数据总线同步工作，用于缓冲与Level 1 内存的数据读取速度差异，但读取速度不需要与level 1相同。<br>外部存储： 外部的存储设备数据读取的速度比数据总线慢，因此需要缓冲来补偿速度差异，但是其成本相比于level 1和level 2更低，因此容量通常更大。  </p><h3 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h3><p>大端： 对于一个多字节的数据，其MSB首先被存储的硬件称之为大端。 大端模式下，MSB被存储在最小的地址上，后续比特依次存储在更大的地址上，LSB被存储在最大的地址上。<br>小端： 对于一个多字节的数据，其LSB首先被存储的硬件称之为大端。 大端模式下，LSB被存储在最小的地址上，后续比特依次存储在更大的地址上，MSB被存储在最大的地址上。  </p><h2 id="冯诺依曼架构-哈佛架构"><a href="#冯诺依曼架构-哈佛架构" class="headerlink" title="冯诺依曼架构/ 哈佛架构"></a>冯诺依曼架构/ 哈佛架构</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="冯诺依曼架构"><a href="#冯诺依曼架构" class="headerlink" title="冯诺依曼架构"></a><strong>冯诺依曼架构</strong></h4><ol><li>基本组成部分：CPU.ALU.I/O.Memory  </li><li>所有的组成部分都与线缆连接，这些线缆在逻辑上和物理上被整合到一起，称为总线。   </li><li>程序和数据都被存放在同一个内存当中，没有任何外部存储。  </li><li>控制器从内存中读取指令并运行。  </li></ol><h4 id="哈佛架构"><a href="#哈佛架构" class="headerlink" title="哈佛架构"></a><strong>哈佛架构</strong></h4><ol><li>物理上具有分别独立的信道和存储用于储存指令和数据。  </li><li>这两部分存储的实现方式、字长、时钟、地址、存储介质都可以不同。  </li></ol><h3 id="判断结构类型"><a href="#判断结构类型" class="headerlink" title="判断结构类型"></a>判断结构类型</h3><ol><li>给出结论  </li><li>说明有哪些结构特点是符合/不符合冯诺依曼架构的（所有的组成部分有无由总线连接）  </li><li>说明有哪些结构特点是符合/不符合哈佛架构的（指令和数据是否具有分别独立的存储）  </li></ol><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ol><li>哈佛架构允许在同一时间内读取指令和数据，且不会产生数据和指令的竞争。  </li><li>哈佛架构允许使用不同的存储介质和方法存储指令和数据。  </li><li>冯诺依曼架构中允许像访问数据一样访问指令，反之亦然。  </li><li>冯诺依曼架构中指令被视作数据，因此冯诺依曼架构允许从外部存储中加载程序。  </li></ol><h2 id="栈和缓存"><a href="#栈和缓存" class="headerlink" title="栈和缓存"></a>栈和缓存</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ol><li>栈是一种数据结构，其遵循后进先出（LIFO）的原则。  </li><li>在现代计算机中，栈被应用于每一级内存。  </li><li>基本的两个对栈的操作：出栈和入栈。  </li></ol><h4 id="栈实例：逆波兰表示法计算器"><a href="#栈实例：逆波兰表示法计算器" class="headerlink" title="栈实例：逆波兰表示法计算器"></a><strong>栈实例：逆波兰表示法计算器</strong></h4><ol><li>表达式遵循从左到右，先运算数后运算符的顺序依次放入栈中。  </li><li>运算符入栈后，栈顶的两个运算数同运算符一起出栈，运算结果入栈。  </li><li>运算结果出栈。  </li></ol><h3 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h3><p>缓冲遵循先进先出（FIFO）的原则，分为两种缓冲：线形缓冲和环形缓冲，环形缓冲用于流媒体加载。<br>缓冲区的大小如果过大，初始化时间会比较长，需要将缓冲区填满的时间也比较长。<br>缓冲区如果过小，容易发生溢出，如果缓冲区不能够容纳所有的扰乱（Disruption），整个缓冲就会出错。  </p><h2 id="CPU的类型"><a href="#CPU的类型" class="headerlink" title="CPU的类型"></a>CPU的类型</h2><h3 id="CISC-Complex-Instruction-Set-Computer"><a href="#CISC-Complex-Instruction-Set-Computer" class="headerlink" title="CISC,Complex Instruction Set Computer"></a>CISC,Complex Instruction Set Computer</h3><p>每一条指令可以执行数条低级的操作（比如一条指令就可以实现内存加载和数学运算等）  </p><h3 id="RISC-Reduced-Instruction-Set-Computer"><a href="#RISC-Reduced-Instruction-Set-Computer" class="headerlink" title="RISC,Reduced Instruction Set Computer"></a>RISC,Reduced Instruction Set Computer</h3><p>大多数指令被限制成统一的长度和相似的结构，数学运算被限制在了CPU寄存器当中，只有对内存的读取和储存是分别的指令。<br>大多数的寄存机也是通用的，只有浮点寄存器仍然被专门化。<br>RISC指令集的计算机对pipline stages的平衡更佳，且允许更高的时钟频率，也更为高效。  </p><h3 id="MISC-Minimal-Instruction-Set-Computer"><a href="#MISC-Minimal-Instruction-Set-Computer" class="headerlink" title="MISC,Minimal Instruction Set Computer"></a>MISC,Minimal Instruction Set Computer</h3><p>数量非常少的操作和对应的操作码，指令集基本上是基于栈结构构造的。  </p><blockquote><p>ZISC和OISC在此略</p></blockquote><h2 id="串行连接和并行连接"><a href="#串行连接和并行连接" class="headerlink" title="串行连接和并行连接"></a>串行连接和并行连接</h2><h3 id="对比-1"><a href="#对比-1" class="headerlink" title="对比"></a>对比</h3><ol><li>通常串行传输比并行传输速度更快。  </li><li>串行传输不易出现Clock Skew（时钟信号在不同组件中到达的时间有差异）。   </li><li>串行传输占用空间更少。  </li><li>串行线路不容易受到周围线路的影响。  </li><li>串行线路避免内Crosstalk（数据在传输时对另外的线路产生影响）。  </li><li>串行线路由于Pin数更少，因此更便宜。  </li></ol><h2 id="并行算法"><a href="#并行算法" class="headerlink" title="并行算法"></a>并行算法</h2><h3 id="基本定律"><a href="#基本定律" class="headerlink" title="基本定律"></a>基本定律</h3><p>阿姆达尔定律：理想中对整个系统最大的改进是对系统中的部分进行改进。因此来自部分升级的影响总是有限的。  </p><h2 id="校验码"><a href="#校验码" class="headerlink" title="校验码"></a>校验码</h2><h3 id="汉明码"><a href="#汉明码" class="headerlink" title="汉明码"></a>汉明码</h3><p>在一串$d$位数据的$2^{n-1}$位上加入校验位，校验位的数量$c$满足：$2^c-1&gt;=d$。<br>第$n$个校验码的校验条件满足： 从第$2^n$位开始，使用偶校验检测$2^n$位，再跳过$2^n$位，再检测$2^n$位，重复直到检测最后一位。<br><strong>数据和校验码的位置序号是相反的</strong>,数据的比特位编号是从右到左依次减小，校验码的比特位是从右到左依次增大<br>缺点： 当只有一个校验码出错时，有50%的概率是数据出错，有50%的概率是校验码自己出错，无法确定。  有两个比特出错时可以检验，但无法校正。  </p><p>题目类型：  </p><ol><li>编码</li><li>解码</li><li>求未知数的值（注意可能性有很多种）</li></ol><p>汉明码的局限性：  </p><ol><li>当同时出现两个以上的比特位错误时，可能无法被检测到。  </li><li>出现一位比特错误时，在某些情况下无法判断是校验码还是数据发生了错误。  </li></ol><h3 id="其他的校验方式"><a href="#其他的校验方式" class="headerlink" title="其他的校验方式"></a>其他的校验方式</h3><p><strong>循环冗余校验（CRC,Cyclic Redundancy Checks）</strong><br>通过生成独特的哈希函数来检测比特位的改变，但不能检测出恶意引入的错误。  </p><p><strong>前项校验（Forward Error Correction）</strong><br>在卷积码和块码（通常是里德-所罗门码）之间做校验。  </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>计算机结构与接口</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>11. 滤波器设计</title>
    <link href="/2021/06/14/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/11.%20%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%AE%BE%E8%AE%A1/"/>
    <url>/2021/06/14/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/11.%20%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="滤波器设计"><a href="#滤波器设计" class="headerlink" title="滤波器设计"></a>滤波器设计</h1><h2 id="失真"><a href="#失真" class="headerlink" title="失真"></a>失真</h2><p>系统方程$H(s)$可以写作：</p><script type="math/tex; mode=display">H(jω)=|H(jω)|e^{jϕ(jω)}</script><p>即幅值和相位两部分。系统输出的实质是对系统方程的频率和赋值用$E(jω)$进行加权。<br>如果不同频率信号的幅值加权或相位校正不同，则输出波形将与输入波形形状不同，从而导致失真。<br>失真分为两种类型：<br>线性失真：信号的幅值和相位发生变化，但是没有引入新的频率信号。<br>非线性失真：引入了新的频率信号。  </p><h2 id="滤波器波形"><a href="#滤波器波形" class="headerlink" title="滤波器波形"></a>滤波器波形</h2><p>实际的滤波器波形如图表示：<br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210531161932.png" alt=""><br>滤波器波形的四个参数：</p><ol><li>通带边缘（Passband edge,$ω_p$）</li><li>最大允许变化（Maximum allowed variation,$A_max$）</li><li>阻带边缘（Stopband edge,$ω_s$）</li><li>最小阻带衰减要求（Minimum required stopband attenuation,$A_min$）</li></ol><h2 id="滤波器设计-1"><a href="#滤波器设计-1" class="headerlink" title="滤波器设计"></a>滤波器设计</h2><h3 id="低通-滤波器类型"><a href="#低通-滤波器类型" class="headerlink" title="(低通)滤波器类型"></a>(低通)滤波器类型</h3><h4 id="巴特沃斯滤波器"><a href="#巴特沃斯滤波器" class="headerlink" title="巴特沃斯滤波器"></a><strong>巴特沃斯滤波器</strong></h4><p>传递函数：</p><script type="math/tex; mode=display">|T(jω)|=\frac{1}{√(1+ɛ^2(\frac{ω}{ω_p})^(2n))}</script><p>其中：$n≥\frac{logM}{logΩ}$为电路阶数，$ɛ=√{10^{\frac{A_{max}}{10}}-1}$<br>$Ω=\frac{ω_s}{ω_p}$，$M=√{\frac{\frac{1}{K_A}-1}{\frac{1}{K_r-1}}}$</p><p>滤波器特点：  </p><ol><li>没有波纹</li><li>$|ω_s-ω_p|$较大，无法立刻停止</li></ol><h4 id="切比雪夫滤波器"><a href="#切比雪夫滤波器" class="headerlink" title="切比雪夫滤波器"></a><strong>切比雪夫滤波器</strong></h4><p>传递函数：</p><script type="math/tex; mode=display">|T(jω)|=\frac{1}{√1+ɛ^2C^2_n(ω/ω_p)}</script><p>其中：$n≥\frac{cosh^{-1}M}{cosh^{-1}Ω}$为电路阶数，$ɛ=√{10^{\frac{A_{max}}{10}}-1}$<br>$Ω=\frac{ω_s}{ω_p}$，$M=√{\frac{\frac{1}{K_A}-1}{\frac{1}{K_r-1}}}$  </p><div class="note note-info">            <p>将电感和电容对换就可以得到高通滤波器。   </p>          </div>  <h3 id="设计方法"><a href="#设计方法" class="headerlink" title="设计方法"></a>设计方法</h3><ol><li>确定使用的滤波器类型  </li><li>找到能够拟合要求的传递函数（巴特沃斯/切比雪夫）  </li><li>根据波形图求出电路的最小阶数$n$  </li><li>查表找到CL的数值，并作反归一化  </li><li>连接电路  </li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>信号与系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>附录2：冲激信号·卷积·傅里叶/拉普拉斯/Z变换的运算性质</title>
    <link href="/2021/06/13/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/%E9%99%84%E5%BD%952%EF%BC%9A%E5%8D%B7%E7%A7%AF%E3%80%81%E4%B8%89%E5%A4%A7%E5%8F%98%E6%8D%A2%E7%9A%84%E8%BF%90%E7%AE%97%E6%80%A7%E8%B4%A8/"/>
    <url>/2021/06/13/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/%E9%99%84%E5%BD%952%EF%BC%9A%E5%8D%B7%E7%A7%AF%E3%80%81%E4%B8%89%E5%A4%A7%E5%8F%98%E6%8D%A2%E7%9A%84%E8%BF%90%E7%AE%97%E6%80%A7%E8%B4%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="附录2：冲激信号·卷积·傅里叶-拉普拉斯-Z变换的运算性质"><a href="#附录2：冲激信号·卷积·傅里叶-拉普拉斯-Z变换的运算性质" class="headerlink" title="附录2：冲激信号·卷积·傅里叶/拉普拉斯/Z变换的运算性质"></a>附录2：冲激信号·卷积·傅里叶/拉普拉斯/Z变换的运算性质</h1><h2 id="冲激信号的性质"><a href="#冲激信号的性质" class="headerlink" title="冲激信号的性质"></a>冲激信号的性质</h2><p>采样性质：<br>$δ(t)f(t)=f(0)δ(t)$<br>$∫δ(t)f(t)dt=f(0)$  </p><p>对称:<br>$δ(t)=δ(-t)$  </p><p>尺度变换：<br>$δ(at)=\frac{1}{\lvert a\rvert}δ(t)$</p><p>卷积性质：<br>$f(t)*δ(t)=δ(t)$  </p><p>$f(t)*δ(t-t_0)=f(t-t_0)$  </p><h4 id="冲激偶的性质"><a href="#冲激偶的性质" class="headerlink" title="冲激偶的性质"></a><strong>冲激偶的性质</strong></h4><p>尺度变换：<br>$δ’(at)=\frac{1}{|a|}\frac{1}{a}δ’(t)$<br>积分性质：<br>$∫δ’(t)dt=0$<br>$∫δ’(t)f(t)dt=-f’(0)$  </p><p>卷积性质：<br>$f(t)*δ’(t)=f’(t)$  </p><h2 id="卷积的性质"><a href="#卷积的性质" class="headerlink" title="卷积的性质"></a>卷积的性质</h2><p>交换律、结合律、分配律<br>微分性质：<br>$g’(t)=f(t)h’(t)=f’(t)*h(t)$  </p><p>$g^{(n-m)}(t)=f^{(n)}(t)*h^{(-m)}(t)=f^{(-m)}(t)*h^{(n)}(t)$  </p><p>任何函数都可以表示为自己和冲激函数的卷积：  </p><script type="math/tex; mode=display">f(t)=f(t)*δ(t)</script><h2 id="傅里叶-拉普拉斯-z变换的性质"><a href="#傅里叶-拉普拉斯-z变换的性质" class="headerlink" title="傅里叶/拉普拉斯/z变换的性质"></a>傅里叶/拉普拉斯/z变换的性质</h2><h3 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h3><div class="table-container"><table><thead><tr><th style="text-align:center">注解</th><th style="text-align:center">时域</th><th style="text-align:center">频域</th></tr></thead><tbody><tr><td style="text-align:center">对偶性</td><td style="text-align:center">$2πf(-ω)$</td><td style="text-align:center">$F(t)$</td></tr><tr><td style="text-align:center">尺度变换</td><td style="text-align:center">$f(at)$</td><td style="text-align:center">$\frac{1}{\lvert a\rvert}F(\frac{ω}{a})$</td></tr><tr><td style="text-align:center">时移</td><td style="text-align:center">$f(t-t_0)$</td><td style="text-align:center">$F(ω)e^{-jωt_0}$</td></tr><tr><td style="text-align:center">频移</td><td style="text-align:center">$f(t)e^{-jω_0t}$</td><td style="text-align:center">$F(ω+ω_0)$</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">时域微分</td><td style="text-align:center">$f’(t)$</td><td style="text-align:center">$jωF(ω)$</td></tr><tr><td style="text-align:center">频域微分</td><td style="text-align:center">$-jtf(t)$</td><td style="text-align:center">$F’(ω)$</td></tr><tr><td style="text-align:center">时域积分</td><td style="text-align:center">$∫f(t)dt$</td><td style="text-align:center">$πF(0)δ(ω)+\frac{F(ω)}{jω}$</td></tr></tbody></table></div><h3 id="拉普拉斯变换"><a href="#拉普拉斯变换" class="headerlink" title="拉普拉斯变换"></a>拉普拉斯变换</h3><div class="table-container"><table><thead><tr><th style="text-align:center">注解</th><th style="text-align:center">时域</th><th style="text-align:center">频域</th></tr></thead><tbody><tr><td style="text-align:center">时移</td><td style="text-align:center">$f(t-t_0)$</td><td style="text-align:center">$F(ω)e^{-t_0s}$</td></tr><tr><td style="text-align:center">频移</td><td style="text-align:center">$f(t)e^{-at}$</td><td style="text-align:center">$F(s+a)$</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">时域微分（一阶）</td><td style="text-align:center">$f’(t)$</td><td style="text-align:center">$sF(s)-f(0)$</td></tr><tr><td style="text-align:center">时域微分（二阶）</td><td style="text-align:center">$\frac{df^2(t)}{dt}$</td><td style="text-align:center">$s[sF(s)-f(0)]-f’(0)$</td></tr><tr><td style="text-align:center">频域微分</td><td style="text-align:center">$t^nf(t)$</td><td style="text-align:center">$(-1)^n\frac{d^nF(s)}{ds^n}$</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">时域积分</td><td style="text-align:center">$∫f(t)dt$</td><td style="text-align:center">$\frac{F(s)}{s}+\frac{f’(0)}{s}$</td></tr><tr><td style="text-align:center">频域积分</td><td style="text-align:center">$\frac{f(t)}{t}$</td><td style="text-align:center">$∫F(s)ds$</td></tr></tbody></table></div><p>初值定理: $f(0_+)\lim_{s→∞}sF(s)$<br>终值定理：$\lim_{t→∞}f(t)=\lim_{s→0}sF(s)$<br>卷积理论：$L[f(t)h(t)]=\frac{1}{2πj}F(s)*H(s)$  </p><h3 id="z变换"><a href="#z变换" class="headerlink" title="z变换"></a>z变换</h3><div class="table-container"><table><thead><tr><th style="text-align:center">注解</th><th style="text-align:center">时域</th><th style="text-align:center">频域</th></tr></thead><tbody><tr><td style="text-align:center">双侧时移</td><td style="text-align:center">$x(n+m)$</td><td style="text-align:center">$z^mX(z)$</td></tr><tr><td style="text-align:center">尺度变换（时域）</td><td style="text-align:center">$nx(n)$</td><td style="text-align:center">$-z\frac{dX(z)}{dz}$</td></tr><tr><td style="text-align:center">尺度变换(z域)</td><td style="text-align:center">$a^nx(n)$</td><td style="text-align:center">$X(\frac{z}{a})$</td></tr></tbody></table></div><p>初值定理: $x(0_+)\lim_{x→∞}sX(z)$<br>终值定理：$\lim_{n→∞}x(n)=\lim_{z→1}(z-1)X(z)$<br>卷积理论：$Z[x(n)*h(n)]=X(z)H(z)$  </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>信号与系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机结构基础-课堂笔记</title>
    <link href="/2021/06/12/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84%E4%B8%8E%E6%8E%A5%E5%8F%A3/1.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/06/12/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84%E4%B8%8E%E6%8E%A5%E5%8F%A3/1.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机结构基础"><a href="#计算机结构基础" class="headerlink" title="计算机结构基础"></a>计算机结构基础</h1><blockquote><p>讲义复习<br>BUL EE2623 Computer Architecture and Interface<br>Dr. Takebumi Itagaki   </p></blockquote><h2 id="冯诺依曼架构"><a href="#冯诺依曼架构" class="headerlink" title="冯诺依曼架构"></a>冯诺依曼架构</h2><p>组成部分： CPU/ALU,I/O, Buses, Main Memory<br>特征： 所有的部分都通过总线连接<br>总线的类别： 数据总线，地址总线，控制总线</p><h2 id="数制"><a href="#数制" class="headerlink" title="数制"></a>数制</h2><p>十六进制，十进制，八进制，二进制的相互转化。</p><h3 id="二进制整数的表达和运算"><a href="#二进制整数的表达和运算" class="headerlink" title="二进制整数的表达和运算"></a>二进制整数的表达和运算</h3><h4 id="Unsigned"><a href="#Unsigned" class="headerlink" title="Unsigned"></a>Unsigned</h4><p>  不表示负数，因此第一位比特位到最后一位都可以用来表示数   </p><ul><li><p>逻辑运算<br>AND（乘法）  OR（加法）  NOT（取反）  XOR（取异）</p><h4 id="Signed"><a href="#Signed" class="headerlink" title="Signed"></a>Signed</h4><p>可以表示正数，负数，0， 第一位比特位表示正负号：0为正，1为负。<br>因此表示范围折半，以8比特为例，Unsigned表示的范围为0~255，而Signed表示的范围为-128~127（中间有0，故不是128）。   </p><ul><li>转换<br>转换为Signed的方法是先找到十进制绝对值对应的二进制数，取反码后+1得到二补码，即Signed Number。  </li><li>加减法<br>二补码的加法是<strong>异或运算</strong>，比特相同取0，不同取1。<br>减法看做是与负数相加。   </li></ul><p>加法要注意判断是否发生溢出，有两种思路可以判断是否发生了溢出。    </p></li></ul><ol><li>转换为十进制加减法，看是否发生了溢出</li><li>遵循两个原则：<br>a. 进位值的比特位数与数据的比特位数相同<br>b. 如果进位值的前两位是”01”或者是”10”，那么就发生了溢出。</li></ol><ul><li>乘法<br>类似于十进制乘法：第一行的所有位与第二行的每一个比特位分别相乘并作移位，最后相加。 单个比特位的乘法遵循：“除了$1×1=1$外，其余结果都为0。（与0相乘都为0。）”     </li></ul><h3 id="二进制浮点数的表达"><a href="#二进制浮点数的表达" class="headerlink" title="二进制浮点数的表达"></a>二进制浮点数的表达</h3><h4 id="IEEE-754"><a href="#IEEE-754" class="headerlink" title="IEEE 754"></a><strong>IEEE 754</strong></h4><p>IEEE 754是用来表示二进制浮点数的标准，<strong>基于二进制</strong>。其中有32位，64位，128位表示方法，以32位为例：32位浮点数的表示方法为：</p><div class="table-container"><table><thead><tr><th style="text-align:center">Width of Bits</th><th style="text-align:center">1</th><th style="text-align:center">8</th><th style="text-align:center">23</th></tr></thead><tbody><tr><td style="text-align:center">Content</td><td style="text-align:center">Sign</td><td style="text-align:center">Exponent</td><td style="text-align:center">Fraction</td></tr><tr><td style="text-align:center">bias: +127</td></tr></tbody></table></div><ul><li>Bias<br>为了让Signed更方便的进行比较，将Signed转换成二进制后的指数部分人为地加一个Bias使得指数部分转变到Unsigned的范围内（0和255特殊处理）便于比较。<br>Bias的值规定是exp位十进制数的中位数或中间两个数的平均数。<br>IEEE 754 能够表示0， 规格数（Exp部分不为0），非规格数（Exp部分为0，如果Exp小于0则把Exp划到0后，剩下的部分进入小数部分），无穷和其他未规定的计算结果（NaN）。   </li><li>十进制转IEEE754<ol><li>确定正负</li><li>小数部分（$2^{-k}$）和整数部分（$2^{k}$）分别写出二进制形式（负数不需要转化为补码），合并，中间以小数点隔开</li><li>将小数点移动到第一位和第二位末尾，假设移动距离为$x$，后面的指数部分写作$2^x$。</li><li>取现在的小数部分，并在末尾补0直到小数部分的总比特数为23位。  </li><li>取现在的指数部分$x+bias$，并转换为二进制填入Exp中。  </li></ol></li><li><p>IEEE754转十进制  </p><script type="math/tex; mode=display">(-1)^s(1+x)2^{exponent-127}</script><p>其中$s$为符号位，为0则表示正数，反之1为负数；$x$为第9～31位共23位所表示的小数的十进制；$exponent$为第1～8位表示的幂数。  </p></li><li><p>运算规定<br>规定如下的情况结果会是Not A Number(e全是1，f=0)：  </p><ol><li>$⨦0 ÷ ⨦0$  </li><li>$∞-∞$  </li><li>$⨦∞÷⨦∞$  </li><li>$⨦∞ × 0$  </li></ol><p>规定如下的情况结果会是无穷(e全是1,f$̸=$0)：  </p><ol><li>$∞ × ∞$  </li><li>$∞ + ∞$  </li><li>$nonezero ÷ 0$<br>规定$n ÷ ∞=0$(e全是0,f全是0)。  </li></ol></li><li><p>范围  </p><ul><li>最大正数：<br>$(2-2^{-23}）2^{127}≈2^{128}$<br>(0 | 1111 1111 | 1111 1111 11111 1111 1111 111)   </li><li>最小非规格数：<br>$2^{-23}×2^{-127}=2^{-150}$<br>(0 | 0000 0000 | 0000 0000 0000 0000 0000 001)  <div class="note note-info">            <p>请注意，这是在不考虑移位的情况下，如果考虑移位，那么这个数应该为$2^{-23}×2^{-126}=2^{-149}$  </p>          </div></li></ul></li></ul><ul><li>最小正数：<br>$2^{-126}$<br>(0 | 0000 0001 | 0000 0000 0000 0000 0000 000)  </li></ul><h4 id="IBM-Float-System"><a href="#IBM-Float-System" class="headerlink" title="IBM Float System"></a><strong>IBM Float System</strong></h4><p>IBM Float System是基于<strong>基于十六进制</strong>的浮点数表示方法。<br>32位IBM 浮点数的表示方法为：</p><div class="table-container"><table><thead><tr><th style="text-align:center">Width of Bits</th><th style="text-align:center">1</th><th style="text-align:center">7</th><th style="text-align:center">24</th></tr></thead><tbody><tr><td style="text-align:center">Content</td><td style="text-align:center">Sign</td><td style="text-align:center">Exponent</td><td style="text-align:center">Fraction</td></tr><tr><td style="text-align:center">bias: +64</td></tr></tbody></table></div><ul><li><p>IBM Float转十进制</p><script type="math/tex; mode=display">(-1)^s\frac{M}{2^{24}}16^{exponent-64}</script><p>$M$是24位小数部分转成10进制后的数。  </p></li><li><p>范围<br>$16^{-88}$-$16^{64}$</p></li></ul><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><h3 id="分级存储"><a href="#分级存储" class="headerlink" title="分级存储"></a>分级存储</h3><p>由于CPU的速度受到内存读取速度的牵制，因此有必要将内存进行分级，读写速度越快的内存越靠近CPU，但是由于成本等原因，其储存空间越小。   将内存可以大致分为几层：  </p><ul><li>CPU内部的寄存器：用于存放临时数据，读写速度非常快，储存空间非常小，断电消失。  </li><li>CPU外部的存储（RAM）： 用于存放程序和数据，读写速度相对快，储存空间相对大，断电消失。  </li><li>外部的永久储存（硬盘）：读写速度慢，储存空间大，断电可以保存。  <h3 id="数据的组织"><a href="#数据的组织" class="headerlink" title="数据的组织"></a>数据的组织</h3><script type="math/tex; mode=display">\begin{array}{c}bit & 1  \\byte & 4  \\word & 8   \\Longword & 16 \end{array}</script>在主存储器中，每一个Byte都对应了一个地址，但是英特尔和摩托罗拉有两种不同的存放数据的方式，一种(Intel)是先存最低位（LSB），再存最高位(MSB)，称为小端模式（Small Endian）另一种（摩托罗拉）是先存最高位（MSB），再存最低位（LSB），称为大端模式（Big Endian）。<br>具体而言，小端的LSB被存储到最小的地址，然后下一个字节被存储到更大的地址，直到MSB被存储到最大的地址。<br>大端的MSB被存储到最小的地址，然后下一个字节被存储到更小的地址，直到LSB被存储到最大的地址。<br>因此数据在两种机器间必须先要转换，才能存放再另一种机器中。  </li></ul><h3 id="程序与指令"><a href="#程序与指令" class="headerlink" title="程序与指令"></a>程序与指令</h3><h4 id="CPU中模块的连接方式"><a href="#CPU中模块的连接方式" class="headerlink" title="CPU中模块的连接方式"></a>CPU中模块的连接方式</h4><p>寄存器： 数据总线<br>ALU： 地址总线<br>控制单元(CU): 控制总线</p><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><p>寄存器可以分为用户可见（数据寄存器，地址寄存器，条件寄存器 ）和不可见的两种寄存器。<br>状态和控制寄存器：<br>PC（指针）：指向下一条指令对应的地址<br>MAR（内存地址寄存器），MBR（内存缓冲寄存器）：将指令从内存放入缓冲区，协调CPU与存储的速度。<br>指令寄存器： 存放当前的指令  </p><h4 id="指令的运行"><a href="#指令的运行" class="headerlink" title="指令的运行"></a>指令的运行</h4><ol><li>将PC指向的内容移到MAR,PC指向下一条指令</li><li>将MAR的内容移到MBR</li><li>将MBR的内容移到IR</li><li>将IR的控制内容交给CU，地址内容交给MAR</li><li>将MAR的内容移到MBR</li><li>ALU执行</li><li>ALU返回结果到指定内存<br>有两种执行指令的方式：   </li></ol><ul><li><p>硬件连接（Hardwiring）<br>一种指令对应一个硬件<br>优点：<br>快速，一个时钟内就能够解码一条指令</p></li><li><p>Micro-Programming<br>每条指令都转换成最原始的指令（Micro-instructions），对应了一个指定的门或者触发器等等，在CU中被执行。<br>因此Micro-Programming 是仅次于逻辑电路的第二层级，它也被称作固件，将软件与硬件连接起来。<br>优点：    </p><ol><li>可以创建任何复杂的指令或指令集</li><li>灵活，能够允许用户进行micro-program</li><li>有更高级的语言层</li></ol></li></ul><h2 id="栈和缓存"><a href="#栈和缓存" class="headerlink" title="栈和缓存"></a>栈和缓存</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>原则：后进先出<br>入栈（Push）： 将新节（node）放入栈顶<br>出栈（Pop）： 将栈顶节移除栈<br>溢出： 节数量超过了栈能够容纳的最大限度<br>优点： </p><ol><li>分配简单  </li><li>当函数退出的时候栈会自动回收    </li></ol><p>缺点：  </p><ol><li>有溢出可能</li><li>由于函数结束后栈会自动回收，因此如果有别的函数想要使用当前函数的返回值时，就必须要在当前函数执行结束前复制返回值以避免被回收。  </li></ol><p>使用栈结构与使用寄存器结构相比：   </p><ol><li>指令更小，因为操作对象（操作数）不需要指定地址</li><li>执行速度更慢，因为堆栈在外部内存中    </li></ol><h3 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h3><p>原则： 先进后出<br>溢出： 写速度大于读速度<br>空缓冲： 读速度大于写速度<br>缓冲分为两种：线形缓冲和环形缓冲（应用：视频处理）。<br>缓冲区大小的影响：  </p><ul><li>缓冲区过大  </li></ul><ol><li>启动时间长  </li><li>填满缓冲区的时间也长  </li></ol><ul><li>缓冲区过小  </li></ul><ol><li>更容易溢出  </li><li>如果缓冲区不够容纳所有的中断，系统会出错  </li></ol><h2 id="拓扑结构（物理）"><a href="#拓扑结构（物理）" class="headerlink" title="拓扑结构（物理）"></a>拓扑结构（物理）</h2><div class="table-container"><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">优点</th><th style="text-align:left">缺点</th></tr></thead><tbody><tr><td style="text-align:left">Liner</td><td style="text-align:left">1. 连接简单 <br>2.用线短</td><td style="text-align:left">1. 如果主线断所有都断  <br>2. 主线断时难以查错  <br>3. 两端需要端子</td></tr><tr><td style="text-align:left">Ring</td><td style="text-align:left">1.加入简单</td><td style="text-align:left">1. 一处断，处处断</td></tr><tr><td style="text-align:left">Star*</td><td style="text-align:left">1. 连接简单  <br>2.设备之间不会有干扰  <br>3.简单查错  <br>4.加入和移除新设备简单</td><td style="text-align:left">1. 需要更多的线  <br>2. Hub断，所有断  <br>3.成本高(因为需要Hub)</td></tr><tr><td style="text-align:left">Tree*</td><td style="text-align:left">1.点对点的连线</td><td style="text-align:left">1.难以布线  <br>2.主线断，处处断</td></tr></tbody></table></div><h2 id="拓扑协议"><a href="#拓扑协议" class="headerlink" title="拓扑协议*"></a>拓扑协议*</h2><h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><p>如果网络没人广播，目标就广播。如果有人广播，目标等待其他人结束广播后广播。  </p><h3 id="本地会话"><a href="#本地会话" class="headerlink" title="本地会话"></a>本地会话</h3><p>如果目标需要传输和发送空令牌，数据就会附加到空令牌上，在Token Ring中传输直到找到接收者。   </p><h3 id="ATM"><a href="#ATM" class="headerlink" title="ATM"></a>ATM</h3><p>所有的数据以固定大小的小包传送，通常在两个局域网间使用。  </p><h2 id="I-O-接口"><a href="#I-O-接口" class="headerlink" title="I/O 接口"></a>I/O 接口</h2><p>I/O 接口的功能是为CPU和总线提供一个标准的借口。同时兼容各种I/O设备的借口需求，并且释放CPU对于I/O设备的管理。   </p><h3 id="I-O的控制方式"><a href="#I-O的控制方式" class="headerlink" title="I/O的控制方式"></a>I/O的控制方式</h3><ol><li>程序I/O<br>在I/O执行命令时，CPU一直等待并检测I/O是否完成任务，直到I/O执行完成。<br>特点：<br>程序I/O损失了CPU大部分的计算力，是一种低下的连接方式。   </li><li>中断I/O<br>CPU发出一个指令到I/O，之后做其他的任务直到I/O完成操作。 I/O完成操作后，会发出中断指令中断CPU当前的任务。 CPU处理完来自I/O的任务后，继续执行之前的任务。   </li><li>DMA<br>由于冯诺依曼架构中内存，I/O，存储都通过总线连接，使得数据在I/O 与内存之间能够直接传输数据成为可能。<br>整块数据在I/O与内存之间的传送在DMA控制器的控制下完成，仅在传输数据块的开始和结束时才需要CPU干预。<br>DMA会在CPU不使用总线时接管总线。    <h3 id="I-O接口的类型"><a href="#I-O接口的类型" class="headerlink" title="I/O接口的类型"></a>I/O接口的类型</h3>PCI，ATA，ISA，USB等等……</li></ol><h2 id="串行和并行连接"><a href="#串行和并行连接" class="headerlink" title="串行和并行连接"></a>串行和并行连接</h2><p>串行连接： 一比特一时钟发送数据<br>并行连接： 所有的比特会一起发送   </p><h3 id="串行连接的方式"><a href="#串行连接的方式" class="headerlink" title="串行连接的方式"></a>串行连接的方式</h3><ol><li>串行连接的时分复用<br>CPU在每一个单位时间内都处理不同并行通道内的一个数据包。  每个通道的前几个比特是用来与系统进行时间同步的。<br>例子： GSM（2G），TD-CMDA（3G）</li><li>Teletype<br>Teletype的一个数据包内通常包括： Start bit， Content， Stop Bit， Parity Bit。<br>串行需要信号去控制数据传输的暂停和恢复以适配不同速度的数据流。   </li></ol><h3 id="硬件-UART"><a href="#硬件-UART" class="headerlink" title="硬件-UART"></a>硬件-UART</h3><p>UART 遵循先进先出原则，传输异步信号。   </p><h3 id="并行连接"><a href="#并行连接" class="headerlink" title="并行连接"></a>并行连接</h3><p>并行连接往往需要不止一条数据线传输，因此体积会更大，同时数据传输更容易受到线长的限制。<br>并行连接一般有4种Pins： Data Pins, Control Pins, Status Pins, Ground Pins。      </p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ol><li>通常串行传输比并行传输速度更快。   </li><li>串行传输不易出现Clock Skew（时钟信号在不同组件中到达的时间有差异）。</li><li>串行传输占用空间更少。</li><li>串行线路不容易受到周围线路的影响。</li><li>串行线路避免内Crosstalk（数据在传输时对另外的线路产生影响）。   </li><li>串行线路由于Pin数更少，因此更便宜。   </li></ol><h2 id="并行算法"><a href="#并行算法" class="headerlink" title="并行算法"></a>并行算法</h2><h3 id="并行算法的类型"><a href="#并行算法的类型" class="headerlink" title="并行算法的类型*"></a>并行算法的类型*</h3><ol><li>Pipline<br>在执行第一个任务的同时准备后面的任务。<br>所有的任务都不可能比整个任务链的处理速度更快，先前的任务必须要完成后才能完成之后的任务。 但是大多数的算法都不会有太长的计算链。   </li></ol><h3 id="并行计算"><a href="#并行计算" class="headerlink" title="并行计算"></a>并行计算</h3><p>并行计算体现在两点：  </p><ol><li>一个处理器执行时分复用（多线程）       </li><li>拥有不止一个处理器 （多核心）<br>弗莱因分类法将并行计算机按照指令和数据流分为四类：SISD，MISD，SIMD，MIMD。 即单/多指令，单/多数据流。<br>通常n个并行处理器比n倍快的单个处理器效率更慢，但是并行系统更便宜。    <h3 id="基本定律"><a href="#基本定律" class="headerlink" title="基本定律"></a>基本定律</h3>阿姆达尔定律: 理想中对整个系统最大的改进是对系统中的部分进行改进。<br>古斯塔夫森定律*:  $S_{latency}=1-p+sp$<br>$S_{latency}$： 整个任务执行延迟的理论加速。<br>$s$：受益于系统资源改善的部分的加速。<br>$p$：整个任务中，相对于改进前受益于改善后的部分所占的百分比。     </li></ol><h3 id="并行计算的层级"><a href="#并行计算的层级" class="headerlink" title="并行计算的层级"></a>并行计算的层级</h3><ol><li>比特层级<br>加倍字长。 部分需要两个字长才能运行的指令（需要两个时钟）变成一个字，进而在一个时钟内就能运行。     </li><li>指令层级<br>基础的分量级处理器只能在一个时钟内运行不到一个指令。<br>对这些指令重排，并整合成指令群。现代处理器还将pipline分成了多级，因此在一个时钟内可以运行一条指令。<br>超标量处理器有多个处理单元，因此可以在一个时钟内运行多条指令。但是指令来源于同一个指令流。多核处理器也可以在一个时钟内运行多条指令，但指令来源于多个指令流。      </li><li>任务层级<br>将任务分成多个子任务并交给不同的处理器运行。   </li></ol><h3 id="并行计算的例子"><a href="#并行计算的例子" class="headerlink" title="并行计算的例子*"></a>并行计算的例子*</h3><ol><li>分布式计算<br>与并行计算并无太多区别，可以理解为并行计算。   </li><li>网格计算<br>通过Internet将不同的计算机连接（需要中间件兼容），但是由于Internet的低带宽高延迟特性，因此性能往往不好。  </li><li>可重构计算（FGPA）<br>将一个可编程门</li><li>GPU</li><li>向量处理器</li></ol><h2 id="哈佛架构"><a href="#哈佛架构" class="headerlink" title="哈佛架构"></a>哈佛架构</h2><p>和冯诺依曼架构最大的不同是：内存被分为了两部分：Program Memory（静态内存）和 Data Memory（动态内存）。</p><h3 id="与冯诺依曼架构对比"><a href="#与冯诺依曼架构对比" class="headerlink" title="与冯诺依曼架构对比"></a>与冯诺依曼架构对比</h3><ol><li>哈佛架构的CPU可以在同一时间读取指令和数据（同时性），且指令和数据不会在fetch时竞争（独立性）。     </li><li>哈佛架构允许Program Memory 和 Data Memory的储存介质不同。    </li><li>哈佛架构允许像访问数据一样访问指令储存器的内容。</li><li>冯诺依曼架构中代码被视为数据，数据也被看作代码。 因此冯诺依曼架构允许从硬盘中读取和执行程序。<br>现代的处理器通常是哈佛架构和冯诺依曼架构的混合架构，通常被视作是改进的哈佛架构。   如：x86，ARM， PowerPC。     </li></ol><h2 id="校验码"><a href="#校验码" class="headerlink" title="校验码"></a>校验码</h2><h3 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h3><p>在数据包后加上一个校验位，使得所有的比特位中1的总数为奇数/偶数。<br>缺点： 无法探测错误的位置。 对于两位以上的错误，无法矫正错误。   </p><h3 id="汉明码"><a href="#汉明码" class="headerlink" title="汉明码"></a>汉明码</h3><p>在一串$d$位数据的$2^{n-1}$位上加入校验位，校验位的数量$c$满足：$2^c-1&gt;=d$。<br>第$n$个校验码的校验条件满足： 从第$2^n$位开始，使用偶校验检测$2^n$位，再跳过$2^n$位，再检测$2^n$位，重复直到检测最后一位。<br><strong>数据和校验码的位置序号是相反的</strong>,数据的比特位编号是从右到左依次减小，校验码的比特位是从右到左依次增大<br>缺点： 当只有一个校验码出错时，有50%的概率是数据出错，有50%的概率是校验码自己出错，无法确定。  有两个比特出错时可以检验，但无法校正。  </p><h3 id="前向纠错码"><a href="#前向纠错码" class="headerlink" title="前向纠错码"></a>前向纠错码</h3><p>前向纠错是一种差错控制方式，它是指信号在被送入传输信道之前预先按一定的算法进行编码处理，加入带有信号本身特征的冗码，在接收端按照相应算法对接收到的信号进行解码，从而找出在传输过程中产生的错误码并将其纠正的技术。<br>前向纠错码分为两种：卷积码（一个比特一个比特地处理）和块码（一个块一个块地处理）。 块纠错码的代表是里得-所罗门码。   </p><h3 id="循环冗余校验"><a href="#循环冗余校验" class="headerlink" title="循环冗余校验"></a>循环冗余校验</h3><p>循环冗余校验是利用里得-所罗门码进行校验的一种方式，具体是将整个数据包的每一位转换成多项式的系数（值）和次数（位置）。在伽罗瓦域中以输入值作为被除数做多项式除法，得到的余数作为校验的结果。<br>循环冗余校验不能检测恶意插入的错误。   </p><h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p>将原数据输入哈希函数，得到的将是一个哈希值序列的信息摘要。对原数据任何的更改都会导致哈希值序列发生改变，因此可以检测恶意或偶然出现的错误。     </p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>Internet—和校验<br>数字卫星电视信号—循环冗余校验<br>硬盘—循环冗余校验<br>条形码<br>快速响应矩阵（QR二维码）—循环冗余校验     </p><h2 id="CPU的类型"><a href="#CPU的类型" class="headerlink" title="CPU的类型"></a>CPU的类型</h2><p>CPU按照指令集的复杂程度可以分为5类架构：<br>Complex/ Reduced/ Minimal/ One/ Zero Instruction Set Computer  </p><h3 id="CISC"><a href="#CISC" class="headerlink" title="CISC"></a>CISC</h3><p>每一条指令都能够运行一些复杂的低层级的操作，比如算术运算或者从内存加载等等，所有的操作都在一条指令内被执行。<br>优点： 一些复杂或者高级的操作（例如循环）能够直接被整合为一条指令。<br>缺点： 从简单的指令加载复杂的操作并不一定能够提高电脑的性能。<br>常见的CISC处理器架构： x86<br>现代x86处理器能够解码并将指令划分到动态的缓冲微操作中，以便能够在单线程中运行更大的负指令集，同时精简了并行计算。   </p><h3 id="RISC"><a href="#RISC" class="headerlink" title="RISC"></a>RISC</h3><p>RISC 的设计遵循： 如果简化的指令集能够使得每条指令更快的运行，那么简化的指令集就能提高性能。<br>特点：     </p><ol><li>基本上大多数的指令都有相似的结构和固定的长度。通常为一个字长加上固定比特位的操作码。   </li><li>寄存器大多相似且通用（浮点寄存器除外），能够简化编译设计。   </li><li>简单的地址模型。  </li><li>硬件支持的数据类型更少。<br>优点：有更好的pipeline stagesstages 和更快的时钟频率 因此更高效。<br>常见的RISC处理器架构： ARM 和 PowerPC     </li></ol><h3 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h3><p>处理器有很少的基本操作和对应的操作码，通常基于栈结构。<br>优点： 指令和解码单元更小，因此单个指令的运行速度更快。<br>缺点： 指令更依赖于串行结构，减少了并行计算。<br>常见的MISC处理器架构： INMOS</p><h3 id="OISC-和-ZISC"><a href="#OISC-和-ZISC" class="headerlink" title="OISC 和 ZISC"></a>OISC 和 ZISC</h3><p>OISC： 只使用一条指令，不需要操作码。<br>ZISC： 基于纯模式匹配而不需要微指令。   </p><h2 id="特殊化处理器"><a href="#特殊化处理器" class="headerlink" title="特殊化处理器*"></a>特殊化处理器*</h2><h3 id="Cell-Processor"><a href="#Cell-Processor" class="headerlink" title="Cell Processor"></a>Cell Processor</h3><p>Cell Processor是一种拥有很多sub-processor的处理单元，其特征在于：</p><ol><li>所有的子处理器都是独立的，但是公用一个总线，在通信上并不是独立的。  </li><li>只要任务的粒度（Granularity）能够让所有的子处理器都能够同时工作，那么任务就能够被快速处理。  </li></ol><h3 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h3><p>GPU是一种用于加速建图和图像处理的专门化处理器。 GPU内部高度并行化。<br>功能： 加速渲染多边形和纹理匹配， 解码高清视频等等。  </p><h3 id="DSP"><a href="#DSP" class="headerlink" title="DSP"></a>DSP</h3><p>专门化的数字信号处理器，用于声音、图像、雷达系统。<br>功能： 数字信号与模拟信号的转换和处理。<br>DSP 的指令集优化用于处理数学运算、特殊的地址模型、特殊化的循环控制。<br>DSP 中的数学计算常常是Fixed-point 计算。<br>DSP 不支持虚拟内存和内存保护。   </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>计算机结构与接口</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PIC16F系列单片机接口程序设计经典案例</title>
    <link href="/2021/06/10/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84%E4%B8%8E%E6%8E%A5%E5%8F%A3/3.%20%E7%BB%8F%E5%85%B8PIC16F%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A1%88%E4%BE%8B/"/>
    <url>/2021/06/10/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84%E4%B8%8E%E6%8E%A5%E5%8F%A3/3.%20%E7%BB%8F%E5%85%B8PIC16F%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="PIC16F系列单片机接口程序设计经典案例"><a href="#PIC16F系列单片机接口程序设计经典案例" class="headerlink" title="PIC16F系列单片机接口程序设计经典案例"></a>PIC16F系列单片机接口程序设计经典案例</h1><blockquote><p>针对Brunel University：2021 EE2623    Computer Architecture and Interfacing 的期末复习笔记<br>Lecturer: Dr. Itagaki Takebumi（板垣　剛文）/Dr.Hongying Meng（孟鸿鹰）<br>程序仅包含主函数部分。  </p></blockquote><h2 id="输入接口"><a href="#输入接口" class="headerlink" title="输入接口"></a>输入接口</h2><h3 id="简单开关"><a href="#简单开关" class="headerlink" title="简单开关"></a>简单开关</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br>    <span class="hljs-keyword">if</span>((porta&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">0</span>)<br>    &#123;<br>        delay(<span class="hljs-number">5</span>); <span class="hljs-comment">//避免switch bounce</span><br>        <span class="hljs-keyword">if</span>((porta&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">0</span>)<br>        &#123;<br>            ... <span class="hljs-comment">// 触发开关后的操作</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    adcon1 = <span class="hljs-number">0x06</span>; <span class="hljs-comment">//初始化</span><br>    trisa = <span class="hljs-number">11110000b</span>; <span class="hljs-comment">//设置porta一半输入一半输出</span><br>    porta = <span class="hljs-number">0xff</span>; <span class="hljs-comment">//porta=1111 1111</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        clear_bit(porta,<span class="hljs-number">0</span>); <span class="hljs-comment">//porta=1111 1110 切换到第一行扫描</span><br>        <span class="hljs-keyword">if</span>((porta&amp;<span class="hljs-number">0x10</span>)==<span class="hljs-number">0</span>) <span class="hljs-comment">// porta=1110 1110</span><br>        &#123;<br>            value = <span class="hljs-string">&#x27;1&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>((porta&amp;<span class="hljs-number">0x20</span>)==<span class="hljs-number">0</span>) <span class="hljs-comment">// 键盘：为0按下，为1弹起</span><br>        &#123;<br>            value = <span class="hljs-string">&#x27;2&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>((porta&amp;<span class="hljs-number">0x40</span>)==<span class="hljs-number">0</span>)<br>        &#123;<br>            value = <span class="hljs-string">&#x27;3&#x27;</span>;<br>        &#125;<br>        set_bit(porta,<span class="hljs-number">0</span>);<br>        clear_bit(porta,<span class="hljs-number">1</span>); <span class="hljs-comment">//porta=1111 1101 切换到第二行扫描</span><br>        <span class="hljs-keyword">if</span>((porta&amp;<span class="hljs-number">0x10</span>)==<span class="hljs-number">0</span>) <span class="hljs-comment">//porta=1110 1101</span><br>        &#123;<br>            value = <span class="hljs-string">&#x27;4&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>((porta&amp;<span class="hljs-number">0x20</span>)==<span class="hljs-number">0</span>)<br>        &#123;<br>            value = <span class="hljs-string">&#x27;5&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>((porta&amp;<span class="hljs-number">0x40</span>)==<span class="hljs-number">0</span>)<br>        &#123;<br>            value = <span class="hljs-string">&#x27;6&#x27;</span>;<br>        &#125;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="显示接口"><a href="#显示接口" class="headerlink" title="显示接口"></a>显示接口</h2><h3 id="LED"><a href="#LED" class="headerlink" title="LED"></a>LED</h3><h4 id="闪烁LED"><a href="#闪烁LED" class="headerlink" title="闪烁LED"></a>闪烁LED</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    trisb = <span class="hljs-number">0</span>;  <span class="hljs-comment">//设置portb为输出</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        portb = <span class="hljs-number">0xff</span>; <span class="hljs-comment">// LED 灯： 为0熄灭，为1亮起</span><br>        delay(<span class="hljs-number">10</span>); <br>        portb = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="流水灯"><a href="#流水灯" class="headerlink" title="流水灯"></a>流水灯</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    trisb = <span class="hljs-number">0</span>;  <span class="hljs-comment">//设置portb为输出</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        portb = portb &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 左移一位</span><br>        delay(<span class="hljs-number">10</span>); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="八位数码管"><a href="#八位数码管" class="headerlink" title="八位数码管"></a>八位数码管</h3><h4 id="一位数字显示"><a href="#一位数字显示" class="headerlink" title="一位数字显示"></a>一位数字显示</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">seg8</span><span class="hljs-params">(<span class="hljs-keyword">char</span> value)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(value == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>(<span class="hljs-number">0xc0</span>); <span class="hljs-comment">//八位数码管的比特位控制见讲义中图片</span><br>    <span class="hljs-keyword">if</span>(value == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>(<span class="hljs-number">0xf9</span>); <span class="hljs-comment">// 八位数码管：为0亮，为1不亮</span><br>    ...<br>    <span class="hljs-keyword">if</span>(value &gt; <span class="hljs-number">9</span>) <span class="hljs-keyword">return</span>(<span class="hljs-number">0xff</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="四位数显示"><a href="#四位数显示" class="headerlink" title="四位数显示"></a>四位数显示</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span></span><br><span class="hljs-function"></span>&#123;<br>    portb = seg8(value / <span class="hljs-number">1000</span>); <span class="hljs-comment">// 得到千位数字</span><br>    set_bit(porta,<span class="hljs-number">3</span>); <span class="hljs-comment">// porta负责控制哪一个八位数码管亮起（1为亮）</span><br>    delay(<span class="hljs-number">4</span>);<br>    value = value % <span class="hljs-number">1000</span>; <span class="hljs-comment">// 求余数</span><br>    clear_bit(porta,<span class="hljs-number">3</span>);<br>    portb = seg8(value / <span class="hljs-number">100</span>);<br>    set_bit(porta,<span class="hljs-number">2</span>)；<br>    delay(<span class="hljs-number">4</span>);<br>    value = value % <span class="hljs-number">100</span>;<br>    clear_bit(porta,<span class="hljs-number">1</span>);<br>    portb = seg8(value / <span class="hljs-number">10</span>);<br>    set_bit(porta,<span class="hljs-number">1</span>)；<br>    delay(<span class="hljs-number">4</span>);<br>    value = value % <span class="hljs-number">100</span>;<br>    clear_bit(porta,<span class="hljs-number">2</span>);<br>    portb = seg(value % <span class="hljs-number">10</span>);<br>    set_bit(porta,<span class="hljs-number">0</span>);<br>    delay(<span class="hljs-number">4</span>);<br>    clear_bit(porta,<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="LCD"><a href="#LCD" class="headerlink" title="LCD"></a>LCD</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lcd_init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 本质上来说是向portb重复发送一些东西，0x23和0x03可以自由设定。</span><br>    delay(<span class="hljs-number">10</span>);<br>    portb = <span class="hljs-number">0x23</span>;<br>    portb = <span class="hljs-number">0x03</span>;<br>    delay(<span class="hljs-number">10</span>);<br>    portb = <span class="hljs-number">0x23</span>;<br>    portb = <span class="hljs-number">0x03</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="发送指令"><a href="#发送指令" class="headerlink" title="发送指令"></a>发送指令</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lcd_cmd</span><span class="hljs-params">(<span class="hljs-keyword">char</span> cmd)</span></span><br><span class="hljs-function"></span>&#123;<br>    portb = <span class="hljs-number">0x20</span>+((cmd&gt;&gt;<span class="hljs-number">4</span>)&amp;<span class="hljs-number">0x0f</span>); <span class="hljs-comment">//开启（0x20）+指令头四位</span><br>    portb = (cmd&gt;&gt;<span class="hljs-number">4</span>)&amp;<span class="hljs-number">0x0f</span>; <span class="hljs-comment">//移动指令头四位到后四位，并清除原来头四位</span><br>    portb = <span class="hljs-number">0x20</span>+(cmd&amp;<span class="hljs-number">0x0f</span>); <span class="hljs-comment">//开启（0x20）+指令后四位</span><br>    portb = cmd &amp; <span class="hljs-number">0x0f</span>; <span class="hljs-comment">//清除指令头四位</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="发送单个字符"><a href="#发送单个字符" class="headerlink" title="发送单个字符"></a>发送单个字符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lcd_char</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    portb = <span class="hljs-number">0x30</span> + ((c&gt;&gt;<span class="hljs-number">4</span>)&amp;<span class="hljs-number">0x0f</span>); <span class="hljs-comment">//开启（0x30）+指令头四位</span><br>    portb = <span class="hljs-number">0x10</span> + ((c&gt;&gt;<span class="hljs-number">4</span>)&amp;<span class="hljs-number">0x0f</span>); <span class="hljs-comment">//移动指令头四位到后四位，并清除原来头四位</span><br>    portb = <span class="hljs-number">0x30</span> + (c&amp;<span class="hljs-number">0x0f</span>); <span class="hljs-comment">//开启（0x30）+指令后四位</span><br>    portb = <span class="hljs-number">0x10</span> + (c&amp;<span class="hljs-number">0x0f</span>); <span class="hljs-comment">//清除指令头四位</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="显示字符串"><a href="#显示字符串" class="headerlink" title="显示字符串"></a>显示字符串</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display_message</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* message)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(message[i] != <span class="hljs-number">0</span>)<br>    &#123;<br>        lcd_char(message[i]);<br>        i++;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    adcon1 = <span class="hljs-number">0x06</span>; <span class="hljs-comment">//设置adcon1接收来自portA的所有pins的数字信号</span><br>    trisa = <span class="hljs-number">0xf8</span>; <span class="hljs-comment">//设置portA的PA0,PA1,PA2为输出</span><br>    trisb = <span class="hljs-number">0x00</span>; <span class="hljs-comment">//设置PortB为输出</span><br>    lcd_cmd(<span class="hljs-number">1</span>); <span class="hljs-comment">//清除显示</span><br>    lcd_init(); <span class="hljs-comment">//初始化LCD</span><br>    lcd_cmd(<span class="hljs-number">0x38</span>); <span class="hljs-comment">//设置两行，8比特，5x7点阵</span><br>    lcd_cmd(<span class="hljs-number">0x0c</span>); <span class="hljs-comment">//设置打开显示，不显示光标</span><br>    lcd_cmd(<span class="hljs-number">0x06</span>); <span class="hljs-comment">//设置光标右移</span><br>    lcd_cmd(<span class="hljs-number">1</span>); <span class="hljs-comment">//清除显示</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        lcd_cmd(<span class="hljs-number">0x80</span>); <span class="hljs-comment">// 第一行第一个光标位置的地址：0x00（地址）+0x80（指令）</span><br>        display_massage(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        lcd_cmd(<span class="hljs-number">0xc0</span>); <span class="hljs-comment">// 第二行第一个光标位置的地址：0x40+0x80</span><br>        display_message(<span class="hljs-string">&quot;world&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>LCD在显示数字时，一定要将数字转换为ASCII码，具体操作为：<code>display_char(&#39;0&#39;+number);</code>  </p></blockquote><h2 id="数模转换器-ADC"><a href="#数模转换器-ADC" class="headerlink" title="数模转换器 ADC"></a>数模转换器 ADC</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">convert</span><span class="hljs-params">(<span class="hljs-keyword">char</span> channel)</span></span><br><span class="hljs-function"></span>&#123;<br>    adcon0 = <span class="hljs-number">11000001b</span> + (channel&lt;&lt;<span class="hljs-number">3</span>); <span class="hljs-comment">//设置channel</span><br>    set_bit(adcon0, GODONE); <span class="hljs-comment">// 清除GODONE，开始转换</span><br>    <span class="hljs-keyword">while</span>((adcon0 &amp; <span class="hljs-number">00000100b</span>) !=<span class="hljs-number">0</span>); <span class="hljs-comment">//等待到转换结束</span><br>    <span class="hljs-keyword">return</span>((adresh&lt;&lt;<span class="hljs-number">8</span>)+adresl);  <span class="hljs-comment">//返回得到的10比特值</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> value;<br>    adcon1 = <span class="hljs-number">0x80</span>; <span class="hljs-comment">//设置8个通道都是模拟信号</span><br>    adcon0 = <span class="hljs-number">11000001b</span>; <span class="hljs-comment">//设置转换速度</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        value = covnert(<span class="hljs-number">4</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h2><h3 id="延迟函数（通用）"><a href="#延迟函数（通用）" class="headerlink" title="延迟函数（通用）"></a>延迟函数（通用）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delay</span><span class="hljs-params">(<span class="hljs-keyword">int</span> j)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">for</span>(; j!=<span class="hljs-number">0</span>; j--)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">8333</span>; i!=<span class="hljs-number">0</span>; i--); <span class="hljs-comment">//执行一次循环需要12us 8333*12≈0.1s</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="利用溢出设置延迟"><a href="#利用溢出设置延迟" class="headerlink" title="利用溢出设置延迟"></a>利用溢出设置延迟</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delay</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    tmr0 = <span class="hljs-number">0</span>; <span class="hljs-comment">//重置timer0</span><br>    clear_bit(intcon,TOIF); <span class="hljs-comment">//重置溢出flag</span><br>    <span class="hljs-keyword">while</span>(x!=<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">while</span>((intcon &amp; <span class="hljs-number">00000100b</span>) == <span class="hljs-number">0</span>); <span class="hljs-comment">//等到溢出</span><br>        clear_bit(intcon, T0IF); <span class="hljs-comment">//重置溢出flag</span><br>        x--;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>如果Fosc/4=0.2s， Pre-scalar=1:32，x=61时，能造成 0.2x32x256usx61=0.0999424s的延迟  </p></blockquote><h2 id="中断程序"><a href="#中断程序" class="headerlink" title="中断程序"></a>中断程序</h2><h3 id="中断程序的时间控制"><a href="#中断程序的时间控制" class="headerlink" title="中断程序的时间控制"></a>中断程序的时间控制</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">interrupt</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    clear_bit(intcon,T0IF); <span class="hljs-comment">//重置溢出flag</span><br>    tmr0 = <span class="hljs-number">100</span>; <span class="hljs-comment">//给timer0设置初始值，此时一个中断运行的时间是256-100=156us</span><br>    ··· <span class="hljs-comment">// 中断内的其他操作</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="PWM-控制马达"><a href="#PWM-控制马达" class="headerlink" title="PWM 控制马达"></a>PWM 控制马达</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C">TMR0 = <span class="hljs-number">246</span>; <span class="hljs-comment">// 中断发生的时间为256-246=10us</span><br><span class="hljs-keyword">int</span> cycle; <span class="hljs-comment">// 一个周期的时间，时间设定在中断程序中设置</span><br><span class="hljs-keyword">int</span> pwm = <span class="hljs-number">400</span>; <span class="hljs-comment">// 一个周期内马达开启的时间，此处时间为400 x 10us=4ms</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">interrupt</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cycle--;<br>    <span class="hljs-keyword">if</span>(cycle == <span class="hljs-number">0</span>)<br>    &#123;<br>        cycle = <span class="hljs-number">1000</span>; <span class="hljs-comment">// 此处一个周期的时间为1000 x 10us=10ms</span><br>    &#125;<br>        <span class="hljs-keyword">if</span>(pwm == <span class="hljs-number">0</span>) <span class="hljs-comment">// 如果pwm没有设置</span><br>        &#123;<br>            pulse = <span class="hljs-number">0</span>;<br>            clear_bit(portb,<span class="hljs-number">7</span>); <span class="hljs-comment">// 关闭转子，转子不会工作</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>        pulse = pwm; <span class="hljs-comment">// 转子开启的时间</span><br>        set_bit(portb,<span class="hljs-number">7</span>); <span class="hljs-comment">// 开启转子</span><br>        &#125;  <br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(pulse != <span class="hljs-number">0</span>)<br>        &#123;<br>            pulse--; <span class="hljs-comment">// pulse 自减</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(pulse == <span class="hljs-number">0</span>)<br>        &#123;<br>            clear_bit(portb,<span class="hljs-number">7</span>); <span class="hljs-comment">//进入转子的关闭期</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>计算机结构与接口</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>附录1：冲激函数的特性·常见信号的傅里叶/拉普拉斯/Z变换</title>
    <link href="/2021/06/01/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/%E9%99%84%E5%BD%951%EF%BC%9A%E5%B8%B8%E8%A7%81%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%8F%98%E6%8D%A2/"/>
    <url>/2021/06/01/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/%E9%99%84%E5%BD%951%EF%BC%9A%E5%B8%B8%E8%A7%81%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%8F%98%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="常见信号的傅里叶-拉普拉斯-Z变换"><a href="#常见信号的傅里叶-拉普拉斯-Z变换" class="headerlink" title="常见信号的傅里叶/拉普拉斯/Z变换"></a>常见信号的傅里叶/拉普拉斯/Z变换</h1><h2 id="冲激函数的特性"><a href="#冲激函数的特性" class="headerlink" title="冲激函数的特性"></a>冲激函数的特性</h2><h3 id="冲激函数的特性-1"><a href="#冲激函数的特性-1" class="headerlink" title="冲激函数的特性"></a>冲激函数的特性</h3><div class="table-container"><table><thead><tr><th style="text-align:center">特性</th><th style="text-align:center">公式</th></tr></thead><tbody><tr><td style="text-align:center">赋值性</td><td style="text-align:center">$∫δ(t)f(t)dt=f(0)$</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">$f(t)δ(t)=f(0)δ(t)$</td></tr><tr><td style="text-align:center">偶函数</td><td style="text-align:center">$δ(t)=δ(-t)$</td></tr><tr><td style="text-align:center">缩放</td><td style="text-align:center">$δ(at)=\frac{1}{ \vert a \vert }δ(t)$</td></tr></tbody></table></div><h3 id="冲激偶函数的特性"><a href="#冲激偶函数的特性" class="headerlink" title="冲激偶函数的特性"></a>冲激偶函数的特性</h3><div class="table-container"><table><thead><tr><th style="text-align:center">特性</th><th style="text-align:center">公式</th></tr></thead><tbody><tr><td style="text-align:center">赋值性</td><td style="text-align:center">$∫δ’(t)f(t)dt=-f’(0)$</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">$f(t)δ’(t)=f(0)δ’(t)-f’(0)δ(t)$</td></tr><tr><td style="text-align:center">奇函数</td><td style="text-align:center">$δ’(t)=-δ’(t)$</td></tr></tbody></table></div><h2 id="常见函数的傅里叶变换"><a href="#常见函数的傅里叶变换" class="headerlink" title="常见函数的傅里叶变换"></a>常见函数的傅里叶变换</h2><blockquote><p>傅里叶变换：$F(ω)=∫f(t)e^{-jωt}dt$<br>傅里叶反变换：$f(t)=∫F(ω)e^{jωt}dω$  </p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">时域函数$f(t)$</th><th style="text-align:center">频域函数$F(ω)$</th></tr></thead><tbody><tr><td style="text-align:center">门函数</td><td style="text-align:center">$E[u(t+\frac{τ}{2})-u(t-\frac{τ}{2})]$ <br>$E,-\frac{τ}{2}&lt;t&lt;\frac{τ}{2}$</td><td style="text-align:center">$\frac{2Esin(ω\frac{τ}{2})}{ω}=EτSa(\frac{ωτ}{2})$</td></tr><tr><td style="text-align:center">直流信号/常函数</td><td style="text-align:center">$E$</td><td style="text-align:center">$2πEδ(ω)$</td></tr><tr><td style="text-align:center">冲激函数</td><td style="text-align:center">$δ(t)$</td><td style="text-align:center">$1$</td></tr><tr><td style="text-align:center">冲激偶函数</td><td style="text-align:center">$δ’(t)$</td><td style="text-align:center">$jω$</td></tr><tr><td style="text-align:center">单侧指数函数</td><td style="text-align:center">$Ee^{-at}u(t)$</td><td style="text-align:center">$\frac{E}{jω+a}$</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">周期冲激序列</td><td style="text-align:center">$δ_T(t)$</td><td style="text-align:center">$ω_1δ(ω-nω_1)$</td></tr><tr><td style="text-align:center">周期方波/门函数序列</td><td style="text-align:center">-</td><td style="text-align:center">$EτSa(\frac{ωτ}{2})ω_1δ(ω-nω_1)$</td></tr><tr><td style="text-align:center">正弦函数</td><td style="text-align:center">$sin(ω_0t)$</td><td style="text-align:center">$-jπδ(ω-ω_0)+jπδ(ω+ω_0)$</td></tr><tr><td style="text-align:center">余弦函数</td><td style="text-align:center">$cos(ω_0t)$</td><td style="text-align:center">$πδ(ω-ω_0)+πδ(ω+ω_0)$</td></tr></tbody></table></div><h2 id="常见函数的拉普拉斯变换"><a href="#常见函数的拉普拉斯变换" class="headerlink" title="常见函数的拉普拉斯变换"></a>常见函数的拉普拉斯变换</h2><blockquote><p>拉普拉斯变换：$L(s)=∫f(t)e^{-st}dt$<br>拉普拉斯反变换：$F(s)=∑\frac{k}{s-p}↔f(t)=∑ke^{pt}$ （一阶实极点）  </p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">时域函数$f(t)$</th><th style="text-align:center">频域函数$L(s)$</th></tr></thead><tbody><tr><td style="text-align:center">阶跃函数</td><td style="text-align:center">$u(t)$</td><td style="text-align:center">$\frac{1}{s}$</td></tr><tr><td style="text-align:center">冲激函数</td><td style="text-align:center">$δ(t)$</td><td style="text-align:center">$1$</td></tr><tr><td style="text-align:center">单侧指数函数</td><td style="text-align:center">$Ee^{-at}u(t)$</td><td style="text-align:center">$\frac{E}{s+a}$</td></tr><tr><td style="text-align:center">斜坡函数</td><td style="text-align:center">$tu(t)$</td><td style="text-align:center">$\frac{1}{s^2}$</td></tr><tr><td style="text-align:center">正弦函数</td><td style="text-align:center">$sin(ω_0t)$</td><td style="text-align:center">$\frac{1}{s^2+ω_0^2 }$</td></tr><tr><td style="text-align:center">余弦函数</td><td style="text-align:center">$cos(ω_0t)$</td><td style="text-align:center">$\frac{s}{s^2+ω_0^2}$</td></tr></tbody></table></div><h2 id="常见序列的Z变换"><a href="#常见序列的Z变换" class="headerlink" title="常见序列的Z变换"></a>常见序列的Z变换</h2><blockquote><p>Z变换：$X(z)=∑x(n)z^{-n}$<br>Z反变换：$X(z)=z(\frac{A}{z-p_i})⟷x(n)=∑A(p_i)^n$(一阶单极点)  </p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">时域序列$x(n)$</th><th style="text-align:center">频域序列$X(z)$</th><th style="text-align:center">收敛域</th></tr></thead><tbody><tr><td style="text-align:center">单位冲激序列</td><td style="text-align:center">$δ(n)$</td><td style="text-align:center">$1$</td><td style="text-align:center">整个z域</td></tr><tr><td style="text-align:center">单位阶跃序列</td><td style="text-align:center">$u(n)$</td><td style="text-align:center">$\frac{z}{z-1}$</td><td style="text-align:center">$⃒ z ⃒ &lt;1$</td></tr><tr><td style="text-align:center">斜坡序列</td><td style="text-align:center">$nu(n)$</td><td style="text-align:center">$\frac{z}{(z-1)^2}$</td><td style="text-align:center">$⃒ z ⃒ &lt;1$</td></tr><tr><td style="text-align:center">单侧指数序列</td><td style="text-align:center">$a^nu(n)$</td><td style="text-align:center">$\lim_{n→∞}\frac{1-(\frac{a}{z})^{n+1}}{1-\frac{a}{z}}$</td><td style="text-align:center">$⃒ z ⃒ &gt;⃒ a ⃒$</td></tr><tr><td style="text-align:center">单侧正弦序列</td><td style="text-align:center">$sin(ω_0n)u(n)$</td><td style="text-align:center">$\frac{zsinω_0}{z^2-2zcosω_0+1}$</td><td style="text-align:center">$⃒ z ⃒ &gt;1$</td></tr><tr><td style="text-align:center">单侧余弦序列</td><td style="text-align:center">$cos(ω_0n)u(n)$</td><td style="text-align:center">$\frac{z(z-cosω_0)}{z^2-2zcosω_0+1}$</td><td style="text-align:center">$⃒ z ⃒ &gt;1$</td></tr></tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>信号与系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>10. 反馈系统</title>
    <link href="/2021/05/31/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/10.%20%E5%8F%8D%E9%A6%88%E7%B3%BB%E7%BB%9F/"/>
    <url>/2021/05/31/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/10.%20%E5%8F%8D%E9%A6%88%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="反馈系统"><a href="#反馈系统" class="headerlink" title="反馈系统"></a>反馈系统</h1><h2 id="反馈系统结构"><a href="#反馈系统结构" class="headerlink" title="反馈系统结构"></a>反馈系统结构</h2><p>(负)反馈系统框图可以用下图表示：<br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210531144620.png" alt=""><br>$G(s)$是前向系统，$H(s)$是反向系统，$G(s)H(s)$称为开环传递函数，整个系统的闭环传递函数可以写作：  </p><script type="math/tex; mode=display">CLTF=\frac{G(s)}{1+G(s)H(s)}</script><p>$1+G(s)H(s)=0$称为闭环传递函数的特征方程。  </p><div class="note note-info">            <p>放大器的闭环增益就是一个闭环传递函数。  </p>          </div>  <p><strong>反馈系统通过$1+G(s)H(s)$减少了系统对噪声的敏感度，但是相应地，系统增益也同样被减小。</strong>  </p><h2 id="根轨迹图"><a href="#根轨迹图" class="headerlink" title="根轨迹图"></a>根轨迹图</h2><p>为了更好的研究开环传递函数$G(s)H(s)$对反馈系统的影响，用根轨迹图（Root locus diagram）来表现当开环传递函数中的某些人为设定的参数发生改变时，闭环传递函数的极点在s域中的变化情况。<br>得到根轨迹图的步骤：  </p><ol><li>通过闭环传递函数的特征方程解出s与参数$K$之间的关系。</li><li>在s域中标出零点。  </li><li>在s域中标出极点，即$K=0$的位置。  </li><li>增加K的值，在S域中标出一系列的s的位置，并以（$K=x$）在每个点上方进行标注。  </li><li>判断$k→∞$时，s的移动方向，并用箭头标注。  </li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>信号与系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>09. 系统方程</title>
    <link href="/2021/05/31/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/9.%20%E7%B3%BB%E7%BB%9F%E6%96%B9%E7%A8%8B/"/>
    <url>/2021/05/31/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/9.%20%E7%B3%BB%E7%BB%9F%E6%96%B9%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="系统方程"><a href="#系统方程" class="headerlink" title="系统方程"></a>系统方程</h1><h2 id="系统方程概述"><a href="#系统方程概述" class="headerlink" title="系统方程概述"></a>系统方程概述</h2><p>对于一个有输入和输出的系统，可以通过观察系统输入和输出的关系来建立描述系统的方程，在拉普拉斯变换的s域下，系统方程可以表述为<strong>系统输出与输入之比</strong>：  </p><script type="math/tex; mode=display">H(s)=\frac{R(s)}{E(s)}</script><p>也可以按照时域分析方法中的理解，当$e(t)=δ(t)$时，其拉普拉斯变换为1，因此系统方程也是<strong>输入为冲激函数时的系统输出</strong>。</p><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><h4 id="策动点方程"><a href="#策动点方程" class="headerlink" title="策动点方程"></a><strong>策动点方程</strong></h4><p>当系统是一个单口网络（One-port network，输入和输出在同一个端口的系统）时，系统方程称为策动点方程(Driving point funtion)。对于电路分析，单口网络的系统方程可以是$H(s)=\frac{I(s)}{V(s)}$，也可以是$H(s)=\frac{V(s)}{I(s)}$。</p><h4 id="传递函数"><a href="#传递函数" class="headerlink" title="传递函数"></a><strong>传递函数</strong></h4><p>当系统是一个两口网络时，此时的系统方程称为传递函数（Transfer function）。分析时需要找到电路的输入和输出，作比即可得到传递函数。   </p><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><h4 id="并联"><a href="#并联" class="headerlink" title="并联"></a><strong>并联</strong></h4><p>如果两个系统并联，新的系统方程为：$h(t)=h_1(t)+h_2(t)$，在s域内：  </p><script type="math/tex; mode=display">H(s)=H_1(s)+H_2(s)</script><h4 id="串联-级联"><a href="#串联-级联" class="headerlink" title="串联/级联"></a><strong>串联/级联</strong></h4><p>如果两个系统串联，新的系统方程为：$h(t)=h_1(t)*h_2(t)$，在s域内：  </p><script type="math/tex; mode=display">H(s)=H_1(s)H_2(s)</script><blockquote><p>举例：放大器的并联和串联</p></blockquote><h2 id="系统方程的结构"><a href="#系统方程的结构" class="headerlink" title="系统方程的结构"></a>系统方程的结构</h2><p>如之前提到的拉普拉斯反变换和z反变换，由于系统输入和输出在s域内都以多项式表示，系统方程自然是两个多项式的比值：</p><script type="math/tex; mode=display">H(s)=\frac{R(s)}{E(s)}=K\frac{Π(s-z_i)}{Π(s-p_k)}</script><p>其中$p_i$称为系统方程的极点，$z_k$称为系统方程的零点。<br>在电路分析中，极点描述的的对象是电路中电容和电感的个数，即系统方程的阶数。<br>同理，离散系统的方程也可以写作两个多项式的比：</p><script type="math/tex; mode=display">H(z)=\frac{∑b_rz^{-r}}{∑a_kz^{-k}}=A_0+∑\frac{A_kz}{z-p_k}</script><h3 id="强迫响应和自由响应"><a href="#强迫响应和自由响应" class="headerlink" title="强迫响应和自由响应"></a>强迫响应和自由响应</h3><p>如果将系统的输入$E(s)$以多项式表示：$E(s)=\frac{Π(s-z_l)}{Πs-p_k}$，系统方程$H(s)=\frac{Π(s-z_j)}{Πs-p_i}$，由系统的零输入响应$R(s)=E(s)H(s)$:  </p><script type="math/tex; mode=display">R(s)=∑\frac{A_k}{s-p_k}+∑\frac{A_i}{s-p_i}</script><p>经过拉普拉斯反变换：  </p><script type="math/tex; mode=display">r(t)=∑A_ke^{p_kt}u(t)+∑A_ie^{p_it}u(t)</script><p>可以发现$r(t)$受到两部分的影响：系统方程和输入信号：<strong>称$r(t)$受输入影响的部分为强迫响应，受系统方程影响的部分为自由响应。</strong>  </p><h3 id="瞬态响应和稳态响应"><a href="#瞬态响应和稳态响应" class="headerlink" title="瞬态响应和稳态响应"></a>瞬态响应和稳态响应</h3><p>分析时域中的$r(t)$构成，表达式的常数项不会受到$t$变化的影响，<strong>$r(t)$的常数项称为稳态响应</strong>。<strong>$r(t)$中受到$t$影响的部分称为瞬态响应。</strong></p><h2 id="系统稳定性"><a href="#系统稳定性" class="headerlink" title="系统稳定性"></a>系统稳定性</h2><h3 id="s域图像"><a href="#s域图像" class="headerlink" title="s域图像"></a>s域图像</h3><p>由$s=σ+jω$,因此可以将任何一个值在以实部$σ$为横轴，虚部$jω$为纵轴的s域中的一个点来表示。<br>在s域图像中，系统方程的极点以×表示，系统方程的零点以◯表示。  </p><h3 id="连续系统的稳定性"><a href="#连续系统的稳定性" class="headerlink" title="连续系统的稳定性"></a>连续系统的稳定性</h3><p>在时域中有：</p><script type="math/tex; mode=display">∫|h(t)|dt<∞</script><p>满足上述条件的系统是稳定系统。<br>在s域中，如果所有的极点都在s域图像的左侧，即$σ&lt;0$，满足系统稳定的条件。当所有极点都在虚轴上且为一阶时，这个系统是严格的稳定系统。<br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210531130659.png" alt=""> </p><h3 id="离散系统的稳定性"><a href="#离散系统的稳定性" class="headerlink" title="离散系统的稳定性"></a>离散系统的稳定性</h3><p>由$z=e^{sT}$，当$s=0$时，$z=1$，因此如果极点在z域的单位圆内，离散系统是稳定系统，在单位圆外，系统是非稳定系统。<br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210531133708.png" alt=""></p><div class="note note-info">            <p>由连续系统稳定性推导离散系统稳定性的过程：<a href="https://l61012345.top/2022/04/14/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/12.%20%E7%A8%B3%E5%AE%9A%E6%80%A7%E6%8E%A7%E5%88%B6/">控制系统：数字系统稳定性</a></p>          </div>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>信号与系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>08. Z变换</title>
    <link href="/2021/05/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/8.%20z%E5%8F%98%E6%8D%A2/"/>
    <url>/2021/05/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/8.%20z%E5%8F%98%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="Z变换"><a href="#Z变换" class="headerlink" title="Z变换"></a>Z变换</h1><h2 id="Z变换的基本原理"><a href="#Z变换的基本原理" class="headerlink" title="Z变换的基本原理"></a>Z变换的基本原理</h2><p>Z变换的本质是通过采样使得离散信号可以被拉普拉斯变换，因此z变换的对象是<strong>离散信号/序列</strong>。<br>其具体过程如下：<br>由<a href="https://l61012345.top/2021/04/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/6.%20%E5%91%A8%E6%9C%9F%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/">第六讲</a>中提到的采样定理，对于连续序列$x(t)$，对其做自然采样：  </p><script type="math/tex; mode=display">\begin{aligned}    x_s(t)&=x(t)δ_T(t) \\    &=x(t)∑δ(t-nT) \\    &=∑x(nT)δ(t-nT) \\\end{aligned}</script><p>对其做拉普拉斯变换：  </p><script type="math/tex; mode=display">X_s=L[x_s(t)]</script><script type="math/tex; mode=display">\begin{aligned}    L[x_s(t)]&=L[∑x(nT)δ(t-nT)]  \\    &=∑x(nT)L[δ(t-nT)]\\    &=∑x(nT)e^{-snT}\end{aligned}</script><p>令$z=e^{sT}$,得到Z变换的定义式： </p><script type="math/tex; mode=display">X(z)=∑x(n)z^{-n}</script><p>在LTI系统中$n&gt;0$，Z变换的定义式可以写作：</p><script type="math/tex; mode=display">X(z)=∑_{n=0}^∞x(n)z^{-n}</script><h3 id="存在条件-收敛域"><a href="#存在条件-收敛域" class="headerlink" title="存在条件/收敛域"></a>存在条件/收敛域</h3><p>使得序列$x(n)$能够被z变换的条件是<strong>序列$x(n)$收敛</strong>，即：  </p><script type="math/tex; mode=display">∑|x(n)z^{-n}|<∞</script><p>上述条件为z变换的收敛域。  </p><h3 id="Z反变换"><a href="#Z反变换" class="headerlink" title="Z反变换"></a>Z反变换</h3><h4 id="Z变换式的一般形式"><a href="#Z变换式的一般形式" class="headerlink" title="Z变换式的一般形式"></a>Z变换式的一般形式</h4><p>序列$x(n)$的z变换式$X(z)$的一般形式可以写作由两个多项式组成的分式：  </p><script type="math/tex; mode=display">X(z)=\frac{N(z)}{D(z)}=\frac{∑b_mz^m}{∑a_nz^n}</script><p>当极点为一阶时,对等式两边同时除以$z$以提取常系数$A$：  </p><script type="math/tex; mode=display">\frac{X(z)}{z}=∑_{i=1}^N\frac{A_i}{z-z_i}</script><p>其中$A_i=(z-z_i)\frac{X(z)}{z}|_{z=z_i}$。<br>再乘上$z$：  </p><script type="math/tex; mode=display">X(z)=∑_{i=1}^N\frac{A_iz}{z-z_i}</script><p>其中$A_i$为$x(n)$的常系数，$z_i$为底数。<br>对应的$x(n)$：</p><script type="math/tex; mode=display">x(n)=∑_{i=0}^∞A_i(z_i)^n,n≥0</script><div class="note note-info">            <p>另外两种关于$X(z)$极点结构的情况：  </p><ol><li>共轭复数  </li><li>多根<br>本节不会讨论  </li></ol>          </div>  <h2 id="Z变换的性质"><a href="#Z变换的性质" class="headerlink" title="Z变换的性质"></a>Z变换的性质</h2><ol><li><p>线性（同傅里叶变换）</p><div class="note note-info">            <p>线性需要要求两个序列收敛域有公共部分，如果两者没有公共收敛域，那么无法Z变换不具有线性。  </p>          </div>  </li><li><p>变换操作  </p><ul><li>双侧时移<br>时移前后信号形状保持不变。<br>右移：$Z[x(n-m)]=z^{-m}X(z)$<br>左移：$Z[x(n+m)]=z^{m}X(z)$  </li><li><p>单侧时移<br>时移后图像$n&lt;0$的部分被消去。<br>右移:$Z[x(n-m)u(n)]=z^{-m}[X(z)-∑_{k=-m}^{-1}x(k)z^{-k}]$<br>左移:$Z[x(n+m)u(n)]=z^m[X(z)-∑_{k=0}^{m-1}x(k)z^{-k}]$  </p></li><li><p>线性权重<br>$Z[nx(n)]=-z\frac{dX(z)}{dz}=-z^{-1}\frac{dX(z)}{dz^{-1}}$  </p></li><li><p>尺度变换（z频域）<br>$Z[a^nx(n)]=X(\frac{z}{a})$  </p></li></ul><h3 id="初值定理"><a href="#初值定理" class="headerlink" title="初值定理"></a>初值定理</h3><p>如果$x(n)$具有因果性且可以被Z变换，有：</p><script type="math/tex; mode=display">x(0)=\lim_{x→∞}X(z)</script><h3 id="终值定理"><a href="#终值定理" class="headerlink" title="终值定理"></a>终值定理</h3><p>如果$x(n)$具有因果性且可以被Z变换，有：</p><script type="math/tex; mode=display">\lim_{x→∞}x(n)=\lim_{z→1}[(z-1)X(z)]</script><h3 id="卷积理论"><a href="#卷积理论" class="headerlink" title="卷积理论"></a>卷积理论</h3><script type="math/tex; mode=display">Z[x(n)*h(n)]=X(z)H(z)</script><script type="math/tex; mode=display">Z[x(n)h(n)]=X(z)*H(z)</script><p>收敛域为两者的公共收敛域：$max(R_{xmin},R_{hmin})&lt;|z|&lt;min(R_{xmax},R_{hmax})$  </p></li></ol><h2 id="常见信号的Z变换"><a href="#常见信号的Z变换" class="headerlink" title="常见信号的Z变换"></a>常见信号的Z变换</h2><h3 id="单位冲激序列"><a href="#单位冲激序列" class="headerlink" title="单位冲激序列"></a>单位冲激序列</h3><script type="math/tex; mode=display">Z[δ(n)]=∑δ(n)z^{-n}=1</script><p>收敛域：整个z域  </p><h3 id="单位阶跃序列"><a href="#单位阶跃序列" class="headerlink" title="单位阶跃序列"></a>单位阶跃序列</h3><script type="math/tex; mode=display">\begin{aligned}    Z[u(n)]&=∑u(n)z^{-n}\\    &=1+z^{-1}+z^{-2}+...+z^{-n}\\    &=\frac{z}{z-1}\end{aligned}</script><p>收敛域：$|z|&gt;1$  </p><h3 id="斜坡序列"><a href="#斜坡序列" class="headerlink" title="斜坡序列"></a>斜坡序列</h3><p>由单位阶跃序列的变换对：$Z[u(n)]=∑_{n=0}^∞z^{-n}=\frac{z}{z-1}$求导  </p><script type="math/tex; mode=display">\begin{aligned}    (∑_{n=0}^∞z^{-n})'&=(\frac{z}{z-1})'\\    -∑_{n=0}^∞nz^{-n+1}&=-\frac{1}{(1-z^{-1})^2}\\    ∑_{n=0}^∞nz^{-n+1}&=\frac{1}{(1-z^{-1})^2}\\    \text{两边同时乘以}z^{-1}:\\    Z[nu(n)]&=\frac{z}{(z-1)^2}\end{aligned}</script><p>收敛域：$|z|&gt;1$<br>推广：</p><script type="math/tex; mode=display">Z[n^mx(n)]=[z^{-1}\frac{d}{dz^{-1}}]^mX(z)</script><h3 id="指数序列"><a href="#指数序列" class="headerlink" title="指数序列"></a>指数序列</h3><script type="math/tex; mode=display">\begin{aligned}    Z[a^nu(n)]&=∑a^nz^{-n}\\    &=∑(\frac{a}{z})^n\\    &=\lim_{n→∞}\frac{1-(\frac{a}{z})^{n+1}}{1-\frac{a}{z}}\end{aligned}</script><p>当$|\frac{a}{z}|&lt;1$时序列收敛，此时可以简化为：</p><script type="math/tex; mode=display">Z[a^nu(n)]=\frac{z}{z-a}</script><p>收敛域：$|z|&gt;|a|$  </p><h3 id="三角函数序列"><a href="#三角函数序列" class="headerlink" title="三角函数序列"></a>三角函数序列</h3><p>由指数序列的变换对带入$sin(n)$和$cos(n)$的欧拉公式中：  </p><script type="math/tex; mode=display">Z[cos(ω_0n)u(n)]=\frac{z(z-cosω_0)}{z^2-2zcosω_0+1}</script><script type="math/tex; mode=display">Z[sin(ω_0n)u(n)]=\frac{zsinω_0}{z^2-2zcosω_0+1}</script><p>收敛域：$|z|&gt;1$  </p><h2 id="Z变换法求解系统差分方程"><a href="#Z变换法求解系统差分方程" class="headerlink" title="Z变换法求解系统差分方程"></a>Z变换法求解系统差分方程</h2><p>对于描述系统的差分方程，可以对两边做Z变换：</p><script type="math/tex; mode=display">F_{out}(Y(s),s)=F_{in}(X(s),s)</script><p>整理出关于$Y(z)$的方程，即系统的全响应：</p><script type="math/tex; mode=display">Y(z)=F_{多项式分式}(y(n_0),s)+F_{多项式分式}(E(s),s)</script><p><strong>其中含有某些初始状态$y(n_0)$的多项式分式是零输入响应，含有$E(s)$的多项式分式是零状态响应。</strong>  </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>信号与系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>07. 拉普拉斯变换</title>
    <link href="/2021/05/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/7.%20%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E5%8F%98%E6%8D%A2/"/>
    <url>/2021/05/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/7.%20%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E5%8F%98%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="拉普拉斯变换"><a href="#拉普拉斯变换" class="headerlink" title="拉普拉斯变换"></a>拉普拉斯变换</h1><h2 id="傅里叶变换的局限性"><a href="#傅里叶变换的局限性" class="headerlink" title="傅里叶变换的局限性"></a>傅里叶变换的局限性</h2><ol><li>使用傅里叶变换的条件是$f(t)$必须要满足狄利赫里条件，即必须要满足有界、绝对可积和有有限个间断点三个条件。 有些信号并不满足绝对可积的条件，因此这些信号不能被应用傅里叶变换。  </li><li>傅里叶变换中的无穷积分比较困难。  </li></ol><p>对于不满足狄利赫里条件的信号，可以用拉普拉斯变换进行处理。  </p><h2 id="拉普拉斯变换的基本原理"><a href="#拉普拉斯变换的基本原理" class="headerlink" title="拉普拉斯变换的基本原理"></a>拉普拉斯变换的基本原理</h2><p>拉普拉斯变换的基本思想是将$f(t)$乘上一个<strong>衰减系数</strong>：$AF$(Attenuation factor)以改善$f(t)$的收敛性，使得$f(t)AF$满足狄利赫里条件。<br>通用的衰减系数是$e^{-σt}$。<br>因此$f(t)AF$的傅里叶变换写作：  </p><script type="math/tex; mode=display">F(ω)=F[(f(t)e^{-σt})]=∫f(t)e^{-σt}e^{-jωt}dt=∫f(t)e^{-(σ+jω)t}dt</script><p>令$s=(σ+jω)$，得到拉普拉斯变换的定义式：  </p><script type="math/tex; mode=display">L[f(t)]=F(s)=F(σ+jω)=∫f(t)e^{-st}dt</script><p>对于LIT系统，$f(t)=0,t&lt;0$，因此：</p><script type="math/tex; mode=display">L[f(t)]=F(s)=∫_0^∞f(t)e^{-st}dt</script><h3 id="存在条件-收敛域"><a href="#存在条件-收敛域" class="headerlink" title="存在条件/收敛域"></a>存在条件/收敛域</h3><p>保证拉普拉斯变换存在的条件是$f(t)AF$满足满足狄利赫里条件。<br>使得拉普拉斯变换成立的定义域称为<strong>收敛域</strong>(RoC)。其应当是使得$F(s)$存在的$s$的范围。即$f(t)$应当满足：</p><script type="math/tex; mode=display">lim_{t→∞}f(t)e^{-σt}=0</script><h3 id="拉普拉斯反变换"><a href="#拉普拉斯反变换" class="headerlink" title="拉普拉斯反变换"></a>拉普拉斯反变换</h3><p>傅里叶反变换的定义式：  </p><script type="math/tex; mode=display">f(t)=\frac{1}{2π}∫F(ω)e^{jωt}dω</script><p>带入$f(t)e^{-σt}$:</p><script type="math/tex; mode=display">f(t)e^{-σt}=\frac{1}{2π}∫F(σ+jω)e^{jωt}dω</script><p>将两边同时乘上$e^{σt}$:  </p><script type="math/tex; mode=display">f(t)=\frac{1}{2π}∫F(σ+jω)e^{(σ+jω)t}dω</script><p>带入$s=σ+jω$并替换积分域，得到拉普拉斯反变换的定义式：</p><script type="math/tex; mode=display">f(t)=\frac{1}{2πj}∫_{σ-j∞}^{σ+j∞}F(s)e^{st}ds</script><p>拉普拉斯变换对包含拉普拉斯变换和反变换的定义式。  </p><p><strong>拉普拉斯变换的一般形式和反变换求解</strong><br>$f(t)$经拉普拉斯变换后的$F(s)$可以用多项式分数的形式进行表达：  </p><script type="math/tex; mode=display">F(s)=\frac{A(s)}{B(s)}=\frac{∑a_ms^m}{∑b_ns^n}</script><p>倘若$m&lt;n$，则$F(s)$是一个真分数，可以上下做多项式除法，得到：  </p><script type="math/tex; mode=display">F(s)=\frac{a_m(s-z_1)(s-z_2)L(s-z_m)}{b_n(s-p_1)(s-p_2)L(s-p_n)}</script><p>其中$z$表示$F(s)$的时域变换$f(t)$中的零点，$p$表示$F(s)$的时域变换$f(t)$中的指数系数，称为极点(Pole)。  </p><div class="note note-info">            <p>真分数意味着$F(s)$在无穷处收敛的概率很大，因此拉普拉斯变换后的式子具有高稳定性的特点。  </p>          </div><p>在单阶实数极点（Single-order real poles）的条件下：  </p><script type="math/tex; mode=display">F(s)=\frac{A(s)}{(s-p_1)(s-p_2)L(s-p_n)}</script><p>那么$F(s)$经过多项式除法/因式分解之后可以写作：  </p><script type="math/tex; mode=display">F(s)=∑_{i=1}^\frac{k_i}{s-p_i}+L</script><p>可以得到：  </p><script type="math/tex; mode=display">f(t)=∑_{i=1}^{n}k_ie^{p_it}</script><div class="note note-info">            <blockquote><p>另外两种关于$F(s)$极点的情况：</p><ol><li>共轭复数  </li><li>多根<br>本节不会讨论  </li></ol></blockquote>          </div><h2 id="拉普拉斯变换的性质"><a href="#拉普拉斯变换的性质" class="headerlink" title="拉普拉斯变换的性质"></a>拉普拉斯变换的性质</h2><ol><li>线性（同傅里叶变换）</li><li>变换操作  <ul><li>时移特性（同傅里叶变换）  </li><li>频移特性:$f(t)e^{-αt}→F(s+α)$  </li><li>尺度变换（同傅里叶变换）   </li></ul></li><li><p>积分和微分（时域）</p><ul><li>微分<br>一阶微分：$\frac{df(t)}{dt}→sF(s)-f(0_)$<br>二阶微分：$\frac{df^2(t)}{dt}→s[sF(s)-f(0_)]-f’(0_)$  </li><li>积分<br>$∫_{-∞}^tf(τ)dτ→\frac{F(s)}{s}+\frac{f^{(-1)}(0_)}{s}$   <div class="note note-info">            <p>证明过程是将积分域分解为$[-∞,0]$（表示初始状态）和$[0,t]$两段。  </p>          </div>    </li></ul></li><li><p>积分和微分（频域）</p><ul><li>n阶微分<br>$L[t^nf(t)]=(-1)^n\frac{d^nF(s)}{ds^n}$  </li><li>积分  <script type="math/tex; mode=display">L[\frac{f(t)}{t}]=∫_s^∞F(s)ds</script></li></ul></li></ol><h3 id="初值定理"><a href="#初值定理" class="headerlink" title="初值定理"></a>初值定理</h3><p>如果$f(t)$可积可被拉普拉斯变换，$f(t)$在$0_+$时刻的值（即初值）可以通过如下公式求得：  </p><script type="math/tex; mode=display">f(0_+)=lim_{s→∞}sF(s)</script><h3 id="终值定理"><a href="#终值定理" class="headerlink" title="终值定理"></a>终值定理</h3><p>如果$f(t)$可积可被拉普拉斯变换，$f(t)$在$∞$时刻的值（即初值）可以通过如下公式求得：  </p><script type="math/tex; mode=display">lim_{t→∞}f(t)=lim_{s→0}sF(s)</script><h3 id="卷积理论"><a href="#卷积理论" class="headerlink" title="卷积理论"></a>卷积理论</h3><p>拉普拉斯变换的卷积理论与傅里叶变换的卷积理论大抵相同，但是要注意对于时域中乘法的变换在频域中卷积项的参数是$\frac{1}{2πj}$。 </p><script type="math/tex; mode=display">L[f_1(t)*f_2(t)]=F_1(s)F_2(s)</script><script type="math/tex; mode=display">L[f_1(t)f_2(t)]=\frac{1}{2πj}F_1(s)*F_2(s)</script><h2 id="常见信号的拉普拉斯变换"><a href="#常见信号的拉普拉斯变换" class="headerlink" title="常见信号的拉普拉斯变换"></a>常见信号的拉普拉斯变换</h2><h3 id="阶跃信号"><a href="#阶跃信号" class="headerlink" title="阶跃信号"></a>阶跃信号</h3><script type="math/tex; mode=display">\begin{aligned}    L[u(t)] & =∫_0^∞u(t)e^{-st}dt \\    &=∫_0^∞e^{-st}dt \\    &=\frac{1}{s}\end{aligned}</script><blockquote><p>对于直流信号（常数）信号$f(t)=t_0$，可以在其后乘上一个$u(t)$做拉普拉斯变换，得到$L[t_0]=\frac{t_0}{s}$。</p></blockquote><h3 id="指数信号"><a href="#指数信号" class="headerlink" title="指数信号"></a>指数信号</h3><script type="math/tex; mode=display">\begin{aligned}    L[e^{-(α+jβ)t}]&=∫_0^∞e^{-(α+jβ)t}e^{-st}dt \\    &=\frac{1}{s+α+jβ}\end{aligned}</script><h3 id="单位冲激信号及时移"><a href="#单位冲激信号及时移" class="headerlink" title="单位冲激信号及时移"></a>单位冲激信号及时移</h3><script type="math/tex; mode=display">L[δ(t)]=1</script><script type="math/tex; mode=display">L[δ(t-t_0)]=e^{-st_0}</script><h3 id="斜坡信号"><a href="#斜坡信号" class="headerlink" title="斜坡信号"></a>斜坡信号</h3><script type="math/tex; mode=display">\begin{aligned}    L[tu(t)]&=∫_0^∞te^{-st}dt\\    &=\frac{1}{s^2}\end{aligned}</script><h2 id="拉普拉斯变换法求解系统微分方程"><a href="#拉普拉斯变换法求解系统微分方程" class="headerlink" title="拉普拉斯变换法求解系统微分方程"></a>拉普拉斯变换法求解系统微分方程</h2><h3 id="系统方程与全响应"><a href="#系统方程与全响应" class="headerlink" title="系统方程与全响应"></a>系统方程与全响应</h3><ol><li><p>以时域函数$f(t)$的拉普拉斯变换$F(s)$的微分特性：  </p><blockquote><p>一阶微分：$\frac{df(t)}{dt}→sF(s)-f(0_)$<br>二阶微分：$\frac{df^2(t)}{dt}→s[sF(s)-f(0_)]-f’(0_)$  </p></blockquote><p>可以将微分方程以拉普拉斯变换从时域变换至频域。<br>对于描述系统的微分方程将其做拉普拉斯变换：</p><script type="math/tex; mode=display">F_{out}(R(s),s)=F_{in}(E(s),s)</script></li><li><p>带入初始条件和给定的题目条件中的一些$r(t)$在特定时刻下的值，得到方程  </p></li><li>解出频域内的$R(s)$  </li><li>用待定系数法展开多项式分式并用拉普拉斯反变换得到$r(t)$</li></ol><h3 id="零输入响应"><a href="#零输入响应" class="headerlink" title="零输入响应"></a>零输入响应</h3><h4 id="法1"><a href="#法1" class="headerlink" title="法1"></a><strong>法1</strong></h4><p>对于描述系统的微分方程，整理出关于$R(s)$的等式：  </p><script type="math/tex; mode=display">R(s)=F_{多项式分式}(r(t_0),s)+F_{多项式分式}(E(s),s)</script><p><strong>其中含有某些初始状态$r(t_0)$的多项式分式是零输入响应，含有$E(s)$的多项式分式是零状态响应。</strong><br>选取含有$r(t_0)$的多项式分式，带入初始状态即可得到零输入响应$R_{zi}(s)$。<br>利用拉普拉斯反变换得到$r_{zi}(t)$。  </p><h4 id="法2"><a href="#法2" class="headerlink" title="法2"></a><strong>法2</strong></h4><ol><li>令$E(s)=0$，重新写出此时的系统微分方程： <script type="math/tex; mode=display">F_{out}(R(s),s)=0</script></li><li>带入初始条件和给定的题目条件中的一些$r(t)$在特定时刻下的值，得到方程  </li><li>解出频域内的$R_{iz}(s)$  </li><li>用待定系数法展开多项式分式并用拉普拉斯反变换得到$r_{iz}(t)$</li></ol><h3 id="零状态响应"><a href="#零状态响应" class="headerlink" title="零状态响应"></a>零状态响应</h3><h4 id="法1-1"><a href="#法1-1" class="headerlink" title="法1"></a><strong>法1</strong></h4><p>对于描述系统的微分方程，整理出关于$R(s)$的等式：  </p><script type="math/tex; mode=display">R(s)=F_{多项式分式}(r(t_0),s)+F_{多项式分式}(E(s),s)</script><p><strong>其中含有某些初始状态$r(t_0)$的多项式分式是零输入响应，含有$E(s)$的多项式分式是零状态响应。</strong><br>选取带有系统输入$E(s)$的多项式分式，由$L(δ(t))→1$带入$E(s)=1$，得到系统的零状态响应$R_{zs}(s)$。<br>利用拉普拉斯反变换得到$r_{zs}(t)$</p><h4 id="法2-1"><a href="#法2-1" class="headerlink" title="法2"></a><strong>法2</strong></h4><p>求解到$r(t)$与$r_{iz}(t)$后，利用</p><script type="math/tex; mode=display">r_{zs}(t)=r(t)-r_{iz}(t)</script><p>间接求解到$r_{zs}(t)$。  </p><h2 id="用拉普拉斯变换分析电路"><a href="#用拉普拉斯变换分析电路" class="headerlink" title="用拉普拉斯变换分析电路"></a>用拉普拉斯变换分析电路</h2><p>将电路中主要元件的电压电流关系进行拉普拉斯变换：<br>电阻：  </p><script type="math/tex; mode=display">R=\frac{V(s)}{I}</script><p>电容：<br>由时域：$v(t)=\frac{1}{C}∫i(t)dt$  </p><script type="math/tex; mode=display">V(s)=I(s)\frac{1}{sC}+\frac{1}{s}v_c(0_-)</script><p>电容的阻抗（容抗）：  </p><script type="math/tex; mode=display">Z_c=\frac{1}{sC}</script><p>电感：由时域：$v(t)=L\frac{di(t)}{dt}$  </p><script type="math/tex; mode=display">V(s)=I(s)Ls-Li(0_-)</script><p>电感的阻抗（感抗）：</p><script type="math/tex; mode=display">Z_L=sL</script><p>电路的分析方法仍然遵循KCL和KVL。   </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>信号与系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>8.4. 使用支持向量机</title>
    <link href="/2021/05/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/8.%20%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/8.4.%20%E4%BD%BF%E7%94%A8SVM/"/>
    <url>/2021/05/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/8.%20%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/8.4.%20%E4%BD%BF%E7%94%A8SVM/</url>
    
    <content type="html"><![CDATA[<h1 id="使用支持向量机"><a href="#使用支持向量机" class="headerlink" title="使用支持向量机"></a>使用支持向量机</h1><p>本节将考虑在实际中应用SVM算法的一些问题。  </p><h2 id="调用函数库实现"><a href="#调用函数库实现" class="headerlink" title="调用函数库实现"></a>调用函数库实现</h2><p>求解$θ$的过程很繁琐，因此在实际中通常采用调用现有函数库（比如liblinear,libsvm）的方式实现SVM，但仍然需要给这些函数补充参数：  </p><ol><li>选择参数C。</li><li>选择内核参数。<br>如果不同特征之间的取值差异非常大，需要对特征变量做归一化。  </li></ol><h2 id="其他的核函数"><a href="#其他的核函数" class="headerlink" title="其他的核函数"></a>其他的核函数</h2><p>目前学到的两种核函数：<br>线性内核：即不使用内核参数，比如： $y=1,if θ^Tx≥0$。通常在有大量的特征，但是只有少量的训练样本的情况下，为了避免过拟合而采用线性拟合的方式。<br>高斯核： 通常对大样本且决策边界不规则的情况适用。  </p><p>有些函数库需要用户自己写一个核函数。因此事实上除了这两种核函数之外，用户可以创建自己的核函数。但是只有满足默塞尔定理的函数才能被作为核函数。<br>其他的核函数：</p><ol><li>多项式核函数：$k(x,l)=(x^Tl+b)^n$,b和n都是实数参数。    </li><li>字符串核函数</li><li>直方相交核函数</li><li>卡方核函数</li></ol><h2 id="多类别分类"><a href="#多类别分类" class="headerlink" title="多类别分类"></a>多类别分类</h2><p>在$k$分类下，需要构建$k$个SVM函数，每一个函数需要将一个类别从其他的类别中区分开来。<br>在大部分函数库中，多分类函数已经被预置，因此只需要调用即可。  </p><h2 id="逻辑回归与SVM"><a href="#逻辑回归与SVM" class="headerlink" title="逻辑回归与SVM"></a>逻辑回归与SVM</h2><p>已经知道SVM其实是对于逻辑回归的修改，那么在何种情况下使用它们？<br>设$n$为特征数，$m$为训练样本数：<br><strong>如果$n$远大于$m$（比如文本分类），使用逻辑回归或者是线性核的SVM。</strong><br><strong>如果$n$的值相对于$m$较小且$m$的值比较适中，使用高斯核的SVM。</strong><br><strong>如果$n$远小于$m$,应当首先手动增加一些特征，再使用逻辑回归或者是线性核的SVM。</strong>  </p><blockquote><p>线性核的SVM的本质就是线性的逻辑回归，因此两者的预测结果会非常相似，但是在具体的环境中两者的性能会有差异。  </p></blockquote><p>上述的情况都可以使用神经网络进行训练，但是训练的速度可能会非常地慢。  </p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>08. 支持向量机</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05. 时域分析方法（微分/差分方程·卷积）</title>
    <link href="/2021/05/10/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/5.%20%E7%A6%BB%E6%95%A3%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%97%B6%E5%9F%9F%E5%88%86%E6%9E%90%E6%B3%95/"/>
    <url>/2021/05/10/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/5.%20%E7%A6%BB%E6%95%A3%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%97%B6%E5%9F%9F%E5%88%86%E6%9E%90%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><style><br>img{<br>    width: 40%;<br>    padding-left: 20%;<br>}</style>  </p><h1 id="时域分析方法（微分-差分方程·卷积）"><a href="#时域分析方法（微分-差分方程·卷积）" class="headerlink" title="时域分析方法（微分/差分方程·卷积）"></a>时域分析方法（微分/差分方程·卷积）</h1><h2 id="微分-差分方程的解"><a href="#微分-差分方程的解" class="headerlink" title="微分/差分方程的解"></a>微分/差分方程的解</h2><div class="note note-info">            <p>从本节开始：<br>名词“系统输入”与“系统激励”等同，系统输出与系统响应等同。<br>在定积分中$∫$表示从-∞到∞的积分，$∑$表示从-∞到∞的和。  </p>          </div><div class="note note-info">            <p>线性时不变系统可以用一个关于激励($e(t)$)和响应($r(t)$)的$n$阶微分/差分方程对其描述。<br>$n$阶在电路中的具体表现为$n$个电容/电感。  </p>          </div><script type="math/tex; mode=display">C_0\frac{d^nr(t)}{dt^n}+C_1\frac{d^{n-1}r(t)}{dt^{n-1}}+...+C_nr(t)=E_0\frac{d^me(t)}{dt^m}+E_1\frac{d^{m-1}e(t)}{dt^{m-1}}+...+E_me(t)</script><p>这个方程的解由<strong>齐次解</strong>和<strong>特解</strong>两部分组成，齐次解与特解的和构成方程的<strong>全解</strong>。  </p><h3 id="齐次解"><a href="#齐次解" class="headerlink" title="齐次解"></a>齐次解</h3><p>当输入全部为0时，得到的方程：$C_0\frac{d^nr(t)}{dt^n}+C_1\frac{d^{n-1}r(t)}{dt^{n-1}}+…+C_nr(t)=0$，称之为特征方程。<br>由特征方程得到的解称为<strong>齐次解</strong>。<strong>齐次解表示系统的零输入响应</strong>。  </p><h4 id="求齐次解"><a href="#求齐次解" class="headerlink" title="求齐次解"></a><strong>求齐次解</strong></h4><ol><li>将特征方程转化为多项式并求解。<br>对于微分方程的特征方程，其$n$阶微分项可以被换元为$α^n$项，最终将特征方程转化为关于$α$的$n$阶多项式。<br>对于差分方程的特征方程，其0阶差分项$y(n)$可以被换元为关于$α$的最高幂项，如此类推，最终将特征方程转化为关于$α$的$n$阶多项式。  </li><li>根据多项式的解的个数和是否有重根，可以在下表中找到齐次解的形式，并带入多项式的解。  </li><li><p>将齐次解带入已知方程的特解（通常是系统的零状态响应），利用对应阶数项系数相等，求出齐次解中的常系数。  </p><p>不同特征根所对应的齐次解（微分方程）  </p></li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">特征根</th><th style="text-align:center">齐次解$y_p(t)$</th></tr></thead><tbody><tr><td style="text-align:center">单实根</td><td style="text-align:center">$e^{αk}$</td></tr><tr><td style="text-align:center">r重实根</td><td style="text-align:center">$∑C_{r-1}t^{r-1} e^{αk}$</td></tr></tbody></table></div><p>   不同特征根所对应的齐次解（差分方程）  </p><div class="table-container"><table><thead><tr><th style="text-align:center">特征根</th><th style="text-align:center">齐次解$y_p(k)$</th></tr></thead><tbody><tr><td style="text-align:center">单实根</td><td style="text-align:center">$Cα^k$</td></tr><tr><td style="text-align:center">r重实根</td><td style="text-align:center">$∑C_{r-1}k^{r-1} α^k$</td></tr></tbody></table></div><h3 id="特解"><a href="#特解" class="headerlink" title="特解"></a>特解</h3><p>当激励为特定的值或者是函数时，方程的解称为<strong>特解</strong>。  </p><h4 id="求特解"><a href="#求特解" class="headerlink" title="求特解"></a><strong>求特解</strong></h4><ol><li>带入具体的激励$e(t)$到系统的微分/差分方程。</li><li>通过0阶项$r(t)$与激励中最高次数项之间系数的关系，用待定系数法猜想系统响应$r(t)$的结构。</li><li>将$r(t)$的结构代回微分/差分方程，利用对应阶数项系数相等建立方程，解出$r(t)$结构中的常系数。  </li></ol><p>如果已知了一些特解，求另一些特解，可以使用<strong>迭代法</strong>。<br>即从$h(0)$开始列出微分方程，直到列到所求的特解对应的微分方程，将已知的特解带入，从而求出未知的特解。 </p><h2 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h2><h3 id="零状态响应和零输入响应"><a href="#零状态响应和零输入响应" class="headerlink" title="零状态响应和零输入响应"></a>零状态响应和零输入响应</h3><p>在第二讲中对零状态响应和零输入响应以及线性关系进行过介绍，值得注意的是：零状态响应$r_{zs}(t)$和零输入响应$r_{zi}(t)$是相互独立的，即任何的输入只会影响到零状态响应中t的取值，而不会影响零输入响应中t的取值。<br>零输入响应与系统方程的通解有关，零状态响应与系统方程的特解/非齐次解有关。<br>两者可以通过解非齐次的微分/差分方程得到，解微分/差分方程的通用方法是卷积。  </p><h3 id="卷积方法"><a href="#卷积方法" class="headerlink" title="卷积方法"></a>卷积方法</h3><p>在连续系统中，定义$*$ 为卷积符号，定义卷积运算：  </p><script type="math/tex; mode=display">g(t)=f(t)*h(t)=∫f(τ)h(t-τ)dτ</script><p>由于任何信号都可以被分解为$n$个宽为τ，高为$f(nτ)$的门信号，在$τ$非常小的时候可以认为$gate(t)=u’(t)Δτ=δ(t)$，因此任何的信号都可以用与冲激信号的卷积来表示：  </p><script type="math/tex; mode=display">f(t)=∫f(τ)δ(t-τ)dτ</script><h3 id="几何意义"><a href="#几何意义" class="headerlink" title="几何意义"></a>几何意义</h3><p>两个信号$f(t)$$h(t)$卷积的几何意义是： 将其中一个图像左右翻转，然后从$t=0$处向右平移，平移过程中两个函数图像重叠面积的变化即为卷积图像。<br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210420111839.png" alt="">   </p><h3 id="计算性质"><a href="#计算性质" class="headerlink" title="计算性质"></a>计算性质</h3><p>基本性质：交换律，结合律，分配率。<br>微分和积分特性：</p><script type="math/tex; mode=display">g'(t)=f'(t)*h(t)=f(t)*h'(t)</script><script type="math/tex; mode=display">g^{(n-m)}(t)=f^{(n)}(t)*h^{(-m)}(t)=f^{(-m)}(t)*h^{(n)}(t)</script><p>注：$g^{(n-m)}(t)$表示对$g(t)$作n次微分，m次积分。  </p><h4 id="与冲激函数或阶跃函数卷积"><a href="#与冲激函数或阶跃函数卷积" class="headerlink" title="与冲激函数或阶跃函数卷积"></a><strong>与冲激函数或阶跃函数卷积</strong></h4><ol><li>$f(t)*δ(t)=f(t)$</li><li>$f(t-t_0)*δ(t-t_1)=f(t-t_0-t_1)$</li><li>$f(t)*δ’(t)=f’(t)$</li></ol><h3 id="卷积和"><a href="#卷积和" class="headerlink" title="卷积和"></a>卷积和</h3><p>在离散系统中，定义卷积和：</p><script type="math/tex; mode=display">f(k)=∑f(i)h(k-i)</script><p>任何的离散序列都可以用其自身与单位序列的卷积和表示：</p><script type="math/tex; mode=display">f(t)=∑f(i)δ(k-i)di</script><p>卷积和也同样满足如上的计算性质和一些特殊的卷积结果：  </p><script type="math/tex; mode=display">x(k)*\delta(k)=x(k)</script><script type="math/tex; mode=display">x(k)* δ(k-1)=x(k-1)</script><h2 id="冲激响应和单位序列-取样响应"><a href="#冲激响应和单位序列-取样响应" class="headerlink" title="冲激响应和单位序列/取样响应"></a>冲激响应和单位序列/取样响应</h2><p>一个连续的LIT系统<strong>零状态</strong>下输入单位冲激函数$δ(t)$，所引起的响应称为<strong>单位冲激响应</strong>，记作$h(t)$。<br><strong>冲激响应是$e(t)=δ(t)$时微分方程的特解。</strong><br><strong>连续系统的零状态响应$r_{zs}(t)$可以表示为系统输入$f(t)$与单位冲击响应$h(t)$的卷积</strong>：  </p><script type="math/tex; mode=display">r_{zs}(t)=f(t)*h(t)</script><p>一个离散的LIT系统<strong>零状态</strong>下输入单位序列$δ(k)$，所引起的响应称为<strong>单位取样响应</strong>，记作$h(k)$。<br><strong>连续系统的零状态响应$r_{zs}(k)$可以表示为系统输入$f(k)$与单位冲击响应$h(k)$的卷积</strong>：  </p><script type="math/tex; mode=display">r_{zs}(k)=f(k)*h(k)</script><h2 id="阶跃响应"><a href="#阶跃响应" class="headerlink" title="阶跃响应"></a>阶跃响应</h2><p>一个LIT系统<strong>零状态</strong>下输入单位阶跃函数$u(t)$所引起的响应称为<strong>单位阶跃响应</strong>，记作$g(t)$。<br>由$u(t)=∫δ(t)dt$,</p><script type="math/tex; mode=display">g(t)=∫_{-∞}^t h(t)dt</script><p>卷积积分需要满足条件$f_1(τ)f_2(t-τ)≠0$，由于对阶跃函数$u(t)$，$t&gt;0$，因此阶跃响应通从用于决定卷积积分的上下限。 </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>信号与系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>06. 能量·周期信号的傅里叶变换·采样</title>
    <link href="/2021/05/10/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/6.%20%E5%91%A8%E6%9C%9F%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"/>
    <url>/2021/05/10/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/6.%20%E5%91%A8%E6%9C%9F%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<p><style><br>img{<br>    width: 40%;<br>    padding-left: 20%;<br>}</style>  </p><h1 id="能量·周期信号的傅里叶变换·采样"><a href="#能量·周期信号的傅里叶变换·采样" class="headerlink" title="能量·周期信号的傅里叶变换·采样"></a>能量·周期信号的傅里叶变换·采样</h1><h2 id="连续信号的能量"><a href="#连续信号的能量" class="headerlink" title="连续信号的能量"></a>连续信号的能量</h2><h3 id="巴塞瓦尔定理"><a href="#巴塞瓦尔定理" class="headerlink" title="巴塞瓦尔定理"></a>巴塞瓦尔定理</h3><p>信号$x(t)$所带有的能量能够用关于其傅里叶变换$X(jω)$模（频域上的幅值）的积分函数表示：  </p><script type="math/tex; mode=display">E=∫|x(t)|^2dt=\frac{1}{2π}∫|X(jω)|^2dω</script><blockquote><p>$X(jω)$是一个复频率函数表示其带有相位  </p></blockquote><h3 id="能量谱"><a href="#能量谱" class="headerlink" title="能量谱"></a>能量谱</h3><p>一个信号$f(t)$的能量谱函数$P$是频域上各谐波幅值平方的和。  </p><script type="math/tex; mode=display">f(t)=∑|F(nω)|^2</script><p>能量谱密度函数：  </p><script type="math/tex; mode=display">P(ω)=\lim_{T→∞}\frac{|F_T(ω)|^2}{T}</script><h3 id="维纳-辛钦定理"><a href="#维纳-辛钦定理" class="headerlink" title="维纳-辛钦定理*"></a>维纳-辛钦定理*</h3><p>定义复信号$f(t)$的自相关函数$R(τ)$:</p><script type="math/tex; mode=display">R(τ)=\lim_{T→∞}\frac{1}{T}∫f(t)f^*(t-τ)dt</script><p>有如下结论：<br><strong>能量谱密度函数是自相关函数的傅里叶变换。</strong></p><script type="math/tex; mode=display">P(ω)=F[R(τ)]</script><h2 id="时域和频域的对应性质"><a href="#时域和频域的对应性质" class="headerlink" title="时域和频域的对应性质"></a>时域和频域的对应性质</h2><h3 id="卷积与乘法（卷积理论）"><a href="#卷积与乘法（卷积理论）" class="headerlink" title="卷积与乘法（卷积理论）"></a>卷积与乘法（卷积理论）</h3><p><strong>时域中两函数相乘⇔$\frac{1}{2\pi}$频域中两函数的傅里叶变换卷积</strong></p><script type="math/tex; mode=display">f_1(t)f_2(t)⇔\frac{1}{2\pi}F_1(ω)*F_2(ω)</script><p><strong>时域中两函数卷积⇔频域中两函数的傅里叶变换相乘</strong>   </p><script type="math/tex; mode=display">f_1(t)*f_2(t)⇔F_1(ω)F_2(ω)</script><p>应用：</p><ol><li>求谱密度函数</li><li>求$∫_{-∞}^tf(τ)dτ$的傅里叶变换：<br>$∫_{-∞}^tf(τ)dτ=∫_{-∞}^{∞}f(τ)u(t-τ)dτ=f(t)*u(t)⇔F[f(t)]F[u(t)]$</li><li>系统的零状态响应可以表示为$r(t)=f(t)*h(t)⇔F(ω)H(ω)$<br>两个离散序列$x(n)$,$h(n)$的卷积可以表示为卷积和：<script type="math/tex; mode=display">x(n)*h(n)=∑x(m)h(n-m)</script></li></ol><h3 id="周期性和连续性"><a href="#周期性和连续性" class="headerlink" title="周期性和连续性"></a>周期性和连续性</h3><div class="table-container"><table><thead><tr><th>时域</th><th>频域</th></tr></thead><tbody><tr><td>周期信号</td><td>离散频谱</td></tr><tr><td>非周期信号</td><td>连续频谱</td></tr></tbody></table></div><h2 id="一般连续周期信号的傅里叶变换方法及推导"><a href="#一般连续周期信号的傅里叶变换方法及推导" class="headerlink" title="一般连续周期信号的傅里叶变换方法及推导"></a>一般连续周期信号的傅里叶变换方法及推导</h2><p>设一个连续周期信号$f_T(t)$，其可以分解为傅里叶级数(指数形式)：$f_T(t)=∑F(nω_1)e^{jnω_1t}$。<br>对其做傅里叶变换：</p><script type="math/tex; mode=display">\begin{aligned}    F_T(ω) &= F[f_T(t)]\\      & = F[∑F(nω_1)e^{jnω_1t} \\    & = ∑F(nω_1)F[e^{jnω_1t}] \\    ∵ F[1]& =δ(ω)\\     ∴ F[e^{jnω_1t}]&=2πδ(ω-nω_1) \text{ (timeshifting)} \\    ∴ F_T(ω) &= 2πδ(ω-nω_1)∑F(nω_1)\end{aligned}</script><p>即连续周期信号$f_T(t)$傅里叶变换：  </p><script type="math/tex; mode=display">F_T(ω) = 2πδ(ω-nω_1)∑F(nω_1)</script><p>因此如何找到$F(nω_1)$成为了解决连续周期信号的关键。  </p><h3 id="由非周期频谱推导周期频谱"><a href="#由非周期频谱推导周期频谱" class="headerlink" title="由非周期频谱推导周期频谱"></a>由非周期频谱推导周期频谱</h3><p>设周期频谱$F(nω_1)$可以根据周期分解为$n$个非周期子频谱$F_0(ω)$:<br>由$F(nω_1)=\frac{1}{T}∫_{-\frac{T}{2}}^{\frac{T}{2}}f_0(t)e^{-jnω_1t}dt$，有</p><script type="math/tex; mode=display">F(nω_1)=\frac{1}{T}F_0(ω)|_{ω=nω_1}</script><h2 id="常见周期信号的频谱"><a href="#常见周期信号的频谱" class="headerlink" title="常见周期信号的频谱"></a>常见周期信号的频谱</h2><h3 id="单位冲激序列"><a href="#单位冲激序列" class="headerlink" title="单位冲激序列"></a>单位冲激序列</h3><p>由无数个强度为1的冲激信号组成的周期信号$δ_T(t)$：  </p><script type="math/tex; mode=display">\begin{aligned}    F(nω_1)&=\frac{1}{T_1}F_0(ω)|_{ω=nω_1} \\    &=\frac{1}{T_1}×1\\    &=\frac{1}{T_1}\end{aligned}</script><script type="math/tex; mode=display">\begin{aligned}    F(ω)&=2πδ(ω-nω_1)\frac{1}{T_1}\\    &=ω_1δ(ω-nω_1)\end{aligned}</script><p><strong>因此,任何周期信号都可以看做是子信号$f_0(t)$与$δ_T(t)$的卷积。</strong></p><script type="math/tex; mode=display">f(t)=f_0(t)*δ_T(t)↔F(ω)=F_0(ω)F[δ_T(t)]</script><h3 id="周期方波序列"><a href="#周期方波序列" class="headerlink" title="周期方波序列"></a>周期方波序列</h3><p>由若干个方波$G(t)=u(t+τ)-u(t-τ)$组成的周期信号:  </p><script type="math/tex; mode=display">F(nω_1)=\frac{Eτ}{T}Sa(\frac{nω_1τ}{2})</script><script type="math/tex; mode=display">F(ω)=Eτω_1∑Sa(\frac{nω_1τ}{2})δ(ω-nω_1)</script><h3 id="三角函数信号"><a href="#三角函数信号" class="headerlink" title="三角函数信号"></a>三角函数信号</h3><div class="note note-info">            <p>由$F[1]=δ(ω)$及其时移特性： $F[e^{jnω_1t}]=2πδ(ω-nω_1)$,$F[e^{-jnω_1t}]=2πδ(ω+nω_1)$可以推导。   </p>          </div><p><strong>正弦信号</strong>：$f(t)=sin(ω_0t)$  </p><script type="math/tex; mode=display">sin(ω_0t)=\frac{1}{2j}(e^{jω_0t}-e^{-jω_0t})</script><script type="math/tex; mode=display">F(ω)=-jπδ(ω-ω_0)+jπδ(ω+ω_0)</script><p><strong>余弦信号</strong>：$f(t)=cos(ω_0t)$  </p><script type="math/tex; mode=display">cos(ω_0t)=(e^{jω_0t}+e^{-jω_0t})</script><script type="math/tex; mode=display">F(ω)=πδ(ω-ω_0)+πδ(ω+ω_0)</script><h2 id="采样与重构"><a href="#采样与重构" class="headerlink" title="采样与重构"></a>采样与重构</h2><h3 id="模拟信号转数字信号"><a href="#模拟信号转数字信号" class="headerlink" title="模拟信号转数字信号"></a>模拟信号转数字信号</h3><p>模拟信号$f(t)$转换为数字信号经过三步：</p><ol><li>取样</li><li>量化</li><li>编码</li></ol><p>其中取样的本质是$f(t)$与一个周期信号$p(t)$相乘。</p><script type="math/tex; mode=display">f_s(t)=f(t)p(t)</script><p>在频域中：  </p><script type="math/tex; mode=display">F_s(ω)=F(ω)*P(t)</script><h3 id="理想取样"><a href="#理想取样" class="headerlink" title="理想取样"></a>理想取样</h3><p>$p(t)$是周期单位冲激信号$δ_T(t)=∑δ(t-nT_s)$。</p><script type="math/tex; mode=display">\begin{aligned}    P(ω)&=ω_s∑δ(ω-nω_s)\\    F_s(ω)&=\frac{1}{2π}F(ω)*P(t) \\    &=\frac{1}{T_s}∑F(ω-nω_s)\end{aligned}</script><p>如果取样频率$ω_s$（表现为冲激信号的间隔）非常的小，那么频域上取样后的信号可能会产生重叠。<br>如果取样频率非常的大，那么信号会丢失非常多的细节，导致失真。  </p><h3 id="方波取样"><a href="#方波取样" class="headerlink" title="方波取样"></a>方波取样</h3><p>$p(t)$是周期方波信号。</p><script type="math/tex; mode=display">\begin{aligned}    F_s(ω)&=\frac{1}{2π}F(ω)*P(t) \\    &=\frac{Eτ}{T_s}∑San(\frac{nω_sτ}{2})F(ω-nω_s)\end{aligned}</script><h3 id="信号复原"><a href="#信号复原" class="headerlink" title="信号复原"></a>信号复原</h3><p>信号复原的基本思路是利用<strong>低通滤波器</strong>在频域内设定过滤出0到$ω_1$内（一个周期内）的信号频谱$F_0(ω)$，用傅里叶反变换得到$f_0(t)$。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>信号与系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>《机器学习》 周志华 1-5章笔记</title>
    <link href="/2021/05/10/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E8%A5%BF%E7%93%9C%E4%B9%A6%EF%BC%89(1)/"/>
    <url>/2021/05/10/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E8%A5%BF%E7%93%9C%E4%B9%A6%EF%BC%89(1)/</url>
    
    <content type="html"><![CDATA[<h1 id="《机器学习》-周志华-1-5章笔记"><a href="#《机器学习》-周志华-1-5章笔记" class="headerlink" title="《机器学习》 周志华 1-5章笔记"></a>《机器学习》 周志华 1-5章笔记</h1><blockquote><p>作者为博主的同事 黄欣迪   </p></blockquote><h2 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h2><ul><li><p>1.1 引言  </p><p>什么是机器学习？ 机器学习是致力于研究如何通过计算的手段，利用经验来改善系统自身的性能<br>经验——数据 模型——算法 通过相应的算法分析数据——得出结论<br>一些文献用“模型”指全局性结果（决策树） 用“模式”指局部性结果（一条规则）  </p></li><li><p>1.2 基本术语  </p><p>进行机器学习的前提是要有数据，例如给细胞的数据，并对给定细胞的大小，形态等进行记录<br>这组记录的集合称为一个“数据集”，其中每一条记录是关于一个事件或对象的描述，称为一个“示例”或“样本”<br>对于细胞的描述，如大小、形状，称为“属性”或“特征”<br>属性上的取值例如圆形、椭圆形，称为“属性值”<br>属性张成的空间称为“属性空间”、“样本空间”或“输入空间”<br>例如大小、形状、颜色张成的三维空间对于每一个样本都能找到对应的坐标向量，称为“特征向量”<br>从数据中学得模型的过程称为“学习”或“训练”<br>对于潜在规律自身，称为“真相”或“真实”<br>本书有时将模型称为“学习器”<br>拥有了标记信息的示例，称为“样例”<br>如果预测的是离散值，称为“分类” 若为二分类，则是正类和反类 预测的是连续值，称为“回归”<br>监督学习和无监督学习 前者是分类和回归是前者的代表 聚类是后者的代表<br>泛化模型是我们所想要找到的，强泛化模型可以更好适用于整个样本空间  </p></li><li><p>1.3 假设空间  </p><p>泛化学习：通过对训练集中瓜的学习已获得对没有见过的瓜进行判断的能力<br>假设空间：对所有假设组成的空间进行搜索，搜索目标是找到与训练集fit的假设  </p></li><li><p>1.4 归纳偏好  </p><p>偏好：对于不同的模型，它的偏好是不一样的，例如有一个模型更偏好某一特征，它会根据将该特征进行结果的认定<br>任何一个有效的机器学习模型必有其归纳偏好，否则会被假设空间中看似在训练集中“等效”的假设所迷惑<br>算法A优于算法B P9 具体论证 算法A和算法B的期望相同 与算法无关  </p></li><li><p>1.5 发展历程  </p></li><li>1.6 应用现状</li><li>1.7 阅读材料  <h2 id="第二章-模型评估与选择"><a href="#第二章-模型评估与选择" class="headerlink" title="第二章 模型评估与选择"></a>第二章 模型评估与选择</h2></li><li><p>2.1 经验误差与过拟合  </p><p>分类错误的样本占样本总数的比例称为“错误率”<br>m个样本中a个错误  </p><script type="math/tex; mode=display">E=\frac{a}{m}</script><p>相对的精度=1-错误率<br>过拟合的定义为学习器将训练集的自身特点当作了所有潜在样本的性质，这样会导致泛化性下降<br>难以在机器学习的过程中避免过拟合  </p></li><li><p>2.2 评估方法  </p><p>测试集尽量不要出现在训练集当中  </p></li><li><p>2.2.1 留出法  </p><p>将数据集D划分为两个互斥的集合 一个为训练集S 另一个为测试集T<br>划分尽量保持数据分布的一致性 分层采样<br>一般而言测试集至少含30个样例<br><strong>$\frac{2}{3}$到$\frac{4}{5}$的样本用于训练 其余样本用于测试</strong></p></li><li><p>2.2.2 交叉验证法  </p><p>数据集D划分为k个大小相似的互斥子集 每个子集都尽可能保持数据分布的一致性 P26<br>D——D1 D2 D3…. D10<br>D1 D2….D9 训练集  D10 测试集<br>D1 D2….D8 D10 训练集 D9 测试集<br>10次10折交叉验证<br>留一法：交叉验证法的特例——只留下一个样本作为测试集  </p></li><li><p>2.2.3 自助法  </p><p>给定包含m个样本的数据集D 对它进行采样产生数据集D’ 每次随机从D中挑选一个样本 将其拷贝到D’中 重复执行m次<br>得到了包含m个样本的数据集D’ m次采样中始终不被采集到的概率是</p><script type="math/tex; mode=display">(1-\frac{1}{m})^m</script><p>极限值约为0.368 即D中约有36.8%的样本没有在D’中出现<br>用D/D’作为测试集（/表示集合减法) 这样的测试结果叫做“包外估计”<br>自助法适用于数据量较小的数据集 留出法和交叉验证法适用于数据量足够的数据集  </p></li><li><p>2.2.4 调参与最终模型  </p><p>调参往往需要设定一个步长 在对应步长内取值 因为无法在实数范围内取完所有值<br>测试数据：模型在实际使用中遇到的数据  </p></li><li><p>2.3 性能度量  </p><p>定义：衡量模型泛化能力的评价标准<br>性能度量反映了任务需求——不同的性能度量导致不同的评判结果——模型的好坏是相对的<br>回归任务最常用的性能度量是“均方误差”</p><script type="math/tex; mode=display">E(f;D)=\frac{1}{m}\sum_{m=1}^{m}(f(x_i)-y_i)^2</script><p>对于数据分布D和概率密度p(‘) 均方误差为  </p><script type="math/tex; mode=display">E(f;D)=\int_{x\sim D} (f(x)-y)^2p(x)dx</script><p>以下主要是分类任务中常用的性能度量  </p></li><li><p>2.3.1 错误率与精度  </p><p>错误率和精度是分类任务中最常用的两种性能度量 既可以适用于二分类任务 也能适用于多分类任务<br>对样例集D 分类错误率定义为  </p><script type="math/tex; mode=display">E(f;D)=\frac{1}{m}\sum_{i=1}^{m}\prod_{}(f(x_i)\neq{y_i})^2</script><p>精度定义为  </p><script type="math/tex; mode=display">acc(f;D)=\frac{1}{m}\sum_{i=1}^{m}\prod_{}(f(x_i)\neq{y_i})^2=1-E(f;D)</script></li><li><p>2.3.2 查准率、查全率与F1  </p><p>实例：在信息检索中，经常关心的是“检索出的信息中有多少比例是用户感兴趣的”“用户感兴趣的信息中有多少被检索了出来”<br>“查准率”(precision)和“查全率”(recall)是更为适用于此类需求的性能变量<br>对于二分类问题 可将样例根据真实类别与学习器预测类别的组合划分为四种情形<br>真正例 假正例 真反例 假反例 令其为 TP、FP、TN、FN TP+FP+TN+FN=样例总数<br>查准率P与查全率R分别定义为  </p><script type="math/tex; mode=display">P=\frac{TP}{TP+FP}</script><script type="math/tex; mode=display">R=\frac{TP}{TP+FN}</script><p>查全率和查准率除了在一些简单任务中都比较高以外 一般一个高另一个低<br>画出模型实时的P-R图可以判断该模型的性能 如果P-R曲线被另一个模型包裹 那么可以认为被包裹的模型性能差<br>最终可以根据比较P-R曲线围成面积的大小来确定模型性能的好坏(该值不容易估算)<br>平衡点(Break-Event Point, 简称BEP)：查准率=查全率时的取值(平衡点大 学习性能优)<br>但更常用的是F1度量  </p><script type="math/tex; mode=display">F1=\frac{2*P*R}{P+R}=\frac{2*TP}{样例总数+TP-TN}</script><p>如果在实际问题中对查准率和查全率的偏重不同的话 引入Fβ  </p><script type="math/tex; mode=display">\frac{1}{F1}=\frac{1}{2}(\frac{1}{P}+\frac{1}{R})</script><script type="math/tex; mode=display">\frac{1}{F_\beta}=\frac{1}{1+\beta^2}(\frac{1}{P}+\frac{\beta^2}{R})（\beta>1 查全率影响大）（\beta<1 查准率影响大）</script><p>以上公式可以看出F1是基于查准率和查全率的调和平均定义的<br>Fβ则是基于加权调和平均定义的 与算术平均和集合平均相比 调和平均更重视较小值<br>考虑实际情况中需要在n个二分类混淆矩阵上综合考察查全率和查准率<br>做法一：在各个混淆矩阵中分别计算P和R 计算平均值 代入F1<br>做法二：计算TP、FP、TN、FN的平均值 代入P和R 再代入F1  </p></li><li><p>2.3.3 ROC与AUC  </p><p>学习器一般是为测试样本产生一个实值或概率预测 使用该预测值与分类阈值进行比较 若大于阈值则为正类 反之为反类<br>预测结果的好坏决定了学习器的泛化能力<br>该分类过程相当于在排序中以某个截断点将样本分为两个部分 前一部分判做正例 后一部分判做反例<br>ROC曲线则是以排序本身的好坏来判定学习器泛化性能的<br>ROC曲线全称是“受试者工作特征”(Receiver Operating Characteristic)<br>ROC曲线的定义<br>纵轴：“真正例率”  </p><script type="math/tex; mode=display">TPR=\frac{TP}{TP+FN}</script><p>横轴：“假正例率”  </p><script type="math/tex; mode=display">FPR=\frac{FP}{TN+FP}</script><p>真正问题中对于有限个测试样例<br>设给定m+个正例 m-个反例进行排序<br>首先将分类阈值设为最大——所有样例均预测为反例 初始的真正例率和假正例率均为0 初始坐标(0,0)<br>现在预测一个样本 如果为真正例 标记点的坐标为  </p><script type="math/tex; mode=display">(x,y+\frac{1}{m^+})</script><p>如果为假正例 标记点的坐标为  </p><script type="math/tex; mode=display">(x+\frac{1}{m^-},y)</script><p>进行学习器比较时 若一个学习器的ROC曲线被另一个学习器的曲线完全包住 则可断言后者的性能优于前者 若两个学习器的ROC曲线发生交叉 则不能断言<br>同样 如果要比较两个学习器 较为合理的判据是比较ROC曲线下的面积 即AUC<br>AUC可以估算为  </p><script type="math/tex; mode=display">AUC=\frac{1}{2}\sum_{i=1}^{m-1}(x_{i+1}-x_i)*(y_i+y_{i+1})</script><p>但在实际问题中如何考虑排序的误差  </p><script type="math/tex; mode=display">l_{rank}=\frac{1}{m^+m^-}\sum_{x^+\in{D^+}}\sum_{x^+\in{D^+}}(\prod_{}(f(x^+)<f(x^-))+\frac{1}{2}\prod_{}(f(x^+)=f(x^-)))</script><script type="math/tex; mode=display">AUC=1-l_{rank}</script><p>理解：如果正例的预测值小于反例 则记一个罚分 如果正例的预测值等于反例 则记0.5个罚分  </p></li><li><p>2.3.4 代价敏感错误率与代价曲线  </p><p>实际问题中 对于不同类型的错误所造成的后果不同<br>例如在医疗诊断中，错误地把患者诊断为健康人与错误地把健康人诊断为患者的结果不同<br>对于这类问题可以将预测错误的cost设为cost1和cost2<br>代入之前的公式可以计算出总体代价最小时的错误率<br>在非均等代价下 ROC曲线不能直接反映出学习器的期望总体代价 这时需要使用代价曲线<br>具体可见P36  </p></li><li><p>2.4 比较检验（以下为各种概率论中的假设检验）  </p></li><li><p>2.5 偏差和方差  </p><p>泛化误差可以分解为偏差、方差与噪声之和 P45  </p></li></ul><h2 id="第三章-线性模型"><a href="#第三章-线性模型" class="headerlink" title="第三章 线性模型"></a>第三章 线性模型</h2><ul><li><p>3.1 基本形式  </p><p>给定由d个属性描述的示例  </p><script type="math/tex; mode=display">x=(x_1;x_2...;x_d)</script><p>其中xi是x在第i个属性上的取值<br>线性模型学习的是通过属性的线性组合来进行预测的函数 即  </p><script type="math/tex; mode=display">f(x)=w_1x_1+w_2x_2+w_3x_3+.....+w_dx_d+b</script><p>一般用向量写成  </p><script type="math/tex; mode=display">f(x)=w^Tx+b</script><p>w和b学得后 模型就得以确定</p></li><li><p>3.2 线性回归  </p><p>给定数据集  </p><script type="math/tex; mode=display">D={(x_1,y_1),(x_2,y_2),...,(x_m,y_m)}</script><p>其中  </p><script type="math/tex; mode=display">x_i=(x_{i1};x_{i2};...;x_{id}), y_i\in{R}</script><p>线性回归试图学得一个线性模型以尽可能准确的预测实值输出标记<br>首先可以将离散型属性通过连续化将其转化为连续值<br>例如二值属性“身高” 高=1  矮=0<br>线性回归试图学得  </p><script type="math/tex; mode=display">f(x_i)=wx_i+b, 使得f(x_i)\approx{y_i}</script><p>均方误差是回归任务中最常用的性能度量 所以试图让均方误差最小化<br>具体推导过程 P54<br>一个属性只有一个权重 d个属性就会有d个权重<br>可以考虑广义的情况 比如lny  </p></li><li><p>3.3 对数几率回归  </p><p>对数几率函数  </p><script type="math/tex; mode=display">y=\frac{1}{1+e^{-z}}</script><p>也就称为sigmoid函数<br>预测值z 通过z来找y y是逼近0或者1 由此判断预测为正或反  </p></li><li><p>3.4 线性判别分析  </p><p>线性判别分析(Linear Discriminant Analysis LDA)是一种经典的线性学习方法，主要用于二分类问题<br>目标 同类别的方差最小 不同类别的方差最大<br>(该方法应用比较少)  </p></li><li><p>3.5 多分类学习  </p></li><li><p>3.6 类别不平衡问题  </p><p>过采样：不能重复采样 会造成过拟合<br>欠采样：去除一些样本 让正反例数量接近 然后再进行学习  </p></li><li><p>3.7梯度下降法(补充)  </p></li></ul><h2 id="第四章-决策树"><a href="#第四章-决策树" class="headerlink" title="第四章 决策树"></a>第四章 决策树</h2><ul><li><p>4.1 基本流程  </p><p>决策树的生成是一个递归过程  学习目的是为了产生一棵泛化能力强 即处理未见示例能力强的决策树  </p></li><li><p>4.2 划分选择  </p><p>最关键的是如何选择最优化分属性 希望随着划分过程的进行 决策树的分支结点所包含的样本尽可能属于同一类别<br>即结点的“纯度”越来越高  </p></li><li><p>4.2.1 信息增益  </p><p>“信息熵”(information entropy)是度量样本集合纯度最常用的一种指标<br>假定当前样本集合D中第K类样本所占比例为$P_k(k=1,2,…,|y|)$，则D的信息熵定义为  </p><script type="math/tex; mode=display">Ent(D)=-\sum_{K=1}^{|y|}p_klog_2P_k</script><p>Ent(D)的值越小 D的纯度越高<br>什么是熵：对一种事物的不确定性就叫熵 比如买西瓜 不知道买哪一个是好瓜 这就是熵<br>信息：消除这种不确定性的事物（调整概率、排除干扰、确定情况）<br>噪音：不能消除某人对某件事情不确定性的事物<br>数据：信息+噪音<br>假设一件事情有八种等可能的结果 相当于抛三枚硬币 熵为3bit<br>若每种情况概率分布不相等(一般分布)  </p><script type="math/tex; mode=display">A=\frac{1}{2}|B=\frac{1}{3}|C=\frac{1}{6}</script><script type="math/tex; mode=display">P(A)=\frac{1}{2}(log_26-log_23)</script><script type="math/tex; mode=display">P(B)=\frac{1}{3}(log_26-log_22)</script><script type="math/tex; mode=display">P(C)=\frac{1}{6}(log_26-log_21)</script><script type="math/tex; mode=display">Ent(D)=P(A)+P(B)+P(C)</script><p>得知信息的前后 不确定性的变化——熵的差额 就是信息的量<br>例如ABCD四道选择题 等可能的话熵为2bit<br>如果知道C有一半可能是正确的 那么  </p><script type="math/tex; mode=display">P(A)=P(B)=P(D)=\frac{1}{6}|P(C)=\frac{1}{2}</script><p>现在的熵为  </p><script type="math/tex; mode=display">\frac{1}{6}log_26+\frac{1}{6}log_26+\frac{1}{2}log_22+\frac{1}{6}log_26=1.79</script><p>所以 知道C有一半可能正确的条件后 现在的不确定性是1.79 那么信息量就是0.21<br>西瓜数据集2.0 P76<br>17个样例 8个好瓜 9个坏瓜 一般分布<br>先算出信息熵 根节点  </p><script type="math/tex; mode=display">Ent(D)=\frac{8}{17}log_2\frac{17}{8}+\frac{9}{17}log_2\frac{17}{9}=0.998</script><p>然后计算每一个特征不同的信息增益<br>三种色泽 先算每一种的Ent 然后分权 相加 与根结点的熵作差 得到有关色泽的信息增益  </p><script type="math/tex; mode=display">Ent(D_1)=\frac{3}{6}log_2\frac{6}{3}+\frac{3}{6}log_2\frac{6}{3}=1.000</script><script type="math/tex; mode=display">Ent(D_2)=\frac{4}{6}log_2\frac{6}{4}+\frac{2}{6}log_2\frac{6}{2}=0.918</script><script type="math/tex; mode=display">Ent(D_3)=\frac{1}{5}log_2\frac{5}{1}+\frac{4}{5}log_2\frac{5}{4}=0.722</script><script type="math/tex; mode=display">Gain(D,色泽)=Ent(D)-\sum_{v=1}^3\frac{|D^v|}{D}Ent(D^v)=0.998-(\frac{6}{17}*1.000+\frac{6}{17}*0.918+\frac{5}{17}*0.722)=0.109</script><p>根据计算的结果信息增益越高 作为第一轮选择<br>以此类推  </p></li><li><p>4.2.2 增益率(C4.5算法)</p><p>信息增益准则对可取值数目较多的属性有所偏好<br>所以C4.5决策树算法 是先计算Gain 也就是分权后相加的熵 再用该改值除以IV(a)  </p><script type="math/tex; mode=display">Gain_ratio(D,a)=\frac{Gain(D,a)}{IV(a)}=\frac{0.109}{\frac{6}{17}log_2\frac{17}{6}+\frac{6}{17}log_2\frac{17}{6}+\frac{5}{17}log_2{17}{5}}</script><p>使用增益率方法时 先选出信息增益前五位的信息 随后利用该方法进行进一步筛选  </p></li><li><p>4.2.3 基尼指数(CART算法)  </p><p>Classification and Regression 该方法既可以进行分类也可以进行回归<br>例子：首先先进行统计 西瓜2.0数据集<br>第一个特征色泽 分别统计在青绿这一信息中 是好瓜的个数和不是好瓜的个数<br>乌黑中 是好瓜的个数和不是好瓜的个数 以此类推<br>如果统计中有缺失值例如？？？ 直接跳过<br>CART都是二叉树的模型 衡量纯度的方法<br>Gini index 抽两次 抽得样本中不同的概率来衡量纯度<br>例如B站 P59  </p><script type="math/tex; mode=display">Gini index=1-(\frac{105}{105+39})^2-(\frac{39}{105+39})^2</script><p>基尼指数越大 表示这两个大概率是不同的 所以纯度就下降<br>希望基尼指数越大越好<br>补充：基尼指数的计算代码  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gini_index_single</span>(<span class="hljs-params">a,b</span>):</span>  <br>    single_gini=<span class="hljs-number">1</span>-((a/(a+b))**<span class="hljs-number">2</span>)-((b/(a+b))**<span class="hljs-number">2</span>)  <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">round</span>(single_gini,<span class="hljs-number">2</span>)  <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gini_index</span>(<span class="hljs-params">a,b,c,d</span>):</span>  <br>    zuo = gini_index_single(a,b)  <br>    you = gini_index_single(c,d)  <br>    gini_index = zuo*((a+b)/(a+b+c+d))<br>                   +you*((c+d)/(a+b+c+d))  <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">round</span> (gini_index,<span class="hljs-number">2</span>)  <br></code></pre></td></tr></table></figure><p>补充回归问题<br>SKlearn 计算每一个阈值所对应均方值的最小值  </p></li><li><p>4.3 剪枝处理  </p></li><li><p>4.3.1 预剪枝  </p><p>目的是防止过拟合<br>首先将之前的西瓜数据集2.0分为5/5的训练集以及3/4的测试集<br>根据5/5的训练集先生成一颗决策树 采用的是信息增益准则<br>引入验证集之后 对于一个结点 先计算不划分该结点时的准确率<br>对于这个例子 5/5的训练集我们认为第一个结点脐部全为好瓜 对于测试集 准确率为42.9%<br>划分后 我们获得的标记和测试集进行比较 准确率为71.4%<br>所以我们决定对脐部进行划分 之后的特征也由此类推<br>这样的方法确实可以防止过拟合的产生 但也带来了欠拟合的风险  </p></li><li><p>4.3.2 后剪枝  </p><p>后剪枝主要是在生成决策树之后 自下而上的进行判断<br>这样的方法能够有效的防范欠拟合的的风险<br>但因为是在生成决策树之后进行 所以训练时间的开销会比未剪枝和预剪枝要大得多  </p></li><li><p>4.4 连续与缺失值  </p><p>连续值处理<br>C4.5算法采用二分法 例子：西瓜数据集3.0<br>对于该方法主要计算两个取值 1、信息增益 2、划分点<br>对于每一个划分点进行计算 找到信息增益最大的点 以及最大的信息增益即可<br>缺失值处理<br>对于有缺失值的数据来说 计算信息增益时我们只需要计算该特征下无缺失值所获得的信息增益 再用它来乘以无缺失值数据所占比例即可<br>例如有在色泽特征下 有14个无缺失值的数据 一共有17个数据  </p><script type="math/tex; mode=display">Gain=\frac{14}{17}*Gain(14)</script><p>其他方法<br>离散值<br>1、众数填充 2、相关性最高的列填充<br>连续值<br>1、中位数 2、相关性最高的列做线性回归进行估计  </p></li></ul><ul><li><p>4.5 多变量决策树  </p><p>单变量决策树生成的函数图像的分割线总是与函数轴垂直或平行<br>多变量决策树生成的函数图像的分割线相对复杂 一般是曲线<br>多变量的分界点主要是对于特征的线性组合进行分割  </p></li></ul><h2 id="第五章-神经网络"><a href="#第五章-神经网络" class="headerlink" title="第五章 神经网络"></a>第五章 神经网络</h2><ul><li><p>5.1 神经元模型  </p><p>这本书主要讲的是神经网络和机器学习两个学科领域的交叉部分<br>M-P神经元模型 神经元接收到来自n个其他神经元传递过来的输入信号 这些输入信号通过带权重的链接进行传递<br>神经元接收到的总输入值将与神经元的阈值进行比较 然后通过激活函数处理以产生神经元的输出<br>常用sigmoid函数作为激活函数 把这样的多个神经元进行链接 就得到了神经网络  </p></li><li><p>5.2 感知机与多层网络  </p><p>感知机(perceptron)由两层神经元组成 输入层接收外界输入信号后传递给输出层 输出层是M-P神经元 亦称“阈值逻辑单元”<br>感知机能容易地实现逻辑与、或、非运算 假设  </p><script type="math/tex; mode=display">y=f(\sum_iw_ix_i-\theta)</script><p>激活函数为阶跃函数 可以很容易地实现三种运算<br>例：与运算 令$w_1=w_2=1$, $\theta$=2 仅当$x_1=x_2=1$时候 y=1<br>一般情况下 给定训练数据集 权重wi以及阈值theta可以通过学习得到<br>我们也可以设定阈值$\theta$ 为一个固定的输入-1,0的“哑结点”(dummy node)所对应的连接权重$w_n+1$<br>那么就只用对权重进行学习<br>对于权重的调整 对训练样例(x,y) 若当前的感知机的输出为y’那么权重调整为  </p><script type="math/tex; mode=display">w_i\gets{w_i}+\Delta{w_i}</script><script type="math/tex; mode=display">\Delta{w_i}=\eta(y-y')x_i</script><p>其中$\eta$为学习率 是一个0-1之间的数 从调整方程可以看出 若感知机对于样本的预测是正确的 那么w不发生变化<br>反之进行权重调整<br>感知机的学习能力非常有限 因为它只拥有一层功能神经元<br>因为上述问题都是线性可分的(linearly separable) 所以存在一个线性超平面能将它们分开 这样感知机的学习过程一定会收敛(converge) 以求得适当的权向量w<br>反之 若问题不是线性可分的 感知器的权重将无法收敛 发生震荡 这时就需要多层神经元来解决问题<br>若引入两层的感知机 则可以解决亦或问题<br>输出层与输入层之间的一层神经元被称为隐层或隐含层(hidden layer) 隐含层和输出层神经元都是拥有激活函数的功能神经元<br>对于“多层前馈神经网络”来说 每层神经元与下一层神经元全互连 神经元之间不存在同层连接 也不存在跨层连接<br>输入层：仅接收输入，不进行函数处理<br>隐层和输出层包含功能神经元 单隐层指只含有一层隐层的网络 单隐层网络也被称为两层网络<br>神经网络的学习过程 就是根据训练数据来调整神经元之间的“连接权”(connection weight)以及每个功能神经元的阈值  </p></li><li><p>5.3 误差逆传播算法(反向传播算法)  </p><p>误差逆传播(BackPropagation, 简称BP)算法就是其中的代表 BP算法不仅可用于多层前馈神经网络 还可以用于其他神经网络<br>BP算法是什么样的<br>给定训练集  </p><script type="math/tex; mode=display">D={(x_1,y_1),(x_2,y_2),...,(x_m,y_m)}, x_i\in{R^d},y_i\in{R^d}</script><p>即输入示例有d个属性描述 输出l维实质向量(如图所示)<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210313002507.png" alt=""><br>假设隐层和输出层神经元都是用sigmoid函数<br>对于训练例$(x_k,y_k)$ 假定神经网络的输出为$y’_k=(y’_{1k},y’_{2k},…,y’_{lk})$ 即  </p><script type="math/tex; mode=display">y'_{jk}=f(\beta_j-\theta_j)</script><p>则网络在$(x_k,y_k)$上的均方误差为  </p><script type="math/tex; mode=display">E_k=\frac{1}{2}\sum_{j=1}^l(y'_{jk}-y_{jk})^2</script><p>图中的网络有(d+l+1)q+l个参数需确定：输入层到隐层的d<em>q个权值、隐层到输出层的q</em>l个权值、q个隐层神经元的阈值、l个输出层神经元的阈值<br>BP是一个迭代学习算法 对于参数进行更新的规则与之前类似 任意参数v的更新估计式为  </p><script type="math/tex; mode=display">v\gets{v}+\Delta{v}</script><p>推导隐层到输出层的连接权$w_{hj}$  </p></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lecture 1 电磁场</title>
    <link href="/2021/05/10/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%A9%E7%BA%BF%E4%B8%8E%E9%80%9A%E4%BF%A1%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86/1.%20%E7%94%B5%E7%A3%81%E5%9C%BA/"/>
    <url>/2021/05/10/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%A9%E7%BA%BF%E4%B8%8E%E9%80%9A%E4%BF%A1%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86/1.%20%E7%94%B5%E7%A3%81%E5%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="Lecture-1-电磁场"><a href="#Lecture-1-电磁场" class="headerlink" title="Lecture 1 电磁场"></a>Lecture 1 电磁场</h1><p><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/E80207522EEFEE067950951FFD5E839A.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/AF6658951704208DE281DD37FF8491AA.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/00752E0A714B34826A010DBEF98453E5.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/DEE68BF7F8500DABB1114ED34D0A715E.png" alt="">  </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>天线与通信传输原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Lecture 8 非频变天线</title>
    <link href="/2021/05/10/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%A9%E7%BA%BF%E4%B8%8E%E9%80%9A%E4%BF%A1%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86/8.%20%E9%9D%9E%E9%A2%91%E5%8F%98%E5%A4%A9%E7%BA%BF/"/>
    <url>/2021/05/10/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%A9%E7%BA%BF%E4%B8%8E%E9%80%9A%E4%BF%A1%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86/8.%20%E9%9D%9E%E9%A2%91%E5%8F%98%E5%A4%A9%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="Lecture-8-非频变天线"><a href="#Lecture-8-非频变天线" class="headerlink" title="Lecture 8 非频变天线"></a>Lecture 8 非频变天线</h1><p><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/1DA60A65D3A7E8030DE4F80370ACB4EF.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>天线与通信传输原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>04. 频谱·非周期信号的傅里叶变换</title>
    <link href="/2021/05/10/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/4.%20%E9%9D%9E%E5%91%A8%E6%9C%9F%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"/>
    <url>/2021/05/10/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/4.%20%E9%9D%9E%E5%91%A8%E6%9C%9F%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<style>img{    width: 40%;    padding-left: 20%;}</style>  <h1 id="频谱·非周期信号的傅里叶变换"><a href="#频谱·非周期信号的傅里叶变换" class="headerlink" title="频谱·非周期信号的傅里叶变换"></a>频谱·非周期信号的傅里叶变换</h1><h2 id="信号的频谱"><a href="#信号的频谱" class="headerlink" title="信号的频谱"></a>信号的频谱</h2><p>已经知道信号可以分解为一系列正弦信号或者是数字数信号的和。<br>以各分量（称为各谐波（Harmonics））对应的角频率为横坐标，以各分量的<strong>幅值</strong>或者是<strong>相位</strong>为纵坐标绘制图像，就能得到信号的<strong>频谱图像</strong>。<br>频谱分为两种，<strong>单边频谱（描述三角形式的傅里叶级数）</strong>和<strong>双边频谱（描述指数形式的傅里叶级数）</strong>。<br><strong>要绘制其单边或双边的幅值频谱和相位频谱，才能够完整地描述一个傅里叶级数。</strong><br>单边频谱和双边频谱的关系：<br>单边频谱的幅值是双边频谱的两倍：$A_{uni}=2A_{bil}=√{a_n^2+b_n^2}$。<br>两者相位相同：$ϕ_n=arctan(-\frac{b_n}{a_n})$。<br>例如下图中的三角形式傅里叶级数，可以用单边频谱表示后转换为图中的双边频谱。<br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/3B514383E2F98F37F7919A3E32FC0BCD.png" alt=""></p><h3 id="周期矩形脉冲信号的频谱"><a href="#周期矩形脉冲信号的频谱" class="headerlink" title="周期矩形脉冲信号的频谱"></a>周期矩形脉冲信号的频谱</h3><p><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210326205616.png" alt=""><br>对上图的周期脉冲信号求其傅里叶系数，得到：  </p><script type="math/tex; mode=display">F(nω)=\frac{Eτ}{T_1}Sa(nω_1\frac{τ}{2})</script><p><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210326205539.png" alt=""><br>称相邻两个分量间的距离为谐波距离，谐波距离为$ω_1$，函数与横轴的第一个交点为主瓣宽度：$\frac{2\pi}{\tau}$。<br>定义$ω_1=\frac{2π}{T_1}$,$T_1$为采样周期。 可以发现主瓣宽度不变的前提下，$T_1$越大，谐波距离越小，谐波分布越稠密。当$T_1→∞$时，整个频谱将趋于连续。<br>因此<strong>周期信号的频谱是离散的，非周期信号的频谱是连续的。</strong></p><ul><li>周期信号的功率<br>归一化（R=1$Ω$）的周期信号的平均功率可以由如下的公式表示：  <script type="math/tex; mode=display">P=\frac{1}{T}∫_0^Tf(t)dt=∑F(nω_1)^2</script></li></ul><h2 id="傅里叶变换、反变换的推导"><a href="#傅里叶变换、反变换的推导" class="headerlink" title="傅里叶变换、反变换的推导"></a>傅里叶变换、反变换的推导</h2><p>对指数形式的傅里叶系数参数：  </p><script type="math/tex; mode=display">F(nω_1)=\frac{1}{T}∫_0^Tf(t)e^{-jnω_1t}dt</script><p>两边同时乘上周期：  </p><script type="math/tex; mode=display">TF(nω_1)=∫_0^Tf(t)e^{-jnω_1t}dt</script><p>当$T→∞$时，左边$TF(nω_1)$是一个有界函数，此时频谱连续$nω_1→ω$，定义频谱密度$F(ω)$：  </p><script type="math/tex; mode=display">\begin{aligned}F(ω) &=lim_{T→∞}TF(nω_1)\\&=lim_{T→∞}∫_0^Tf(t)e^{-jnω_1t}dt\\&=∫f(t)e^{-jnω_1t}dt    \end{aligned}</script><p>定义傅里叶变换算子$F[⋅]$:  </p><script type="math/tex; mode=display">F[⋅]=∫⋅e^{-jω_1t}dt</script><p>可得傅里叶变换：  </p><script type="math/tex; mode=display">F[f(t)]=∫f(t)e^{-jω_1t}dt</script><p>变换后的结果一定可以表示为复指数形式：  </p><script type="math/tex; mode=display">F(ω)=|F(ω)|e^{jϕ(ω)}</script><p>称$|F(ω)|$为振幅，$ϕ(ω)$为相位角。<br>对傅里叶变换的指数形式变形：  </p><script type="math/tex; mode=display">\begin{aligned}f(t)& =∑F(ω_1)e^{jω_1t}\\&=∑\frac{F(ω_1)}{ω_1}ω_1e^{jω_1t}    \end{aligned}</script><p>当$T→∞$时，可证明$\lim_{T→∞}\frac{F(nω_1)}{ω_1}=\frac{F(ω)}{2π}$，有：  </p><script type="math/tex; mode=display">f(t)=\frac{1}{2π}∫F(ω)e^{jωt}dω</script><p>将如上式子定义为傅里叶反变换。<br>因此：<br>傅里叶变换：$F[f(t)]=∫f(t)e^{-jnω_1t}dt$<br>傅里叶反变换：$f(t)=\frac{1}{2π}∫F(ω)e^{jωt}dω$<br>此外应用奇偶分解和欧拉公式可以将傅里叶变换分解为：  </p><script type="math/tex; mode=display">F(ω)=2∫f_e(t)cosωtdt-2j∫f_0(t)sinωtdt</script><h2 id="傅里叶变换的性质"><a href="#傅里叶变换的性质" class="headerlink" title="傅里叶变换的性质"></a>傅里叶变换的性质</h2><ol><li>$f(-t)→F(-ω)$</li><li>$f(-t)→F^*(ω)$</li><li>线性</li><li>对偶性： $F(t)→2πf(-ω)$</li><li>变换操作：  <ul><li>尺度变换：$f(at)→\frac{1}{|a|}F(\frac{ω}{a})$</li><li>时移： $f(t-t_0)→F(ω)e^{-jωt_0}$</li><li>综合：$f(at+b)=f(a(t+b/a))→\frac{1}{|a|}F(\frac{ω}{a})e^{-jω\frac{b}{a}}$  </li><li>频移：$F(ω+ω_0)→f(t)e^{-jω_0t}$  </li></ul></li><li>导数：  <ul><li>时域倒数：$f’(t)→jωF(ω)$  </li><li>频域导数：$F’(ω)→-jtf(t)$</li></ul></li><li>积分：<ul><li>时域积分：$∫f(t)dt=πF(0)δ(ω)+\frac{F(ω)}{jω}$  </li></ul></li></ol><p>总结：<br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210326215249.png" alt="">   </p><h2 id="常见非周期信号的傅里叶变换"><a href="#常见非周期信号的傅里叶变换" class="headerlink" title="常见非周期信号的傅里叶变换"></a>常见非周期信号的傅里叶变换</h2><h3 id="方波-门函数"><a href="#方波-门函数" class="headerlink" title="方波/门函数"></a>方波/门函数</h3><script type="math/tex; mode=display">f(t)=E, -\frac{τ}{2}<t<\frac{τ}{2}</script><script type="math/tex; mode=display">G(t)=f(t)=u(t+\frac{τ}{2})-u(t-\frac{τ}{2})</script><p>由于$f(t)$只在振幅处有值，因此：  </p><script type="math/tex; mode=display">\begin{aligned}   F(ω)=& ∫_{-\frac{τ}{2}}^{\frac{τ}{2}}Ee^{-jωt}dt \\   & =EτSan(\frac{ωτ}{2})\end{aligned}</script><h3 id="直流信号"><a href="#直流信号" class="headerlink" title="直流信号"></a>直流信号</h3><script type="math/tex; mode=display">f(t)=E</script><p>由于直流信号不满足狄利克雷条件中的绝对可积，因此需要考虑其他方法对其做变换。<br>当门函数的$τ→∞$时，可以将门函数视作一个直流信号函数。  </p><script type="math/tex; mode=display">\begin{aligned}  F(ω) &=\lim_{τ→∞}∫^τ_{-τ}Ee^{-jωt}dt \\    &= E\lim_{τ→∞}\frac{2sin(ωτ)}{ω} \\  &=2πEδ(ω)\end{aligned}</script><p>当$E=1$时，可以推导出</p><script type="math/tex; mode=display">F(ω)=2πδ(ω)</script><h3 id="单位冲激函数"><a href="#单位冲激函数" class="headerlink" title="单位冲激函数"></a>单位冲激函数</h3><script type="math/tex; mode=display">F(ω)=∫δ(t)e^{-jωt}dt=1</script><h3 id="单位冲击偶函数"><a href="#单位冲击偶函数" class="headerlink" title="单位冲击偶函数"></a>单位冲击偶函数</h3><script type="math/tex; mode=display">F(ω)=∫δ'(t)e^{-jωt}dt=jω</script><h3 id="单侧指数函数"><a href="#单侧指数函数" class="headerlink" title="单侧指数函数"></a>单侧指数函数</h3><script type="math/tex; mode=display">f(t)=Ee^{-αt}u(t)</script><script type="math/tex; mode=display">\begin{aligned}   F(ω)=& ∫Ee^{-αt}u(t)dt \\   & =∫_0^∞Ee^{-αt}dt \\   & =\frac{E}{α+jω}\end{aligned}</script><p>对其做复指数变换，就能得到其振幅和相位角：  </p><script type="math/tex; mode=display">\begin{aligned}F(ω) &=\frac{E(α-jω)}{α^2+ω^2}\\   &= \frac{E}{√(a^2+ω^2)}e^{-jarctan\frac{ω}{α}}\end{aligned}</script><h3 id="符号函数"><a href="#符号函数" class="headerlink" title="符号函数"></a>符号函数</h3><script type="math/tex; mode=display">sgn(t)=\begin{cases}   1,t>0\\     -1,t<0\end{cases}</script><p>由于不满足狄利克雷条件中的绝对可积（在t=0处不可积），因此需要对函数做变换，使其可积。<br>设$f_1(t)=sgn(t)e^{-α|t|}$</p><script type="math/tex; mode=display">\begin{aligned}   F(ω)&=\lim_{α→0}[∫_{-∞}^{0}-e^{αt-jωt}dt+∫_0^{∞}e^{-αt-jωt}dt]\\     &=-\lim_{α→0}\frac{2jω}{α^2+ω^2}\\     &=\frac{2}{jω}\end{aligned}</script><p>复指数形式：  </p><script type="math/tex; mode=display">F(ω)=\frac{2}{|ω|}e^{⨦\frac{π}{2}j}</script><h3 id="单位阶梯函数"><a href="#单位阶梯函数" class="headerlink" title="单位阶梯函数"></a>单位阶梯函数</h3><p>由$u(t)=\frac{1}{2}(1+sgn(t))$：  </p><script type="math/tex; mode=display">\begin{aligned}   F(ω)&=∫\frac{1}{2}(1+sgn(t))e^{-jωt}dt\\     &=\frac{1}{2}[∫e^{-jωt}dt+∫sgn(t)e^{-jωt}dt\\     &=πδ(ω)+\frac{1}{jω}\end{aligned}</script>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>信号与系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01. 信号概述</title>
    <link href="/2021/05/06/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/1.%20%E4%BF%A1%E5%8F%B7%E6%A6%82%E8%BF%B0/"/>
    <url>/2021/05/06/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/1.%20%E4%BF%A1%E5%8F%B7%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="信号概述"><a href="#信号概述" class="headerlink" title="信号概述"></a>信号概述</h1><h2 id="按照时间特性的信号分类"><a href="#按照时间特性的信号分类" class="headerlink" title="按照时间特性的信号分类"></a>按照时间特性的信号分类</h2><h3 id="确定信号和随机信号"><a href="#确定信号和随机信号" class="headerlink" title="确定信号和随机信号"></a>确定信号和随机信号</h3><ol><li>确定信号<br>除了间断点外，对于一个确定的时间$t$,都能有一个确定的值$f(t)$与之对应。  </li><li>随机信号<br>又分为稳定的和不稳定的随机信号。  </li><li>伪随机信号  </li></ol><h3 id="连续时间信号和离散时间信号"><a href="#连续时间信号和离散时间信号" class="headerlink" title="连续时间信号和离散时间信号"></a>连续时间信号和离散时间信号</h3><ol><li><p>连续时间信号<br>除了间断点外，在任何时间$t$都能找到一个与之对应的值$f(t)$。<br>连续时间信号的值域可以是连续的，也可以是不连续的。<br>例如模拟信号：<strong>x轴连续，y轴也连续（可以取到任意值）</strong>。  </p></li><li><p>离散时间信号<br>只有在离散的点$n$上存在对应的值$x(n)$。<br>离散时间信号的定义域是离散的，对值域不做定义。<br>数字信号是一种<strong>x轴离散，y轴离散的信号</strong>。<br>均匀的离散信号通常称为序列。  </p></li></ol><p>模拟信号和数字信号的转换：<br>模拟信号经过取样使得x轴离散后，在通过量化使得y轴也离散，进而得到数字信号。  </p><h3 id="周期信号和非周期信号"><a href="#周期信号和非周期信号" class="headerlink" title="周期信号和非周期信号"></a>周期信号和非周期信号</h3><p>周期信号是在实数域每隔一定时间T/或者整数N，按规律重复变化的信号。  </p><script type="math/tex; mode=display">f(t)=f(t+mT),m ∈Z</script><script type="math/tex; mode=display">x(n)=x(n+mN),m ∈Z</script><h3 id="常见的时间连续信号"><a href="#常见的时间连续信号" class="headerlink" title="常见的时间连续信号"></a>常见的时间连续信号</h3><ul><li>指数信号  </li><li>正弦信号<br>衰减的正弦信号：<script type="math/tex; mode=display">f(t)=ke^{-at}sinωt \text{ t>=0}</script></li><li>复指数信号  </li><li>采样信号  <script type="math/tex; mode=display">sinc(x)=\frac{sinx}{x}</script></li><li>奇异信号  <ul><li>单位阶跃信号  <script type="math/tex; mode=display">u(t)=\begin{cases}    0 ~t<0\\    1 ~t>0\\    \end{cases}</script>注意: 当$t=0$时，定义$u(0)=0.5$（《信号与线性系统分析》）。<br>变化：<br>左移的阶梯信号： $u(t+t_0)=\begin{cases}<br>  0 ~t<0\\  1 ~t>0\\<br>\end{cases}$<br>右移的阶梯信号：$u(t-t_0)=\begin{cases}<br>  0 ~t<0\\  1 ~t>0\\<br>\end{cases}$<br>门信号：$g(t)=u(t+\frac{\tau}{2})-u(t-\frac{\tau}{2})$<br>符号函数： $sig(t)=2u(t)-1$  </li><li>单位冲激函数和冲击偶函数<br>推导：<br>面积为1，宽为$τ$，高为$\frac{1}{τ}$的门函数，其对称轴是$x=0$。<br>令$τ→0$,得到宽为$0$，高为$∞$的<strong>单位冲激函数</strong>$δ(t)$，即：  <script type="math/tex; mode=display">δ(t)=lim_{τ→0}\frac{1}{τ}[u(t+\frac{τ}{2})-u(t-\frac{τ}{2})]</script>有：  <script type="math/tex; mode=display">u'(t)=δ(t)</script>任意的信号都可以被分解为有权的单位冲激信号。<br>冲激函数的表示：<br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210319194902.png" alt=""><br>如上图，其中$(n)$表示强度为$n$的冲激函数，即$nδ(t)$。<br>性质：  <ol><li>赋值性  <script type="math/tex; mode=display">∫δ(t)f(t)dt=f(0)</script></li><li>偶函数  <script type="math/tex; mode=display">δ(t)=δ(-t)</script></li><li>缩放<script type="math/tex; mode=display">δ(at)=\frac{1}{|a|}δ(t)</script>证明思路都是利用函数相等=积分相等，分情况讨论得到。<br>对单位冲激函数求导，得到<strong>冲击偶</strong>函数，即$δ’(t)$。<br>性质：  </li><li>赋值性  <script type="math/tex; mode=display">∫δ'(t)f(t)dt=-f'(0)</script><script type="math/tex; mode=display">f(t)δ'(t)=f(0)δ'(t)-f'(0)δ(t)</script></li><li>奇函数  <script type="math/tex; mode=display">δ'(t)=-δ'(t)</script></li></ol></li></ul></li></ul><h3 id="常见的时间离散信号"><a href="#常见的时间离散信号" class="headerlink" title="常见的时间离散信号"></a>常见的时间离散信号</h3><ul><li>单位采样信号  <script type="math/tex; mode=display">δ(n)=\begin{cases}    0,n\not ={0} \\       1, n=0 \\      \end{cases}</script>任何的非连续信号都能够用单位采样信号表示。  </li><li>单位阶梯信号  <script type="math/tex; mode=display">u(n)=\begin{cases}    0,n≧{0} \\       1, n<0 \\      \end{cases}</script>$δ(n)$是$u(n)$的差分信号。  <script type="math/tex; mode=display">δ(n)=u(n)-u(n-1)</script></li><li>方波序列  </li><li>斜坡序列  </li><li>单边指数序列</li><li>正弦序列<br>正弦函数到正弦序列的转换：<br>令$t=nT_s$， 有$f(t)=sin(ω_0t)=sin(ω_0T_sn)=x(n)$<br>令$Ω_0=ω_0T_s$，得到：  <script type="math/tex; mode=display">x(n)=sin(Ωn)</script>注意：  <ol><li>$T_s$表示的是采样的间隔时间，周期$T=nT_s$。  </li><li>对于周期序列，有$x(n)=x(n+N)$。</li><li>如果$\frac{2π}{Ω}$不为有理数，那么正选序列不具有周期。  </li></ol></li></ul><h2 id="信号的基本处理"><a href="#信号的基本处理" class="headerlink" title="信号的基本处理"></a>信号的基本处理</h2><h3 id="加法和乘法"><a href="#加法和乘法" class="headerlink" title="加法和乘法"></a>加法和乘法</h3><ul><li>对于连续信号<br>函数直接相加或者是相乘。<br>注意： 两个周期连续信号相加不一定是一个周期信号  </li><li>对于离散信号<br>两个序列的对应位置相加或者是相乘。  <h3 id="积分和微分"><a href="#积分和微分" class="headerlink" title="积分和微分"></a>积分和微分</h3></li><li><p>对于连续信号<br>先做信号分解，对每一段分别积分或者微分。  </p></li><li><p>对于离散信号<br>只有累积（$z(n)=∑x(k)$）和差分（$Δx(n)=x(n+1)-x(n)$或$Δx(n)=x(n)-x(n-1)$）。</p><h3 id="平移、反转和尺度变换"><a href="#平移、反转和尺度变换" class="headerlink" title="平移、反转和尺度变换"></a>平移、反转和尺度变换</h3><p>平移遵循<strong>左加右减</strong>的原则。<br>横坐标展缩遵循<strong>a&gt;1,图像压缩，a&lt;1，图像扩展</strong>的原则。<br>由于离散信号$x(an)$当且仅当$ak$是一个整数的时候才有定义，如果对其进行展缩，通常会丢失原信号$x(n)$的部分信息，因此离散信号通常不做展缩。  </p></li><li>作图方法<br>一种方法是将信号每一段的分段函数都求出，并将$at+b$代入分段函数及其范围，得到新的函数图像。<br>已知$f(t)$,求$f(at+b)$的图像：基本思路是令$τ=at+b$，反解出$t$的方程，从图像上选择几个关键点，将图像上这些点原来$t$轴的值到$τ$中，得到新的$t$值。<br>已知$f(at+b)$,求$f(t)$的图像： 基本思路是从图像选择几个关键点，将图像上这些点原来$t$轴的值到$τ$中，得到新的$t$值。  </li></ul><h3 id="信号分解"><a href="#信号分解" class="headerlink" title="信号分解"></a>信号分解</h3><ul><li>奇偶分解<script type="math/tex; mode=display">\begin{aligned}  f(t)=f_e(t)+f_o(t) \\  f_e(t)=\frac{1}{2}[f(t)+f(-t)]\\  f_o(t)=\frac{1}{2}[f(t)-f(-t)]\end{aligned}</script></li><li>复分解  <script type="math/tex; mode=display">f(t)=f_r(t)+jf_i(t)</script></li><li>直流交流分解  <script type="math/tex; mode=display">f(t)=f_A(t)+f_D(t)</script><script type="math/tex; mode=display">f_D(t)=\frac{1}{T}∫^{t_0+T}_{t_0}f(t)dt</script></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>信号与系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Lecture 7 环形天线</title>
    <link href="/2021/05/06/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%A9%E7%BA%BF%E4%B8%8E%E9%80%9A%E4%BF%A1%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86/7.%20%E7%8E%AF%E5%BD%A2%E5%A4%A9%E7%BA%BF/"/>
    <url>/2021/05/06/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%A9%E7%BA%BF%E4%B8%8E%E9%80%9A%E4%BF%A1%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86/7.%20%E7%8E%AF%E5%BD%A2%E5%A4%A9%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="Lecture-7-环形天线"><a href="#Lecture-7-环形天线" class="headerlink" title="Lecture 7 环形天线"></a>Lecture 7 环形天线</h1><p><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/65414C29988C4753A0FC683F75D69142.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/E8CB233AB24D05F7CC0379CFFD446AC4.png" alt="">  </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>天线与通信传输原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>03. 信号的傅里叶级数</title>
    <link href="/2021/04/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/3.%20%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%82%85%E9%87%8C%E5%8F%B6%E7%BA%A7%E6%95%B0/"/>
    <url>/2021/04/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/3.%20%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%82%85%E9%87%8C%E5%8F%B6%E7%BA%A7%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="信号的傅里叶级数"><a href="#信号的傅里叶级数" class="headerlink" title="信号的傅里叶级数"></a>信号的傅里叶级数</h1><h2 id="信号变换"><a href="#信号变换" class="headerlink" title="信号变换"></a>信号变换</h2><p>分解、响应、叠加是信号与系统中最基础的信号处理方式。对信号的变换思路来源于时域内的信号$f(t)$是以时间为变量的函数方程，在时域内噪声和有用信号往往是同时发生的，难以将噪声从信号中剥离，因此需要对信号进行变换，将信号从时域变换到频域（以频率为自变量的空间，频域中的信号可以表示为$H(ω)$），通过频率的不同就能利用滤波器将噪声剥离。  </p><h2 id="正交分解"><a href="#正交分解" class="headerlink" title="正交分解"></a>正交分解</h2><h3 id="正交函数与正交函数集"><a href="#正交函数与正交函数集" class="headerlink" title="正交函数与正交函数集"></a>正交函数与正交函数集</h3><p>在信号领域，如果两个信号在$(t_1,t_2)$内有$∫_{t_1}^{t_2}f_1(t)f_2(t)dt=0$，称两个信号是正交的。<br>如果有n个函数构成的函数集：$\{ϕ_1(t),…,ϕ_n(t)\}$在$(t_1,t_2)$内有：  </p><script type="math/tex; mode=display">∫_{t_1}^{t_2}ϕ_i(t)ϕ_j(t)dt=\begin{cases}  0,i\not=j \\ K_i \not= 0, i=j\end{cases}</script><p>称这是一个正交函数集。<br>如果在这个函数集以外找不到任何的另外一个函数满足其与集内函数两两正交，称这个函数集是一个完备的正交函数集。<br><strong>三角函数集$\{1,cosnΩt,sinnΩt\}$就是一个完备的正交函数集。</strong></p><h3 id="信号的正交分解"><a href="#信号的正交分解" class="headerlink" title="信号的正交分解"></a>信号的正交分解</h3><p>正交分解是最简单的一种信号分解方式，任何一个函数$f_1(t)$都可以用$n$个两两正交的函数的线性组合来近似。 有：  </p><script type="math/tex; mode=display">f_1(t)=∑C_iϕ_i(t)+f_e(t)</script><p>这样的分解方式称为信号的<strong>正交分解</strong>，即将目标信号$f_1(t)$分解为若干个正交信号的线性组合和误差信号$f_e(t)$，简化表示方法：    </p><script type="math/tex; mode=display">f_2(t)=∑C_iϕ_i(t)</script><p>此时的$f_2(t)$不在具有限定性，是一个任意的函数。进一步得到任何一个信号$f_1(t)$都可以用一个加权的信号$f_2(t)$与误差信号$f_e(t)$表示：  </p><script type="math/tex; mode=display">f_1(t)=C_{12}f_2(t)+f_e(t)</script><p>$C_{12}$是$f_2(t)$的权重，称为相关系数。$f_e(t)$是拟合误差。<br>判断拟合是否准确的标准是拟合误差的均方值，当拟合误差的均方值最小时，信号拟合度最高，均方值表示为：  </p><script type="math/tex; mode=display">\overline{ɛ^2}=\overline{f^2_e(t)}=\frac{1}{t_2-t_1}∫_{t_1}^{t_2}f_e^2(t)dt</script><p>对其求导令方程等于0，可以解出：  </p><script type="math/tex; mode=display">∫_{t_1}^{t_2}\frac{d}{dC_{12}}[f_1^2(t)-2C_{12}f_2(t)f_1(t)+f_2^2(t)C_{12}^2]dt=0</script><p>要使方程为0，必须每一项都为0，最终解得：  </p><script type="math/tex; mode=display">C_{12}=\frac{∫_{t_1}^{t_2}f_1(t)f_2(t)dt}{∫_{t_1}^{t_2}f_2^2(t)dt}</script><p>但是正交分解依赖于$f_2(t)$的选取，如果于$f_2(t)$选取的不恰当，拟合度往往不高，在分解时容易丢失$f_1(t)$中有用的信息，因此需要其他更加准确的方法对信号进行分解。通过数学方法可知，当$f_2(t)$是一个完备正交集的线性组合时，此时的拟合效果是最好的。  </p><h2 id="信号的傅里叶级数-1"><a href="#信号的傅里叶级数-1" class="headerlink" title="信号的傅里叶级数"></a>信号的傅里叶级数</h2><p>周期信号$f(t)$在一个周期内可以展开为在完正交信号空间中的无穷级数。而三角函数集正好就是一个完备正交集，因此将信号分解为三角函数集是一种理想的正交分解方法。  高等数学中，任何满足有界可积，有有限个间断点（狄利赫里条件）的函数都可以被描述为傅里叶级数：  </p><script type="math/tex; mode=display">f(t)=a_0+∑_{n=1}^{∞}[a_ncos(nω_1t)+b_nsin(nω_1t)]</script><p>在信号中，$a_0$称为直流分量，是函数在周期内的均值。  </p><script type="math/tex; mode=display">a_0=\frac{1}{T}∫_{t_0}^{t_0+T}f(t)dt</script><blockquote><p>有时定义傅里叶级数的第一项为$\frac{a_0}{2}$，此时$a_0=\frac{2}{T}∫_{t_0}^{t_0+T}f(t)dt$。  </p></blockquote><p>$a_n$称为基波分量，是一个偶函数:  </p><script type="math/tex; mode=display">a_n=\frac{2}{T}∫_{t_0}^{t_0+T}f(t)cos(nω_1t)dt</script><p>$b_n$称为谐波分量，是一个奇函数:  </p><script type="math/tex; mode=display">b_n=\frac{2}{T}∫_{t_0}^{t_0+T}f(t)sin(nω_1t)dt</script><h4 id="傅里叶级数的三角变形"><a href="#傅里叶级数的三角变形" class="headerlink" title="傅里叶级数的三角变形"></a><strong>傅里叶级数的三角变形</strong></h4><ul><li>余弦函数形式<script type="math/tex; mode=display">f(t)=c_0+∑_{n=1}^∞c_ncos(nω_1t+ϕ_n)</script>其中$c_0=a_0$,$c_n=√{a_n^2+b_n^2}$，$ϕ_n=arctan(-\frac{b_n}{a_n})$。  </li></ul><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a><strong>参数</strong></h4><ul><li>幅值<script type="math/tex; mode=display">|F(nω_1)|=√{a_n^2+b_n^2}</script></li><li>相位  <script type="math/tex; mode=display">ϕ_n=acrtan(-\frac{b_n}{a_n})</script></li></ul><h3 id="傅里叶级数的指数形式"><a href="#傅里叶级数的指数形式" class="headerlink" title="傅里叶级数的指数形式"></a>傅里叶级数的指数形式</h3><p>周期函数能够被分解为指数信号的线性组合，因此： </p><script type="math/tex; mode=display">f(t)=∑F(nω_1)e^{jnω_1t}</script><p>其中：   </p><script type="math/tex; mode=display">F(nω_1)=\frac{1}{T}∫_0^Tf(t)e^{-jnω_1t}dt</script><p>代入欧拉公式：  </p><script type="math/tex; mode=display">F(nω_1)=\frac{1}{T}∫_0^Tf(t)cos(nω_1t)-jf(t)sin(nω_1t)dt</script><p>可以得到</p><script type="math/tex; mode=display">F(nω_1)=\frac{1}{2}(a_n-jb_n)</script><script type="math/tex; mode=display">a_n=F_n+F_{-n}</script><script type="math/tex; mode=display">b_n=j(F_n-F_{-n})</script><p>需要注意的是负的频率/角频率$-ω_1$实际并不存在，只用作数学分析。  </p><h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a><strong>参数</strong></h4><ul><li>幅值<script type="math/tex; mode=display">|F(nω_1)|=\frac{1}{2}√{a_n^2+b_n^2}</script><strong>指数形式的幅值是三角形式幅值的$\frac{1}{2}$。</strong><br>指数形式的傅里叶级数的幅值函数是一个<strong>偶函数</strong>。  </li><li>相位<script type="math/tex; mode=display">ϕ_n=acrtan(-\frac{b_n}{a_n})</script>指数形式的傅里叶级数的相位函数是一个<strong>奇函数</strong>。</li></ul><h3 id="奇偶周期函数的傅里叶级数"><a href="#奇偶周期函数的傅里叶级数" class="headerlink" title="奇偶周期函数的傅里叶级数"></a>奇偶周期函数的傅里叶级数</h3><p>只需要将奇偶性带入$a_n$,$b_n$即可。<br>对于奇谐/偶谐函数则需要分n的奇偶性进行讨论。  </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>信号与系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Lecture 6 天线阵列</title>
    <link href="/2021/04/29/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%A9%E7%BA%BF%E4%B8%8E%E9%80%9A%E4%BF%A1%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86/6.%20%E5%A4%A9%E7%BA%BF%E9%98%B5%E5%88%97/"/>
    <url>/2021/04/29/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%A9%E7%BA%BF%E4%B8%8E%E9%80%9A%E4%BF%A1%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86/6.%20%E5%A4%A9%E7%BA%BF%E9%98%B5%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="Lecture-6-天线阵列"><a href="#Lecture-6-天线阵列" class="headerlink" title="Lecture 6 天线阵列"></a>Lecture 6 天线阵列</h1><p><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/03105432535A8ACBACA84893DEFA60AA.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/9C59D44507AC8C313C28C27B5A1F4589.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>天线与通信传输原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>8.3. 核函数</title>
    <link href="/2021/04/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/8.%20%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/8.3.%20%E6%A0%B8%E5%87%BD%E6%95%B0/"/>
    <url>/2021/04/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/8.%20%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/8.3.%20%E6%A0%B8%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h1><h2 id="非线性分类的SVM"><a href="#非线性分类的SVM" class="headerlink" title="非线性分类的SVM"></a>非线性分类的SVM</h2><p>本节将使用核函数对支持向量机进行改造，使其成为复杂的非线性分类器。<br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210427144124.png" alt=""><br>比如对于如上图所示的分类，决策边界是非线性的。 此时一种对其拟合的方法是用多项式对其进行拟合。<br>比如： 当$θ_0+θ_1x_1+θ_2x_2+θ_3x_1x_2+θ_4x_1^2+θ_5x_2^2+..≥0$时,预测$y=1$。<br>就能够得到一个假设函数：  </p><script type="math/tex; mode=display">h_θ(x)=\begin{cases} 1  \text{if} θ_0+θ_1x_1+..≥0 \\0  \text{otherwise} \\\end{cases}</script><p>这种方法的问题是假设中的某些高阶项可能是冗余的，并且对于计算机视觉而言，用高阶多项式处理矩阵的计算量非常的大。<br>改进方法是用一些新的特征$F=\{f_i\}$来替换原特征$X=\{x_i\}$。<br>具体而言，比如现在只选取三个特征$x_0$（截距项，如下推导中将被忽略）,$x_1$,$x_2$,在这三个维度上手动选取三个点（称为标记（Landmarks））：$l^{(1)}$,$l^{(2)}$,$l^{(3)}$。<br>将新特征i $f_i$表示为训练样本$x$与$l^{(i)}$的相似度，相似度度量可以用如下公式表示：  </p><script type="math/tex; mode=display">Similarity(x,l^{(i)})=e^{-\frac{||x-l^{(i)}||^2}{2σ^2}}</script><blockquote><p>欧氏距离：空间中两点的连线距离，表示为$d=√{∑x_i^2}$。<br>$||x-l^{(i)}||$表示空间中$x$与$l^{(i)}$的（欧式）距离。  </p></blockquote><p>这个相似度函数称为<strong>高斯核函数</strong>（Gaussian Kernel Function）。  </p><script type="math/tex; mode=display">k(x,l^{(i)})=e^{-\frac{||x-l^{(i)}||^2}{2σ^2}}</script><p>此外还有其他用于度量相似度的函数，这些函数统称为<strong>核函数</strong>（Kernel Function）。  </p><h2 id="核函数的意义"><a href="#核函数的意义" class="headerlink" title="核函数的意义"></a>核函数的意义</h2><p>将高斯核函数利用欧氏距离公式展开：  </p><script type="math/tex; mode=display">\begin{aligned}    k(x,l^{(i)})&=e^{-\frac{||x-l^{(i)}||^2}{2σ^2}}\\      &=e^{-\frac{∑_{j=1}^n(x_j-l^{(i)}_j)^2}{2σ^2}}\end{aligned}</script><p>对于某个特定的$i$:<br>如果$x≈l^{(i)}$（两者的欧氏距离非常近）,$f_i≈e^{-\frac{0}{2σ}}≈1$。<br>如果$x$和$l^{(i)}$的欧氏距离非常远,$f_i≈e^{-\frac{∞}{2σ}}≈0$。<br>对于任何一个样本$x$,都可以计算$f_1$,$f_2$,$f_3$三个特征。<br>在图像上反映相似度与两者距离之间的关系即为高维空间中的高斯分布，且σ越大，图像梯度越小。<br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210427165149.png" alt=""><br>△当$l^{(1)}=[3,5]^T$时x的坐标$[x_1,x_2]^T$与相似度的关系。  </p><h2 id="决策边界"><a href="#决策边界" class="headerlink" title="决策边界"></a>决策边界</h2><p>再回到之前样本在特征上的分布：<br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210427165915.png" alt=""><br>如果样本距离某个$l^{(i)}$非常近（洋红色），那么边界函数输出的结果大于0，预测$y=1$。<br>如果样本距离三个$l^{(i)}$非常远（蓝色），那么边界函数输出的结果小于0，预测$y=0$。<br>当样本足够多的时候，所有$y=1$的点的边界即为决策边界，此时的决策边界是非线性的。<br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210427190114.png" alt="">  </p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>08. 支持向量机</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>8.2. 数学原理</title>
    <link href="/2021/04/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/8.%20%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/8.2.%20%E6%95%B0%E5%AD%A6%E5%8E%9F%E7%90%86/"/>
    <url>/2021/04/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/8.%20%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/8.2.%20%E6%95%B0%E5%AD%A6%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p><style><br>img{<br>    width: 50%;<br>    padding-left: 20%;<br>}</style></p><h1 id="数学原理"><a href="#数学原理" class="headerlink" title="数学原理"></a>数学原理</h1><h2 id="回顾：向量的点乘"><a href="#回顾：向量的点乘" class="headerlink" title="回顾：向量的点乘"></a>回顾：向量的点乘</h2><p>对于向量$u=[\begin{smallmatrix}<br>    u_1 \\<br>    u_2<br>\end{smallmatrix}]$,$v=[\begin{smallmatrix}<br>    v_1 \\<br>    v_2<br>\end{smallmatrix}]$,定义向量的点乘为：$u^Tv=||v||cosθ||u||$。<br>其中$||u||$称为$u$的模长：$||u||=√{u_1^2+u_2^2}$；定义$||v||cosθ=p$，它是v在u上的投影。  </p><h2 id="优化函数的几何意义"><a href="#优化函数的几何意义" class="headerlink" title="优化函数的几何意义"></a>优化函数的几何意义</h2><p>对于svm的目标优化函数： 即存在$min_θ\frac{1}{2}∑θ^2$,使得满足如果$y^{(i)}=1,θ^Tx^{(i)}≥1$，$y^{(i)}=0,θ^Tx^{(i)}≤-1$。<br>现在为了简化运算，假定$θ_0=0$，有且仅有两个参数，此时$\frac{1}{2}∑θ^2=\frac{1}{2}(√{θ_1^2+θ_2^2})^2$。<br>$√{θ_1^2+θ_2^2}$可以看做是向量$Θ$的模长，因此目标优化函数可以看做是0.5倍参数向量$Θ$长度的平方：  </p><script type="math/tex; mode=display">\frac{1}{2}∑θ^2=\frac{1}{2}||Θ||^2</script><p>现在来分析$,θ^Tx^{(i)}$的几何意义，按照向量的点乘法则，可以看做是向量$x^{(i)}$在$Θ$上的投影$p^{(i)}$与$||Θ||$相乘。<br>现在优化函数就可以表示成:<br>存在$min_θ\frac{1}{2}||Θ||^2$，使得：<br>如果$y^{(i)}=1,p^{(i)}||Θ||≥1$，<br>如果$y^{(i)}=0,p^{(i)}||Θ||≤-1$  </p><p>现在来考虑svm对线性可分样本的分类：<br>如果决策边界与样本边界的间距很小，由于参数向量与决策边界是始终正交的，那么每一个样本到参数向量的投影$p^{(i)}$都很小，想要使得$p^{(i)}||Θ||≥1$或者$p^{(i)}||Θ||≤-1$就需要$||Θ||$非常的大。（下图左）<br>反之如果决策边界与样本边界的间距很大，那么$||Θ||$就可以小一些。(下图右)<br>因此决策向量机总是使得决策边界具有大间距的特性。<br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210330151800.png" alt="">  </p><blockquote><p>由于决策边界的上方有${x^{(i)}}^T||Θ||&gt;0$，下方有${x^{(i)}}^TΘ&lt;0$,因此直线上必定有${x^{(i)}}^T||Θ||=0$。<br>因此<strong>参数向量与决策边界是始终正交的</strong>。 </p></blockquote>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>08. 支持向量机</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>8.1. 激活函数、代价函数和决策边界</title>
    <link href="/2021/04/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/8.%20%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/8.1.%20%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E3%80%81%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B0%E5%92%8C%E5%86%B3%E7%AD%96%E8%BE%B9%E7%95%8C/"/>
    <url>/2021/04/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/8.%20%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/8.1.%20%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E3%80%81%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B0%E5%92%8C%E5%86%B3%E7%AD%96%E8%BE%B9%E7%95%8C/</url>
    
    <content type="html"><![CDATA[<p><style><br>img{<br>    width: 50%;<br>    padding-left: 20%;<br>}</style></p><h1 id="激活函数、代价函数和决策边界"><a href="#激活函数、代价函数和决策边界" class="headerlink" title="激活函数、代价函数和决策边界"></a>激活函数、代价函数和决策边界</h1><h2 id="逻辑回归的代价函数的线性拟合"><a href="#逻辑回归的代价函数的线性拟合" class="headerlink" title="逻辑回归的代价函数的线性拟合"></a>逻辑回归的代价函数的线性拟合</h2><p>逻辑回归的激活函数：$h(x)=\frac{1}{1+e^{-θ^Tx}}$。<br>对于单个样本$(x,y)$，逻辑回归的代价函数是：$-ylog(h_θ (x))−((1−y)log⁡(1−h_θ (x)))$，将$y=1$与$y=0$时的代价函数作出，并用线性进行拟合得到$Cost_1(z)$与$Cost_0(z)$（$z=θ^Tx$）两个线性的代价函数，两者的函数图像大致如此。<br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210328160423.png" alt=""><br>支持向量机是线性化的逻辑回归。  </p><h2 id="支持向量机的代价函数"><a href="#支持向量机的代价函数" class="headerlink" title="支持向量机的代价函数"></a>支持向量机的代价函数</h2><p>逻辑回归的代价函数：  </p><script type="math/tex; mode=display">J(θ)=min\frac{1}{m}[∑_{i=1}^m y^{(i)} -log⁡(h_θ(x^{(i)} ))+(1−y^{(i)}) -log(1−h_θ (x^{(i)}))]+\frac{λ}{2m}∑θ^2</script><p>将$-log$项替换为如上图所示的两个线性函数：$Cost_1(z)$和$Cost_0(z)$，并去除$\frac{1}{m}$项（并不会改变最终结果）<br>得到支持向量机的代价函数：  </p><script type="math/tex; mode=display">J(θ)=min[∑_{i=1}^m y^{(i)} Cost_1(z))+(1−y^{(i)})Cost_0(z))]</script><p>在支持向量机中，通常通过给前项附加权重$C$而非给正则化项附加权重$λ$的方法来防止过拟合，得到正则化的支持向量机的代价函数：  </p><script type="math/tex; mode=display">J(θ)=minC[∑_{i=1}^m y^{(i)} Cost_1(z))+(1−y^{(i)})Cost_0(z))]+\frac{1}{2}∑θ^2</script><h2 id="支持向量机的激活函数"><a href="#支持向量机的激活函数" class="headerlink" title="支持向量机的激活函数"></a>支持向量机的激活函数</h2><p>与逻辑回归不同的是，逻辑回归的$h(x)$输出的是概率，而支持向量机的激活函数直接给出了预测的结果：  </p><script type="math/tex; mode=display">h_θ(x)=\begin{cases}    1, z>=0 \\      0, otherwise\end{cases}</script><h2 id="支持向量机的决策边界"><a href="#支持向量机的决策边界" class="headerlink" title="支持向量机的决策边界"></a>支持向量机的决策边界</h2><p><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210328162717.png" alt="">  </p><blockquote><p>原本只需要0作为阈值，但是为了保证SVM的精确度，因此将阈值选定为-1和1，这两个阈值间的距离称为安全间距。  </p></blockquote><p>如上图所示，如果$y=1$，需要$z&gt;=1$,反之如果$y=1$，需要$z≦-1$。<br>当SVM的代价函数前的权重值$C$非常大时：<br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210328163459.png" alt=""><br>这为SVM创造了一个相当特殊的决策边界：<br>即在样本线性可分的条件下，SVM的决策边界是一条拥有与训练样本的最小距离的直线（图中黑线）。<br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210328164253.png" alt=""><br>图中的蓝线表示了SVM决策边界与训练样本的间距。<br>因此支持向量机又被称为大间距分类器。<br>但是当正则化系数$C$被设置的非常大时，支持向量机的决策边界对异常数据非常的敏感，如下图的例子中所示。<br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210328164523.png" alt="">   </p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>08. 支持向量机</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>大学物理下-常考知识点</title>
    <link href="/2021/04/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86(%E4%B8%8B)/"/>
    <url>/2021/04/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86(%E4%B8%8B)/</url>
    
    <content type="html"><![CDATA[<h1 id="大学物理下"><a href="#大学物理下" class="headerlink" title="大学物理下"></a>大学物理下</h1><blockquote><p>整理重邮常考的知识点  </p><p>参考书目为《物理学 （上）》 东南大学 第六版  </p></blockquote><h2 id="导体和介质"><a href="#导体和介质" class="headerlink" title="导体和介质"></a>导体和介质</h2><h3 id="导体的性质"><a href="#导体的性质" class="headerlink" title="导体的性质"></a>导体的性质</h3><ol><li>自由电荷分布在导体表面  </li><li>静电平衡时，导体内部电场为0  </li><li>导体表面与叠加电场垂直  </li><li>越尖锐的表面，电荷积聚越多  </li></ol><h3 id="电位移矢量"><a href="#电位移矢量" class="headerlink" title="电位移矢量"></a>电位移矢量</h3><script type="math/tex; mode=display">\vec{D}=ɛ_0ɛ_r\vec{E}</script><h3 id="静电屏蔽"><a href="#静电屏蔽" class="headerlink" title="静电屏蔽"></a>静电屏蔽</h3><ol><li>将物体放入导体壳（法拉第笼）内部，导体壳内部的物体不会受到外电场的影响  </li><li>将法拉第笼接地，里面放入电荷，导体壳内部的电荷不会对外界有影响</li></ol><h3 id="极化电场"><a href="#极化电场" class="headerlink" title="极化电场"></a>极化电场</h3><p>  真空中的电场$E_0$进入介质后，电场大小变为$E=ɛ_rE_0$,定义电位移矢量$D=ɛ_0ɛ_rE_0$。极化强度：$\vec{P}=\frac{∑\vec{p}}{Δv}$,它在数值上与电荷面密度$σ$相同。<br>  电极化率：  </p><script type="math/tex; mode=display">\chi_E=ɛ_r-1=\frac{P}{ɛ_0E}</script><blockquote><p>$ɛ_r&lt;1$</p></blockquote><h3 id="电容器"><a href="#电容器" class="headerlink" title="电容器"></a>电容器</h3><p>  电容器的最大能量：</p><script type="math/tex; mode=display">W=\frac{1}{2}CU^2</script><p>  电场的能量密度：</p><script type="math/tex; mode=display">w_E=\frac{1}{2}ɛE^2</script><h2 id="恒定磁场"><a href="#恒定磁场" class="headerlink" title="恒定磁场"></a>恒定磁场</h2><ul><li>电场与磁场的对偶性  </li></ul><div class="table-container"><table><thead><tr><th>\</th><th>磁场</th><th>电场</th></tr></thead><tbody><tr><td>高斯定理</td><td>$∫\vec{B}.d\vec{S}=0$</td><td>$∫\vec{B}.d\vec{S}=\frac{∑q_{in}}{ɛ_0}$</td></tr><tr><td>安培定理</td><td>$∫\vec{B}.d\vec{l}=μ_0I$</td><td>$∫\vec{E}.d\vec{S}=0$</td></tr><tr><td>结论</td><td>无源有旋</td><td>有源无旋</td></tr></tbody></table></div><h3 id="左-右手定则"><a href="#左-右手定则" class="headerlink" title="左/右手定则"></a>左/右手定则</h3><div class="table-container"><table><thead><tr><th style="text-align:center">右手定则</th><th style="text-align:center">左手定则</th></tr></thead><tbody><tr><td style="text-align:center">判断电流产生的磁场</td><td style="text-align:center">判断导体受到的安培力</td></tr><tr><td style="text-align:center">判断感应电流的方向</td><td style="text-align:center">/</td></tr></tbody></table></div><h3 id="洛伦兹力的应用"><a href="#洛伦兹力的应用" class="headerlink" title="洛伦兹力的应用"></a>洛伦兹力的应用</h3><p>  洛伦兹力提供向心力，不做功  </p><script type="math/tex; mode=display">F_l=qBv=m\frac{v^2}{R}=F_向</script><ol><li>磁聚焦</li><li>回旋加速器</li><li>霍尔效应</li></ol><h3 id="磁介质"><a href="#磁介质" class="headerlink" title="磁介质"></a>磁介质</h3><p>  磁化强度：$M=\frac{∑m}{ΔV}$,m表示磁矩<br>  磁场强度：$B=\mu_0\mu_rH$<br>  磁化率：  </p><script type="math/tex; mode=display">χ_r=\mu_r-1</script><script type="math/tex; mode=display">M=(\mu_r-1)H</script><blockquote><p>$\mu_r$没有大小限制  </p></blockquote><p>  若$\mu_r<1$, 称介质为抗磁质     若$\mu_r>1$, 称介质为顺磁质<br>  若$\mu_r&gt;&gt;1$, 称介质为铁磁质  </p><h2 id="电磁感应"><a href="#电磁感应" class="headerlink" title="电磁感应"></a>电磁感应</h2><h3 id="涡旋电场"><a href="#涡旋电场" class="headerlink" title="涡旋电场"></a>涡旋电场</h3><p>  涡旋电场是有变化的磁场所产生的电场。  </p><script type="math/tex; mode=display">∮E_Bd\vec{l}=-\frac{dΦ_B}{dt}</script><script type="math/tex; mode=display">∯E_Bd\vec{S}=0</script><p>  结论：涡旋电场是无源有旋的电场  </p><h3 id="自感"><a href="#自感" class="headerlink" title="自感"></a>自感</h3><p>  自感系数：  </p><script type="math/tex; mode=display">L=\frac{Φ}{I}</script><p>  通过自感产生的电势：  </p><script type="math/tex; mode=display">ϵ_L=-\frac{dΦ}{dt}=-L\frac{di}{dt}</script><h3 id="互感"><a href="#互感" class="headerlink" title="互感"></a>互感</h3><p>  互感系数：  </p><script type="math/tex; mode=display">M=\frac{Φ_{21}}{I_1}</script><p>   其中$Φ_{21}$表示在2中由1产生的磁通量，$I_1$是1的电流  </p><h3 id="磁场能"><a href="#磁场能" class="headerlink" title="磁场能"></a>磁场能</h3><p>  自感耗能：  </p><script type="math/tex; mode=display">W_m=\frac{1}{2}LI^2</script><p>  整个电路的能量：  </p><script type="math/tex; mode=display">\int_0^t ϵIdt=\frac{1}{2}LI^2+I^2Rt</script><p>  能量密度：</p><script type="math/tex; mode=display">W=\frac{1}{2}LI^2=\frac{B^2V}{2μ}</script><p>  V为螺线管/螺绕环的体积  </p><script type="math/tex; mode=display">w_M=\frac{W}{V}=\frac{B^2}{2μ}=\frac{1}{2}BH</script><p>  由$B=\mu_0\mu_rH$,  </p><script type="math/tex; mode=display">w_m=\frac{1}{2}\frac{B^2}{\mu_0\mu_r}=\frac{1}{2}\mu_0\mu_rH^2</script><h2 id="麦克斯韦方程"><a href="#麦克斯韦方程" class="headerlink" title="麦克斯韦方程"></a>麦克斯韦方程</h2><h3 id="光的两大特性"><a href="#光的两大特性" class="headerlink" title="光的两大特性"></a>光的两大特性</h3><script type="math/tex; mode=display">C=\frac{1}{\sqrt{\mu_0ɛ_0}}</script><p>表示光速是恒定的  </p><p>由折射光介质比$n=\frac{C}{V}$，有  </p><script type="math/tex; mode=display">n=\frac{1}{\sqrt{\mu_rɛ_r}}</script><p>表示光是一种电磁波  </p><h3 id="位移电流"><a href="#位移电流" class="headerlink" title="位移电流"></a>位移电流</h3><p>位移电流是假想出来的电流，它遵循所有的电传导定律<br>全电流是<strong>传导电流</strong>和<strong>位移电流</strong> （以及运流电流*）的总称</p><h3 id="麦克斯韦方程组的积分形式"><a href="#麦克斯韦方程组的积分形式" class="headerlink" title="麦克斯韦方程组的积分形式"></a>麦克斯韦方程组的积分形式</h3><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">方程</th><th style="text-align:center">结论</th></tr></thead><tbody><tr><td style="text-align:center">电场中的高斯定理</td><td style="text-align:center">$∮\vec{D}.d\vec{S}=∫_D ρdV=q$</td><td style="text-align:center">静电场有源</td></tr><tr><td style="text-align:center">电场中的安培环路定理</td><td style="text-align:center">$∮\vec{E}.d\vec{l}=-∫\frac{∂B}{\partial t}dS+0$</td><td style="text-align:center">涡旋电场有旋，静电场无旋</td></tr><tr><td style="text-align:center">磁场中的高斯定理</td><td style="text-align:center">$∮\vec{B}.d\vec{S}=0$</td><td style="text-align:center">磁场无源</td></tr><tr><td style="text-align:center">磁场中的安培环路定理</td><td style="text-align:center">$∮\vec{H}.d\vec{l}=∫(j_c+\frac{\partial D}{∂t})dS$</td><td style="text-align:center">磁场有旋</td></tr></tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>复习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>概率论与数理统计-常考知识点</title>
    <link href="/2021/04/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"/>
    <url>/2021/04/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="概率论与数理统计"><a href="#概率论与数理统计" class="headerlink" title="概率论与数理统计"></a>概率论与数理统计</h1><blockquote><p>整理重邮常考的知识点  </p></blockquote><h2 id="独立、相关、互斥、概率的计算"><a href="#独立、相关、互斥、概率的计算" class="headerlink" title="独立、相关、互斥、概率的计算"></a>独立、相关、互斥、概率的计算</h2><ul><li>独立<br>如果事件A,B相互独立，有$P(AB)=P(A)P(B)$, $E(AB)=E(A)E(B)$</li><li>互斥<br>如果事件A,B互斥，有$P(A+B)=P(A)+P(B)$,即$P(AB)=0$  <blockquote><p>独立与互斥没有任何关系</p></blockquote></li><li>不相关<br>如果事件A，B不相关，有$Cov(A,B)=0$   <blockquote><p>独立可以推出不相关，不相关不能推出独立  </p></blockquote></li><li>概率中常用的计算公式<ul><li>和事件的概率  <script type="math/tex; mode=display">P(A+B)=P(A)+P(B)-P(AB)</script></li><li>德摩根律  <script type="math/tex; mode=display">P(\overline)=1-P(A+B)</script></li><li>概率拆分   <script type="math/tex; mode=display">P(AB)=P(A(1-P(\overline{B})))=P(A)-P(A\overline{B})</script></li></ul></li></ul><h2 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h2><ul><li><p>乘法公式<br>在A的条件下，B发生的概率：</p><script type="math/tex; mode=display">P(B|A)=\frac{P(AB)}{P(A)}</script><p>满足性质：  </p><script type="math/tex; mode=display">P(B|A)=1-P(\overline{B}|A)</script></li><li><p>全概率公式<br>将A事件（条件）划分为多个事件$A_i$,那么事件B发生的概率：  </p><script type="math/tex; mode=display">P(B)=ΣP(A_i)P(B|A_i)</script></li><li><p>贝叶斯公式<br>全概率公式的逆公式，表示已知B事件发生的概率下，在A中某一个划分下发生的概率：</p><script type="math/tex; mode=display">P(A_i|B)=\frac{P(A_i)P(B|A_i)}{P(B)}=\frac{P(A_i)P(B|A_i)}{ΣP(A_i)P(B|A_i)}</script></li></ul><h2 id="连续性随机变量的分布"><a href="#连续性随机变量的分布" class="headerlink" title="连续性随机变量的分布"></a>连续性随机变量的分布</h2><ul><li>概率密度函数<br>表示连续性随机变量在数轴上分布的稠密程度,有  <script type="math/tex; mode=display">\int_{-∞}^∞f(x)dx=1</script>性质：  <script type="math/tex; mode=display">P(a≤x≤b)=\int_{a}^bf(x)dx</script></li><li><p>概率分布函数<br>表示连续性随机变量在数轴左端分布的概率情况，即$P(X≤x)$的概率</p><script type="math/tex; mode=display">F(x)=\int_{-∞}^xf(x)dx</script><blockquote><p>分段的概率分布函数不要忘记了还要加上前一段的概率    </p></blockquote><p>性质：  </p><script type="math/tex; mode=display">P(a≤x≤b)=F(b)-F(a)</script><script type="math/tex; mode=display">P(x>a)=1-F(a)</script></li><li><p>正态分布<br>分布函数特性:  </p><ol><li>$Φ(a)=P(x ≤ a)$，$P(x &gt; a)=1-Φ(a)$  </li><li>$Φ(0)=0.5$  </li><li>$Φ(-a)=1-Φ(a)$  </li></ol><p>数值特征：  </p><ol><li>$X∼N(μ,σ^2),E(\overline{X})=μ,D(\overline{X})=Cov(X,\overline{X})=\frac{σ^2}{n}$</li><li>见中心极限定理</li></ol></li><li><p>随机变量之间的函数关系<br>倘若随机变量X，Y 之间存在某种函数关系$Y=g(X)$,给定X的分布函数$F_x(x)$,求Y的概率密度函数   </p><script type="math/tex; mode=display">F_y(y)=P(Y≤y)=P(g(x)≤y)=P(x≤h(y))=F_X(h(y))</script><script type="math/tex; mode=display">f_Y(y)=F'_y(y)=F'_x(h(y))h'(y)=f_x(h(y))h'(y)</script></li></ul><h2 id="二元随机变量"><a href="#二元随机变量" class="headerlink" title="二元随机变量"></a>二元随机变量</h2><ul><li><p>二元连续性随机变量的分布函数</p><script type="math/tex; mode=display">F(x,y)=\iint f(x,y)dA=P(A)</script><p>其中A是由x,y围成的区域，对应x和y的一组规划</p></li><li><p>边缘分布概率密度和分布函数<br>对于$F(x,y)$,  </p><script type="math/tex; mode=display">f_x(x)=∫_{-∞}^{∞}f(x,y)dy</script><script type="math/tex; mode=display">f_y(y)=∫_{-∞}^{∞}f(x,y)dx</script><script type="math/tex; mode=display">F_x(x)=F(x,∞)=\int_{\infty}^x f_x(x)dx</script><script type="math/tex; mode=display">F_y(y)=F(∞,y)=\int_{\infty}^y f_y(y)dy</script></li><li><p>条件分布函数<br>X在Y=y条件下的概率密度：  </p><script type="math/tex; mode=display">f_{X|Y}(x,y)=\frac{f(x,y)}{f_Y(y)}</script></li><li><p>二元随机变量的分布函数  </p><ul><li>Z=X+Y<script type="math/tex; mode=display">f_z(z)=∫ f_x(z-y)f_y(y)dy=∫ f_x(x)f_y(z-x)dx</script><blockquote><p>注意需要考虑$Z-Y$的取值范围，必要的时候要对$X$，$Z-Y$两者的取值范围大小进行分类讨论，始终取最小的区间</p></blockquote></li><li>Z=max{X,Y}  <script type="math/tex; mode=display">F_z(z)=F_x(z)F_y(z)</script></li><li>Z=min{X,Y}<script type="math/tex; mode=display">F_z(z)=1-[(1-F_x(x))(1-F_y(y))]</script></li></ul></li></ul><h2 id="统计特征"><a href="#统计特征" class="headerlink" title="统计特征"></a>统计特征</h2><ul><li><p>数学期望<br>离散型： 略<br>连续型：  </p><script type="math/tex; mode=display">E(x)=\int x f(x)dx</script><script type="math/tex; mode=display">E(g(x))=\iint g(x) f(x,y)dA</script><p>性质：  </p><ul><li>$E(X+Y)=E(X)+E(Y)$  </li><li>X,Y相互独立时：$E(XY)=E(X)E(Y)$  </li></ul></li><li><p>方差</p><script type="math/tex; mode=display">D(x)=E(x^2)-[E(x)]^2</script><script type="math/tex; mode=display">D(x)=Σ[E{(x-E^2(x))}]</script><p>性质:  </p><ul><li>$D(X⨦Y)=D(X)+D(Y)⨦2Cov(X,Y)$<blockquote><p>当X,Y独立的时候才有$D(X⨦Y)=D(X)+D(Y)$，在使用公式之前一定要注意X,Y是否是独立的  </p></blockquote></li><li>$D(Cx)=c^2D(x)$  </li></ul></li><li><p>协方差和相关系数</p><ul><li><p>协方差  </p><script type="math/tex; mode=display">Cov(X,Y)=E[(X-E(X))(Y-E(Y))]=E(XY)-E(X)E(Y)</script><p>协方差反映了两个随机变量的相关性，如果$Cov(X,Y)=0$，则X,Y不相关。<br>相关系数是标准化的协方差：</p><script type="math/tex; mode=display">ρ_{(X,Y)}=\frac{Cov(X,Y)}{\sqrt{D(X)}\sqrt{D(Y)}}</script></li><li><p>性质<br>$Cov(X,X)=D(X)$<br>$Cov(aX+bY,cX+dY)=acD(X)+(ad+bc)Cov(X,Y)+bdD(Y)$  </p></li></ul></li><li>方差矩阵  <ul><li>原点矩<br>指  $E(X^k)$  </li><li>中心距<br>指  $E[(X-E(X))^k]$  </li></ul></li></ul><h2 id="中心极限定理"><a href="#中心极限定理" class="headerlink" title="中心极限定理"></a>中心极限定理</h2><p>中心极限定理的使用条件都是n比较大的时候。  </p><ul><li><p>李雅普诺夫定理<br>对于n个独立的随机变量$X_1,X_2,…X_n$,当n以概率趋近于无穷时，他们的和服从正态分布。</p><script type="math/tex; mode=display">\frac{ΣX_i-Σ\mu_i}{√{Σσ^2}}∼N(0,1)</script><p>当n个随机变量都是正态分布的时候，他们的和也服从正态分布，即：   </p><script type="math/tex; mode=display">\frac{ΣX_i-n\mu}{σ√n} ∼ N(0,1)</script></li><li><p>棣莫弗-拉普拉斯定理<br>当n足够大时，二项分布可视为正态分布。<br>若$X∼B(n,p)$,<br>有$E(X)=np$,$D(x)=np(1-p)$。<br>那么可以标准化X，有：  </p><script type="math/tex; mode=display">\frac{X-E(X)}{√D(X)}∼N(0,1)</script><blockquote><p>二项分布的极限可以是正态分布，也可以是泊松分布，优先选择泊松分布。  </p></blockquote></li></ul><h2 id="统计样本的数值特征和分布"><a href="#统计样本的数值特征和分布" class="headerlink" title="统计样本的数值特征和分布"></a>统计样本的数值特征和分布</h2><ul><li>样本的数值特征<ul><li>样本均值<script type="math/tex; mode=display">\overline{X}=\frac{1}{n}Σx_i</script></li><li>样本方差<script type="math/tex; mode=display">S^2=\frac{1}{n-1}Σ(x_i-\overline{x})^2</script><blockquote><p>n-1</p></blockquote></li></ul></li><li>样本的分布<ul><li>$χ^2$分布<br>如果样本$X_1,X_2,…X_n$服从正态分布，那么$χ^2=Σx_i^2$服从自由度为n的$\chi^2$分布。<br>$χ^2$统计量：  <script type="math/tex; mode=display">\chi^2=\frac{(n-1)S^2}{\sigma^2}</script>分位点：<br>双侧α分位点：$\chi^2_{1-\frac{α}{2}}$,$\chi^2_{\frac{α}{2}}$<br>单侧α分位点：$\chi^2_{1-α}$，$\chi^2_{α}$   </li><li>t分布<br>如果样本$X ∼ N(0,1)$,且$Y ∼ χ^2_{n}$, X,Y独立，那么$t=\frac{X}{√\frac{Y}{n}}$服从自由度为n的t分布。<br>t统计量：  <script type="math/tex; mode=display">t=\frac{x-\overline{μ}}{S}</script>分位点：<br>双侧α分位点：$t_{\frac{α}{2}}$,$t_{-\frac{α}{2}}$<br>单侧α分位点：$t_{α}$,$-t_{α}$  </li><li>F分布<br>设$U ∼ χ^2(n_1)$,$V ∼ χ^2(n_2)$,U,V相互独立，则称$F=\frac{\frac{U}{N_1}}{\frac{V}{N_2}}$服从自由度为$(n_1,n_2)$的F分布。  </li></ul></li></ul><h2 id="样本的点估计法"><a href="#样本的点估计法" class="headerlink" title="样本的点估计法"></a>样本的点估计法</h2><ul><li>矩估计法<br>设X的概率密度函数为$f(x:θ_1,…,\theta_k)$, 用样本1~k阶矩（$E(x^k)$）代替总体1~k阶矩建立k个方程，联立求解，结果是含有A的式子。<ul><li>结论<script type="math/tex; mode=display">μ=\overline{x},~~~~~σ^2=B_2=A_2-A_1^2</script></li></ul></li><li>最大似然估计法<br>设X的概率密度函数为$f(x:θ_1,…,\theta_k)$, 通过如下方法找出参数的估计量：   <ol><li>求解似然函数$L(\theta)=Πf(x)$   </li><li>对似然函数取对数$ln(L(\theta))=ln(Πf(x))$  </li><li>求导或者是偏导数，使每一个结果都等于0：$\frac{\partial ln(L(\theta)}{\partial θ}=\frac{\partial ln(Πf(x))}{\partial θ}=0$    </li><li>求解θ  <blockquote><p>特殊情况： 均匀分布估计a,b的值，需要设最大值最小值函数      </p></blockquote></li></ol><ul><li>统计量的选取  <ul><li>无偏性<br>如果$θ$的估计量 $θ̂$ 的数学期望存在，且$E(θ̂)=θ$，称$θ̂$是$θ$的无偏估计量。</li></ul><ul><li>有效性<br>如果$θ$的估计量 $θ̂_1$,$θ̂_2$的方差存在，且$D(θ̂_1)&lt;D(θ̂_2)$,称$θ̂_1$比$θ̂_2$更有效。  </li><li>相合性*<br>如果$θ$的估计量 $θ̂$以概率趋近于$θ$，称$θ̂$是$θ$的相合估计量。  </li></ul></li></ul></li></ul><h2 id="区间估计"><a href="#区间估计" class="headerlink" title="区间估计"></a>区间估计</h2><p>区间估计遵循以下方法：  </p><ol><li>选取一个合适的统计量    </li><li>找到α分位点   </li><li>反解出关于参数的不等式  </li><li>代值求出不等式，即为置信区间  </li></ol><h2 id="假设检验"><a href="#假设检验" class="headerlink" title="假设检验"></a>假设检验</h2><p>假设检验遵循以下方法：     </p><ol><li>提出原假设和备择假设，备择假设中不能有等于符号   </li><li>找到α分位点，根据备择假设的符号来判断是单边检验还是双边检验 <blockquote><p>拒绝域的符号和备择假设的符号是相同的  </p></blockquote></li><li>找到拒绝域   </li><li>计算统计量的值，并与分位点的值进行比对，看统计量是否落在了拒绝域     </li></ol><h2 id="随机过程的数值特征和平稳性"><a href="#随机过程的数值特征和平稳性" class="headerlink" title="随机过程的数值特征和平稳性"></a>随机过程的数值特征和平稳性</h2><ul><li>数值特征<br>均值函数：$μ_x(t)=E(X(t))$<br>    例如：若 $X(t)=At+B$,那么$μ_x(t)=E(X(t))=tE(A)+E(B)$<br>自相关函数：$R_{xx}(t_1,t_2)=E[X(t_1).X(t_2)]$<br>方差函数：$D_x(t)=R_{xx}(t,t)-[μ_x(t)]^2$  </li><li>平稳性<br>验证随机过程是否具有宽平稳性需要有三步：  </li></ul><ol><li>验证该过程是否是二阶矩过程*  </li><li>求均值函数是否是一个常数  </li><li>求自相关函数$R(t,t+τ)$是否只与τ有关  </li></ol><h2 id="马尔科夫链"><a href="#马尔科夫链" class="headerlink" title="马尔科夫链"></a>马尔科夫链</h2><ul><li><p>概率转移矩阵<br>表示状态由现态转移到n次态的概率 $P=[现态（竖） \backslash 次态（横）]$</p><script type="math/tex; mode=display">P(n)=p^n</script><p>$p$表示一步转移矩阵，$P(n)$为n步转移矩阵</p></li><li><p>转移概率</p><script type="math/tex; mode=display">P_{ij}(m,m+n)=P(X_{m+n}=a_j|X_m=a_i)</script><p>表示马尔科夫链在时刻m，状态$a_i$下在时刻m+n下转移到状态$a_j$的概率  </p><ul><li>利用全概率公式可以推出$P(X_{m+n})$的概率</li><li>利用乘法公式可以推出$P(X_{m},X_{m+n})$的概率</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>复习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数字系统与微处理器-常考知识点</title>
    <link href="/2021/04/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <url>/2021/04/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Knowledge-points-of-Digital-Systems-and-Microprocessors"><a href="#Knowledge-points-of-Digital-Systems-and-Microprocessors" class="headerlink" title="Knowledge points of Digital Systems and Microprocessors"></a>Knowledge points of Digital Systems and Microprocessors</h1><blockquote><p>Made for the final test of Brunel University 2020 EE1655:    Digital Systems and Microprocessors<br>Lecturer: Dr.Zhengwen Huang（黄正文）/Dr. Guoquan Li（李国权）<br>*: appeared in all 3-year final tests  </p></blockquote><p> (Given table): the reference is given in the test paper</p><h2 id="Basic-knowledge-of-binary-code-and-Boolean-algebra"><a href="#Basic-knowledge-of-binary-code-and-Boolean-algebra" class="headerlink" title="Basic knowledge of binary code and Boolean algebra"></a>Basic knowledge of binary code and Boolean algebra</h2><p><strong>Conversion between Dec  BCD, Hex and Binary*</strong><br>X-based to Dec:  </p><script type="math/tex; mode=display">∑_{k=0}^na \times x^k</script><p>ec to X-based:<br>Successive division  </p><p><strong>m-in-n/m-out-of-n/m-of-n codes</strong><br>N stands for total number bits<br>M stands for m bits must be set to 1<br>If the number of  1 in a data package is not equal to m, error happens  </p><p><strong>Parity code</strong><br>The number of 1 in a line is consistently to be even/odd.<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211227155708.png width=50%>      </p><p><strong>Truth table equivalence*</strong><br>If two Boolean functions share the same truth table, they are equal.  </p><h2 id="Combinational-logic"><a href="#Combinational-logic" class="headerlink" title="Combinational logic"></a>Combinational logic</h2><p><strong>1st and 2nd canonical form*</strong><br>1st canonical form: (.)+(.)<br>the result of Kmap: 0: F, 1:T<br>2nd canonical form: (+).(+)<br>the result of Kmap: 0:T, 1:F<br>Relation:   $F_{1st}+F_{2nd}=1$<br>They share the same Kmap.  </p><p><strong>Conversion between NAND NOR version*</strong><br>1st canonical form to NAND version:   </p><script type="math/tex; mode=display">A.B+C.D=\overline{(\overline{A}.\overline{B}).(\overline{C}.\overline{D})}</script><p>2nd canonical form to NOR version:   </p><script type="math/tex; mode=display">(A+B).(C+D)=\overline{\overline{A+B}+\overline{C+D}}</script><p><strong>Cellular Logic</strong><br>Recursive function   </p><h2 id="Sequential-logic"><a href="#Sequential-logic" class="headerlink" title="Sequential logic"></a>Sequential logic</h2><p><strong>Structure of SRFF</strong><br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211227155641.png width=50%>      </p><p><strong>Characteristics of TFF and DFF*</strong><br>TFF:<br>Structure:<br>Asynchronous TFF:  J=K=1 CLK=T<br>Synchronous TFF:    J=K=T CLK=CLK<br>Functionality:<br>T=0 keep the state<br>T=1 change the state<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211227154618.png width=50%>  </p><p>DFF:<br>Structure:<br>$J=D$ $K=\overline{D}$<br>Functionality:<br>whenever the current state is, the next state will be D.<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211227154837.png width=50%>                  </p><p><strong>Feedback Shift Register*</strong><br>Method: move the head bits to the tail, with possible options.   </p><p><strong>Counter</strong><br>Counter is used to generate a sequence.  </p><p><strong>Circuit design (Transition diagram, P/N state table, Transition table, K-maps)*</strong><br>Transition diagram:<br>Set A=00 B=01 C=11 D=10<br>Input is IA/B/C/D, list the transition table.  </p><h2 id="Digital-System"><a href="#Digital-System" class="headerlink" title="Digital System"></a>Digital System</h2><p><strong>Multiplexer and design*</strong><br>Simplify some variables in Boolean function, the simplified variables will be used for encoder part.<br>The meaning of n to 1: the number of control bits will be 2^k=n  </p><p><strong>Memory and how to determine its size</strong><br>The memory is determined by the number of logic gates which connected to R/W line.<br>The size of memory= number of gates x number of layers bits.<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20211227155612.png width=50%>  </p><h2 id="Introduction-of-PIC"><a href="#Introduction-of-PIC" class="headerlink" title="Introduction of PIC"></a>Introduction of PIC</h2><p><strong>The basic information of PIC16F876A*</strong>, including:<br>The size of Program memory/Code memory is 8k bits, Data memory is 13k bits, Program counter(PCL) is 13k bits and located in data memory.<br>The maximum level of stacks is 8, with 13 bits width.<br>Number of Pins is 40 (DIP40).<br>Harvard Architecture.<br>There are 35 instructions for PIC16F876A.<br>The location and functionality of SFRs:  </p><ul><li>W register: outside of program memory, the data transition station  </li><li>STATUS register: Program memory, determine which bank in program memory will be used  </li></ul><p><strong>Functionality of some assembly language instructions (Given the table)*</strong>, including:  </p><ul><li>BSF: set the file register to be 1  </li><li>BCF: clear the file register to be 0  </li><li>NOP: do nothing but create a 1 bit delay  </li><li>BTFSC: bit check, if file register is cleared, then skip the following line  </li><li>BTFSS: bit check, if file register is set, then skip the following line  </li></ul><p><strong>Conversion between Two’s complement and  Dec*</strong><br>Positive Dec number: convert to binary number, then keep it.<br>Negative Dec number: remove “-“,convert to binary number, do complement on the number, then +1.  </p><p><strong>Conversion between assembly language instructions and machine code*</strong> (Give the table)<br>Structure of machine code:   </p><ul><li>operation code     </li><li>destination     </li><li>file address  </li></ul><p>4 kinds of characters of instruction’s 14-bit Opcoder:  </p><ul><li>K literal </li><li>X don’t care (default to be 0)</li><li>D W register (1 for W register to File register, 0 for File register to W register)</li><li>F  file register’s address</li><li>b  bit address within an 8-bit file register</li></ul><p><strong>Subroutine’s explanation by explaining instructions like CALL, GOTO and RETURN and time consumption*</strong><br>Time/Cycle consumption: Normal execution costs 1 us, GOTO and RETURN instruction costs 2us.  </p><p><strong>Track the value of W register</strong><br><strong>Output Devices*</strong>  </p><ul><li><p>7-Segments:<br>Port A: which 7-segments will be lighten<br>Port B: display the number (0:light, 1:dark)  </p></li><li><p>Keypad:<br>Switch Bounce: There should be a delay to wait the time in order to let the key bounce (about10-3s) be finished, or may cause the hazard.  </p></li></ul><p><strong>ADC</strong><br>Precession and LSB:  $LSB=\frac{Range}{2^k}$ , k is the number of bits<br>Quantity error: ⁺-0.5 LSB</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>复习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Lecture 5 成像理论</title>
    <link href="/2021/04/26/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%A9%E7%BA%BF%E4%B8%8E%E9%80%9A%E4%BF%A1%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86/5.%20%E6%88%90%E5%83%8F%E7%90%86%E8%AE%BA/"/>
    <url>/2021/04/26/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%A9%E7%BA%BF%E4%B8%8E%E9%80%9A%E4%BF%A1%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86/5.%20%E6%88%90%E5%83%8F%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="Lecture-5-成像理论"><a href="#Lecture-5-成像理论" class="headerlink" title="Lecture 5 成像理论"></a>Lecture 5 成像理论</h1><p><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/35B7C4F7C041A7815C1CD209C38BFE41.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>天线与通信传输原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>7.3. 数据量与学习性能</title>
    <link href="/2021/04/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/7.%20%E5%AD%A6%E4%B9%A0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E5%AE%9E%E9%99%85%E9%97%AE%E9%A2%98/7.3.%20%E6%95%B0%E6%8D%AE%E9%87%8F/"/>
    <url>/2021/04/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/7.%20%E5%AD%A6%E4%B9%A0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E5%AE%9E%E9%99%85%E9%97%AE%E9%A2%98/7.3.%20%E6%95%B0%E6%8D%AE%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="数据量与学习性能"><a href="#数据量与学习性能" class="headerlink" title="数据量与学习性能"></a>数据量与学习性能</h1><p>在某些情况下，获取大量数据来进行机器学习并得到模型是一个非常有效的提升模型性能的办法。<br>2001年Banko 和 Brill试图用不同的算法对一些容易混淆的词汇进行分类，他们用数据集训练这些算法，并绘制了学习曲线。 学习曲线反映出来对于大部分算法，数据集量的提升都能够改进模型的性能。<br>假设有一个需要大量参数的学习算法（通常这样的算法能够拟合更加复杂的模型，因此训练误差会很小），<strong>在特征充足的条件下，采用更多的数据能够减小过拟合的可能性，那么测试误差会接近于训练误差，测试误差也会很小。</strong>  </p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>07. 机器学习系统设计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>7.2. 查准率和召回率</title>
    <link href="/2021/04/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/7.%20%E5%AD%A6%E4%B9%A0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E5%AE%9E%E9%99%85%E9%97%AE%E9%A2%98/7.2.%20%E6%9F%A5%E5%87%86%E7%8E%87%E5%92%8C%E5%8F%AC%E5%9B%9E%E7%8E%87/"/>
    <url>/2021/04/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/7.%20%E5%AD%A6%E4%B9%A0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E5%AE%9E%E9%99%85%E9%97%AE%E9%A2%98/7.2.%20%E6%9F%A5%E5%87%86%E7%8E%87%E5%92%8C%E5%8F%AC%E5%9B%9E%E7%8E%87/</url>
    
    <content type="html"><![CDATA[<p><style><br>img{<br>    width: 50%;<br>    padding-left: 20%;<br>}</style></p><h1 id="查准率和召回率"><a href="#查准率和召回率" class="headerlink" title="查准率和召回率"></a>查准率和召回率</h1><h2 id="偏斜类问题"><a href="#偏斜类问题" class="headerlink" title="偏斜类问题"></a>偏斜类问题</h2><p>在上一讲中提到了用一些数学指标来评估算法是非常有效的一种方法，但是如果错误地选用了某些指标就会导致<strong>偏斜类问题</strong>（Skewed Classification）的出现。<br>具体而言，对于癌症分类问题，如果训练了一个模型并用测试集检测出错误率为1%，但实际上测试集中只有0.5%的患者真正得了癌症。<br>这是因为在测试集中相比于正样本（不患癌症），负样本的比例太低，这就是偏斜类问题：即数据集中某一类样本的数量比其他类多很多，在这种情况下，机器学习算法甚至比“总是认为结果是该类”的算法准确度更低。在偏斜类的情况下，实验者无法判断高正确率（比如改动后的算法的准确度(Accurancy)只发生了非常细微的改动：从99.2%提升到了99.5%）究竟是由于类别不均衡还是算法本身造成的。<br>解决偏斜类问题的方法是引入新的数学指标：<strong>查准率</strong>(Precision)和<strong>召回率</strong>(Recall)。</p><h2 id="查准率和召回率的定义"><a href="#查准率和召回率的定义" class="headerlink" title="查准率和召回率的定义"></a>查准率和召回率的定义</h2><p>有如下将测试结果可视化的方法，称为<strong>混淆矩阵</strong>(Confusion matrix)方法：<br>将横轴作为实际的标签，纵轴作为预测的标签，每一格表示“实际为标签i/但是预测为标签j”的频率，做出矩阵，如下图所示：<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210217114634.png" alt=""><br>对角线上频率的总和即为训练集的正确率。<br>混淆矩阵能够容易的表现出分类器错误的分类情况。<br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210323130333.png" alt=""><br>混淆矩阵可以得到查准率（P）和召回率(R)，具体定义为：<br>查准率=是阳性，预测为阳性的数目（真阳性）/预测为阳性=真阳性总数/（真阳性总数+假阳性总数）<br>召回率=是阳性，预测为阳性的数目（真阳性）/阳性总数=真阳性总数/（真阳性总数+假阴性总数）<br>用查准率和召回率检验“总是认为结果是该类”的算法，其召回率为0。  </p><h3 id="阈值、准确率与查准率和召回率"><a href="#阈值、准确率与查准率和召回率" class="headerlink" title="阈值、准确率与查准率和召回率"></a>阈值、准确率与查准率和召回率</h3><p>如果要想在非常确定的情况下才判断确证癌症，就需要对逻辑回归的阈值进行修改（比如$h(x)$大于0.9才判断为癌症），那么模型将具有高查准率，低召回率的特性，且模型的准确率很高。<br>相反，如果下降阈值（比如$h(x)$只要大于0.1就判断为癌症），那么模型将具有低查准率，高召回率的特性，且模型的准确率很低。<br>由此观之，以上的几个指标均与阈值的设定有关，那么如何通过准确率与查准率评价算法在不同阈值下的性能，从而决定阈值的取值？<br>基本的思路是将这两个指标转化为一个指标，从而更方便地对算法进行选择。 基本想法是用两者的均值替代这两者，但是极端情况（比如：极高召回率和极低的查准率）会让均值不能很好的反应算法的性能。 在这里介绍<strong>F值</strong>（或$F_1$值）:  </p><script type="math/tex; mode=display">F=2\frac{PR}{P+R}</script><p>F值能够给予两者中较低的值较大权重，因此<strong>F值越大，查准率和召回率越接近于1，算法性能越好。</strong>    </p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>07. 机器学习系统设计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>7.1. 学习系统构建方法</title>
    <link href="/2021/04/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/7.%20%E5%AD%A6%E4%B9%A0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E5%AE%9E%E9%99%85%E9%97%AE%E9%A2%98/7.1.%20%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA%E6%96%B9%E6%B3%95/"/>
    <url>/2021/04/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/7.%20%E5%AD%A6%E4%B9%A0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E5%AE%9E%E9%99%85%E9%97%AE%E9%A2%98/7.1.%20%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><style><br>img{<br>    width: 50%;<br>    padding-left: 20%;<br>}</style></p><h1 id="学习系统构建方法"><a href="#学习系统构建方法" class="headerlink" title="学习系统构建方法"></a>学习系统构建方法</h1><h2 id="方法优先级"><a href="#方法优先级" class="headerlink" title="方法优先级"></a>方法优先级</h2><p>假设垃圾邮件中会存在一些故意拼错的单词，如何通过监督机器学习建立一个垃圾邮件分类器？<br>设$x$表示邮件的特征，分类标签$y={0,1}$分别表示不是垃圾邮件和是垃圾邮件。<br>一个简单思路是从邮件中选取100个单词作为分类器决定邮件是否是垃圾邮件的特征。<br>将这100个单词编码按照字典排序，设特征向量$x$是一个100维的向量，每一个维度代表了100个词中的某一个词在一封邮件中出现（1）或者是不出现（0），用数学的表达即为</p><script type="math/tex; mode=display">x_j=\begin{cases}    1 \text{   if appear} \\    0 \text{   if not appear}\end{cases}</script><p>整个过程如下图所示。<br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210319212137.png" alt="">  </p><p>事实上，在实际的分类器中，通常会按照训练集中邮件的词频选出10000到50000个单词来作为特征向量的维度。<br>对于上述的垃圾邮件分类器，如何在邮箱的时间内让垃圾邮件分类器具有高准确率？ 下面提供了几种常见的思路：   </p><ol><li>收集更多的数据。（比如：Honeypot Project）    </li><li>用更加复杂的特征向量。（比如包括发件人，邮件的主题等等）    </li><li>简化目前的特征向量，比如“deal”和“deals”，“discount”和“discounts”是否应该合并在同一维度？ 或者考虑大小写以及标点符号。  </li><li>检测故意拼错的单词。  </li></ol><p>这些思路中哪些才是最具效率的？ 怎样用科学和系统的方法从这些改进方法中选择出真正有效率的改进方法？ 这是本章将会聚焦的问题。   </p><h2 id="系统构建的方法"><a href="#系统构建的方法" class="headerlink" title="系统构建的方法"></a>系统构建的方法</h2><ol><li>用最简单的算法构建神经网络，训练并且用验证集验证。  </li><li>画出学习曲线决定是否需要更多的特征或者数据。  </li><li>误差分析：查看被算法分类错误的文件，找出共同的规律。  </li></ol><p>具体而言，对于垃圾邮件分类器，需要查看全部分类错误的邮件，将它们手动分类并确认它们共同的特性。思考这些共性作为特征如何帮助分类器进行识别。<br>这样做的目的是通过简单的分类算法更能够发现错误的识别，从而获取更明显的特征，进而优化算法。  </p><h3 id="数值方法"><a href="#数值方法" class="headerlink" title="数值方法"></a>数值方法</h3><p>此外，在训练过程中返回一个数学结果（比如准确率）是非常有效的。<br>比如：思考是否将“discount/discounted/discounts/discounting”作为同一个特征？<br>基本思路是通过词干提取(Stemming)软件来提取词干，但是这种软件最简单的检查单词前面的几个字母，因此可能会发生误识别的情况（比如“University/Universe”）。那么是否应该应用词干提取软件来提取特征呢？简单的办法是快速运行一下词干提取软件，获取此时的正确率，与不进行词干提取软件时的正确率进行对比。通过对比试验来辅助决策。  </p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>07. 机器学习系统设计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>6.4. 总结：诊断与调试</title>
    <link href="/2021/04/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/6.%20%E8%AF%8A%E6%96%AD%E4%B8%8E%E8%B0%83%E8%AF%95/6.4.%20%E6%9C%AC%E7%AB%A0%E5%9B%9E%E9%A1%BE/"/>
    <url>/2021/04/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/6.%20%E8%AF%8A%E6%96%AD%E4%B8%8E%E8%B0%83%E8%AF%95/6.4.%20%E6%9C%AC%E7%AB%A0%E5%9B%9E%E9%A1%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="总结：-诊断与调试"><a href="#总结：-诊断与调试" class="headerlink" title="总结： 诊断与调试"></a>总结： 诊断与调试</h1><h2 id="回顾：-改进算法性能的思路"><a href="#回顾：-改进算法性能的思路" class="headerlink" title="回顾： 改进算法性能的思路"></a>回顾： 改进算法性能的思路</h2><p>回到本章最开始的改进算法性能的思路：     </p><ol><li>获得更多的数据集</li><li>选用更少的特征以防止过拟合</li><li>获得更多的特征来补充特征集</li><li>增加多项式特征</li><li>增加正则化参数$λ$   </li><li>减小正则化参数$λ$  </li></ol><p>通过这一章的学习，这些思路有各自的功能和局限性：   </p><ol><li>获得更多的数据集            —仅对高方差有效</li><li>选用更少的特征以防止过拟合   —仅对高方差有效</li><li>获得更多的特征来补充特征集   —通常用于高偏差问题</li><li>增加多项式特征              —仅对高偏差有效</li><li>增加或减小正则化参数$λ$     —仅对高偏差有效</li><li>减小正则化参数$λ$           —仅对高方差有效  </li></ol><h2 id="大型神经网络和小型神经网络"><a href="#大型神经网络和小型神经网络" class="headerlink" title="大型神经网络和小型神经网络"></a>大型神经网络和小型神经网络</h2><p>小型神经网络： 计算量简单<br>大型神经网络： 大计算量，更容易出现过拟合现象<br>通常使用一个正则化的大型神经网络的效果要比小型神经网络更好。<br>大型神经网络的隐藏层数目和单元数目可以通过调参进行优化。  </p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>06. 诊断与调试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>6.3. 学习曲线</title>
    <link href="/2021/04/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/6.%20%E8%AF%8A%E6%96%AD%E4%B8%8E%E8%B0%83%E8%AF%95/6.3.%20%E5%AD%A6%E4%B9%A0%E6%9B%B2%E7%BA%BF/"/>
    <url>/2021/04/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/6.%20%E8%AF%8A%E6%96%AD%E4%B8%8E%E8%B0%83%E8%AF%95/6.3.%20%E5%AD%A6%E4%B9%A0%E6%9B%B2%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<p><style><br>img{<br>    width: 30%;<br>    padding-left: 40%;<br>}</style></p><h1 id="学习曲线"><a href="#学习曲线" class="headerlink" title="学习曲线"></a>学习曲线</h1><p>学习曲线是一种检查算法是否正常运行的方法。 具体方法如下：<br>改变训练样本的总数$m$, 分别计算一系列的训练误差$J_{train}(\theta)$和交叉验证误差$J_{cv}(\theta)$。得到结论：如果训练样本的总数很小，模型往往能够很好的拟合，随着样本数的增大，假设模型的平均训练误差会逐渐增大。对于验证集，由于验证集当中的样本都是未被训练过的，在训练样本数很低时，模型的泛化程度不高，因此如果训练样本的总数很小时，假设模型的平均验证误差会很高，随着样本数的增大，平均验证误差会逐渐减小。如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/master/img/20210312162734.png" alt="">   </p><h2 id="高偏差和高方差学习曲线"><a href="#高偏差和高方差学习曲线" class="headerlink" title="高偏差和高方差学习曲线"></a>高偏差和高方差学习曲线</h2><h3 id="高偏差学习曲线"><a href="#高偏差学习曲线" class="headerlink" title="高偏差学习曲线"></a>高偏差学习曲线</h3><p>如果模型不能很好的拟合数据，即出现了高偏差。  在训练集总数$m$非常小时，训练误差非常大，随着随着训练集总数$m$的增大，验证误差会逐渐的减小，最终停留在一个较高的水平。 对于训练误差，随着训练集总数$m$的增大，训练误差误差会越来越大，最终趋近于验证误差。  因为模型的参数过少，因此最终验证误差和训练误差会非常的接近。   </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210821152919.png width=80%>     </p><p>从上图可以看出：<strong>如果一个模型具有高偏差的特性，选用更多的训练集数据并不能改善准确度。</strong>   </p><h3 id="高方差学习曲线"><a href="#高方差学习曲线" class="headerlink" title="高方差学习曲线"></a>高方差学习曲线</h3><p>模型在过拟合下，随着训练集总数$m$的增大，由于模型的泛化程度底下，因此训练误差会越来越高，并最终保持在一定水平。  同高偏差学习曲线一样，高方差模型的验证误差很大，并最终保持在一定水平。   </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210821153002.png width=80%>  </p><p>从上图可以看出：<strong>如果一个模型具有高方差的特性，选用更多的训练集数据能够改善准确度。</strong>    </p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>06. 诊断与调试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>6.2. 方差与偏差</title>
    <link href="/2021/04/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/6.%20%E8%AF%8A%E6%96%AD%E4%B8%8E%E8%B0%83%E8%AF%95/6.2.%20%E6%96%B9%E5%B7%AE%E5%92%8C%E5%81%8F%E5%B7%AE/"/>
    <url>/2021/04/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/6.%20%E8%AF%8A%E6%96%AD%E4%B8%8E%E8%B0%83%E8%AF%95/6.2.%20%E6%96%B9%E5%B7%AE%E5%92%8C%E5%81%8F%E5%B7%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="方差和偏差"><a href="#方差和偏差" class="headerlink" title="方差和偏差"></a>方差和偏差</h1><h2 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h2><p>运行一个学习算法时，如果模型表现不理想，有高可能性是发生了欠拟合（<strong>高偏差（Bias）</strong>）或者过拟合（<strong>高方差（Variance）</strong>）问题。 那么如何判断算法究竟出现了哪一种问题？<br>上一讲中已经定义过训练，测试和验证误差。 通常情况下，假设多项式模型中多项式的次数与训练和测试、验证误差的关系如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210319212237.png" alt=""><br>通过上图能够判断模型到底出现了欠拟合还是过拟合：<br><strong>如果训练和测试误差都很高，那么有高概率是发生了欠拟合问题。</strong> <strong>如果训练误差低，测试误差高（远大于训练误差），那么有高概率发生了过拟合问题。</strong>    </p><h2 id="偏差和方差与正则化算法"><a href="#偏差和方差与正则化算法" class="headerlink" title="偏差和方差与正则化算法"></a>偏差和方差与正则化算法</h2><p>假设已经得到了一个$d=4$的多项式模型：</p><script type="math/tex; mode=display">h_θ(x)=θ_0+θ_1x+θ_2x^2+θ_3x^3+θ_4x^4</script><p>对其代价函数增加一个正则化项使得参数尽量缩小:   </p><script type="math/tex; mode=display">J_{\theta}=\frac{1}{2m}[\Sigma_{i=1}^{m}(h_θ(x^{(i)})-y^{(i)})^2+λ\Sigma_{j=1}^{m}\theta_j^2]</script><p>下图表示了正则化系数$λ$的大小与拟合情况的关系：<br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210319212259.png" alt=""><br><strong>过大的$λ$容易发生欠拟合问题，而过小的$λ$（近似于$λ=0$）则无法起到规避过拟合的作用。</strong><br>如何设置合适的$λ$呢？<br>通过正则化的代价函数$J(θ)$求出最合适的一组$θ$，此时模型的<strong>训练误差$J_{train}(θ)$应当不包含正则化项</strong>，也就是：</p><script type="math/tex; mode=display">J_{train}(\theta)=\frac{1}{2m}\sum_{i=1}^{m}(h_θ(x^{(i)})-y^{(i)})^2</script><p>在加入正则化算法后，测试一系列的$λ$的值，并得到一系列最优化的代价函数，并求到一系列的$Θ$,再用验证集计算验证集误差$J_{cv}(θ)$,最终选择验证集误差最小的那一组$θ$,使用测试集计算出测试误差$J_{test}$。<br>下图表示了$λ$的大小与训练误差和验证误差的关系：<br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210319212322.png" alt="">   </p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>06. 诊断与调试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>6.1. 性能评估</title>
    <link href="/2021/04/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/6.%20%E8%AF%8A%E6%96%AD%E4%B8%8E%E8%B0%83%E8%AF%95/6.1.%20%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0/"/>
    <url>/2021/04/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/6.%20%E8%AF%8A%E6%96%AD%E4%B8%8E%E8%B0%83%E8%AF%95/6.1.%20%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="性能评估"><a href="#性能评估" class="headerlink" title="性能评估"></a>性能评估</h1><h2 id="下一步做什么"><a href="#下一步做什么" class="headerlink" title="下一步做什么"></a>下一步做什么</h2><p>从第一章到现在，我们已经学习了许多中机器学习的方法。但是在面对如今眼花缭乱的算法时，应当如何选择最合适的算法来对数据集进行学习并改进这个算法？<br>思考如下的例子：<br>假设已经用波士顿房价数据集得到了线性回归的代价函数：   </p><script type="math/tex; mode=display">J_{\theta}=\frac{1}{2m}[\Sigma_{i=1}^{m}(h_θ(x^{(i)})-y^{(i)})^2+λ\Sigma_{j=1}^{m}\theta_j^2]</script><p>然而使用这个模型对一个新的房价数据集进行预测的时候，发现误差非常的大，如何改进这个算法的性能？<br>有如下几种解决思路：   </p><ol><li>获得更多的数据集</li><li>选用更少的特征以防止过拟合</li><li>获得更多的特征来补充特征集</li><li>增加多项式特征</li><li>增加或减小正则化参数$λ$    </li></ol><p>很多人从如上的解决思路中随机地选择几项对人工智能进行优化，然而对于某一种人工智能算法，上述的解决思路不一定每一种都有效。运用本章讲的一些技巧后，能够对如上的解决思路中每一项的有效性进行判别，从而更高效地调试神经网络。<br>下面将介绍两种评估机器学习性能的方法，它们被称为<strong>机器学习诊断法</strong>(Machine learning diagnostic)。通过运行这些方法，人们可以了解算法在哪里出现了问题，也能告诉人们做什么样的改进尝试才是有意义的。    </p><h2 id="评估假设"><a href="#评估假设" class="headerlink" title="评估假设"></a>评估假设</h2><p>在3.3.中已经介绍过了过拟合现象，因此单纯地得到预测值和标签的距离很小并不能说明这个假设模型是一个好的模型。<br>那么有什么方法能够排除过拟合地评估假设的性能呢？   </p><p>答案是划分测试集和训练集， 具体而言：将数据集划分(Split)为测试集和训练集（通常是以3：7的比例随机选择（Shuffle）），将训练集中的样本进行机器学习，测试集进行验证。<br>从训练集进行线性回归得到最适合的参数$J(θ)$，再将测试集带入其中：   </p><script type="math/tex; mode=display">J_{test}(\theta)=\frac{1}{2m_{test}}[\Sigma_{i=1}^{m_{test}}(h_θ(x_{test}^{(i)})-y_{test}^{(i)})^2+λ\Sigma_{j=1}^{m_{test}}\theta_j^2]</script><p>回归分类中对数据集的划分和验证类型大致同上，只是$J_{test}(\theta)$的形式略有差别。<br>对于回归分类还有另一形式的测试度量叫做<strong>错误分类</strong>(Misclassification Error/ 0-1 misclassification error)。<br>定义预测值和标签的误差$err(h_θ(x),y)$，有：   </p><script type="math/tex; mode=display">err(h_θ(x),y)= \begin{cases}    1  \text{   if     }   h_θ ≥ 0.5, y=0 \text{   or     } h_θ ≤ 0.5, y=1 \\    0  \text{   if     }   h_θ ≥ 0.5, y=1 \text{   or     } h_θ ≤ 0.5, y=0\end{cases}</script><p>定义测试集的误差：</p><script type="math/tex; mode=display">TestError=\frac{1}{m_{test}}∑_{i=1}^{m_{test}}err(h_θ(x^{(i)}_{test}),y^{(i)})</script><h2 id="训练集，测试集和验证集"><a href="#训练集，测试集和验证集" class="headerlink" title="训练集，测试集和验证集"></a>训练集，测试集和验证集</h2><p>如果要从如下的多项式中选择一个作为假设模型：  </p><script type="math/tex; mode=display">h_θ(x)=θ_0+θ_1x</script><script type="math/tex; mode=display">h_θ(x)=θ_0+θ_1x+θ_2x^2</script><script type="math/tex; mode=display">...</script><script type="math/tex; mode=display">h_θ(x)=θ_0+θ_1x+θ_2x^2+...+θ_nx^n</script><p>设$d$表示多项式中$x$的最大次数，要测试它们对于样本的泛化能力（即过拟合的程度，泛化能力低意味着模型过拟合，模型能够很好的拟合当前的数据集，但是对新的数据并不敏感），最简单的思路是可以对每一个模型都投入数据集，然后得到最优化的一组向量$Θ^{(d)}$，并从测试集求出每一个$J_{test}(Θ^{(d)})$，然后看哪一个模型的$J_{test}(Θ^{(d)})$最小。  但是由于我们用测试集拟合了$d$，并选择了一个最好的$d$，因此$Θ^{(d)}$很可能是对泛化误差的乐观假设。<br>解决办法是对一个数据集分为三个部分：训练集，测试集，和<strong>交叉验证集</strong>（以CV表示）。通常的比例是60%作为训练集，20%作为测试集，20%作为交叉验证集。<br>那么定义训练误差，测试误差，验证误差分别为：   </p><script type="math/tex; mode=display">J_{train}(\theta)=\frac{1}{2m}\sum_{i=1}^{m}(h_θ(x^{(i)})-y^{(i)})^2</script><script type="math/tex; mode=display">J_{test}(\theta)=\frac{1}{2m_{test}}\sum_{i=1}^{m_{test}}(h_θ(x_{test}^{(i)})-y_{test}^{(i)})^2</script><script type="math/tex; mode=display">J_{cv}(\theta)=\frac{1}{2m_{cv}}\sum_{i=1}^{m_{cv}}(h_θ(x_{cv}^{(i)})-y_{cv}^{(i)})^2</script><p>现在使用验证集来选择模型：<br>同样地，每一个数据集都投入模型，然后得到最优化的一组向量$Θ^{(d)}$，将这些Θ投入验证集并使用交叉验证得到一系列的$J_{cv}(\theta^{(d)})$,找到最合适的$d$，再放入测试集中运行。  </p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>06. 诊断与调试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Lecture 4 偶极子天线</title>
    <link href="/2021/04/22/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%A9%E7%BA%BF%E4%B8%8E%E9%80%9A%E4%BF%A1%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86/4.%20%E5%81%B6%E6%9E%81%E5%AD%90%E5%A4%A9%E7%BA%BF/"/>
    <url>/2021/04/22/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%A9%E7%BA%BF%E4%B8%8E%E9%80%9A%E4%BF%A1%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86/4.%20%E5%81%B6%E6%9E%81%E5%AD%90%E5%A4%A9%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="Lecture-4-偶极子天线"><a href="#Lecture-4-偶极子天线" class="headerlink" title="Lecture 4 偶极子天线"></a>Lecture 4 偶极子天线</h1><p><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/5694F3B43C86B30F56B20322A9C96071.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/2B207B031170016D90FFCCA11DC39411.png" alt="">  </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>天线与通信传输原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Lecture 2 传输线模型</title>
    <link href="/2021/04/22/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%A9%E7%BA%BF%E4%B8%8E%E9%80%9A%E4%BF%A1%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86/2.%20%E4%BC%A0%E8%BE%93%E7%BA%BF%E6%A8%A1%E5%9E%8B/"/>
    <url>/2021/04/22/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%A9%E7%BA%BF%E4%B8%8E%E9%80%9A%E4%BF%A1%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86/2.%20%E4%BC%A0%E8%BE%93%E7%BA%BF%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Lecture-2-传输线模型"><a href="#Lecture-2-传输线模型" class="headerlink" title="Lecture 2 传输线模型"></a>Lecture 2 传输线模型</h1><p><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/0C5F59E0CE623110CFE54C469261C092.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/5B40E0BC5D5BFF59BECBEE0B759683AC.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>天线与通信传输原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Lecture 3 天线的类型与参数</title>
    <link href="/2021/04/22/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%A9%E7%BA%BF%E4%B8%8E%E9%80%9A%E4%BF%A1%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86/3.%20%E5%A4%A9%E7%BA%BF%E7%9A%84%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%82%E6%95%B0/"/>
    <url>/2021/04/22/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%A9%E7%BA%BF%E4%B8%8E%E9%80%9A%E4%BF%A1%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86/3.%20%E5%A4%A9%E7%BA%BF%E7%9A%84%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Lecture-3-天线的类型与参数"><a href="#Lecture-3-天线的类型与参数" class="headerlink" title="Lecture 3 天线的类型与参数"></a>Lecture 3 天线的类型与参数</h1><p><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/3E086B01F0FC442575E5C8E04AE35E39.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/DDE797FAF6B2844E8DA657C1C6B20E7F.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/CE32250C1D3A9273B71F7A64B61D83C0.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/CE0A293BF2868A3247A2C2CE29E150C2.png" alt="">  </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>天线与通信传输原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>3.2. 分类算法的优化</title>
    <link href="/2021/03/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/3.%20%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/3.2.%20%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <url>/2021/03/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/3.%20%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/3.2.%20%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="分类算法的优化"><a href="#分类算法的优化" class="headerlink" title="分类算法的优化"></a>分类算法的优化</h1><h2 id="其他代价函数优化算法"><a href="#其他代价函数优化算法" class="headerlink" title="其他代价函数优化算法"></a>其他代价函数优化算法</h2><p>对于代价函数，它可以被拆分成求$J(θ)$和求$\frac{∂J(θ)}{∂θ_j }$  两个基础的部分  </p><p>事实上，除了基础的梯度下降算法能够求到最小值之外，还有如下的集中基本方法：</p><ol><li>共轭梯度算法（Conjugate Gradient）</li><li>BFGS</li><li>L-BFGS</li></ol><p>这些算法有一些共同的特点：</p><ol><li>这些算法利用线搜索算法（一种智能内循环）不需要手动选择学习率 α。</li><li>收敛的速度高于梯度下降算法</li><li>复杂度高于梯度下降算法</li></ol><h2 id="多分类问题"><a href="#多分类问题" class="headerlink" title="多分类问题"></a>多分类问题</h2><p>对于同一个数据集x，需要分类的目标不只有两种，意味着离散取值y的值不只有0，1两个值。<br>基本思想是<strong>将一个n元分类问题转化为n个二分类问题</strong>。<br>比如对y=1，2，3:<br>可以先将2，3 设置为负类，使用之前的逻辑分类方法就能够将1与（2，3）分开，重复三次，能得到三个逻辑斯蒂函数：$h_θ^i (x)i=1,2,3$。<br>由于$h_θ^i (x)=P(y=i│x; θ)$， 因此$h_θ^i (x)$表示将1设置为正类别，分类器中是1的概率。<br>最后给定函数$max(h_θ^i (x))$， 表示选择出三个当中概率最高的部分，作为判断的结果。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>03. 逻辑回归与正则化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>3.1. 激活函数和代价函数</title>
    <link href="/2021/03/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/3.%20%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/3.1.%20%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E5%92%8C%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B0/"/>
    <url>/2021/03/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/3.%20%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/3.1.%20%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E5%92%8C%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><style><br>img{<br>    width: 60%;<br>    padding-left: 20%;<br>}</style></p><h1 id="逻辑回归、激活函数及其代价函数"><a href="#逻辑回归、激活函数及其代价函数" class="headerlink" title="逻辑回归、激活函数及其代价函数"></a>逻辑回归、激活函数及其代价函数</h1><h2 id="线性回归的可行性"><a href="#线性回归的可行性" class="headerlink" title="线性回归的可行性"></a>线性回归的可行性</h2><p>对分类算法，其输出结果y只有两种结果{0，1}，分别表示负类和正类，代表没有目标和有目标。<br>在这种情况下，如果用传统的方法以线性拟合${h_θ (x)=θ^T X}$，对于得到的函数应当对y设置阈值a，高于a为一类，低于a为一类。<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20201224223513.png" alt=""><br>对于分类方法，这种拟合的方式极易受到分散的数据集的影响而导致损失函数的变化，以至于对于特定的损失函数，其阈值的设定十分困难。<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20201224223523.png" alt=""><br>除此之外，${h_θ(x)}$（在分类算法中称为分类器）的输出值很可能非常大或者非常小，并不与{0，1}完全相符</p><h2 id="假设表示"><a href="#假设表示" class="headerlink" title="假设表示"></a>假设表示</h2><p>基于上述情况，要使分类器的输出在[0,1]之间，可以采用假设表示的方法。<br>设$h_θ (x)=g(θ^T x)$，其中$g(z)=\frac{1}{(1+e^{−z} )}$, 称为<strong>逻辑斯蒂函数</strong>（Sigmoid function，又称为<strong>激活函数</strong>，生物学上的S型曲线），有：</p><script type="math/tex; mode=display">h_θ (x)=\frac{1}{(1+e^{−θ^T X} )}</script><p>其两条渐近线分别为h(x)=0和h(x)=1</p><p>在分类条件下，最终的输出结果是：</p><script type="math/tex; mode=display">h_θ (x)=P(y=1│x,θ)</script><p>其代表在给定x的条件下 其y=1的概率<br>有:  </p><script type="math/tex; mode=display">P(y=1│x,θ)+P(y=0│x,θ)=1</script><h2 id="决策边界-Decision-boundary"><a href="#决策边界-Decision-boundary" class="headerlink" title="决策边界(Decision boundary)"></a>决策边界(Decision boundary)</h2><p>对假设函数设定阈值$h(x)=0.5$，<br>当$h(x)≥0.5$ 时，输出结果y=1.<br>根据假设函数的性质，当 $x≥$0时，$h(x)≥0.5$<br>由于之前用$θ^T x$替换x，则当$θ^T x≥0$时，$h(x)≥0.5，y=1$<br>解出 $θ^T x≥0$，其答案将会是一个在每一个$x_i$轴上都有的不等式函数。<br>这个不等式函数将整个空间分成了y=1 和 y=0的两个部分，称之为决策边界。  </p><h2 id="激活函数的代价函数"><a href="#激活函数的代价函数" class="headerlink" title="激活函数的代价函数"></a>激活函数的代价函数</h2><p>在线性回归中的代价函数：</p><script type="math/tex; mode=display">J(θ)=\frac{1}{m}∑_{i=1}^m \frac{1}{2} (h_θ (x^{(i)} )−y^{(i)} )^2</script><p>令$Cost（hθ (x)，y）=\frac{1}{2}(h_θ (x^{(i)} )−y^{(i)} )^2$， Cost是一个非凹函数，有许多的局部最小值，不利于使用梯度下降法。对于分类算法，设置其代价函数为：</p><p>对其化简：</p><script type="math/tex; mode=display">Cost（h_θ (x),y）=−ylog(h_θ (x))−((1−y)log⁡(1−h_θ (x)))</script><p>检验：<br>当 $y=1$时，$−log⁡(h_θ (x))$<br>当 $y=0$时，$−log⁡(1−h_θ (x))$  </p><p>那么代价函数可以写成：  </p><script type="math/tex; mode=display">J(θ)=-\frac{1}{m}[∑_{i=1}^m y^{(i)} log⁡(h_θ(x^{(i)} ))+(1−y^{(i)}) log(1−h_θ (x^{(i)}))]</script><p>对于代价函数，采用梯度下降算法求θ的最小值，其更新公式为：</p><script type="math/tex; mode=display">{θ_j≔θ_j−α\frac{∂J(θ)}{∂θ_j}}</script><p>代入梯度：    </p><script type="math/tex; mode=display">θ_j≔θ_j−α∑_{i=1}^m(h_θ (x^{(i)} )−y^{(i)} ) x_j^i</script>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>03. 逻辑回归与正则化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02. 系统概述</title>
    <link href="/2021/03/26/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/2.%20%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <url>/2021/03/26/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/2.%20%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="系统概述"><a href="#系统概述" class="headerlink" title="系统概述"></a>系统概述</h1><h2 id="系统的类型"><a href="#系统的类型" class="headerlink" title="系统的类型"></a>系统的类型</h2><p>系统可以用数学模型和框图来表示。<br>系统$H[·]$的基本数学模型是:   </p><script type="math/tex; mode=display">y(⋅)=H[f(⋅)]</script><p>称$y(⋅)$是系统的输出，$f(⋅)$是系统的输入。<br>因此对输入的处理与系统本身无任何关系。<br>按照系统的数学模型类型，系统可以分为即时系统（输出（称为系统的响应）仅与当前的输入（称为系统的激励）有关）和动态系统（响应与过去和现在的激励都有关系），离散系统（激励和响应都是离散信号）和连续系统（激励和响应都是连续信号）。  </p><p>本课程主要讨论动态系统。  </p><h2 id="系统的框图模型"><a href="#系统的框图模型" class="headerlink" title="系统的框图模型"></a>系统的框图模型</h2><p>表示系统基本功能的常用单元有：积分器（连续）/延迟单元（离散），加法器，数乘器，延时器。<br>它们的框图如下图（《信号与线性系统分析》）所示。<br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210319202256.png" alt=""><br>通常的系统方程是左边为系统的输出结果，右边为系统的输入结果。<br>给定已知框图，写出对应的方程的流程通常是：  </p><ol><li>找到系统中的数个加法器，通过分析加法器的来源信号列出等式。  </li><li>将等式进行处理，最终得到$f(t)$与$y(t)$的方程。  </li></ol><h2 id="线性时不变系统的特性"><a href="#线性时不变系统的特性" class="headerlink" title="线性时不变系统的特性"></a>线性时不变系统的特性</h2><h3 id="线性"><a href="#线性" class="headerlink" title="线性"></a>线性</h3><p>线性包含两个内容： 齐次性和可加性。<br>若系统满足：  </p><script type="math/tex; mode=display">H[af(·)]=aH[f(·)]</script><p>称系统$H(·)$具有齐次性。<br>若系统满足：  </p><script type="math/tex; mode=display">H[f_1(·)+f_2(·)]=H[f_1(·)]+H[f_2(·)]</script><p>称系统$H(·)$具有可加性。<br>若以上两点系统$H(·)$都满足，即：</p><script type="math/tex; mode=display">H[C_1f_1(·)+C_2f_2(·)]=C_1H[f_1(t)]+C_2H[f_2(t)]</script><p>称系统是线性的。<br><strong>动态系统的线性判别</strong><br>动态系统的响应$y(·)$与初始状态$x(0)$和系统激励$f(·)$相关，称<strong>输入信号为0（$f(t)=0$）时，仅有初始状态引起的响应叫零输入响应$y_{zi}$</strong>； <strong>初始状态为0（$x(0)=0$）时，仅由输入信号引起的响应叫零状态响应$y_{zs}$</strong>。线性系统的全响应可以分解为这两种响应，称为线性系统的分解特性。<br>如果系统有多个初始状态或/和多个输入信号，对于每一个输入的零状态响应和对于每一个零输入响应都呈现线性，称为零状态/零输入线性。<br><strong>如果一个系统具有分解特性、零状态/零输入线性特性，则该系统是线性系统。</strong><br>因此求解一个动态系统是否是线性系统的步骤：  </p><ol><li>判断系统的零状态响应和零输入响应，将其相加判断是否满足分解性。  </li><li>令$f_3(t)=f_1(t)+f_2(t)$，带入零状态响应和零输入响应，看两者是否分别满足线性。  </li></ol><h3 id="时不变性"><a href="#时不变性" class="headerlink" title="时不变性"></a>时不变性</h3><p>如果系统的参数都是不随着时间变化的常数，称这样的系统是时不变系统。<br>判断方法：系统的输出与激励时移的时间无关，即：  </p><script type="math/tex; mode=display">y(t-τ)=H[f(t-τ)],y(t)=H[f(t)]</script><p><strong>动态系统的时不变性判别</strong>  </p><ol><li>找出系统的零状态。  </li><li>带入$f(t-τ)$，看系统结果是否是$y(t-τ)$。  </li></ol><h3 id="因果性"><a href="#因果性" class="headerlink" title="因果性"></a>因果性</h3><p>如果视激励为响应产生的原因，零状态响应是激励的结果，那么响应不应该出现于激励之前。 换句话说，系统的响应不应该与未来的激励有关，而只与现在和过去的激励有关。<br>称这样的系统为因果系统，因果系统只在以时间为变量的系统中出现。<br>对于系统输出$y(t_r)$,如果系统输入$x(t_i)$导致$t_i&gt;t_r$，此时系统的因果性被破坏，系统不具有因果性。  </p><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>如果系统的激励是有界的，且零状态响应也是有界的，称这样的系统是稳定系统。  </p><h2 id="LTI系统分析方法概述"><a href="#LTI系统分析方法概述" class="headerlink" title="LTI系统分析方法概述"></a>LTI系统分析方法概述</h2><h3 id="描述系统的方法"><a href="#描述系统的方法" class="headerlink" title="描述系统的方法"></a>描述系统的方法</h3><ul><li>输入-输出法<br>只把输入变量和输出变量作为描述的因素，系统内部的结构视作黑箱。  </li><li>状态变量法<br>状态变量法用两个方程描述系统：  <ol><li>状态方程：描述系统内部状态与输入的关系。  </li><li>输出方程： 描述系统内部响应与输入和状态变量之间的关系。  </li></ol></li></ul><h3 id="求解系统方程的方法"><a href="#求解系统方程的方法" class="headerlink" title="求解系统方程的方法"></a>求解系统方程的方法</h3><ul><li>时域分析法<br>直接分析时间变量函数。连续系统通常由微分方程描述，离散系统通常由差分方程描述。因此直接求解对应的以时间为变量的方程。此外还有卷积方法。  </li><li>变换法<br>对时间变量函数转换为某个域中以其他因素作为变量的函数。  </li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>信号与系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>5.7. 神经网络的优化</title>
    <link href="/2021/03/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/5.%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/5.7.%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <url>/2021/03/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/5.%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/5.7.%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h1><h2 id="参数展开"><a href="#参数展开" class="headerlink" title="参数展开"></a>参数展开</h2><p>参数展开是一种将矩阵展开为向量的方法，常用于很多高级优化中。<br>例如如下的高级优化：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">function[jVal,gradient]=costFunction(theta)<br>...<br>optTheta=fminunc(@costFunction,initialTheta,options)<br></code></pre></td></tr></table></figure><br>fminuc是一种高级的优化算法。这些高级优化算法的输入值的形式都是参数向量。<br>在神经网络中，很多参数并非是向量的形式，而是完整的矩阵，比如第l层的参数矩阵$Θ^{(l)}$和梯度矩阵$D^{(l)}$(见5.1.)，这时就需要应用参数展开将这些矩阵展开为向量，方法是在Octave中应用<code>[;]</code>表达将所有的元素从矩阵中取出，展开成一个长向量，并应用<code>reshape</code>语法重新合成矩阵。<br>比如如下的10层神经网络：<br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/master/img/20210204151039.png" alt="">   </p><h2 id="梯度检测"><a href="#梯度检测" class="headerlink" title="梯度检测"></a>梯度检测</h2><p>反向传播算法的实现过程非常的繁琐，因此在与其他算法一同工作的时候可能会产生一些bug，这些bug可能本身不会影响程序的运行，但是最终输出的模型准确度可能会非常低。 因此需要引入梯度检测(Gredient Check)来解决反向传播算法或类梯度下降算法中出现的这类问题。  </p><ul><li>从数值上近似梯度<br>要想求出代价函数$J(\Theta)$在某一点$\theta$的梯度（在二维内反映为该点的斜率），可以在$\theta$的两边取$\theta \plusmn \epsilon, \epsilon \rightarrow 0$,$\theta$处的梯度可以近似的表示为（实数形式）：<script type="math/tex; mode=display">\frac{dJ(θ )}{dθ }≈  \frac{J(θ +ε )-J(θ -ε )}{2ε }</script>称为双侧差分（Two-side difference）。<br>当$\theta$是$\Theta^{(i)}$的展开时，可以用双侧差分来估计所有的偏导数项：<script type="math/tex; mode=display">\frac{∂ J(θ)}{∂ θ_k}≈ \frac{J(θ _k+ε ,θ_1,...,θ_n )-J(θ _k-ε ,\theta_1,...,θ_n  )}{2ε }</script>在Octave中用如下的代码实现：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Cpp"><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>:n,<br>  thetaPlus=theta;<br>  thetaPlus=thetaPlus(i)+epsilon;<br>  thetaMinus=theta;<br>  thetaMinus(i)=thetaMinus(i)-epsilon;<br>  gradApprox(i)=(J(thetaPlus)-J(thetaMinus))/(<span class="hljs-number">2</span>*epsilon);<br>end;<br>Check gradApprox≈DVec<br></code></pre></td></tr></table></figure></li><li>总结流程<ol><li>利用反向传播算法算出$D^{(i)}$的展开向量DVec</li><li>利用双侧差分计算gradApprox</li><li>DVec和gradApprox作比较    </li><li>关闭双侧差分，利用反向传播进行训练（以提高训练时的算法效率）</li></ol></li></ul><h2 id="随机初始化"><a href="#随机初始化" class="headerlink" title="随机初始化"></a>随机初始化</h2><p>在最开始执行高级优化或者是神经网络的梯度下降时，应当对$Θ$设置一些初始值，即初始化$Θ$。<br>在逻辑回归中，将参数全部初始化为0的做法会导致神经网络中一个单元出发的所有的参数都相等，导致神经网络中所有的隐藏单元都在计算相同的特征。正确的做法是对$Θ$随机地设定一些值来初始化它，具体的做法是：<br>设置某个区间$[-ϵ,ϵ]$，使得所有$θ$都在这个区间内随机取到，用Octave代码实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">theta1 = rand(<span class="hljs-number">10</span>,<span class="hljs-number">11</span>)*(<span class="hljs-number">2</span>*init_epsilon)-init_epsilon; <br><span class="hljs-meta">#rand()的作用是随机生成一个mxn的矩阵，矩阵里面所有的元素值都介于0,1之间。</span><br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>05. 神经网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>5.6. 回顾：神经网络的实现与梯度下降算法</title>
    <link href="/2021/03/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/5.%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/5.6.%20%E6%95%B4%E5%90%88%E5%88%B0%E4%B8%80%E8%B5%B7/"/>
    <url>/2021/03/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/5.%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/5.6.%20%E6%95%B4%E5%90%88%E5%88%B0%E4%B8%80%E8%B5%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="回顾：神经网络的实现与梯度下降算法"><a href="#回顾：神经网络的实现与梯度下降算法" class="headerlink" title="回顾：神经网络的实现与梯度下降算法"></a>回顾：神经网络的实现与梯度下降算法</h1><h2 id="搭建神经网络"><a href="#搭建神经网络" class="headerlink" title="搭建神经网络"></a>搭建神经网络</h2><h3 id="选择神经网络的架构"><a href="#选择神经网络的架构" class="headerlink" title="选择神经网络的架构"></a>选择神经网络的架构</h3><p>即选择神经元之间的连接模式，和神经网络的层数，每一层的单元数。   </p><ul><li>输出和输入单元<br>输入单元的数目由分类问题中要区分的类别个数，即特征的维度数量所确定。<br>注意：多元分类问题中输出单元应该是一个多维的向量，对应的维度为1。</li><li>隐藏层<br>通常只有一层隐藏层；如果选择构建多个隐藏层，通常情况下每一个隐藏层中的单元数都是相同的。<br>单元数越多越好，但是隐藏单元数的增加会导致计算量的增大。因此每一个隐藏层中隐藏单元的数目通常与输入层的维度，即特征的数目相匹配（是特征数目的整数倍$k=1,2,3…$）。</li></ul><h3 id="训练神经网络"><a href="#训练神经网络" class="headerlink" title="训练神经网络"></a>训练神经网络</h3><ol><li>随机初始化权重，通常初始化为接近于0的值。</li><li>执行前向传播算法，得到$h_θ(x^{(i)})$的值。</li><li>计算代价/损失函数$J(Θ)$。</li><li>执行方向传播算法来计算$\frac{∂}{∂Θ_{jk}^{(l)}}J(Θ)$具体执行方法是用一个循环<code>for i = 1:m</code>对每一个样本执行前向传播和反向传播算法，得到每一个单元的激励值$a^{(l)}$和误差$δ^{(l)}$。</li><li>使用梯度检查，将反向传播算法得到的$\frac{∂}{∂Θ_{jk}^{(l)}}J(Θ)$与用数值近似得到的$J(Θ)$的梯度进行比较，确定两个值是接近的。</li><li>停用梯度检查。  </li><li>用梯度下降算法或者其他的一些高级的优化方法与反向传播算法结合，并最小化$J(Θ)$的$Θ$。  </li></ol><h2 id="梯度下降算法在神经网络中的应用"><a href="#梯度下降算法在神经网络中的应用" class="headerlink" title="梯度下降算法在神经网络中的应用"></a>梯度下降算法在神经网络中的应用</h2><p><img src="![](https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210319212547.png" alt=""><br>如图所示的参数与$J(Θ)$的关系中（图中只有两个参数），图中每一点的高度表示了$J(Θ)$的值，也代表了在该点的参数取值下，预测值$h_Θ(x^{(i)})$与实际标签$y^{(i)}$的差距。<br>同之前一样，梯度下降算法从随机的一点开始求这一点的梯度（即下降的最快方向），然后沿着梯度方向持续下降，直到得到局部最优点。</p><h2 id="案例：-ALVINN无人驾驶转向"><a href="#案例：-ALVINN无人驾驶转向" class="headerlink" title="案例： ALVINN无人驾驶转向"></a>案例： ALVINN无人驾驶转向</h2><p>Dean Pomerieau使用三层神经网络ALVINN来训练计算机进行无人驾驶。<br>将汽车转向进行量化，左急转和右急转分别对应了坐标轴上仅有的两个极值点。 每隔两秒，ALVINN就会生成一张前方的路况图，并记录驾驶者的行驶方向，在最开始ALVINN的转向是随机的，通过训练路况图和行驶方向的关系，ALVINN最终做出的转向决定与人类驾驶员的转向基本相同。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>05. 神经网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>5.5. 代价函数·反向传播</title>
    <link href="/2021/03/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/5.%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/5.5.%20%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B0.%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/"/>
    <url>/2021/03/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/5.%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/5.5.%20%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B0.%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/</url>
    
    <content type="html"><![CDATA[<h1 id="代价函数·反向传播"><a href="#代价函数·反向传播" class="headerlink" title="代价函数·反向传播"></a>代价函数·反向传播</h1><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>接下来的讲义主要考虑两种分类问题：第一种是二元分类，如之前的讲义所述，y的取值只能是0或者1，输出层只有一个输出单元，假设函数的输出值是一个实数；第二种是多元分类，y的取值是一个k维的向量，输出层有k个输出单元。</p><h2 id="神经网络的代价函数形式"><a href="#神经网络的代价函数形式" class="headerlink" title="神经网络的代价函数形式"></a>神经网络的代价函数形式</h2><p>假设一个神经网络训练集有m个训练样本：${(x^{(1)},y^{(1)}),(x^{(2)},y^{(2)}),…,(x^{(m)},y^{(m)})}$<br>$L$表示神经网络的总层数，$s_l$表示$l$层中神经元的数量（不包括偏置神经元）。<br>在神经网络中使用的代价函数是在逻辑回归中使用的正则化代价函数：  </p><script type="math/tex; mode=display">J(θ)=-\frac{1}{m}[∑_{i=1}^m y^{(i)} log⁡(h_θ(x^{(i)} ))+(1−y^{(i)}) log(1−h_θ (x^{(i)}))]+\frac{λ}{2m}∑_{j=1}^n θ_j^2</script><p>略微不同的是，在神经网络中分类标签和假设函数的输出值都变成了k维的向量，因此神经网络中的代价函数变成了：  </p><script type="math/tex; mode=display">J(θ)=-\frac{1}{m}[∑_{i=1}^m ∑_{k=1}^Ky_k^{(i)} log⁡(h_θ(x^{(i)} )_k)+(1−y_k^{(i)}) log(1−h_θ (x^{(i)})_k)]+\frac{λ}{2m}∑_{l=1}^{L-1}∑_{j=1}^{s_l}∑_{j=1}^{s_l+1} (Θ_{ji}^{(l)})_j^2</script><p>解释：  </p><ol><li>用$(h_Θ(x))_i$来表示第i个输出  </li><li>这个代价函数中$∑_{k=1}^K$表示所有的输出单元之和，这里主要是将$y_k$的值与$(h_Θ(x))_k$的大小作比较   </li><li>正则项的作用是去除那些对应于偏置单元的项，具体而言就是不对$i=0$的项进行求和和正则化。  </li></ol><h2 id="代价函数最小化：反向传播算法"><a href="#代价函数最小化：反向传播算法" class="headerlink" title="代价函数最小化：反向传播算法"></a>代价函数最小化：反向传播算法</h2><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>同之前的线性回归和逻辑回归一样，接下来要求得代价函数的最小值$J(Θ)min$并求出$Θ$。主要的步骤是写出$J(Θ)$并求关于每一个$Θ_{ij}^{(l)}$的偏导项$\frac{∂}{∂Θ_{ij}^{(l)}}J(Θ)$。<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210201185117.png" alt=""><br>现在先来讨论如上图所示的神经网络中，只有一个训练样本$(x,y)$的情况：<br>首先先用前向传播算法（见讲义4.2）验证假设函数是否会真的输出结果:    </p><script type="math/tex; mode=display">a^{(1)}=x</script><script type="math/tex; mode=display">z^{(2)}=Θ^{(1)}a^{(1)},并增加一个偏置单元</script><script type="math/tex; mode=display">a^{(2)}=g(z^{2})</script><script type="math/tex; mode=display">z^{(3)}=Θ^{(2)}a^{(2)},并增加一个偏置单元</script><script type="math/tex; mode=display">a^{(3)}=g(z^{3})</script><script type="math/tex; mode=display">z^{(4)}=Θ^{(3)}a^{(3)}</script><script type="math/tex; mode=display">a^{(4)}=g(z^{4})=h_Θ(x)</script><p>接下来，为了计算关于每一个$Θ_{ij}^{(l)}$的偏导项$\frac{∂}{∂Θ_{ij}^{(l)}}J(Θ)$，就要用到<strong>反向传播算法</strong>（Backpropagation）。<br>从直观上说，对于每一个节点，都要计算每个节点的误差：$δ^{(l)}_j$,表示第l层第j个节点的误差。  </p><script type="math/tex; mode=display">δ^{(l)}_j=a_j^{(l)}-y_j=(h_Θ(x))_j-y_j</script><p>y表示训练集中y向量里的第j个元素的值。<br>其向量形式：  </p><script type="math/tex; mode=display">δ^{(l)}=a^{(l)}-y</script><p>这里的$δ^{(l)}$和$a^{(l)}$都是一层每一个误差/输出所构成的向量。<br>具体而言，对于上图所示的4层（$L=4$）神经网络,第四层的误差项：  </p><script type="math/tex; mode=display">δ^{(4)}=a^{(4)}-y</script><p>照例写出前面两层的误差：  </p><script type="math/tex; mode=display">\delta^{(3)}=(Θ^{(3)})^Tδ^{(4)}⋅g'(z^{(3)})</script><script type="math/tex; mode=display">\delta^{(2)}=(Θ^{(2)})^Tδ^{(3)}⋅g'(z^{(2)})</script><p>事实上应用微积分的链式法则，$g’(z^{(3)})=a^{(3)}⋅(1-a^{(3)})$,1是一个每项都为1的向量。<br>反向传播的步骤相当于是从最后一层开始求误差，然后将最后一层的误差传给前一层，反向依次传播。<br>最终将会有： </p><script type="math/tex; mode=display">\frac{∂}{∂Θ_{ij}^{(l)}}J(Θ)=a^{(l)}_iδ^{(l+1)}_i</script><p>此处忽略了正则化项：$λ$。<br>现在将反向传播算法从一个训练样本拓展到一个有m个训练样本：${(x^{(1)},y^{(1)}),(x^{(2)},y^{(2)}),…,(x^{(m)},y^{(m)})}$,$L$层的神经网络训练集：      </p><p>定义$Δ_{ij}^{(l)}=0$用于计算$\frac{∂}{∂Θ_{ij}^{(l)}}J(Θ)$,接下来遍历整个训练集：<br>For $i=1$ to $m$:<br>  set $a^{(1)}=x^{(i)}$ #用于将所有的x输入到输入层的激活函数中<br>  用正向传播算法计算$a^{(l)}~for~l=2,3,…,L$<br>  $δ^{(L)}=a^{(L)}-y^{i}$ #计算最后一层的误差<br>  用反向传播算法计算$\delta^{(L-1)}$到$δ^{(2)}$,<br>  $Δ^{(l)}_{ij}:=Δ^{(l)}_{ij}+a_j^{(l)}δ^{(l+1)}_i$<br>  (写成向量的形式：$Δ^{(l)}:=Δ^{(l)}+δ^{(l+1)}(a_j^{(l)})^T$)<br>结束循环后，令  </p><script type="math/tex; mode=display">D^{(l)}_{ij}:=\begin{cases}    \frac{1}{m}Δ^{(l)}_{ij},j=0       \frac{1}{m}Δ^{(l)}_{ij}+λΘ^{(l)}_{ij},j \not=0 \end{cases}</script><p>那么最终：  </p><script type="math/tex; mode=display">\frac{∂}{∂Θ_{ij}^{(l)}}J(Θ)=D^{(l)}_{ij}</script><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><ul><li>回顾：前向传播模型<br>前向传播的整个过程可以用下图表示：<br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210319212706.png" alt=""><br>比如：如果洋红色的部分其权重为$Θ_{10}^{(2)}$,红色的权重值为$Θ_{11}^{(2)}$，青色的权重值是$Θ_{12}^{(2)}$， 那么$z_1^{(3)}=Θ_{10}^{(2)} \times 1+Θ_{11}^{(2)} × a_1^{(2)}+Θ_{12}^{(2)}×a_1^{(2)}$。<br>反向传播的过程和前向传播非常类似，只是传播的方向不同。  </li><li>反向传播的理解<br>关注反向传播的代价函数：   <script type="math/tex; mode=display">J(θ)=-\frac{1}{m}[∑_{i=1}^m ∑_{k=1}^Ky_k^{(i)} log⁡(h_θ(x^{(i)} )_k)+(1−y_k^{(i)}) log(1−h_θ (x^{(i)})_k)]+\frac{λ}{2m}∑_{l=1}^{L-1}∑_{j=1}^{s_l}∑_{j=1}^{s_l+1} (Θ_{ji}^{(l)})_j^2</script>对于单个的样本:$(x^{(i)},y^{(i)})$，只有一个输出单元并且忽略正则化，那么这个样本的代价函数：  <script type="math/tex; mode=display">Cost(i)=y^{(i)} log⁡(h_θ(x^{(i)} ))+(1−y^{(i)}) log(1−h_θ (x^{(i)}))</script>这个代价函数的功能类似于计算方差，可以近似的看做是方差函数：  <script type="math/tex; mode=display">Cost(i)≈(h_\Theta(x^{(i)})-y^{(i)})^2</script>它反应了样本模型输出值和样本值的接近程度。<br>反向传播中每个节点的误差：$δ^{(l)}_j$,表示第l层第j个节点的误差。有：   <script type="math/tex; mode=display">δ^{(l)}_j=\frac{\partial}{∂z_j^{(l)}}Cost(i)</script>$z_j^{(l)}$与$h_\Theta(x^{(i)})$相关。  </li></ul><p>  反向传播的整个过程可以用下图表示：<br><img src="https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210319212735.png" alt=""><br>  例如对$δ^{(2)}_2$，洋红色和红色箭头分别表示两个权重值$Θ_{12}^{(2)}$和$Θ_{22}^{(2)}$，有  </p><script type="math/tex; mode=display">δ^{(2)}_2=Θ_{12}^{(2)} ×δ^{(3)}_1 +Θ_{22}^{(2)} ×δ^{(3)}_2</script>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>05. 神经网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>5.4. 多元分类</title>
    <link href="/2021/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/5.%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/5.4.%20%E5%A4%9A%E5%85%83%E5%88%86%E7%B1%BB/"/>
    <url>/2021/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/5.%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/5.4.%20%E5%A4%9A%E5%85%83%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="多元分类"><a href="#多元分类" class="headerlink" title="多元分类"></a>多元分类</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>一对多分类的实质是对一对一分类的拓展。<br>基本方法是建立一个多输出的神经网络，因此<strong>在多元分类中，最终的输出结果将是一个n维的向量</strong>，输出层的每一个输出单元用于判断是否是某一类（例如：是否是行人，是否是自行车），当判断为结果是某一类时，在理想情况下，这个网络会在这一输出单元输出1，其他的输出单元输出0，最终输出的结果是如：$h_Θ(x)≈\left[\begin{smallmatrix} 1 \\\ 0 \\\ 0 \\\ 0 \end{smallmatrix}\right]$之类的向量。<br>以前我们在训练集中用一个整数y来表示分类的标签，在多元分类中，我们使用如上所示的向量来表示分类的标签。<br>现在假设函数的模型应该为：</p><script type="math/tex; mode=display">h_Θ(x^{(i)})≈y^{(i)}</script><p>等式的左右两边输出的结果都是n维的向量。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>05. 神经网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>5.3. 神经单元的逻辑函数功能</title>
    <link href="/2021/03/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/5.%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/5.3.%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E9%80%BB%E8%BE%91%E5%87%BD%E6%95%B0/"/>
    <url>/2021/03/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/5.%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/5.3.%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E9%80%BB%E8%BE%91%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><style><br>img{<br>    width: 50%;<br>    padding-left: 20%;<br>}</style></p><h1 id="神经单元的逻辑函数功能"><a href="#神经单元的逻辑函数功能" class="headerlink" title="神经单元的逻辑函数功能"></a>神经单元的逻辑函数功能</h1><p>思考下面一个例子：<br>如果$x_1,x_2$都为二进制数，如图有四个样本分布在样本空间内，<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210101151549.png" alt=""><br>那么假设函数可以写成：</p><script type="math/tex; mode=display">y=x_1 XNOR x_2</script><p>那么神经网络是否可以生成这样的函数呢？ </p><h2 id="简单逻辑函数的实现——AND-OR-NOT"><a href="#简单逻辑函数的实现——AND-OR-NOT" class="headerlink" title="简单逻辑函数的实现——AND,OR,NOT"></a>简单逻辑函数的实现——AND,OR,NOT</h2><p>为了解决这个问题，我们从AND函数入手：<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210101151722.png" alt=""><br>如图，输入层有两个特征$x_1$和$x_2$，他们是二进制数。目标函数为$y=x_1 AND x_2$.  </p><p><strong>观察激活函数$y=g(x)$,我们发现当$x=4$时，$y=0.99$,当$x=-4$时，$y=0.01$</strong><br>由上述激活函数的性质，为了计算这样的神经网络，首先先增加一个偏置单元 【+1】，对每个单元赋予权重：-30，20,20<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210101152043.png" alt=""><br>列出真值表：  </p><script type="math/tex; mode=display">\begin{array}{lcr}x_1 & x_2 & h_θ(x) \\\    0 & 0 & g(-30)≈0 \\\   0 & 1 & g(-10)≈0  \\\  1 & 0 & g(-10)≈0  \\\  1 & 1 & g(10)≈1 \\\  \end{array}</script><p>观察最后一列，我们发现最后一列的输出事实上很接近与AND函数的结果，那么可以认为$h_θ(x) ≈ x_1 AND x_2$</p><p>那么同理，下图的神经网络最终可以生成一个类似于OR函数的假设函数。<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210101152850.png" alt="">  </p><p>下图的神经网络最终可以生成一个类似于NOT函数的假设函数。<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210101153145.png" alt=""><br>可以发现NOT是通过给对应的单元施加一个较大的负数来实现的。</p><h2 id="复杂逻辑函数的实现"><a href="#复杂逻辑函数的实现" class="headerlink" title="复杂逻辑函数的实现"></a>复杂逻辑函数的实现</h2><p>下面我们来试试生成如下的函数：  </p><script type="math/tex; mode=display">h_θ(x)=(NOT x_1)AND(NOT x_2)</script><p>分析：<br>要想使$h_θ(x)=1$,那么当且仅当$x_1=x_2=0$时成立，最终的神经网络如下图所示：<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210101154246.png" alt="">   </p><p>现在我们可以应付本节一开头的问题了——如何使神经网络生成$y=x_1 XNOR x_2$？<br>分析： </p><script type="math/tex; mode=display">x_1XNORx_2=NOT(X_1 XOR X_2)=(x_1 AND x_2)OR((NOT x_1) AND (NOT x_2))</script><p>以逻辑表达式形式书写：</p><script type="math/tex; mode=display">h_θ(x)=(x_1.x_2)+\overline{x_1}.\overline{x_2}</script><p>将它分层：<br>第一层： 获取$x_1$和$x_2$<br>第二层：计算  $a_1^{(2)}=x_1.x_2$  和  $a_2^{(2)}=\overline{x_1}.\overline{x_2}$.<br>第三层：计算  $a_1^{(2)}+a_2^{(2)}$.<br>通过这一节的前半部分，我们已经知道了每一层所需要的函数的神经网络构建方法，最终的神经网络将是：<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210101155720.png" alt="">   </p><blockquote><p>实例： 可视化Minst手写字符数据集识别</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>05. 神经网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>5.2. 前向传播模型</title>
    <link href="/2021/03/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/5.%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/5.2.%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9E%8B/"/>
    <url>/2021/03/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/5.%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/5.2.%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p><style><br>img{<br>    width: 60%;<br>    padding-left: 20%;<br>}</style></p><h1 id="前向传播模型"><a href="#前向传播模型" class="headerlink" title="前向传播模型"></a>前向传播模型</h1><h2 id="神经元模型"><a href="#神经元模型" class="headerlink" title="神经元模型"></a>神经元模型</h2><ul><li>假设： 大脑对于不同功能（听觉，视觉，触觉的处理）的实现是依赖于同样的学习方法  </li><li>依据： 神经重接实验  </li><li>神经元模型<br>神经网络模拟了大脑中的神经元或者是神经网络。先来看大脑中的神经元构成，我们会发现神经元有很多的输入通道（树突），同时通过轴突给其他的神经元传递信号。  将神经元简单抽象：一个计算单元，它从输入端接收一定数目的信息，并作一些处理，并将结果传递给其他的神经元。</li></ul><p>在计算机中，我们构建一个逻辑单元，它从输入端接收数据集X，并作处理来生成一个激活函数$h_θ (x)=\frac{1}{1+e^{-θ^T X}}$<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20201229183932.png" alt=""><br>在这个模型之上，输入端会额外增加一个$x_0=1$，称为偏置单元。<br>在神经网络中，$Θ$称为模型的权重，$g(z)=\frac{1}{1+e^{-z}}$称为激活函数。  </p><p>神经网络是一组神经元连接在一起的集合，如图所示<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20201229184740.png" alt=""><br>第一层称为输入层，我们在这一层输入全部的特征，最后一层称为输出层，这一层的神经元输出假设的最终结果，中间的层称为隐藏层，隐藏层可能不止有一层。<br>统一地，$a_i^{(j)}$将表示第j层的第i个激活项（激活指计算并输出结果），同时，第j层到第j+1层之间的映射由参数矩阵$Θ^{(j)}$确定，那么上图就可以用公式表示为：</p><script type="math/tex; mode=display">a_1^{(2)}=g(Θ_{10}^{(1)}x_0+Θ_{11}^{(1)}x_1+Θ_{12}^{(1)}x_2+Θ_{13}^{(1)}x_3)</script><script type="math/tex; mode=display">a_2^{(2)}=g(Θ_{20}^{(1)}x_0+Θ_{21}^{(1)}x_1+Θ_{22}^{(1)}x_2+Θ_{23}^{(1)}x_3)</script><script type="math/tex; mode=display">a_3^{(2)}=g(Θ_{30}^{(1)}x_0+Θ_{31}^{(1)}x_1+Θ_{32}^{(1)}x_2+Θ_{33}^{(1)}x_3)</script><script type="math/tex; mode=display">h_{Θ}(x)=g(Θ_{10}^{(2)}a_0^{(2)}+Θ_{11}^{(2)}a_1^{(2)}+Θ_{12}^{(2)}a_2^{(2)}+Θ_{13}^{(2)}a_3^{(2)})</script><p>如果一个网络在第j层有$s_j$个单元，且在第j+1层有$s_j+1$个单元，那么矩阵$Θ^{(j)}$的维度为$s_{j+1} \times (s_j+1)$</p><h2 id="神经网络的向量化-前向传输-Forward-propagation"><a href="#神经网络的向量化-前向传输-Forward-propagation" class="headerlink" title="神经网络的向量化:前向传输(Forward propagation)"></a>神经网络的向量化:前向传输(Forward propagation)</h2><p>对如上的等式，现在将$g()$中的线性加权组合以$z^{(2)}_1,z^{(2)}_2,z^{(2)}_3$表示，那么就有：</p><script type="math/tex; mode=display">a_1^{(2)}=g(z_1^{(2)})</script><script type="math/tex; mode=display">a_2^{(2)}=g(z_2^{(2)})</script><script type="math/tex; mode=display">a_3^{(2)}=g(z_3^{(2)})</script><p>现在就能够定义三个向量使得上述等式转化为向量乘法：<br>$x= \left[\begin{smallmatrix} x_0 \\\ x_1 \\\ x_2 \\\ x_3 \end{smallmatrix}\right]$, $z^{(2)}=\left[\begin{smallmatrix} z_1^{(2)}\\\ z_2^{(2)}\\\ z_3^{(2)}\end{smallmatrix}\right]=Θ^{(1)}x$，$a^{(2)}=\left[\begin{smallmatrix} a_1^{(2)}\\\ a_2^{(2)}\\\ a_3^{(2)}\end{smallmatrix}\right]$  </p><p>那么上述等式最终就可以转化成：</p><script type="math/tex; mode=display">z^{(2)}=Θ^{(1)}x</script><script type="math/tex; mode=display">a^{(2)}=g(z^{(2)})</script><p>对于隐藏层的偏置单元，增加一项$a_0^{(2)}=1$.<br>最后计算$z^{(3)}=Θ^{(2)}a^{(2)}$,那么最终得到的假设模型将会是：    </p><script type="math/tex; mode=display">h_{Θ}(x)=a^{(3)}=g(z^{(3)})</script><p>单看layer2 和 layer3，事实上，这两层做的就是逻辑回归，但输入进逻辑回归的特征不再是原始的特征x，而是通过原始特征生成的特征$a$。<br>而$a$与$x$之间的关系通过θ来定义。 因此可以通过改变$θ$来改变输入层和隐藏层之间的关系。</p><blockquote><p>下一章将说明如何调整$θ$的值来优化假设函数。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>05. 神经网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>5.1. 神经网络的背景</title>
    <link href="/2021/03/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/5.%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/5.1.%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%83%8C%E6%99%AF/"/>
    <url>/2021/03/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/5.%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/5.1.%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%83%8C%E6%99%AF/</url>
    
    <content type="html"><![CDATA[<p><style><br>img{<br>    width: 60%;<br>    padding-left: 20%;<br>}</style></p><h1 id="神经网络的背景知识"><a href="#神经网络的背景知识" class="headerlink" title="神经网络的背景知识"></a>神经网络的背景知识</h1><h2 id="激活函数算法的局限性"><a href="#激活函数算法的局限性" class="headerlink" title="激活函数算法的局限性"></a>激活函数算法的局限性</h2><p>假设一个数据集拥有非常多的原始特征和数据量，执行激活函数算法，那么次方项、交叉项会非常的多，计算量非常的大，最终的拟合结果也不好。<br>计算机视觉中的例子：<br>计算机读取到的是图片所对应的像素强度的矩阵。 </p><blockquote><p>对于灰度图像来说，像素强度就是每一个像素的灰度值。<br>对于RGB彩色图像来说，图片上的一个像素以三个值（R,G,B）/三维向量 来进行表示  </p></blockquote><p>如果现在设计一个分类器，使得计算机能够区分一个图片的主体是否为汽车。<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/472E9216086782CF8029F2818CA1027A.png" alt=""><br>以图中的pixel1 和 pixel2的位置为例，我们可以把所有数据集中pixel1和pixel2的像素强度投射到坐标轴上，如图使用一个非线性假设来对图像进行分类。<br>如果对于一个50*50像素的图片数据集，那么训练集中将包含至少2500个原始特征（7500 RGB），这时候用激活函数算法计算量会非常的大。  </p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>05. 神经网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>✨【置顶】本站说明</title>
    <link href="/2021/03/15/%E7%BD%AE%E9%A1%B6/"/>
    <url>/2021/03/15/%E7%BD%AE%E9%A1%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>1️⃣ 建议点击右上角【📚分类】查看文章<br>2️⃣ 由于本站暂未在中国大陆备案，因此会出现偶发性无法访问的情况，此时请先通过科学上网访问，在浏览器留下cookies之后便可正常访问本站⚡<br>3️⃣ 电脑端Chrome/Edge 等Chromium浏览器可以点击左下角的铃铛🔔订阅我的博客<br>4️⃣ 本博客所有文章全部为我手工编写。请尊重我的劳动成果，转载请注明出处，谢谢📖</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>常考知识点</title>
    <link href="/2021/03/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E8%B7%AF%E4%B8%8E%E5%99%A8%E4%BB%B6/%E7%94%B5%E8%B7%AF%E4%B8%8E%E5%99%A8%E4%BB%B6/"/>
    <url>/2021/03/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%B5%E8%B7%AF%E4%B8%8E%E5%99%A8%E4%BB%B6/%E7%94%B5%E8%B7%AF%E4%B8%8E%E5%99%A8%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="电路与器件常考知识点"><a href="#电路与器件常考知识点" class="headerlink" title="电路与器件常考知识点"></a>电路与器件常考知识点</h1><blockquote><p>针对Brunel University 2020: EE1618 Devices and Circuits的期末复习笔记<br>Lecturer: Dr. Ruiheng Wu（武瑞恒）/Dr. Chunsing Lai（赖俊升）<br>图因为挂在了github上，需要通过科技才能够看得到。</p></blockquote><h2 id="电学部分知识点"><a href="#电学部分知识点" class="headerlink" title="电学部分知识点"></a>电学部分知识点</h2><h3 id="静态电路分析"><a href="#静态电路分析" class="headerlink" title="静态电路分析"></a>静态电路分析</h3><h4 id="1-Y-Delta-形电路转换"><a href="#1-Y-Delta-形电路转换" class="headerlink" title="1. Y- $\Delta$ 形电路转换"></a>1. Y- $\Delta$ 形电路转换</h4><p>现推方法：<br>从Y电路的两个节点看整个电路，必然只有两个电阻被串联使用<br>从$\Delta$ 电路的两个节点看整个电路，电路呈现一个电阻与两个串联电阻并联的情况<br>列出两个电路的方程，求解即可<br>公式：  </p><script type="math/tex; mode=display">R_3=\frac{R_a R_b}{R_A+R_B+R_C}</script><blockquote><p>注：$R_3$是Y- $\Delta$ 形电路中属于Y的，且在$\Delta$电路中 $R_a$与$R_b$中间的电阻  </p><p>当$R_A=R_B=R_C$时，  </p><script type="math/tex; mode=display">R_Y=\frac{R_Δ}{3}</script></blockquote><h4 id="2-最大功率传输定理"><a href="#2-最大功率传输定理" class="headerlink" title="2. 最大功率传输定理"></a>2. 最大功率传输定理</h4><p>最大功率传输定理针对的是某一部分的最大功率<br>当负载$R_L$的电阻值与内电路电阻值相等时，有负载的功率最大<br>结合戴维南定理，可以将$R_L$外的所有部分等效为一个内电路，当<br>$R_L=R_{Th}$ 时有$R_L$的功率最大。  </p><h3 id="动态电路元件"><a href="#动态电路元件" class="headerlink" title="动态电路元件"></a>动态电路元件</h3><h4 id="1-电容"><a href="#1-电容" class="headerlink" title="1. 电容"></a>1. 电容</h4><ul><li><p>连接方式<br>   串联：</p><script type="math/tex; mode=display">\frac{1}{C_t}=\frac{1}{C_1}+\frac{1}{C_2}+...+\frac{1}{C_n}</script><p>   并联：</p><script type="math/tex; mode=display">C_t=C_1+C_2+...+C_n</script></li><li><p>动态响应方程<br>  时间常数：  </p><script type="math/tex; mode=display">\tau = RC</script><p>  未充电： 断路<br>  充电阶段：</p><script type="math/tex; mode=display">v_C(t)=E(1-e^{-\frac{t}{τ}})</script><script type="math/tex; mode=display">i_C(t)=\frac{E}{R}e^{-\frac{t}{τ}}</script><p>  充电完成：短路（理想）<br>  开关断开的瞬间:</p><script type="math/tex; mode=display">u(0_+)=u(0_-)</script><p>  放电阶段：  </p><script type="math/tex; mode=display">v_C(t)=Ee^{-\frac{t}{τ}}</script><script type="math/tex; mode=display">i_C=\frac{E}{R}e^{-\frac{t}{τ}}</script><p>  放电完成： 断路</p></li><li><p>交流电路响应<br>阻抗：  </p><script type="math/tex; mode=display">Z_c=X_c=-\frac{1}{ωC}j=\frac{V_m}{I_m}</script><blockquote><p>j是虚数单位</p></blockquote><p>随着频率的增加，阻抗会逐渐减小</p></li></ul><h4 id="2-电感"><a href="#2-电感" class="headerlink" title="2. 电感"></a>2. 电感</h4><ul><li>电感的定义<script type="math/tex; mode=display">L=\frac{Φ}{I}</script></li><li>连接方式<br>串联：<script type="math/tex; mode=display">L_t=L_1+L_2+...+L_n</script>并联：<script type="math/tex; mode=display">\frac{1}{L_t}=\frac{1}{L_1}+\frac{1}{L_2}+...+\frac{1}{L_n}</script></li><li><p>动态响应方程<br> 时间常数：  </p><script type="math/tex; mode=display">\tau = \frac{L}{R}</script><p>  未充电： 短路<br>  充电阶段：</p><script type="math/tex; mode=display">v_L(t)=Ee^{-\frac{t}{τ}}</script><script type="math/tex; mode=display">i_L(t)=\frac{E}{R}（1-e^{-\frac{t}{τ}}）</script><p>  充电完成：断路（理想）<br>  开关断开的瞬间:</p><script type="math/tex; mode=display">i(0_+)=i(0_-)</script><p>  放电阶段：  </p><script type="math/tex; mode=display">v_L(t)=Ee^{-\frac{t}{τ}}</script><script type="math/tex; mode=display">i_L=\frac{E}{R}e^{-\frac{t}{τ}}</script><blockquote><p>注：放电过程应当与L并联一个电阻以保护整个电路的安全，因此此处的R的阻值与原来相比已经发生了变化  </p></blockquote><p>  放电完成： 短路</p></li><li><p>交流电路响应<br>阻抗： </p><script type="math/tex; mode=display">Z_L=X_L= ωL=\frac{V_m}{I_m}</script><p>随着频率的增加，阻抗会逐渐增加</p></li><li><p>谐振<br>当电路处于谐振状态时， 有：  <strong>$-X_c=X_L$</strong><br>根据该公式可以求出谐振频率。<br>在谐振电路中：$I=\frac{E}{R}$<br>谐振的时候功率因子为1.<br>品质因数（Q）：</p><script type="math/tex; mode=display">Q=\frac{Q(power)}{P}=\frac{X_L}{R}（串联）=\frac{R}{X_c}(并联)</script></li></ul><h3 id="交流电基础"><a href="#交流电基础" class="headerlink" title="交流电基础"></a>交流电基础</h3><ol><li><p>复角表达<br>以 $v=V_msin(\omega t+ θ)$为例：</p><script type="math/tex; mode=display">v=V_msin(\omega t+ θ) →V_{rms} ∠θ</script><script type="math/tex; mode=display">V_{rms}=\frac{V_m}{\sqrt{2}}</script><script type="math/tex; mode=display">V=V_{rms}=V_{rms} ∠θ</script><blockquote><p>相位角相同才能用复角表示</p></blockquote></li><li><p>RLC-交流电电路的功率<br>平均功率/有功功率：</p><script type="math/tex; mode=display">P=V_{rms}I_{rms}cos\theta=\frac{V_{m}I_{m}}{2}cos\theta</script><blockquote><p>在不含LC的交流电电路中：$P=V_{rms}I_{rms}=\frac{V_{m}I_{m}}{2}$  </p></blockquote><script type="math/tex; mode=display">P=I_{rms}^2R</script><p>功率因子：</p><script type="math/tex; mode=display">cos\theta=\frac{P}{S}</script><p>视在功率：</p><script type="math/tex; mode=display">S=V_{rms}I_{rms}</script><script type="math/tex; mode=display">S=I_{rms}^2Z</script><p>无功功率：</p><script type="math/tex; mode=display">Q=V_{rms}I_{rms}sin\theta</script><script type="math/tex; mode=display">Q=I_{rms}^2X</script><script type="math/tex; mode=display">Q=\sqrt{S^2-P^2}</script><blockquote><p>一般采用通过计算P和S的方式来计算Q  </p></blockquote></li></ol><h3 id="无源滤波器"><a href="#无源滤波器" class="headerlink" title="无源滤波器"></a>无源滤波器</h3><ol><li><p>增益<br>功率增益：</p><script type="math/tex; mode=display">A_{p}=\frac{P_o}{P_i}</script><p>对数形式：</p><script type="math/tex; mode=display">A_{p}=10lg(\frac{P_o}{P_i})</script><blockquote><p>10  </p></blockquote><p>电压增益：</p><script type="math/tex; mode=display">A_{v}=\frac{V_o}{V_i}</script><p>对数形式：</p><script type="math/tex; mode=display">A_{v}=20lg(\frac{V_o}{V_i})</script><blockquote><p>20  </p></blockquote></li><li><p>滤波器电路的连接和功能  </p><ul><li>根据电容和电感频率响应的特性具体问题具体分析  </li><li>截止频率在$X_L=R$或者$X_C=R$时</li><li>相位角：$\theta=arctan(\frac{f_{cutoff}})$</li><li>在截止频率时，相位角为45°</li><li>无源带通滤波器的结构是高通和低通滤波器并联</li></ul></li></ol><h3 id="变压器"><a href="#变压器" class="headerlink" title="变压器"></a>变压器</h3><ol><li><p>变压器的性质</p><ul><li>变压器可以变换<strong>阻抗</strong>，<strong>电压</strong>，<strong>电流</strong></li><li>变压器的耦合系数：<script type="math/tex; mode=display">k=\frac{Φ_m}{Φ_p}</script><blockquote><p>$Φ_m$：次级磁通量，$Φ_p$：初级磁通量  </p></blockquote></li></ul><p>初级电动势：</p><script type="math/tex; mode=display">e_p=N_p \frac{d \Phi_p}{dt}=L_p\frac{d i_p}{dt}</script><p>次级电动势：</p><script type="math/tex; mode=display">e_s=N_s \frac{d \Phi_m}{dt}=kN_s \frac{d \Phi_p}{dt}</script></li><li><p>互感系数（Mutual Inductance）  </p><script type="math/tex; mode=display">M=N_s\frac{d \Phi_m}{di_p}=N_s \frac{d \Phi_p}{di_s}</script><script type="math/tex; mode=display">M=k\sqrt{L_p L_s}</script><p>有，</p><script type="math/tex; mode=display">e_p=M\frac{di_p}{dt}   和  e_p=M\frac{di_s}{dt}</script><blockquote><p>注意下标  </p></blockquote></li><li><p>比例关系  </p><script type="math/tex; mode=display">a=\frac{N_p}{N_s}=\frac{e_p}{e_s}=\frac{i_s}{i_p}</script></li></ol><h2 id="电子元件部分知识点"><a href="#电子元件部分知识点" class="headerlink" title="电子元件部分知识点"></a>电子元件部分知识点</h2><h3 id="半导体原理"><a href="#半导体原理" class="headerlink" title="半导体原理"></a>半导体原理</h3><ol><li>半导体类型<br>N型半导体： 填入电子<br>P型半导体： 抽去原有的电子  </li><li>PN结及性质<br>PN结： P型半导体和N型半导体拼接在一起，使得电流的方向仅能从P极到N极<br>正向偏置： 电流由P到N，P-N结的电阻非常的小，可视为短路<br>反向偏置： 电流由N到P，P-N结的电阻非常大，可视为断路  </li></ol><h3 id="二极管电路"><a href="#二极管电路" class="headerlink" title="二极管电路"></a>二极管电路</h3><ol><li><p><strong>二极管的单向导通性</strong><br>对于理想二极管，顺箭头方向可视为导线，逆箭头方向可视为断路  </p></li><li><p><strong>二极管电路分析</strong><br>先假设二极管是导通的，求出二极管所在支路的电流方向，如果解出电流方向为逆箭头方向，则实际的二极管处于反向偏置状态，假设错误；如果解出的电流方向为顺箭头方向，则二极管处于正向偏置状态，假设正确，以此来判断电路中的二极管是否处于导通状态  </p><blockquote><p>错误的假设情况下 需要重新计算电路</p></blockquote></li><li><p>非理想二极管的等效模型<br>非理想的二极管可以等效为一个理想的二极管和一个0.7V的直流电压源串联  </p></li><li><p>二极管的应用</p><ul><li><strong>半波整流器</strong><br>结构：交流电源和二极管串联<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20201225123418.png" alt=""><br>分析：交流电源的某一方向可以通过二极管，达到整流器的作用</li><li><strong>全波/桥式整流器</strong><br>结构：<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20201225123320.png" alt=""><br>分析： 无论是交流电源的前半期还是后半期，流过电阻的电流始终是同一个方向 </li></ul><ul><li>全波/变压器整流器<br>结构：<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20201225123456.png" alt=""><br>分析： 变压器的输出端被分成了两段，在交流电的前半期还是后半期，电流都能通过其中的一半电路，流过电阻的电流是同一个方向<blockquote><p>由于引入了变压器，这种整流器的噪声非常的大</p><ul><li>并联限流器<br>结构：二极管和直流电压源E串联<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20201225123629.png" alt=""><br>分析：当$|V_{sin}|<E$时，二极管导通$V_{out}=E$     当$|V_{sin}|>E$时，二极管导通$V_{out}=V_{sin}$</li><li><strong>峰值限流器</strong><br>结构：二极管和（电容器||电阻）结构串联<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20201225123629.png" alt=""><br>分析： 在交流电源的前半期，二极管导通，电容器断路，处于充电状态<br>  在交流电源的后半期，二极管断开，电容器放电维持电路的工作  </li></ul></blockquote></li></ul></li></ol><h3 id="运算放大器"><a href="#运算放大器" class="headerlink" title="运算放大器"></a>运算放大器</h3><ol><li><p>放大器的增益<br> 线性增益： 输出与输入的比值是一个定值<br> <strong>电压增益</strong>： $A_v=\frac{V_o}{V_i}$<br><strong>电流增益</strong>:  $A_i=\frac{I_o}{I_i}$<br> <strong>功率增益</strong>:  $A_P=\frac{P_o}{P_i}=A_vA_i$<br> <strong>增益的指数形式</strong>: $A_p=10lg{\frac{P_o}{P_i}}$  </p><blockquote><p>10  </p></blockquote><p>$A_v=20lg{\frac{V_o}{V_i}}$  </p><blockquote><p>20  </p></blockquote><p> 饱和状态： 对于有两个电源的运算放大器，输出电压不会超过最大/最小饱和电压  </p></li><li><p><strong>理想放大器的直流线性等效模型</strong>  </p><ul><li><p><strong>电压等效模型</strong><br>结构:<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20201225123821.png" alt=""><br>分析：</p><script type="math/tex; mode=display">\frac{V_s}{V_i}=\frac{R_s+R_i}{R_i} \tag{1}</script><script type="math/tex; mode=display">\frac{A_{V_o}V_i}{V_o}=\frac{R_O+R_L}{R_L} \tag{2}</script><script type="math/tex; mode=display">A_v=\frac{V_o}{V_s}=\frac{V_o}{V_i}\frac{V_i}{V_s}=\frac{A_{V_o}}{(1+\frac{R_s}{R_i})(1+\frac{R_O}{R_L})}</script><blockquote><p>对于理想的运算放大器:<br>$A_o=∞,R_i=∞,R_o=0$  </p></blockquote></li><li><p><strong>电流等效模型</strong>  </p></li></ul></li></ol><ol><li><p><strong>级联放大器的增益计算</strong></p><ul><li><strong>一般形式</strong>：<script type="math/tex; mode=display">A_t=\Pi A_i</script></li><li><strong>指数形式</strong>：<script type="math/tex; mode=display">A_t =\Sigma A_i</script></li></ul></li><li><p>运算放大器的符号和端口</p><ul><li>pin1：反相输入端</li><li>pin2：同相输入端 </li><li>pin3：输出端</li></ul></li><li><p><strong>运算放大器电路分析</strong></p><ul><li><strong>虚短路和虚接地</strong><br>在线性应用当中，电流从+ 流向 -时（同相输入）运算放大器的同相输入端和反相输入端之间可以认为是短路的，称为虚短路。<br>当电流从-流向+时（反相输入），反相输入端相当于接地，称为虚接地。</li><li><p><strong>反相输入的运算法放大器电路分析</strong><br>   电路图:<br>   <img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20201225123925.png" alt=""><br>   如图，<br>   由虚接地$V_-=0$:</p><script type="math/tex; mode=display">i_1=\frac{V_i}{R_1}</script><script type="math/tex; mode=display">i_2=\frac{-V_o}{R_2}</script><p>   同时，$i_1=i_2$<br>   电压增益：<strong>$A_v=\frac{V_o}{V_i}=-\frac{R_2}{R_1}$</strong>  </p><blockquote><p>反向放大器使用负反馈牺牲增益来增加精度  </p></blockquote><p> <strong>反相加法放大器（2个输入电阻的情况）</strong>：  </p><script type="math/tex; mode=display">i_1=\Sigma_{x=1}\frac{V_x}{R_x} \tag{1}</script><script type="math/tex; mode=display">i_2=\frac{-V_o}{R_f} \tag{2}</script><script type="math/tex; mode=display">i_1=i_2 \tag{3}</script><script type="math/tex; mode=display">V_o=-R_f \Sigma_{x=1}\frac{V_x}{R_x}</script></li><li><p>同相输入的运算放大器电路分析    </p><pre><code class="hljs">  电路图:</code></pre><p>   <img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20201225123941.png" alt=""><br>   如图，<br>   由虚短路$V_+=V_-=V_i$:  </p><script type="math/tex; mode=display">i_1=\frac{0-V_i}{R_1}</script><script type="math/tex; mode=display">i_2=\frac{V_o-V_i}{R_2}</script><p>   同时，$i_1=i_2$<br>   电压增益：<strong>$A_v=\frac{V_o}{V_i}=1+\frac{R_2}{R_1}$</strong>  </p><pre><code class="hljs">  同相加法放大器（2个输入电阻的情况）：  </code></pre><p>   设输入节点电压为$V_n$, 有：</p><script type="math/tex; mode=display">\frac{V_o}{V_n}=1+\frac{R_f}{R_b} \tag{1}</script><p>   由<em>叠加定理</em>：  </p><script type="math/tex; mode=display">V_n=\frac{R_2}{R_1+R_2}V_1+\frac{R_1}{R_1+R_2}V_2 \tag{2}</script><script type="math/tex; mode=display">V_o=(1+\frac{R_f}{R_b}) (\frac{R_2}{R_1+R_2}V_1+\frac{R_1}{R_1+R_2}V_2)</script></li></ul></li></ol><h3 id="三极管电路"><a href="#三极管电路" class="headerlink" title="三极管电路"></a>三极管电路</h3><ol><li>三极管电路的符号和三种模式 <ul><li>三极管有PNP和NPN型两种，无论是哪一种，三极管的箭头永远是在基极（B）和发射极（E）两端，由P型半导体指向N型半导体(即激活态下三极管BE的电流方向)</li><li>三种模式： <strong>激活态</strong>（相当于放大器）、截止态、饱和态（CE之间短路） </li></ul></li><li><p>激活状态下的电路分析  </p><ul><li><p>电流关系  </p><script type="math/tex; mode=display">i_E=i_B+i_c</script><script type="math/tex; mode=display">\frac{i_C}{i_B}=\beta</script><blockquote><p>当$β&gt;100$时，通常可以认为$i_C=i_E$  </p><script type="math/tex; mode=display">V_{BE}=0.7V</script><p>$V_B$和$V_E$的孰大孰小由半导体类型决定  </p><p>善用<em>戴维南等效定理</em>，对复杂的三极管电路进行化简</p></blockquote></li></ul><ul><li><strong>KVL在直流三极管电路下的应用</strong><br>如果E最后未接地而接的电源，则可以对BE间进行KVL分析，列出方程，结合电流关系解出方程 </li></ul></li></ol><h3 id="反馈模型"><a href="#反馈模型" class="headerlink" title="反馈模型"></a>反馈模型</h3><ol><li><strong>反馈模型的结构</strong><br> <img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20201225124457.png" alt=""><br>开环增益：当电路中没有反馈结构B时候的输入与输出之比：$A=\frac{x_o}{x_i}$</li><li><strong>反馈放大器的闭环增益</strong>  <script type="math/tex; mode=display">A_f=\frac{x_o}{x_i}=\frac{A}{1+AB}</script>推导：<script type="math/tex; mode=display">x_o=Ax_i \tag{1}</script><script type="math/tex; mode=display">x_f=Bx_o \tag{2}</script><script type="math/tex; mode=display">x_s=x_f+x_i=x_i+ABx_i \tag{3}</script><script type="math/tex; mode=display">A_f=\frac{x_o}{x_i}=\frac{A}{1+AB}</script></li><li><strong>反馈放大器的优点</strong><br>当$AB$足够大时，$A_f=\frac{1}{B}$,<br>反馈电路（B）通常是由无源器件（RLC）组成，因此此时的增益十分稳定而且可以直接精确地计算得出，即：<ul><li>准确</li><li>可预测</li><li>稳定 </li></ul></li></ol><h3 id="电闸管"><a href="#电闸管" class="headerlink" title="电闸管"></a>电闸管</h3><ol><li><p><strong>肖克利二极管</strong>  </p><ul><li><p>结构<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20201225124603.png" alt=""><br>两个PNP，NPN三极管串联，其中：<br>$B_1 →C_2$ 且 $C_1 →B_2$<br>$E_1=A,E_2=K$</p></li><li><p>特性曲线<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20201225124629.png" alt=""><br>当AK之间的电压非常小时,流过肖克利二极管的电流$I_A$非常小，即肖克利二极管表现大电阻的特性<br>当$V_{AK}=V_{BR}$时，A的三极管很容易饱和，此时会回落到某个电压，此后肖克利二极管可视为小电阻或者导线</p></li></ul></li><li><p><strong>锯齿波发生器</strong></p><ul><li>结构<br>肖克利二极管和电容器并联<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20201225124651.png" alt=""></li><li>分析<br>肖克利二极管和电容器两端的电压相等，设为$V_C$,<br>当$V_C<V_{BR}$时，肖克利二极管表现大电阻特性，电容器充电  当$V_C>V_{BR}$时，肖克利二极管表现小电阻特性（相当于短路），电容器迅速放电</li></ul></li><li><p><strong>SCR整流器</strong></p><ul><li>结构<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20201225124913.png" alt=""><br>两个三极管串联，其中：<br>$B_1 →C_2$ 且 $C_1 →B_2$<br>$E_1=A,E_2=K，B_2=G$</li><li><p>原理<br>给$B_2$一个非常小的电流$i_G$,</p><script type="math/tex; mode=display">i_{B2}=i_G</script><script type="math/tex; mode=display">i_{C2}=\beta_2 i_G=i_{B1}</script><script type="math/tex; mode=display">i_{C1}=\beta_1 i_{C2}=\beta_1 \beta_2 i_G=i_{B2}</script><script type="math/tex; mode=display">...</script><p>最终$i_{B2}$会非常大  </p></li><li><p>IG0=0时的特性曲线<br>同肖克利二极管</p></li></ul></li></ol><h3 id="标准电源调节"><a href="#标准电源调节" class="headerlink" title="标准电源调节"></a>标准电源调节</h3><ol><li><strong>线性调节公式</strong><script type="math/tex; mode=display">Line Regulation=\frac{\frac{\Delta V_{out}}{V_{out}}\times 100\%}{ΔV_{in}}</script></li><li><strong>串联电压调节器</strong><br>结构：<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20201225125122.png" alt=""></li><li><strong>调整晶体管电路</strong><br>结构：<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20201225124950.png" alt=""><br>原理：<br>肖克利二极管为运算放大器的+提供稳压的作用。<br>当$V_{out}$因为各种原因上升时，与之相连接的分压器$R_2-R_3$会分走一部分电压，对于放大器的反相输入端$V_-=\frac{R_3}{R_2+R_3}$,$V_-$上升，对于整个运算放大器的输入端，有：<script type="math/tex; mode=display">V_{in}(↓)=V_+(-)-V_-(↑)</script>因此输出端$V_{out}=V_{B}$下降，对于可控晶体管，其$V_B(↓)$导致$V_E(↓)$,最终调整$V_{out}(↓)$。<br>与此同时，$V_C(↓)$使得$V_{REF}(↑)$,使得$V_+$上升，但由于肖克利二极管的存在$V_+$的上升幅度不明显。</li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>电路与器件</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>0. 课程简介</title>
    <link href="/2021/03/01/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/0.%20%E8%AF%BE%E7%A8%8B%E7%AE%80%E4%BB%8B/"/>
    <url>/2021/03/01/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/0.%20%E8%AF%BE%E7%A8%8B%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="课程简介"><a href="#课程简介" class="headerlink" title="课程简介"></a>课程简介</h1><p>课程： BUL 2021： EE2622 Fundamentals of Signals and Systems<br>授课教师： Dr. Ruiheng Wu/ Zheng Luo (Assistant)  </p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《信号与线性系统分析》 第四版 吴大正主编 高等教育出版社<br>《信号与系统》 第二版 奥本海姆编 电子工业出版社  </p><h2 id="笔记结构"><a href="#笔记结构" class="headerlink" title="笔记结构"></a>笔记结构</h2><p>笔记按照课程内容顺序按数字编号，内容包括课堂笔记总结、知识点总结以及期末题目分析等等。  </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>信号与系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1.5. 多项式拟合和正规方程</title>
    <link href="/2021/02/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/1.%20%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/1.5.%20%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%8B%9F%E5%90%88%E5%92%8C%E6%AD%A3%E8%A7%84%E6%96%B9%E7%A8%8B/"/>
    <url>/2021/02/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/1.%20%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/1.5.%20%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%8B%9F%E5%90%88%E5%92%8C%E6%AD%A3%E8%A7%84%E6%96%B9%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="多项式拟合和正规方程"><a href="#多项式拟合和正规方程" class="headerlink" title="多项式拟合和正规方程"></a>多项式拟合和正规方程</h1><h2 id="特征点的创建和合并"><a href="#特征点的创建和合并" class="headerlink" title="特征点的创建和合并"></a>特征点的创建和合并</h2><p>对于一个特定的问题，可以产生不同的特征点，<strong>通过对问题参数的重新定义和对原有特征点的数学处理合并拆分，能够得到更加优秀的特征点。</strong></p><h2 id="多项式回归"><a href="#多项式回归" class="headerlink" title="多项式回归"></a>多项式回归</h2><p>对于更多更加常见的数学模型，其拟合往往是非线性关系的，这时候就需要考虑引用多项式来进行拟合，如：$h(x)=θ_0+θ_1 x+θ_2 x^2+θ_3 x^3$  </p><h2 id="正规方程算法"><a href="#正规方程算法" class="headerlink" title="正规方程算法"></a>正规方程算法</h2><p>在微积分中，对于函数$f(x,y)$，其局部最值往往是在$f_x=0$ 且$f_y=0$处取得。<br>因此，对于代价函数$J(θ)$，求$J(θ)$对每一个$θ_i$的偏导数，令它们都为0，即：</p><script type="math/tex; mode=display">\frac{∂J(θ)}{∂θ_i}=0~for~i=0,1,2,…,n</script><p>称为<strong>正规方程</strong>(Regular expression)。正规方程提供了一种直接求出最小值的方法，而不需要依赖迭代进行一步一步地运算。 </p><h3 id="正规方程的矩阵形式"><a href="#正规方程的矩阵形式" class="headerlink" title="正规方程的矩阵形式"></a>正规方程的矩阵形式</h3><p>对于数据集$\{(x^{(1)},y^{(1)}),(x^{(2)},y^{(2)}),…,(x^{(m)},y^{(m)})\}$,  其中每一个$x^{(i)}$都是一个向量：$x^{(i)}=\left[\begin{smallmatrix}x_0^{(i)} \\\ x_1^{(i)} \\\ …\\\ x_n^{(i)}\end{smallmatrix}\right]$ 构建<strong>设计矩阵</strong>（Design matrix）$X=\left[\begin{smallmatrix}<br>(x^{(1)})^T \\\ (x^{(2)})^T \\\ … \\\ (x^{(m)})^T<br>\end{smallmatrix}\right]$  和值向量 $y=\left[\begin{smallmatrix}  y^{(1)} \\\ y^{(2)} \\\ … \\\ y^{(m)}  \end{smallmatrix}\right]$<br>将代价函数转化为矩阵方程的形式，再对其求导，令其等于0，得到代价函数取得最小值时的$θ$：</p><script type="math/tex; mode=display">θ=(X^TX)^{-1}X^Ty</script><p>对比梯度下降算法：<br>正规方程算法不需要学习率和迭代，但<strong>对大规模数量（万数量级以上）的特征点（n），工作效率十分低下</strong>。对于一些如分类算法等等更加复杂的算法，正规方程法并不适用于求它们在极值处的θ值。  </p><h3 id="正规方程的不可逆性"><a href="#正规方程的不可逆性" class="headerlink" title="正规方程的不可逆性"></a>正规方程的不可逆性</h3><p>在使用正规方程时，要注意的问题是，<strong>如果设计矩阵X不可逆（为奇异矩阵），正规方程会无法使用。</strong>  </p><p>设计矩阵为奇异矩阵的常见情况：</p><ol><li>x-I 不满足线性关系  </li><li>正在运行的学习算法中，特征点的数量大于样本点的数量（使得$m≤n$）  </li></ol><p>当设计矩阵X不可逆时，应当尝试删除一些特征点，或者考虑正规化（Regularation）。<br>但是总体而言，<strong>矩阵X不可逆的情况是极少数的。</strong></p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>01. 线性回归</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1.4. 优化和调试方法</title>
    <link href="/2021/02/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/1.%20%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/1.4.%20%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/"/>
    <url>/2021/02/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/1.%20%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/1.4.%20%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="优化和调试方法"><a href="#优化和调试方法" class="headerlink" title="优化和调试方法"></a>优化和调试方法</h1><h2 id="特征缩放"><a href="#特征缩放" class="headerlink" title="特征缩放"></a>特征缩放</h2><p>对于某些不具有比较性的样本特征$x_i$ （比如对其他的x来说$x_i$ 相当大或者相当小），梯度下降的过程可能会非常漫长，并且可能来回波动才能最后收敛到全局的最小值。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210822121924.png width=50%><br>在这样的情况下，可以对$x_i$ 进行缩放（如 $x_i≔αx_i$  或者 $x_i=x_i/α$），使得$x_i$ 与其他的$x$具有可比性，以增加梯度下降的效率。<br><strong>通常将$x$缩放至⟦-1,1⟧</strong>的区间内。（只表示一个大致的范围，这不是绝对的。）</p><h2 id="均值归一"><a href="#均值归一" class="headerlink" title="均值归一"></a>均值归一</h2><p>将$x_i$  替换为$x_i−μ_i$ 使得特征值具有为0的平均值（对$x_0$ 不适用）</p><script type="math/tex; mode=display">x_i:=(x_i−μ_i)/s_i</script><p>定义$μ_i$  为训练集$X$ 的平均值，$s_i=|x_imax−x_imin |$, 表示$x_i$ 的取值范围（近似值），或者直接设置为$s_i$ 的标准差。</p><h2 id="学习率-Learning-rate"><a href="#学习率-Learning-rate" class="headerlink" title="学习率(Learning rate)"></a>学习率(Learning rate)</h2><p>有如下的两种方法可以判断梯度下降算法是否已经处于收敛：</p><ol><li><p>绘制$min_θJ(θ)-batch$的图像<br>以迭代次数为横轴，以此时使得$J(θ)$局部最小时$θ$的值（即$min_θJ(θ)$）为纵轴绘制图像。<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210822121634.png width=50%><br>这样的做法需要在固定的迭代周期（比如每迭代100次穿插）时暂停学习，并求得此时的$θ$，然后绘制图像。<br>原则：在固定的迭代周期之后$θ$的值都应该减小，这样的图像能够通过直观地表现变化率来表现梯度下降是否收敛（变化率为0）。  </p></li><li><p>自动收敛测试<br>如果$J(θ)$在某一次迭代之后的下降值小于某个设定好的阈值$ε$后，就能够判断算法已经达到了收敛。<br>$ε$的设定具有技巧性，所以通常采取1.中的方法进行观测。  </p></li></ol><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><p>常见的α过大的$min_θJ(θ)-batch$的图像：  </p><ul><li><p>α过大,导致代价函数无法收敛<br><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210822121842.png width=50%>   </p></li><li><p>α过小，导致代价函数收敛速度过慢</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>01. 线性回归</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1.3. 多变量线性回归</title>
    <link href="/2021/02/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/1.%20%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/1.3.%20%E5%A4%9A%E5%8F%98%E9%87%8F%E9%A2%84%E6%B5%8B/"/>
    <url>/2021/02/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/1.%20%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/1.3.%20%E5%A4%9A%E5%8F%98%E9%87%8F%E9%A2%84%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<p><style><br>img{<br>    width: 30%;<br>    padding-left: 20%;<br>}</style></p><h1 id="多变量线性回归"><a href="#多变量线性回归" class="headerlink" title="多变量线性回归"></a>多变量线性回归</h1><h2 id="多元线性回归"><a href="#多元线性回归" class="headerlink" title="多元线性回归"></a>多元线性回归</h2><p>对于多个特征量(Features)，规定符号表示：<br>$n$ 特征的总数量<br>$x^{(i)}$  第i个训练样本的输入特征向量，$i$表示的是一个索引(Index)<br>$x_j^i$  第i个训练样本中特征向量的第j个值  </p><p>此时的假设函数不再是单纯的 $h_θ (x)=θ_0+θ_1 x$ 的形式。<br>对于多个特征量，此时的假设函数为：   </p><script type="math/tex; mode=display">h_θ (x)=θ^T x=θ_0+θ_1 x^{(1)}+θ_2 x^{(2)}+…+θ_n x^{(n)}</script><p>对这个样本进行简化：<br>定义$x_0^i=1$, 定义参数向量：$x=\left[\begin{smallmatrix} x_0 \\\ x_1 \\\ … \\\ x_n \end{smallmatrix}\right]n$，系数向量：$θ=\left[\begin{smallmatrix}θ_0 \\\ θ_1 \\\ … \\\ θ_n \end{smallmatrix}\right]$<br>有：   </p><script type="math/tex; mode=display">h_θ (x)=θ^T x</script><p>这就是假设函数的向量形式。   </p><h2 id="梯度下降算法在多元线性回归中的应用"><a href="#梯度下降算法在多元线性回归中的应用" class="headerlink" title="梯度下降算法在多元线性回归中的应用"></a>梯度下降算法在多元线性回归中的应用</h2><p>对于假设函数：</p><script type="math/tex; mode=display">\begin{aligned}h_θ(x)  & =  θ^T x \\\  & =θ_0+θ_1 x^{(1)}+θ_2 x^{(2)}+…+θ_n x^{(n)} \\\       \end{aligned}</script><p>和损失函数：   </p><script type="math/tex; mode=display">J(θ_0,θ_1,…,θ_n)=\frac{1}{2m} ∑_{i=1}^m(h_θ (x^{(i)} )−y^{(i)} )^2</script><p>此时的梯度下降算法：<br>Repeat\{</p><script type="math/tex; mode=display">θ_j≔θ_j−α\frac{∂J(θ)}{∂θ_j}</script><p>\}<br>对$\frac{∂J(θ)}{∂θ_j}$进行等价变形：<br>Repeat\{</p><script type="math/tex; mode=display">θ_j≔θ_j−α\frac{1}{m}∑_{i=1}^m(h_θ (x^{(i)} )−y^{(i)})  x_j^i</script><p>\}</p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>01. 线性回归</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1.2. 梯度下降算法</title>
    <link href="/2021/02/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/1.%20%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/1.2.%20%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E7%AE%97%E6%B3%95/"/>
    <url>/2021/02/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/1.%20%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/1.2.%20%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><style><br>img{<br>    width: 40%;<br>    padding-left: 20%;<br>}</style></p><h1 id="梯度下降算法"><a href="#梯度下降算法" class="headerlink" title="梯度下降算法"></a>梯度下降算法</h1><p>在开始之前规定几个符号所代表的意义：<br>$m$ 训练集中训练样本的数量<br>$X$  输入变量<br>$Y$  输出变量<br>$(x,y)$ 训练样本<br>$(x^i,y^i)$第i个训练样本（i表示一个索引）  </p><h2 id="监督学习算法的流程"><a href="#监督学习算法的流程" class="headerlink" title="监督学习算法的流程"></a>监督学习算法的流程</h2><p>提供训练集&gt;学习算法得到$h$（假设函数：用于描绘$x$与$y$的关系）&gt;预测$y$ 的值  </p><h2 id="假设函数"><a href="#假设函数" class="headerlink" title="假设函数"></a>假设函数</h2><p><strong>假设函数(Hypothesis function)</strong>——$h$是用来表示某一个数据集可能存在的线性/非线性关系的函数。对于线性拟合，其假设函数为：  </p><script type="math/tex; mode=display">h_θ(x)=θ_1x+θ_0</script><p>其中$θ$是假设函数当中的参数。<br>如果不考虑截距项$θ_0$，$h_θ(x)$可以简化为：</p><script type="math/tex; mode=display">h_θ(x)=θ_1x</script><h2 id="代价-损失函数"><a href="#代价-损失函数" class="headerlink" title="代价/损失函数"></a>代价/损失函数</h2><p><strong>代价函数</strong>（Cost/Loss function），在统计学上称为均方根误差函数。当假设函数中的系数$θ$取不同的值时，$\frac{1}{2m}$倍假设函数预测值$h_θ(x^{(i)})$和真实值$y^{(i)}$的差的平方的和之间的函数关系表示为代价函数$J$。</p><script type="math/tex; mode=display">J(θ_0,θ_1)= \frac{1}{2m}∑_{i=1}^m(h_θ(x^{(i)})-y^{(i)})^2</script><blockquote><p>取1/2的原因是便于消除求导之后产生的2倍,同时也可以进一步缩小$θ$  </p><p>线性回归的代价函数的自变量有两个：$θ_1$和$θ_0$，因此该函数是三维的函数。线性回归的代价函数图像如下图所示：<br> <img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210131130651.png" alt="">  </p></blockquote><p><strong>代价函数在几何上表示为数据集空间内的各点到假设函数的欧式距离的平方的平均值的一半。</strong><br>要想使得数据能够被假设函数很好地拟合，那么代价函数要尽量地小。<strong>当代价函数取到它的最小值即</strong>$J(θ_1)_{min}$<strong>时，此时的填入假设函数的</strong>$θ$<strong>对数据的拟合程度是最好的</strong>。<br>对于线性的代价函数，假设函数对数据集的拟合程度越高，对应的$(θ_0,θ_1)$越接近代价函数图像等高线的中心。<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210131132852.png" alt="">   </p><h2 id="梯度下降算法（Gradient-Descent）"><a href="#梯度下降算法（Gradient-Descent）" class="headerlink" title="梯度下降算法（Gradient Descent）"></a>梯度下降算法（Gradient Descent）</h2><h3 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h3><p>在微积分中，函数$f(x,y)$在$(x_0,y_0)$处是函数值增加最快的方向是<strong>梯度（Gradient）</strong>的方向，<strong>梯度的反方向是函数值减小最快的方向。</strong><br>$f(x,y)$在$(x_0,y_0)$处的梯度：  </p><script type="math/tex; mode=display">▿f|_{(x_0,y_0)}=(\frac{∂}{∂x}f(x_0,y_0),\frac{∂}{∂y}f(x_0,y_0))</script><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>梯度下降算法是一种求解代价函数最小值的方法，它可以用在<strong>多维任意的假设函数</strong>当中。<br>简而言之，梯度下降算法求得$J(θ_1)_{min}$的主要思路是：   </p><ol><li>给定$θ_0$和$θ_1$的初始值，通常令$θ_0=0$，$θ_1=0$。</li><li>不断改变$θ_0$和$θ_1$的值使得$J(θ_0,θ_1)$的值逐渐变小，直到找到$J(θ_0,θ_1)$的最小值或者局部最小值。<br>如果从一个初始值出发，寻找附近的最小值，重复该过程，得到上图，最后得到的值为局部最优解。  <blockquote><p>将梯度下降算法类比为爬山，从一个点开始，不断寻找“下山”的路线，最后找到一个“下山”的出口。  </p></blockquote></li></ol><p>当改变初始值时，会找到另一条“下山”的路径，找到第二个局部最优解（局部最小值）。  </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210822101757.png width=80%>  </p><p>对于线性回归的代价函数而言，只存在一个局部最小值。（见线性回归代价函数的图像）  </p><h3 id="表示"><a href="#表示" class="headerlink" title="表示"></a>表示</h3><p>梯度下降算法可以表示为：<br>Repeat untill convergence\{  </p><script type="math/tex; mode=display">θ_j:=θ_j-α\frac{∂J(θ_0,θ_1)}{∂θ_j},j=0~and~j=1</script><p>\}<br>解释：    </p><ol><li>:=  表示赋值运算符</li><li>α称为<strong>学习率</strong>，用来控制下降的<strong>步长</strong>（Padding），即更新的幅度：  <ul><li>α太小，同步更新的速率会非常的慢     </li><li>α过大，同步更新时可能会越过最小值点   </li></ul></li><li>$\frac{∂J(θ_0,θ_1)}{∂θ_j}$是代价函数的梯度：<script type="math/tex; mode=display">\frac{∂J(θ_0,θ_1)}{∂θ_0}=\frac{1}{m}∑_{i=1}^m(h_θ(x^{(i)})-y^{(i)})</script><script type="math/tex; mode=display">\frac{∂J(θ_0,θ_1)}{∂θ_1}=\frac{1}{m}∑_{i=1}^m(h_θ(x^{(i)})-y^{(i)})x^{(i)}</script><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210131135144.png" alt=""><br>△在代价函数中（以简化的代价函数为例），无论初始值在最小值点的左侧还是右侧，通过同步更新都能够使该点被移动到最小值，在最小值点，由于导数值为0，最终同步更新停止在了$θ_j=θ_j$，此时的$θ_j$即为极小值点。  </li></ol><h3 id="同步更新"><a href="#同步更新" class="headerlink" title="同步更新"></a>同步更新</h3><p><strong>同步更新</strong>（Simulaneous update）是梯度下降算法中用于处理多个参数$θ$的方式。  </p><script type="math/tex; mode=display">temp0:θ_0:=θ_0-α\frac{∂J(θ_0,θ_1)}{∂θ_0}</script><script type="math/tex; mode=display">temp1:θ_1:=θ_1-α\frac{∂J(θ_0,θ_1)}{∂θ_1}</script><script type="math/tex; mode=display">θ_0:=temp0</script><script type="math/tex; mode=display">θ_1:=temp1</script><p>这个更新方程能够同时更新$θ_0$和$θ_1$。<br>更新的方法是计算赋值号右边带入$θ_1$和$θ_2$的值进行计算，得到的两个值分别储存在temp0和temp1中，从上到下进行赋值。  </p><p>对于简化的代价函数：  </p><script type="math/tex; mode=display">θ_1：=θ_1-αJ'(θ_1)</script><script type="math/tex; mode=display">\frac{dJ(θ_1)}{dθ_1} =\frac{d}{dθ_1}(\frac{1}{2m}Σ(h_θ(x_i)-y_i))^2)</script><p>将梯度代回代价函数中就得到了<strong>批量梯度下降</strong>算法的基本形式：<br>重复如下的更新方程，直到$θ_0$和$θ_1$都收敛 </p><script type="math/tex; mode=display">θ_0:=θ_0-α\frac{1}{m}∑_{i=1}^m(h_θ(x^{(i)})-y^{(i)})</script><script type="math/tex; mode=display">θ_1:=θ_1-α\frac{1}{m}∑_{i=1}^m(h_θ(x^{(i)})-y^{(i)})x^{(i)}</script><blockquote><p>本节学习的梯度下降算法在每一轮迭代时都要对数据集中所有的数据进行求和，因此称为批量梯度下降算法。这种算法在数据集的数据量非常大时，执行算法所消耗的计算量相当大。因此在大数据集学习时，采用另一种梯度下降的方式，称为随机梯度下降。<br>关于随机梯度下降的的内容：<a href="https://l61012345.top/2021/08/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/13.%20%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%AD%A6%E4%B9%A0/13.2.%20%E9%9A%8F%E6%9C%BA%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E7%AE%97%E6%B3%95/">13.2. 随机梯度下降算法</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>01. 线性回归</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2.4. 向量化</title>
    <link href="/2021/02/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/2.%20Octave%E8%AF%AD%E8%A8%80%E5%88%9D%E6%AD%A5/2.4.%20%E5%90%91%E9%87%8F%E5%8C%96/"/>
    <url>/2021/02/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/2.%20Octave%E8%AF%AD%E8%A8%80%E5%88%9D%E6%AD%A5/2.4.%20%E5%90%91%E9%87%8F%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="向量化"><a href="#向量化" class="headerlink" title="向量化"></a>向量化</h1><p>对于求和的算法，有时可以转换为矩阵的乘法来进行计算<br>E.g.  </p><script type="math/tex; mode=display">H(θ)(x)=∑_{j=0}^nθ_j x_j</script><p>如果直接求和，求和的过程会非常冗长<br>而设计两个向量$θ$ $x$<br>则有线性回归假设函数的向量形式：</p><script type="math/tex; mode=display">h(x)=θ^T x</script><p>对更新函数：<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20201224232957.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>02. Octave语言初步</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2.3. 控制和定义语句</title>
    <link href="/2021/02/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/2.%20Octave%E8%AF%AD%E8%A8%80%E5%88%9D%E6%AD%A5/2.3.%20%E6%8E%A7%E5%88%B6%E5%92%8C%E5%AE%9A%E4%B9%89%E8%AF%AD%E5%8F%A5/"/>
    <url>/2021/02/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/2.%20Octave%E8%AF%AD%E8%A8%80%E5%88%9D%E6%AD%A5/2.3.%20%E6%8E%A7%E5%88%B6%E5%92%8C%E5%AE%9A%E4%B9%89%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="控制和定义语句"><a href="#控制和定义语句" class="headerlink" title="控制和定义语句"></a>控制和定义语句</h1><p>for i=1:10,<br>Indices=a : b 从a到b的索引<br>Break Continue 与C语言相同<br>While, end 结构体 同C语言  </p><p>选择结构：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> condition,    <br>command   <br>end   <br></code></pre></td></tr></table></figure><br>分支选择结构：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> condition,   <br>command;   <br>elseif condition,   <br>Command;  <br></code></pre></td></tr></table></figure><br>循环结构：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> condition，  <br>Conmand;  <br> end  <br></code></pre></td></tr></table></figure><br>定义函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">function y=function(x)  <br>command with Y,x;  <br></code></pre></td></tr></table></figure><br>保存为function.m文件  </p><p>返回多个值的函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">function [y1,y2]=function(x)  <br>Command with y1,y2,x;  <br></code></pre></td></tr></table></figure><br>加载函数：<br>定位到m文件目录下  </p><p><code>addpath（&#39;path&#39;）</code>: 加入Octave路径  </p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>02. Octave语言初步</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2.2. 数据计算和绘制</title>
    <link href="/2021/02/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/2.%20Octave%E8%AF%AD%E8%A8%80%E5%88%9D%E6%AD%A5/2.2.%20%E6%95%B0%E6%8D%AE%E8%AE%A1%E7%AE%97%E5%92%8C%E7%BB%98%E5%88%B6%E5%9B%BE%E5%83%8F/"/>
    <url>/2021/02/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/2.%20Octave%E8%AF%AD%E8%A8%80%E5%88%9D%E6%AD%A5/2.2.%20%E6%95%B0%E6%8D%AE%E8%AE%A1%E7%AE%97%E5%92%8C%E7%BB%98%E5%88%B6%E5%9B%BE%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="数据计算和绘制"><a href="#数据计算和绘制" class="headerlink" title="数据计算和绘制"></a>数据计算和绘制</h1><h2 id="对元素的操作"><a href="#对元素的操作" class="headerlink" title="对元素的操作"></a>对元素的操作</h2><p><code>A.\*B</code> A矩阵和B矩阵的每一个元素对应相乘<br><code>.</code> 对每一个元素进行运算操作<br><code>abs(A)</code> 对A每一个元素取绝对值<br><code>v+1</code> 对向量v里面的每一个元素+1<br><code>A’</code> 矩阵A的转置<br><code>pinv(A)</code>对A求逆矩阵，不可逆时即为伪逆矩阵<br><code>max(A)</code> A中最大的元素的值<br><code>max(A,[], DI)</code> A中DI维度下元素最大的值（1 列 2 行）<br><code>ind()</code> 某个元素的位置<br><code>magic(n)</code> 返回n*n的幻方<br><code>find(condition)</code>查找对应条件的元素，并返回一个向量<br><code>sum(A)</code>A所有元素的和<br><code>prod(A)</code>A所有元素的乘积<br><code>ceil(A)</code> 对A向上取整<br><code>floor(A)</code>对A每个元素向下取整<br><code>flipud(A)</code>对A上下翻转  </p><h2 id="绘制图像"><a href="#绘制图像" class="headerlink" title="绘制图像"></a>绘制图像</h2><p><code>Plot(x,y,&#39;r&#39;)</code> 绘制关于x，y的图像 r表示y的函数是红色的（默认为蓝色）<br><code>hold on</code> 保存octave内存中的旧函数图像<br><code>xlabel(&#39;&#39;)</code>添加横轴标签<br><code>ylabel（‘’）</code>添加纵轴标签<br><code>legend(&#39;&#39;,&#39;&#39;)</code> 图例<br><code>title（‘’）</code>添加标题<br><code>print -dpng &#39;xx.png&#39;</code> 在当前路径下以png保存当前图像<br><code>close</code> 关闭当前图像<br><code>figure(1)</code>; 标记图像（多开图像窗口）<br><code>subplot(1,2,1)</code> 把图像分成1x2的网格 从第一个格图开始画图<br><code>axis([0.5 1 -1 1])</code>横轴0.5~1 纵轴-1~1<br><code>clf</code> 清除一幅图像<br><code>imagesc(A)</code>可视化矩阵<br><code>colorbar</code> 添加颜色条<br><code>colormap gray</code>  生成黑白图像<br><code>,</code>依次执行每一个命令  </p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>02. Octave语言初步</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2.1. 基本命令</title>
    <link href="/2021/02/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/2.%20Octave%E8%AF%AD%E8%A8%80%E5%88%9D%E6%AD%A5/2.1.%20%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/02/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/2.%20Octave%E8%AF%AD%E8%A8%80%E5%88%9D%E6%AD%A5/2.1.%20%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><h2 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h2><p>代数运算：+ - * / sqrt（）<br>布尔运算：且：&amp;&amp;  或：||  非：！<br>赋值：=  </p><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><p><code>disp()</code> 显示（）内的命令到屏幕<br><code>sprintf()</code>用法同c语言中的printf<br><code>format lone</code> 显示变量的更多小数位数<br><code>formate short</code> 显示变量的更少小数位数（4位）<br><code>help fuction</code> 显示function 函数的帮助文档  </p><h2 id="矩阵的快速操作"><a href="#矩阵的快速操作" class="headerlink" title="矩阵的快速操作"></a>矩阵的快速操作</h2><p><code>[a b; c d;]</code> 2x2矩阵<br>[]矩阵符号<br>；换行<br>快速建立步长相等的行向量：  起始参数：步长（默认为1）：终止参数<br><code>ones(a,b)</code> 快速生成axb的矩阵，且所有元素为1<br><code>zeros(a,b)</code>快速生成axb的矩阵，且所有元素为0<br><code>rand(a,b)</code>快速生成axb的矩阵，且所有元素的值为在（0，1）内的随机数<br><code>randn(a,b)</code>快速生成axb的矩阵，且所有元素的值为服从正态分布的随机数<br><code>hist()</code> 快速绘制变量的直方图<br><code>eye(a)</code> 快速生成axa的单位矩阵<br><code>size(row,column)</code>返回矩阵的大小，并将大小存入一个1x2的矩阵中<br><code>length(A)</code>返回向量A的最大维度的值<br><code>rref(A)</code> 求解矩阵A的阶梯型</p><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p><code>pwd</code> 返回Octave当前指向的路径<br><code>cd &#39;path&#39;</code> 使Octave指向path路径<br><code>ls</code> 返回Octave当前指向的路径下所有的文件名称  </p><p><code>Load (&#39;file.dat&#39;)</code>  加载file.dat文件<br>*file.dat 是一个编写好的仅有数据（用固定格式aaa bbb ccc）的文件<br><code>Who</code> 返回Octave当前内存中所有的变量<br><code>Whos</code> 返回Octave当前内存中所有的变量和对应的维度、数据类型、数据大小<br><code>Clear varible</code> 清除varible变量<br><code>Clear</code> 清除内存中所有的变量<br><code>Varible1=varible2(a:b)</code>将varible2中的a到b位数据赋给varible1<br><code>Save file.mat varible</code> 将varible存入file.mat中<br><code>Save file.txt varible ascii</code> 将varible存入file.txt中 编码为ascii  </p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p><code>varible(a,b)</code>定位到varible中的（a，b）变量<br><code>C=[A B]</code> 生成[A B]矩阵（B在A右边）<br><code>C=[A;B]</code> 生成[A B]矩阵（B在A下边）  </p>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>02. Octave语言初步</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1.1. 什么是机器学习</title>
    <link href="/2021/02/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/1.%20%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/1.1.%20%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/02/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%B4%E6%81%A9%E8%BE%BE/1.%20%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/1.1.%20%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是机器学习"><a href="#什么是机器学习" class="headerlink" title="什么是机器学习"></a>什么是机器学习</h1><h2 id="机器学习的定义"><a href="#机器学习的定义" class="headerlink" title="机器学习的定义"></a>机器学习的定义</h2><blockquote><p>A computer  program is said to learn from experience E with respect to some task T and some performance measure P, if its performance on T, as measured by P, improves with experience E.    ——Tom Mitchelle  </p></blockquote><p>简言之，机器学习通过完成任务（T）得到经验（E），进而提升性能（P）。<br>例如：一个自我对弈的跳棋学习机器：E ：自我对弈的棋局 T：下跳棋 P：与新对手玩跳棋时的获胜概率  </p><h2 id="机器学习的主要算法类型"><a href="#机器学习的主要算法类型" class="headerlink" title="机器学习的主要算法类型"></a>机器学习的主要算法类型</h2><ul><li><strong>监督学习</strong>（Supervised）<br>人教会计算机完成任务。<br>根据统计数据做直线或曲线拟合/分离数据，来预测结果。<br>其中包括了两大问题：  <ul><li><strong>回归</strong>（Regression）<br>给算法做一个数据集，包含正确答案，（比如房价-年），用线性/非线性回归方程拟合数据,预测数据。<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210131124639.png" alt=""></li><li><strong>分类问题</strong>（<strong>逻辑回归</strong>问题）（Classification/Logical regression）<br>用实数对出现的可能状况分类<br>（比如：1和0表示患乳腺癌/不患乳腺癌 ；1表示患乳腺癌A，2表示患乳腺癌B，0表示不患乳腺癌），在多维坐标系中（每一个维度表示不同的属性），然后用线性或非线性的函数将不同类的数据分开。<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210131124726.png" alt=""></li></ul></li><li><strong>无监督学习</strong>（Unsupervised）<br>计算机自己学习，经典的算法分为两大类：    <ul><li><strong>聚类算法</strong><br>对并不明确分类的数据集，计算机根据数据特征自动将数据分为几个簇<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210131124803.png" alt=""></li><li><strong>鸡尾酒会算法</strong>（Cocktail party）<br>略，这里只对鸡尾酒会问题和解决方法作一个概述：<br>鸡尾酒会问题是在计算机语音识别 领域的一个问题。<br>当前语音识别技术已经可以以较高精度识别一个人所讲的话，但是当说话的人数为两人或者多人时，语音识别率就会极大的降低，这一难题被称为鸡尾酒会问题。<br>对于的给定混合信号，分离出鸡尾酒会中 同时说话的每个人的独立信号。<br>鸡尾酒问题的解决方法是把两个收音器分别放在两个人的附近，每个收音器且与两个人的距离是不等距的，如此来分离两个人的声音。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习基础课程——吴恩达</category>
      
      <category>01. 线性回归</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo搭建博客记录</title>
    <link href="/2021/02/20/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/hexo%E5%8D%9A%E5%AE%A2%E7%97%9B%E7%82%B9/"/>
    <url>/2021/02/20/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/hexo%E5%8D%9A%E5%AE%A2%E7%97%9B%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo搭建博客记录"><a href="#Hexo搭建博客记录" class="headerlink" title="Hexo搭建博客记录"></a>Hexo搭建博客记录</h1><p>搭建这个博客前前后后花了大概一周左右的时间，基本上把能踩的雷全都踩过了，现在记录一下搭建过程中的问题和解决办法。</p><h2 id="Github-Pages-相关问题"><a href="#Github-Pages-相关问题" class="headerlink" title="Github Pages 相关问题"></a>Github Pages 相关问题</h2><h3 id="Github-Pages-无法创建页面-显示“Pages-build-faild”-但是没有任何报错信息"><a href="#Github-Pages-无法创建页面-显示“Pages-build-faild”-但是没有任何报错信息" class="headerlink" title="Github Pages 无法创建页面 显示“Pages build faild” 但是没有任何报错信息"></a>Github Pages 无法创建页面 显示“Pages build faild” 但是没有任何报错信息</h3><p>第一个遇到的问题是Github Pages 始终反馈无法创建（build）页面，反馈邮件当中没有任何关于错误的信息。<br>debug非常多次之后发现是由于Git 把所有的代码都同步到了项目里：<br>自己用的VS Code来写的博客。自己的VS Code里面本来就设置好了git，因此就直接用VS Code里面的git把项目里面所有的文件都提交上去了……<br>所以解决办法是不要用VS Code里面的git来提交代码，正确的做法是用git bash里的<code>hexo g</code>生成文件后，用<code>hexo d</code>提交。  </p><h3 id="Github-Pages-反馈邮件“You-are-attempting-to-use-a-Jekyll-theme-which-is-not-supported-by-GitHub-Pages-”"><a href="#Github-Pages-反馈邮件“You-are-attempting-to-use-a-Jekyll-theme-which-is-not-supported-by-GitHub-Pages-”" class="headerlink" title="Github Pages 反馈邮件“You are attempting to use a Jekyll theme, which is not supported by GitHub Pages.”"></a>Github Pages 反馈邮件“You are attempting to use a Jekyll theme, which is not supported by GitHub Pages.”</h3><p>本地build正常，但是同步到github pages后会收到来自github的邮件：   </p><blockquote><p>You are attempting to use a Jekyll theme, which is not supported by GitHub Pages. Please visit <a href="https://pages.github.com/themes/">https://pages.github.com/themes/</a> for a list of supported themes. If you are using the “theme” configuration variable for something other than a Jekyll theme, we recommend you rename this variable throughout your site. For more information, see <a href="https://help.github.com/en/articles/adding-a-jekyll-theme-to-your-github-pages-site">https://help.github.com/en/articles/adding-a-jekyll-theme-to-your-github-pages-site</a>.      </p></blockquote><p>这个问题是由更换主题时直接clone的主题，导致项目下面有两个repo造成的。<br>解决方法有两个：</p><ol><li>直接在主题的release页面中下载发布的压缩包，解压之后放theme里【推荐】</li><li>在git中使用submodule：<code>git submodule add url</code></li></ol><h3 id="Github-Pages-显示-404-“There-isn’t-a-GitHub-Pages-site-here-”"><a href="#Github-Pages-显示-404-“There-isn’t-a-GitHub-Pages-site-here-”" class="headerlink" title="Github Pages 显示 404 “There isn’t a GitHub Pages site here.”"></a>Github Pages 显示 404 “There isn’t a GitHub Pages site here.”</h3><p>这个问题是由Github 里博客对应的项目名称不是username.github.io造成的，解决方法是把项目的名字命名为username.github.io     </p><h3 id="Github-Pages-显示“The-custom-domain-for-your-GitHub-Pages-site-is-pointed-at-an-outdated-IP-address-You-must-update-your-site’s-DNS-records-if-you’d-like-it-to-be-available-via-your-custom-domain-”"><a href="#Github-Pages-显示“The-custom-domain-for-your-GitHub-Pages-site-is-pointed-at-an-outdated-IP-address-You-must-update-your-site’s-DNS-records-if-you’d-like-it-to-be-available-via-your-custom-domain-”" class="headerlink" title="Github Pages 显示“The custom domain for your GitHub Pages site is pointed at an outdated IP address. You must update your site’s DNS records if you’d like it to be available via your custom domain.”"></a>Github Pages 显示“The custom domain for your GitHub Pages site is pointed at an outdated IP address. You must update your site’s DNS records if you’d like it to be available via your custom domain.”</h3><p>原因是因为在云解析DNS控制台中没有加入github给的DNS或DNS已经失效。<br>解决方法是在[<a href="https://docs.github.com/en/github/working-with-github-pages/managing-a-custom-domain-for-your-github-pages-site]页面的">https://docs.github.com/en/github/working-with-github-pages/managing-a-custom-domain-for-your-github-pages-site]页面的</a><br>“6 To confirm that your DNS record configured correctly, use the dig command, replacing EXAMPLE.COM with your apex domain. Confirm that the results match the IP addresses for GitHub Pages above. “中找到github提供的DNS，然后加入到云解析DNS控制台的解析记录中。<br>同时还要删除很多教程中提到的用<code>ping username.github.io</code>ping出来的ip地址。  </p><h3 id="Github-Pages-显示“Domain’s-DNS-record-could-not-be-retrieved-”"><a href="#Github-Pages-显示“Domain’s-DNS-record-could-not-be-retrieved-”" class="headerlink" title="Github Pages 显示“Domain’s DNS record could not be retrieved.”"></a>Github Pages 显示“Domain’s DNS record could not be retrieved.”</h3><p>原因是网站的解析设置有问题造成的，在解析控制台中的解析记录要注意解析类型和主机记录的对应关系：<br>A类对应@，CNAME对应www或者别的。<br>还有可能是项目中的CNAME文件和github settings中custom domain设置的域名前面加了www.等其他东西。<br>同时解析线路一定要选择默认。    </p><h2 id="博客访问问题"><a href="#博客访问问题" class="headerlink" title="博客访问问题"></a>博客访问问题</h2><h3 id="无梯访问username-github-io-显示“已拒绝连接”"><a href="#无梯访问username-github-io-显示“已拒绝连接”" class="headerlink" title="无梯访问username.github.io 显示“已拒绝连接”"></a>无梯访问username.github.io 显示“已拒绝连接”</h3><p>解决办法是更换为自己的域名，可以在阿里云，腾讯云之类的地方购买自己的域名，然后在github上对应项目的设置中Custom domain一项中填写自己买的域名（前面不要加www.之类的，就是纯域名）。<br>同时解析线路一定要选择默认。   </p><h3 id="访问博客显示“连接已关闭”"><a href="#访问博客显示“连接已关闭”" class="headerlink" title="访问博客显示“连接已关闭”"></a>访问博客显示“连接已关闭”</h3><p>通常是由于github pages在build和分发的过程中出错导致的，要去github上对应的项目的设置中看github pages的报错信息，具体问题具体分析。  </p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="git-频繁要求输入邮箱和用户名"><a href="#git-频繁要求输入邮箱和用户名" class="headerlink" title="git 频繁要求输入邮箱和用户名"></a>git 频繁要求输入邮箱和用户名</h3><p>  这个问题是由于_config.yml末尾的deploy: repo:中设置的是https网址导致的<br>  正确的填写方法是用SSH链接：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">deploy:<br>type: <span class="hljs-string">&#x27;git&#x27;</span><br>repo: git<span class="hljs-meta">@github</span>.com:username/username.github.io.git<br>branch: master<br></code></pre></td></tr></table></figure></p><h3 id="博客中的LaTeX-MathJaX公式显示混乱"><a href="#博客中的LaTeX-MathJaX公式显示混乱" class="headerlink" title="博客中的LaTeX/MathJaX公式显示混乱"></a>博客中的LaTeX/MathJaX公式显示混乱</h3><p>这个是由于renderer-marked的转义与markdown本身出现了冲突所造成的。<br>解决方法：  </p><ol><li>卸载原来的公式渲染引擎改用kramed<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm uninstall hexo-renderer-marked --save<br>npm install hexo-renderer-kramed --save<br></code></pre></td></tr></table></figure></li><li>然后在node_modules\kramed\lib\rules\inline.js目录下把第11行的escape变量的值做相应的修改： <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//  escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,</span><br>escape: /^\\([`*\[\]()#$+\-.!_&gt;])/<br></code></pre></td></tr></table></figure> 这一步是在原基础上取消了对\,{,}的转义(escape)。<br> 同时把第20行的em变量也要做相应的修改。    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//  em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br>em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/<br></code></pre></td></tr></table></figure></li><li>执行<code>hexo clean</code>再用<code>hexo g</code>重新生成</li></ol><h3 id="页面中的LaTeX-MathJaX矩阵无法换行，只有一列"><a href="#页面中的LaTeX-MathJaX矩阵无法换行，只有一列" class="headerlink" title="页面中的LaTeX/MathJaX矩阵无法换行，只有一列"></a>页面中的LaTeX/MathJaX矩阵无法换行，只有一列</h3><ol><li>行内矩阵不能用<code>\begin&#123;matrix&#125;</code>，要用<code>\begin&#123;smallmatrix&#125;</code>，括号用<code>\left[</code>和<code>\right]</code>表示</li><li>由于渲染问题，换行符<code>\\</code>要改为<code>\\\</code> 同时注意前后都要空格</li></ol><h3 id="页面中的表格无法显示"><a href="#页面中的表格无法显示" class="headerlink" title="页面中的表格无法显示"></a>页面中的表格无法显示</h3><p>这是由于mathjax不支持markdown中的表格语法造成的，正确的写法是用数组array代替:<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript">$$<br><span class="hljs-string">\begin&#123;array&#125;&#123;c|lcr&#125;</span><br>n &amp; <span class="hljs-string">\text&#123;Left&#125;</span> &amp; <span class="hljs-string">\text&#123;Center&#125;</span> &amp; <span class="hljs-string">\text&#123;Right&#125;</span> <span class="hljs-string">\\</span><br><span class="hljs-string">\hline</span><br><span class="hljs-number">1</span> &amp; <span class="hljs-number">0.24</span> &amp; <span class="hljs-number">1</span> &amp; <span class="hljs-number">125</span> <span class="hljs-string">\\</span><br><span class="hljs-number">2</span> &amp; -<span class="hljs-number">1</span> &amp; <span class="hljs-number">189</span> &amp; -<span class="hljs-number">8</span> <span class="hljs-string">\\</span><br><span class="hljs-number">3</span> &amp; -<span class="hljs-number">20</span> &amp; <span class="hljs-number">2000</span> &amp; <span class="hljs-number">1</span>+<span class="hljs-number">10i</span><br><span class="hljs-string">\end&#123;array&#125;</span><br>$$<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>技术杂谈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>7. 总结</title>
    <link href="/2021/01/30/Machine%20Learning-NAU/7.%20%E6%80%BB%E7%BB%93/"/>
    <url>/2021/01/30/Machine%20Learning-NAU/7.%20%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>分类是将标签赋予给输入图像的过程。</li><li>选择特征是一门艺术。   </li><li>选择好的特征能够让分类器更好的工作。（有些分类器需要很长的工作时间。）</li><li>用测试集对分类器进行性能评估是重要的一步。   </li></ol>]]></content>
    
    
    <categories>
      
      <category>Machine Learning-NUS 2021</category>
      
      <category>讲义</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>6. 人脸识别与感知机</title>
    <link href="/2021/01/29/Machine%20Learning-NAU/6.%20%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E4%B8%8E%E6%84%9F%E7%9F%A5%E6%9C%BA/"/>
    <url>/2021/01/29/Machine%20Learning-NAU/6.%20%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E4%B8%8E%E6%84%9F%E7%9F%A5%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="人脸识别与感知机"><a href="#人脸识别与感知机" class="headerlink" title="人脸识别与感知机"></a>人脸识别与感知机</h1><h2 id="早期人脸识别技术"><a href="#早期人脸识别技术" class="headerlink" title="早期人脸识别技术"></a>早期人脸识别技术</h2><p>最早的人脸识别技术由Sung Kah Kay (MIT), Henry Rowley (CMU)运用ANN识别得来，方法大致为：</p><ul><li>将有人脸图像分割为$20 × 20 px$的矩阵块</li><li>对每个块运用亮度矫正和直方图均衡</li><li>放入神经网络学习，检测每一个矩阵块是否为人脸，如果不是，则平移矩阵块，并不断缩小矩阵的大小，再次检测。<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210223201717.png" alt="">   </li></ul><h3 id="Viola-Jones-人脸检测方法"><a href="#Viola-Jones-人脸检测方法" class="headerlink" title="Viola-Jones 人脸检测方法"></a>Viola-Jones 人脸检测方法</h3><p><strong>Viola-Jones 人脸检测方法</strong> （Viola Jones Face detection）是Paul viola 和 Michael J Jones共同提出的一种人脸检测框架。它极大的提高了人脸检测的速度和准确率。 目前的人脸识别设备大多采用这种方法。<br>这种方法主要提取了4类最基本的特征。<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210223202823.png" alt=""><br>右图： 特征A主要是用于检测双眼，特征C主要用于检测额头的部位。   </p><ul><li>特征的加强与感知机<br>Viola-Jones 人脸检测方法使用了加强的特征，具体方法为：   <ol><li>称一个简单的分类器叫做<strong>单特征感知机</strong>（single-feature perceptron），对每一种特征都使用一种不同的单特征感知机，得到加权的一些数据，如果有K个特征，就要用K个不同的单特征感知机。  </li><li>对之前获得的数据进行加权。  </li><li>训练所有的K个单特征感知器。  </li><li>在此阶段选择一个最佳分类器。  </li><li>与先前选择的其他分类器组合。  </li><li>重新加权新得到的所有数据。</li><li>再次学习所有K个分类器，选择最佳分类器，合并，重新加权。</li><li>重复执行，直到选择了T个分类器。   </li></ol></li></ul><p>在当时，运用这种方法训练5k张人脸和9.5k张非人脸图像花费了一周的时间，最后的结果是一个38层的感知机，它提取了6060个特征。    </p>]]></content>
    
    
    <categories>
      
      <category>Machine Learning-NUS 2021</category>
      
      <category>讲义</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>6. 大作业-创建一个交通标志分类器</title>
    <link href="/2021/01/29/Machine%20Learning-NAU/6.%20%E6%9C%80%E5%90%8E%E5%A4%A7%E4%BD%9C%E4%B8%9A/"/>
    <url>/2021/01/29/Machine%20Learning-NAU/6.%20%E6%9C%80%E5%90%8E%E5%A4%A7%E4%BD%9C%E4%B8%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="Traffic-Sign-Recognition"><a href="#Traffic-Sign-Recognition" class="headerlink" title="Traffic Sign Recognition"></a>Traffic Sign Recognition</h1><p>Traffic-sign recognition (TSR) is a technology by which a vehicle is able to recognize the traffic signs<br>put on the road e.g. “speed limit” or “children” or “turn ahead”. This is a very important technology<br>in self-driving cars.<br>This project will give you the chance to train different models using various features to classify traffic<br>signs.<br>The project is divided into 3 difficulty levels. Beginner, Expert and Bonus.   </p><h2 id="Beginner-Level"><a href="#Beginner-Level" class="headerlink" title="Beginner Level"></a>Beginner Level</h2><p>For this level we use the Chinese Traffic Sign Database (Traffic Sign Recogntion Database (ia.ac.cn)).<br>This is available as a zip file in your project folder under the name “Dataset_1.zip”.<br>This dataset consists of 5998 images belonging to 58 classes. Each image is named “XXX_yyyy.png”.<br>Here XXX represent the class (traffic sign type) and yyyy represents the image number within each<br>class.<br>For the beginner level, we make use of the “starter.py” code, which you can find in the project<br>directory.<br>Follow along with the tasks and fill in the blanks of the given code to complete beginner level.<br>Follow the tasks with “starter.py” and fill in the missing code for each section.</p><h3 id="T1-Reading-images"><a href="#T1-Reading-images" class="headerlink" title="T1: Reading images."></a>T1: Reading images.</h3><ul><li>Change the dataset_path to point to the unzipped Dataset_1/images folder in your<br>computer.</li><li>The given loop will go through all the files in the folder, variable i gives each file name.</li><li>Complete the code to read the images and append them to list X</li><li>The labels for each image has been already appended to list y for you<br>At the end of T1, you should have X, y with 5998 entries on each.<h3 id="T2-Pre-processing-images"><a href="#T2-Pre-processing-images" class="headerlink" title="T2: Pre-processing images."></a>T2: Pre-processing images.</h3></li><li>Given loop will go through all images in X and resize them to 48x48 pixels.</li><li>Complete the code to convert the images to grayscale. (Hint: use the cvtColor function in<br>opencv)</li><li>Complete the code to append the pre-processed images to X_processed list.<br>At the end of T2, you should have X_processed with 5998 entires of resized and grayscale images.<br>T3: Calculating Features and Splitting train/test sets.</li><li>Install skimage using anaconda. (you can follow the same instructions given for installing<br>sklearn with the package name “scikit-image”)</li><li>The given code will use skimage and extract hog features for you.</li><li>Write code to split X_features and y into training and testing sets. Make use of the<br>“sklearn.model_selection.train_test_split” to do this. Use a 80-20 split and make sure to<br>shuffle the samples.<br>At the end of T3, you should have x_train, x_test, y_train and y_test. Training sets should have 4798<br>samples and the test sets should have 1200 samples.<br>T4: Training and testing the classifier.</li><li>Use the sklearn SVM package to train a classifier using x_train and y_train.</li><li>Use the x_test and y_test to evaluate the classifier and print the accuracy value.<h2 id="Expert-Level"><a href="#Expert-Level" class="headerlink" title="Expert Level:"></a>Expert Level:</h2>We will build upon the beginner level code to try out different techniques and improve our model.<br>The same dataset will be used here.<br>Complete the following tasks,<h3 id="T1-Different-pre-processing-techniques"><a href="#T1-Different-pre-processing-techniques" class="headerlink" title="T1: Different pre-processing techniques"></a>T1: Different pre-processing techniques</h3>What are other pre-processing steps you can use?<br>Examples: Keep 3 channels (RGB), add a gaussian blur to reduce noise, etc.<br>Try few other pre-processing techniques and evaluate how they affect accuracy<h3 id="T2-Different-features"><a href="#T2-Different-features" class="headerlink" title="T2: Different features"></a>T2: Different features</h3>What are other feature extraction methods you can use?<br>Explore some other feature extraction methods given in skimage (Module: feature —<br>skimage v0.19.0.dev0 docs (scikit-image.org))<br>Try few other feature extraction methods and evaluate how they affect accuracy, you can<br>also try different packages here (no need to stick with skimage)<h3 id="T3-Different-Classification-Models"><a href="#T3-Different-Classification-Models" class="headerlink" title="T3: Different Classification Models"></a>T3: Different Classification Models</h3>What are other classification models you can use?<br>Try other classifiers including but not limited to; RandomForrest, kNN and Decision Tree.<br>For each classifier, change parameters and evaluate how the parameters affect accuracy.<h2 id="Bonus-Level"><a href="#Bonus-Level" class="headerlink" title="Bonus Level"></a>Bonus Level</h2>This level is for you to apply what you learned to a more challenging dataset from scratch. The<br>dataset is, German Traffic Sign Recognition Benchmark (GTSRB) (German Traffic Sign Benchmarks<br>(rub.de)). This is available in the “Dataset_2.zip” file.<br>This dataset is already split into training and testing sets for you.<h3 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h3>Write a python program to load the images from this dataset, into X, y. Then do suitable preprocessing, feature extraction and model training to develop a Traffic Sign Recognition system.<br>Report on the methods used and the results obtained by your Traffic Sign Recognition system.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">from</span> cv2 <span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><br><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> metrics<br><span class="hljs-keyword">from</span> skimage.feature <span class="hljs-keyword">import</span> hog<br><span class="hljs-keyword">from</span> skimage.feature <span class="hljs-keyword">import</span> canny<br><span class="hljs-keyword">from</span> skimage.feature <span class="hljs-keyword">import</span> local_binary_pattern<br><br><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> svm<br><span class="hljs-keyword">import</span> sklearn.naive_bayes <span class="hljs-keyword">as</span> sk_bayes<br><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier<br><br><span class="hljs-keyword">import</span> datetime<br><br><span class="hljs-comment"># load the dataset</span><br>dataset_path = <span class="hljs-string">&quot;Dataset_1\\images\\&quot;</span><br>X = []  <span class="hljs-comment"># 图像集</span><br>y = []  <span class="hljs-comment"># 标签集</span><br>print(<span class="hljs-string">&quot;Loading from the dataset...&quot;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> glob.glob(dataset_path + <span class="hljs-string">&#x27;*.png&#x27;</span>, recursive=<span class="hljs-literal">True</span>):<br>    label = i.split(<span class="hljs-string">&quot;images&quot;</span>)[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>:<span class="hljs-number">4</span>]  <span class="hljs-comment"># 根据文件名开头划分标签</span><br>    y.append(label)<br>    img = cv2.imread(i)<br>    X.append(img)  <span class="hljs-comment"># 加载图像</span><br><br><span class="hljs-comment"># Preprocess</span><br>x_prossessed = []<br>print(<span class="hljs-string">&quot;Preprocessing the images...&quot;</span>)<br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> X:<br>    x = cv2.imread(x)<br>    temp_x = cv2.resize(x, (<span class="hljs-number">48</span>, <span class="hljs-number">48</span>))<br>    <span class="hljs-comment"># 图像处理部分，给出了如下三种图像处理的方式，可以组合，也可以单独使用，不需要的直接注释掉然后append（36行）对应的结果就行</span><br>    <span class="hljs-comment"># convert to gray 转换为灰度图</span><br>    x_process_gray = cv2.cvtColor(temp_x, cv2.COLOR_BGR2GRAY)<br>    <span class="hljs-comment"># gave the gaussian blur 高斯滤波</span><br>    x_process_gau = cv2.GaussianBlur(x_process_gray, (<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), <span class="hljs-number">0</span>)<br>    <span class="hljs-comment"># gave the medianBlur 中值滤波</span><br>    x_process_md = cv2.medianBlur(x_process_gau, <span class="hljs-number">3</span>)<br>    x_prossessed.append(x_process_md)<br><br><span class="hljs-comment"># calculate features</span><br><span class="hljs-comment"># 提取特征，给出了下面的三种方法，三选一，选一个取消注释。</span><br>X_features = []<br>print(<span class="hljs-string">&quot;Calculating features...&quot;</span>)<br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> x_prossessed:<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    # Hog features : 提取图像的直方图信息</span><br><span class="hljs-string">    x_feature_hog = hog(x,</span><br><span class="hljs-string">                    orientations=8,</span><br><span class="hljs-string">                    pixels_per_cell=(10, 10),</span><br><span class="hljs-string">                    cells_per_block=(1, 1),</span><br><span class="hljs-string">                    visualize=False,</span><br><span class="hljs-string">                    multichannel=False)</span><br><span class="hljs-string">    X_features.append(x_feature_hog)</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    # canny features： 提取图像的边缘特征</span><br><span class="hljs-string">    x_feature_canny = canny(np.array(x), sigma=1.0)</span><br><span class="hljs-string">    X_features.append(x_feature_canny)</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>   <br>    <span class="hljs-comment"># LBP features: 对光照有很强的鲁棒性</span><br>    x_feature_lbp = local_binary_pattern(x, <span class="hljs-number">8</span>, <span class="hljs-number">1.0</span>, method=<span class="hljs-string">&#x27;default&#x27;</span>)<br>    X_features.append(x_feature_lbp)<br>    <br><span class="hljs-comment"># 把X_features 转换为长向量</span><br>images = np.array(X_features).reshape((<span class="hljs-built_in">len</span>(np.array(X_features)), -<span class="hljs-number">1</span>))<br><br><span class="hljs-comment"># 划分训练集和测试集</span><br>print(<span class="hljs-string">&quot;Trainning the dataset...&quot;</span>)<br>x_train, x_test, y_train, y_test = train_test_split(images,<br>                                                    y,<br>                                                    test_size=<span class="hljs-number">0.2</span>,<br>                                                    shuffle=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 分类器，下面给出了三种分类器</span><br>acc = []  <span class="hljs-comment"># 创建一个列表用于存放准确率</span><br>timecosts = []  <span class="hljs-comment"># 创建一个列表用于存放耗时</span><br><span class="hljs-comment"># 支持向量机分类器</span><br>print(<span class="hljs-string">&quot;Trainning by svm...&quot;</span>)<br>time1 = (datetime.datetime.now())  <span class="hljs-comment"># 第一个时间戳</span><br>clf1 = svm.SVC()<br>clf1.fit(x_train, y_train)  <span class="hljs-comment"># 数据拟合</span><br>time2 = (datetime.datetime.now())  <span class="hljs-comment"># 第二个时间戳</span><br>acc_svm = clf1.score(x_test, y_test)  <span class="hljs-comment"># 计算准确率</span><br>acc.append(acc_svm)<br>timecost = <span class="hljs-built_in">str</span>(time2 - time1)  <span class="hljs-comment"># 计算时间差</span><br>timecosts.append(timecost)<br><br><span class="hljs-comment"># 伯努利分布的朴素贝叶斯分类器</span><br>print(<span class="hljs-string">&quot;Trainning by BN...&quot;</span>)<br>time1 = (datetime.datetime.now())  <span class="hljs-comment"># 第一个时间戳</span><br>clf2 = sk_bayes.BernoulliNB(alpha=<span class="hljs-number">1.0</span>,<br>                            binarize=<span class="hljs-number">0.0</span>,<br>                            fit_prior=<span class="hljs-literal">True</span>,<br>                            class_prior=<span class="hljs-literal">None</span>)<br>clf2.fit(x_train, y_train)  <span class="hljs-comment"># 数据拟合</span><br>time2 = (datetime.datetime.now())  <span class="hljs-comment"># 第二个时间戳</span><br>acc_NB = clf2.score(x_test, y_test)  <span class="hljs-comment"># 计算准确率</span><br>acc.append(acc_NB)<br>timecost = <span class="hljs-built_in">str</span>(time2 - time1)  <span class="hljs-comment"># 计算时间差</span><br>timecosts.append(timecost)<br><br><span class="hljs-comment"># KNN分类器 k=1 (对于这个KNN，k越大，越不行)</span><br>print(<span class="hljs-string">&quot;Trainning by KNN...&quot;</span>)<br>time1 = (datetime.datetime.now())  <span class="hljs-comment"># 第一个时间戳</span><br>clf3 = KNeighborsClassifier(n_neighbors=<span class="hljs-number">1</span>)<br>clf3.fit(x_train, y_train)  <span class="hljs-comment"># 数据拟合</span><br>time2 = (datetime.datetime.now())  <span class="hljs-comment"># 第二个时间戳</span><br>acc_KNN = clf3.score(x_test, y_test)  <span class="hljs-comment"># 计算准确率</span><br>acc.append(acc_KNN)<br>timecost = <span class="hljs-built_in">str</span>(time2 - time1)  <span class="hljs-comment"># 计算时间差</span><br>timecosts.append(timecost)<br><br>clfname = [<span class="hljs-string">&#x27;SVM&#x27;</span>, <span class="hljs-string">&#x27;NB&#x27;</span>, <span class="hljs-string">&#x27;KNN&#x27;</span>]<br>print(<span class="hljs-string">&quot;---------result-------------&quot;</span>)<br>print(<span class="hljs-string">&quot;accurancy is:&quot;</span>)<br>print(clfname)  <span class="hljs-comment"># 输出分类器的名字</span><br>print(acc)  <span class="hljs-comment"># 输出准确率</span><br>print(<span class="hljs-string">&quot;timecost:&quot;</span>)<br>print(timecosts)<br><br>print(<span class="hljs-string">&quot;Displaying the Confusion Matrixes&quot;</span>)<br><span class="hljs-comment"># 显示混淆矩阵</span><br><span class="hljs-comment"># 混淆矩阵显示有点慢 但是三张都可以显示 【要关闭当前之后才能显示下一张】</span><br><span class="hljs-comment"># svm算法的混淆矩阵</span><br>print(<span class="hljs-string">&quot;cm of svm&quot;</span>)<br>cm1 = metrics.plot_confusion_matrix(clf1, x_test, y_test)  <span class="hljs-comment"># 创建混淆矩阵</span><br>plt.get_current_fig_manager().window.state(<span class="hljs-string">&#x27;zoomed&#x27;</span>)<br>plt.show()  <span class="hljs-comment"># 显示混淆矩阵</span><br><br><span class="hljs-comment"># BN算法的混淆矩阵</span><br>print(<span class="hljs-string">&quot;cm of bn&quot;</span>)<br>cm2 = metrics.plot_confusion_matrix(clf2, x_test, y_test)  <span class="hljs-comment"># 创建混淆矩阵</span><br>plt.get_current_fig_manager().window.state(<span class="hljs-string">&#x27;zoomed&#x27;</span>)<br>plt.show()  <span class="hljs-comment"># 显示混淆矩阵</span><br><br><span class="hljs-comment"># KNN的混淆矩阵</span><br>print(<span class="hljs-string">&quot;cm of knn&quot;</span>)<br>cm3 = metrics.plot_confusion_matrix(clf3, x_test, y_test)  <span class="hljs-comment"># 创建混淆矩阵</span><br>plt.get_current_fig_manager().window.state(<span class="hljs-string">&#x27;zoomed&#x27;</span>)<br>plt.show()  <span class="hljs-comment"># 显示混淆矩阵</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Machine Learning-NUS 2021</category>
      
      <category>课后练习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>5. 特征</title>
    <link href="/2021/01/28/Machine%20Learning-NAU/5.%20%E7%89%B9%E5%BE%81/"/>
    <url>/2021/01/28/Machine%20Learning-NAU/5.%20%E7%89%B9%E5%BE%81/</url>
    
    <content type="html"><![CDATA[<p><style><br>img{<br>    width: 60%;<br>    padding-left: 30%;<br>}</style></p><h1 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h1><h2 id="特征的选择"><a href="#特征的选择" class="headerlink" title="特征的选择"></a>特征的选择</h2><p>曾在第四讲中提到过特征的选择，特征的选取可以从颜色、形状、直方图等等来提取。<br>好的特征应该具有如下的性质：  </p><ul><li>计算简便</li><li>鲁棒性</li><li>储存小</li><li>好的区分度</li><li>更优的距离度量    <h3 id="NP-hard！"><a href="#NP-hard！" class="headerlink" title="NP hard！"></a>NP hard！</h3>尝试试所有的特征组合是一种在直觉上认为的简便方案，它是一种非确定性多项式(Non-Deterministic polynomial Hard，NP hard)问题，该问题在理论上能够用一种称为贪心算法(Greedy approach)的方法尝试解决：     <ul><li>对于F 个可能的特征，选择其中能给出最高准确率的一个特征X</li><li>对于剩下的 F-1个可能的特征，选择与特征X组合能够给出最高准确率的一个特征。</li><li>重复上述过程，直到选择出所有的特征。  </li></ul></li></ul><h3 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h3><p>主成分分析（Principal Component Analysis，PCA）是另一种选择出更好的一组特征的方法。<br>设$y ∈ R^k$是图像(或者上一级的特征向量)$x ∈ R^d$的特征向量，$k&lt;&lt;d$，有：   </p><script type="math/tex; mode=display">y=W^Tx</script><ul><li><p>$W$<br>$W$是一个$d × k$的正交矩阵，由x计算得到。<br>设均值矩阵$E[x]=0$,协方差矩阵$E[xx^T]=C_x$,如下是计算$W$的方法：<br>设回复向量（recovered vector）$x_r=Wy$,误差$ε =x-x_r=x-WW^Tx$,</p><script type="math/tex; mode=display">\begin{aligned}    |ϵ|^2 & = ϵ^Tϵ \\      & =(x-WW^TX)^T(X-WW^Tx) \\    & =x^Tx-x^TWW^Tx-x^TWW^Tx+x^TWW^TWW^Tx \\    & =x^Tx-x^TWW^Tx\end{aligned}</script><p>令$k=1$,此时$W$是一个向量:</p><script type="math/tex; mode=display">\begin{aligned}  E[ ϵ^Tϵ] & =E[x^Tx-x^Tww^Tx]\\  & =E[x^Tx]-W^TC_xW\end{aligned}</script><p>那么需要找到使得$E[ ϵ^Tϵ]$最小的$w$，这一步与求$max_w w^TC_xw$等价。<br>设$J=\frac{w^TC_xw}{W^TW}$以正规化W：<br>令$\frac{dJ}{dw}=0$，得到：</p><script type="math/tex; mode=display">\frac{2C_xw}{w^Tw}-[\frac{w^TC_xw}{w^Tw}]·\frac{2w}{w^Tw}=0</script><script type="math/tex; mode=display">C_xw=Jw</script><p>这个公式正好是协方差矩阵$C_x$的特征值方程公式，即:$w$为协方差矩阵$C_x$的特征向量，$J$是它的特征值。    </p><p>如果对$C_x$进行特征分解(Eigen composition),得到一组特征值，将特征值从大到小排序，从中选取k个最大的特征值所对应的特征向量，组成矩阵$W$。  </p><script type="math/tex; mode=display">W=[w_1 |w_2 |...|w_k]</script><p>w称为主成分，所有的主成分两两正交。<br>最终得到的PCA是：  </p><script type="math/tex; mode=display">y=W^T(x-E[x])</script><p>PCA将依据数据的分布，改变样本空间的坐标原点和坐标轴（表示原来的特征），并将所有的坐标轴变更为主成分，如图所示：<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210222144956.png" alt=""><br>y事实上是x的压缩集，改变后的y中的元素都是不相关的。   </p></li></ul><p>整个PCA过程中，k的选取十分的重要，通常k的选取遵循如下的规则：<br>记 $λ$是$C_x$特征分解后得到的从大到小特征值，有:    </p><script type="math/tex; mode=display">\frac{∑^kλ_i}{∑^dλ_i}≈90\%</script><p>即前k个特征值的和大约是总的特征值和的0.9左右。   </p><ul><li>案例<br>1990年 Turk 和 Pentland应用PCA算法对人脸图像进行处理，称为特征子脸技术。特征子脸技术的基本思想是：从统计的观点，寻找人脸图像分布的基本元素，即人脸图像样本集协方差矩阵的特征向量，以此近似地表征人脸图像。这些特征向量称为特征脸(Eigenface)。<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210222150404.png" alt="">   </li></ul>]]></content>
    
    
    <categories>
      
      <category>Machine Learning-NUS 2021</category>
      
      <category>讲义</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>5. 课后练习-使用更多的分类器</title>
    <link href="/2021/01/28/Machine%20Learning-NAU/5.a%20%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0-%E6%89%8B%E5%86%99%E5%AD%97%E7%AC%A6%E8%AF%86%E5%88%AB/"/>
    <url>/2021/01/28/Machine%20Learning-NAU/5.a%20%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0-%E6%89%8B%E5%86%99%E5%AD%97%E7%AC%A6%E8%AF%86%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="课后练习-5"><a href="#课后练习-5" class="headerlink" title="课后练习 5"></a>课后练习 5</h1><h2 id="Tasks"><a href="#Tasks" class="headerlink" title="Tasks:"></a>Tasks:</h2><ul><li>Study k-Nearest Neighbours classifiers sklearn.neighbors.KNeighborsClassifier — scikit-learn<br>0.24.1 documentation (scikit-learn.org)</li><li>Study RandomForrest classifiers sklearn.ensemble.RandomForestClassifier — scikit-learn<br>0.24.1 documentation (scikit-learn.org)</li><li>Study Naïve Bayes classifiers 1.9. Naive Bayes — scikit-learn 0.24.1 documentation (scikitlearn.org)<h2 id="Programming-exercise"><a href="#Programming-exercise" class="headerlink" title="Programming exercise:"></a>Programming exercise:</h2>This tutorial will use the MNIST dataset which was explored in tutorial 3.<h3 id="Q1-Train-a-k-Nearest-Neighbours-classifier-for-handwritten-digit-recognition-with-MNIST-dataset"><a href="#Q1-Train-a-k-Nearest-Neighbours-classifier-for-handwritten-digit-recognition-with-MNIST-dataset" class="headerlink" title="Q1. Train a k-Nearest Neighbours classifier for handwritten digit recognition with MNIST dataset."></a>Q1. Train a k-Nearest Neighbours classifier for handwritten digit recognition with MNIST dataset.</h3>Try different parameter settings and study how the performance varies.</li><li>Plot the accuracy vs k while changing the number of neighbours (k) with values [1, 3, 5, 7, 9]<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> datasets<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier<br><br>digits = datasets.load_digits()<br>labels = digits.target<br><br>data = images.reshape(<span class="hljs-built_in">len</span>(images), -<span class="hljs-number">1</span>)<br>x_train, x_test, y_train, y_test = train_test_split(data, labels, test_size=<span class="hljs-number">0.2</span>, shuffle=<span class="hljs-literal">False</span>)<br>g = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>]<br>accurancy = []<br><span class="hljs-keyword">for</span> g_ <span class="hljs-keyword">in</span> g:<br>    clf = KNeighborsClassifier(n_neighbors = g)<br>    clf.fit(x_train, y_train)<br>    acc = clf.predict(x_test, y_test)<br>    accurancy.append(acc)<br><br>plt.plot(g, accurancy)<br>plt.show()<br></code></pre></td></tr></table></figure><h3 id="Q2-Train-a-RandomForrest-classifier-for-handwritten-digit-recognition-with-MNIST-dataset"><a href="#Q2-Train-a-RandomForrest-classifier-for-handwritten-digit-recognition-with-MNIST-dataset" class="headerlink" title="Q2. Train a RandomForrest classifier for handwritten digit recognition with MNIST dataset."></a>Q2. Train a RandomForrest classifier for handwritten digit recognition with MNIST dataset.</h3>Try different parameter settings and study how the performance varies.</li><li>Plot the accuracy vs max_depth while changing the max depth parameter with values [1, 2, 4, 8, 16]<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> datasets<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForrest<br><br>digits = datasets.load_digits()<br>labels = digits.target<br><br>data = images.reshape(<span class="hljs-built_in">len</span>(images), -<span class="hljs-number">1</span>)<br>x_train, x_test, y_train, y_test = train_test_split(data, labels, test_size=<span class="hljs-number">0.2</span>, shuffle=<span class="hljs-literal">False</span>)<br>g = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">16</span>]<br>accurancy = []<br><span class="hljs-keyword">for</span> g_ <span class="hljs-keyword">in</span> g:<br>    clf = RandomForrest(max_depth = g)<br>    clf.fit(x_train, y_train)<br>    acc = clf.predict(x_test, y_test)<br>    accurancy.append(acc)<br>plt.plot(g, accurancy)<br>plt.show()<br></code></pre></td></tr></table></figure><h3 id="Q3-Train-a-Gaussian-Naive-Bayes-classifier-for-handwritten-digit-recognition-with-the-MNIST-dataset"><a href="#Q3-Train-a-Gaussian-Naive-Bayes-classifier-for-handwritten-digit-recognition-with-the-MNIST-dataset" class="headerlink" title="Q3. Train a Gaussian Naive Bayes classifier for handwritten digit recognition with the MNIST dataset."></a>Q3. Train a Gaussian Naive Bayes classifier for handwritten digit recognition with the MNIST dataset.</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> datasets<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForrest<br><br>digits = datasets.load_digits()<br>labels = digits.target<br><br>data = images.reshape(<span class="hljs-built_in">len</span>(images), -<span class="hljs-number">1</span>)<br>x_train, x_test, y_train, y_test = train_test_split(data, labels, test_size=<span class="hljs-number">0.2</span>, shuffle=<span class="hljs-literal">False</span>)<br>clf1 = sk_bayes.BernoulliNB(alpha=<span class="hljs-number">1.0</span>,<br>                            binarize=<span class="hljs-number">0.0</span>,<br>                            fit_prior=<span class="hljs-literal">True</span>,<br>                            class_prior=<span class="hljs-literal">None</span>)<br>clf1.fit(x_train, y_train)  <br>acc_BN = clf1.score(x_test, y_test) <br>acc.append(acc_BN)<br></code></pre></td></tr></table></figure></li><li>Plus： Displaying the wrong images  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 显示错误的图片</span><br>clf = RandomForrest(max_depth = g)<br>clf.fit(x_train, y_train)<br>predictions = clf.predict(x_test)<br><span class="hljs-comment"># clf.predict_proba() 显示每张图有多少概率是哪个标签</span><br>print(predictions) <span class="hljs-comment"># 这样会输出所有图片的预测标签</span><br>print(y_test)<br></code></pre></td></tr></table></figure><h3 id="Q4-Do-a-comparison-between-the-four-classifiers-SVM-–-Tutorial-3-kNN-RandomForrest-and-NaiveBayes-by-plotting-the-best-performing-accuracy-value-for-each-classifier-in-a-bar-chart"><a href="#Q4-Do-a-comparison-between-the-four-classifiers-SVM-–-Tutorial-3-kNN-RandomForrest-and-NaiveBayes-by-plotting-the-best-performing-accuracy-value-for-each-classifier-in-a-bar-chart" class="headerlink" title="Q4. Do a comparison between the four classifiers (SVM – Tutorial 3, kNN, RandomForrest and NaïveBayes) by plotting the best performing accuracy value for each classifier in a bar chart."></a>Q4. Do a comparison between the four classifiers (SVM – Tutorial 3, kNN, RandomForrest and NaïveBayes) by plotting the best performing accuracy value for each classifier in a bar chart.</h3></li></ul>]]></content>
    
    
    <categories>
      
      <category>Machine Learning-NUS 2021</category>
      
      <category>课后练习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>4. 分类器</title>
    <link href="/2021/01/27/Machine%20Learning-NAU/4.%20%E5%88%86%E7%B1%BB%E5%99%A8/"/>
    <url>/2021/01/27/Machine%20Learning-NAU/4.%20%E5%88%86%E7%B1%BB%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p><style><br>img{<br>    width: 60%;<br>    padding-left: 30%;<br>}</style></p><h1 id="分类器"><a href="#分类器" class="headerlink" title="分类器"></a>分类器</h1><h2 id="分类器概述"><a href="#分类器概述" class="headerlink" title="分类器概述"></a>分类器概述</h2><p>设$S=\{ω_1,ω_2,..,ω_c\}$是表示所有特征标签ω的集合，x表示数据集空间$R^n$中的特征向量，定义：<strong>分类器</strong>（Classifier）是一种能够使$R^n→S$的函数$f$。分类器能够将特征标签（labels）指定到特征向量。  </p><ul><li>图像识别的基本流程<br>输入图像—&gt;预处理-&gt;获取特征-&gt;分类<h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><strong>特征</strong>(Features)是不同类别的数据具有的用于识别其自身的属性。在机器学习中，要想对数据集进行识别和分类就必须要提取数据集的特征。<br>特征的提取并不是越多越好，不相关的特征（称为噪声（Noise features））会降低识别的准确度；具有高相关性的特征（比如：长发和女性）会让模型出现过拟合（Generalization）和模型冗余之类的其他问题。  </li><li><p>决策边界<br><strong>决策边界</strong>（Decision boundary）是二元分类中能够依据特征的分布来分出两类的边界。<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210208145142.png" alt="">   </p></li><li><p>过拟合问题（Generalization）<br>如果一个模型虽然可以穿过所有的数据点，但是其图像波动很大，其同样也不能描述数据的分布，（其数据的分布是无法被泛化处理），称为过拟合，或者说这个算法具有高方差的特性。<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210208150529.png" alt=""></p></li></ul><h2 id="贝叶斯分类器"><a href="#贝叶斯分类器" class="headerlink" title="贝叶斯分类器"></a>贝叶斯分类器</h2><p><strong>贝叶斯分类器</strong>(Bayes’ classifier)被理论证明是目前最好的分类器。贝叶斯分类器依赖于模式识别(Pattern recognition)<br>想象如下的情形：我们已经测量了用于识别男女性别的特征，现在要根据这些特征来对一个未知的人判断其性别。如果你对其不做任何的测量，那么你是否还能进行分类？<br>₋答案是：如果我们知道男女性别的比例，比如男性/总的人群:$P{ω_1}=58.8%$。将频率视为概率，那么这个概率被称为<strong>先验概率</strong>（Prior probability），由于是男性的概率大于是女性的概率，因此我们将这个识别目标<strong>总是判断为概率最高的标签</strong>——即男性，那么我们判断其为男性的正确率为58.8%。<br>如何去优化这个正确率？——对识别目标进行观测：<br>假设已经观测到目标的特征$X$，对标签集$Ω$,计算所有的如果具有特性$x$,识别目标为标签$ω_i$的概率，并从中找到最大的条件概率，目标特征的标签$ω^*$即为最大的条件概率。用数学公式表达为：   </p><script type="math/tex; mode=display">ω^*=arg_{ω_i}~maxP(ω_i|x)</script><p>由计算得出的概率$P(ω_i|x)$称为<strong>后验概率</strong>(Posteriori)。<br>由贝叶斯公式：  </p><script type="math/tex; mode=display">P(A|B)=\frac{P(B|A)×P(A)}{P(B)}</script><p>那么后验概率可以转化为：</p><script type="math/tex; mode=display">P(ω_i|x)=\frac{P(x|ω_i)·P(ω_i)}{P(x)}</script><p>带入分类器公式：   </p><script type="math/tex; mode=display">ω^*=arg_{ω_i}~max\frac{P(x|ω_i)·P(ω_i)}{P(x)}</script><p>由于$P(x)$是一个常数，那么最大值函数可以被简化为求$P(x|ω_i)·P(ω_i)$的最大值：  </p><script type="math/tex; mode=display">ω^*=arg_{ω_i}~maxP(x|ω_i)·P(ω_i)</script><p>这就是贝叶斯分类器公式。    </p><ul><li><p>特殊情况<br>如果先验概率是均等的：</p><script type="math/tex; mode=display">P(ω_i)=P(ω_1)=...=P(ω_n)=C</script><p>那么分类器公式还能被简化为：  </p><script type="math/tex; mode=display">ω^*=arg_{ω_i}~maxP(x|ω_i)</script><p>称为最大可能公式（Maximunm Likelihood）。   </p><p>如果分类器中只有两个标签$ω_1,ω_2$:<br>那么设定：   </p><script type="math/tex; mode=display">g(x)=P(ω_1|x)-P(ω_2|x)</script><p>如果$g(x)&gt;0$则判断为$ω_1$,反之判断为另一类。$g(x)$称为判别函数（Discriminant function）。   </p></li><li><p>代价/损失（Cost）<br>设对于标签集$\{ω_1,ω_2,…,ω_c\}∈C$,$λ_{ij}$是分类器判断为$ω_i$但实际上的标签是$ω_j$所作出的<strong>代价</strong>（Cost）。<br>规定在$λ$中，当$i=j$时，$λ_{ij}=0$。<br>那么二元的贝叶斯分类器的代价函数为：   </p><script type="math/tex; mode=display">\frac{P(x|ω_1)}{P(x|ω_2)}>\frac{λ_{12}-λ_{22}}{λ_{21}-λ_{11}}·\frac{P(ω_2)}{P(ω_1)}.......ω_1</script><script type="math/tex; mode=display">\frac{P(x|ω_1)}{P(x|ω_2)}<\frac{λ_{12}-λ_{22}}{λ_{21}-λ_{11}}·\frac{P(ω_2)}{P(ω_1)}.......ω_2</script><p>如果$λ_{12}=λ_{21}=1$且$λ_{11}=λ_{22}=0$,称$P(x|ω_i)P(ω_i)$为MAP方程。</p></li></ul><blockquote><p>贝叶斯分类器被证明是理论上误差最小的分类器。     </p></blockquote><p>运用贝叶斯分类器需要知道在有特征$x$的条件下是分类标签$ω_i$的概率——$P(ω_i|x)$，称为可能性（Likelyhood）。在实际运用当中，一般是从数据集中估计这个概率（采用抽样检测等方法），这个估计出的概率通常是不准确的。<br>这个抽样检测的原则是：<strong>如果要创建一个D维（D是特征向量X的维度，即特征的数量）的直方图，一般而言至少需要$10^D$的训练样本。</strong></p><h2 id="朴素贝叶斯分类器"><a href="#朴素贝叶斯分类器" class="headerlink" title="朴素贝叶斯分类器"></a>朴素贝叶斯分类器</h2><p>解决贝叶斯分类器需要的训练样本数量大的问题的其中一个办法是假设所有的特征之间是独立的，根据概率论，有：</p><script type="math/tex; mode=display">P(XY)=P(X)P(Y)</script><p>假设特征向量$x=[x_1,x_2,…,x_D]^T$，有：</p><script type="math/tex; mode=display">ω^*=arg_{ω_j}~maxP(x|ω_j)P(ω_j)</script><script type="math/tex; mode=display">ω^*=arg_{ω_j}~maxP(ω_j)Π_{i=1}^DP(x_i|ω_j)</script><blockquote><p>在实际中，由于$P(x_i|ω_j)∈[0,1]$，因此$Π_{i=1}^DP(x_i|ω_j)$的乘积可能会下溢（非常趋近0）。因此对两边取log函数将乘法项目转为加法项防止下溢。   </p></blockquote><script type="math/tex; mode=display">ω^*=arg_{ω_j}~max~log[P(ω_j)]+∑_{i=1}^Dlog[P(x_i|ω_j)]</script><p>这种分类器公式称为朴素贝叶斯分类器（Naive Bayes）   </p><h2 id="K邻近算法"><a href="#K邻近算法" class="headerlink" title="K邻近算法"></a>K邻近算法</h2><p>K邻近算法（K-Nearest Neighbor,KNN）是一种不依赖概率而直接求得决策边界的办法。<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210215095611.png" alt=""><br>如上图，设想现在样本空间内有两类样本，新加入一个x到样本空间内，设定$k=5$,计算x到样本空间内所有点的距离，最终取5个距离x最近的样本点，这五个样本点中哪一种类别的样本点多x就是哪一种类别。<br>通常情况下，标签数和K是都是奇数。<br>有数学证明在训练样本足够多的条件下， KNN的错误概率相比于贝叶斯更小。   </p><script type="math/tex; mode=display">P(error_{KNN})⪙P(error_{Bayes})</script><ul><li>距离度量（Distance Metrics）<br>设定距离度量函数$D(x,y)$,具有非负性、唯一性、和三角矢量性。   <script type="math/tex; mode=display">D_p(x,y)=(∑_{i=1}^n|x_i-y_i|^p)^{1/p}</script>x,y为向量。p称为范数（Norm）。<br>为了避免x，y的数值过于悬殊，人为地添加权重$w_i$，有：  <script type="math/tex; mode=display">D_p(x,y)=(∑_{i=1}^nw_i|x_i-y_i|^p)^{1/p}</script></li></ul><h2 id="其他分类器"><a href="#其他分类器" class="headerlink" title="其他分类器"></a>其他分类器</h2><ul><li>神经网络<br>神经网络是目前最热门的分类器方法，它模拟了神经元的传递过程，即输入信号——处理信号——接收信号。 </li><li>向量机（Support vector machine,SVM）<br>向量机的目的是为了找到一个线性的决策边界。<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210215102440.png" alt="">  </li></ul><h2 id="性能评估"><a href="#性能评估" class="headerlink" title="性能评估"></a>性能评估</h2><p>现在要对一个分类器的效果进行评估，方法是用另一组数据集去测试分类器的性能。在实际运用中，通常把训练集划分为两部分：训练集和测试集。 测试集不会被训练。 将测试集放入分类器后，分类器得出的标签和测试集中的标签进行对比。   </p><h3 id="混淆矩阵"><a href="#混淆矩阵" class="headerlink" title="混淆矩阵"></a>混淆矩阵</h3><p>有如下将测试结果可视化的方法，称为<strong>混淆矩阵</strong>(Confusion matrix)方法：<br>将横轴作为实际的标签，纵轴作为预测的标签，每一格表示“实际为标签i/但是预测为标签j”的频率，做出矩阵，如下图所示：<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210217114634.png" alt=""><br>对角线上频率的总和即为训练集的正确率。<br>混淆矩阵能够容易的表现出分类器错误的分类情况。  </p><h3 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h3><p><strong>交叉验证</strong>（K-fold cross validation）能够最大程度的避免测试集发生的“偶然正确（称为福禄克测试，Fluke test）”，具体的做法是：<br>将数据集平均分为k份，取其中一份为测试集，剩下的为训练集。重复上述步骤直到每一份都被做过训练集。 最终分类器的准确率为所有测试的准确率的平均值。    </p><h3 id="错误类型与ROC曲线"><a href="#错误类型与ROC曲线" class="headerlink" title="错误类型与ROC曲线"></a>错误类型与ROC曲线</h3><ul><li><p>FRR<br>False Reject Rate， 表示目标正确却识别为错误的概率。   </p></li><li><p>FAR<br>False Accept Rate， 表示目标错误却识别为正确的概率。</p></li><li><p>FTE<br>Failure to Enroll Rate, 无法识别的概率。</p></li></ul><p>理想条件下，FRR和FAR都应该等于0。不断地改变分类器的阈值，将横轴为FAR,纵轴为1-FRR，作出<strong>ROC曲线</strong>(受试者工作特征曲线, Receiver operating characteristic curve)。这条曲线始终在y=x以上。<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210217121830.png" alt=""><br>理想条件下，ROC曲线应该是一个L形状，即FAR=FRR=0。<br>ROC曲线围成的下夹面积，即AUC表示了系统的强壮性，AUC越大越好。<br>EER(Equal error rate)，也就是FPR=FNR的值，由于FNR=1-TPR，可以画一条从（0,1）到（1,0）的直线，找到直线与ROC曲线的交点。 交点越靠近(1,1)越好。</p>]]></content>
    
    
    <categories>
      
      <category>Machine Learning-NUS 2021</category>
      
      <category>讲义</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>4. 课后练习-MNIST 手写训练集</title>
    <link href="/2021/01/27/Machine%20Learning-NAU/4.a%20%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0-MNIST/"/>
    <url>/2021/01/27/Machine%20Learning-NAU/4.a%20%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0-MNIST/</url>
    
    <content type="html"><![CDATA[<h1 id="课后练习3"><a href="#课后练习3" class="headerlink" title="课后练习3"></a>课后练习3</h1><h2 id="Tasks"><a href="#Tasks" class="headerlink" title="Tasks"></a>Tasks</h2><ol><li>Familiarize yourself with the MNIST dataset: MNIST handwritten digit database, Yann LeCun, Corinna Cortes and Chris Burges. [<a href="http://yann.lecun.com/exdb/mnist/">http://yann.lecun.com/exdb/mnist/</a>]  </li><li>Familiarize yourself with sklearn package: scikit-learn: machine learning in Python — scikitlearn 0.24.1 documentation [scikit-learn.org]  </li></ol><h2 id="Programming-exercise"><a href="#Programming-exercise" class="headerlink" title="Programming exercise"></a>Programming exercise</h2><h3 id="Q1-Use-the-fetch-openml-function-found-in-sklearn-datasets-to-load-the-mnist-784-dataset-into-python-This-will-load-X-and-y-variables-for-you"><a href="#Q1-Use-the-fetch-openml-function-found-in-sklearn-datasets-to-load-the-mnist-784-dataset-into-python-This-will-load-X-and-y-variables-for-you" class="headerlink" title="Q1. Use the fetch_openml function found in sklearn.datasets to load the mnist_784 dataset into python. This will load X and y variables for you."></a>Q1. Use the fetch_openml function found in sklearn.datasets to load the mnist_784 dataset into python. This will load X and y variables for you.</h3><ul><li>Print the dimensions of the variables returned by the function.</li><li>Write a python script to find how many distinct values are present in y?</li><li>Select one sample from X for each distinct y value.</li><li>Resize each sample to represent the 28x28 pixel image.</li><li>Display all the selected images in one diagram using subplots in matplotlib. The following<br>code gives you an example of how to do this,<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python">fig = plt.figure()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>):<br>fig.add_subplot(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, i)<br>plt.imshow(images[i])<br>plt.show()<br></code></pre></td></tr></table></figure>Solutions:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> datasets<br><span class="hljs-keyword">from</span> sklearn,datasets <span class="hljs-keyword">import</span> fetch_openml<br>images,labels = fetch_openml(<span class="hljs-string">&#x27;mnist_784&#x27;</span>,version=<span class="hljs-number">1</span>, return_x_y=true, as_frame=false)<br><span class="hljs-comment"># load 70000 28x28=784 handwriting images</span><br><span class="hljs-comment"># print(images.shape)</span><br><span class="hljs-comment">#&gt;&gt; (7000,784)</span><br></code></pre></td></tr></table></figure>or <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> datasets<br>digits = datasets.load_digits() <span class="hljs-comment">#load the mnist dataset which already in sklearn</span><br>images = digits.images <span class="hljs-comment">#access  1797 8x8 images in mnist by print(images.shape)</span><br>labels = digits.target <span class="hljs-comment">#access 1797 labes </span><br><span class="hljs-comment"># print(images.shape)</span><br><span class="hljs-comment">#&gt;&gt; (1797,8,8)</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> datasets<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>digits = datasets.load_digits() <span class="hljs-comment">#load the mnist dataset which already in sklearn</span><br>images = digits.images <span class="hljs-comment">#access  1797 8x8 images in mnist by print(images.shape)</span><br>labels = digits.target <span class="hljs-comment">#access labels</span><br><br>np.unique(labels) <span class="hljs-comment"># summerize the labels</span><br>print(np.unique(labels).shape)<br><br>fig = plt.figure()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>):<br>    fig.add_subplot(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, i+<span class="hljs-number">1</span>) <span class="hljs-comment"># creat a batch of subplot with 2 rows 5 columns</span><br>    <span class="hljs-comment"># i means the position in the subplot</span><br>    plt.imshow(images[i])<br>plt.show() <span class="hljs-comment"># display the subplot</span><br></code></pre></td></tr></table></figure><h3 id="Q2-Use-sklearn-to-train-a-digit-classifier"><a href="#Q2-Use-sklearn-to-train-a-digit-classifier" class="headerlink" title="Q2. Use sklearn to train a digit classifier."></a>Q2. Use sklearn to train a digit classifier.</h3></li><li>Split the X and y into a training set and testing set of 80-20 split.</li><li>Train a Support Vector Machin (SVM) for classification of the digits using the training set.<br>The following code shows how to train a model using sklearn.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python">clf = svm.SVC()<br>clf.fit(x_train, y_train)<br></code></pre></td></tr></table></figure></li><li>Test the model using the test set.</li><li>Experiment with different parameter values for the SVM and see how it performs. Try<br>changing the gamma value to be [0.0001, 0.0005, 0.001, 0.005, 0.01]</li><li>Plot the accuracy value with respect to the change in gamma above.</li><li>Plot the confusion matrix<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> datasets<br><span class="hljs-keyword">import</span> matplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> svm<br><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> metrics<br><br>digits = datasets.load_digits() <span class="hljs-comment"># load the mnist dataset which already in sklearn</span><br>data = digits.images <span class="hljs-comment"># access  1797 8x8 images in mnist, print(images.shape)</span><br>labels = digits.target <span class="hljs-comment"># access 1797 labels</span><br><br>images = data.reshape((<span class="hljs-built_in">len</span>(data),-<span class="hljs-number">1</span>)) <span class="hljs-comment"># reshaape the 8x8 matrixes into 64x1 vectors</span><br><br>x_train,x_test,y_train,y_test = train_test_split(images,labels, test_size = <span class="hljs-number">0.2</span>, shuffle = false) <span class="hljs-comment"># 20% will be test set</span><br><span class="hljs-comment"># x:images y:labels</span><br><br>clf = svm.SVC() <span class="hljs-comment"># create the svm classifier</span><br>clf.fit(x_train, y_train) <span class="hljs-comment"># fit the data  within vectors</span><br><br>acc = clf.score(x_test, y_test) <span class="hljs-comment"># do the test and retrun the accurancy</span><br>disp = metrics.plot_confusion_matrix(clf,x_test,y_test) <span class="hljs-comment"># add into confusion matrix</span><br>print(acc) <span class="hljs-comment"># print the accurancy</span><br>sklearn.metrics.ConfusionMatrixDisplay(disp) <span class="hljs-comment"># display the confusion matrix</span><br><br>g_ = [<span class="hljs-number">0.0001</span>,<span class="hljs-number">0.0005</span>,<span class="hljs-number">0.001</span>,<span class="hljs-number">0.005</span>,<span class="hljs-number">0.01</span>] <span class="hljs-comment"># list of gamma</span><br>scores = [] <span class="hljs-comment"># list of accurancy</span><br><span class="hljs-keyword">for</span> g <span class="hljs-keyword">in</span> g_:<br>    clf = svm.SVC(gamma = g) <span class="hljs-comment"># create the svm classifier,specify the gamma</span><br>    clf.fit(x_train, y_train) <span class="hljs-comment"># fit the data  within vectors</span><br><br>    acc = clf.score(x_test, y_test) <span class="hljs-comment"># do the test and retrun the accurancy</span><br>    scores.append(acc)<br><br><br><br>print(g_) <span class="hljs-comment"># print the accurancy</span><br>print(scores)<br><br>plt.plot(g_, scores)<br>plt.show()  <br></code></pre></td></tr></table></figure></li></ul><p>```</p>]]></content>
    
    
    <categories>
      
      <category>Machine Learning-NUS 2021</category>
      
      <category>课后练习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>3. 图像处理</title>
    <link href="/2021/01/26/Machine%20Learning-NAU/3.%20%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    <url>/2021/01/26/Machine%20Learning-NAU/3.%20%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p><style><br>img{<br>    width: 60%;<br>    padding-left: 30%;<br>}</style></p><h1 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h1><h2 id="成像原理与数字化"><a href="#成像原理与数字化" class="headerlink" title="成像原理与数字化"></a>成像原理与数字化</h2><ul><li>小孔成像（Pinhole）<br>小孔成像的基本原理如下图所示：<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210207142920.png" alt="">    </li><li>透镜成像<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210207143053.png" alt="">  </li><li><p>CCD/CMOS（电荷耦合）成像<br>在CCD成像当中，通过透镜后的像会呈现在CMOS上，COMS会将呈现数字化，这一过程中有两个重要的步骤：  </p><ol><li><strong>抽样</strong>（Sampling）<br>将图像转化为有限的单位像素，如图所示：<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210207144301.png" alt="">    </li><li><strong>量化</strong>（Quantization）<br>用整数表示单位像素的值，对于8bit而言，单位像素的明暗程度以0~255的灰度值来表示，0表示黑色，255表示白色。  </li></ol><p>现在，一幅黑白的图像中的每一个单位像素点都用一个整数来表示其黑白的程度，那么整张图片就可以用一个只有整数的矩阵来表示（单通道）。<br>对于彩色的图像，通常以RGB（红色、绿色、蓝色）的三种程度（三通道）来进行量化，因此彩色图片的一个单位像素点以一个三维的向量，通常是$[R,G,B]$来表示。最终三个矩阵表示一幅彩色图像，这个过程叫做张量（Tensor）。  </p><h2 id="点处理-Point-Processing"><a href="#点处理-Point-Processing" class="headerlink" title="点处理(Point Processing)"></a>点处理(Point Processing)</h2><p>图像的点处理是： 设定图像上一个像素值$r(x,y)$,经过处理$s(x,y)=T(r(x,y))$后，得到同一位置的像素$s(x,y)$。<br>注意：</p></li></ul><ol><li>$(x,y)$表示坐标。</li><li>不同的图像处理库其坐标系统的原点设置不同，y的取值设定也不同。  </li><li>$T$只能是单调（通常是单调递增）的函数。<h3 id="常见的点处理变换"><a href="#常见的点处理变换" class="headerlink" title="常见的点处理变换"></a>常见的点处理变换</h3></li></ol><ul><li><p>阈值变换(Thresholding)<br>函数图像<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210207152536.png" alt=""><br>阈值函数可分为两种：软阈值函数（左）和硬阈值函数/二值化函数(Hard thresholding/Binarization，右),它们的作用都是将像素转换成黑白像素。<br>图像中的$m$点称为阈值，高于阈值的像素将会被强化为近黑色/黑色的像素值，低于阈值的像素值将被弱化为近白色/白色的像素值。  </p></li><li><p>像素反转</p><script type="math/tex; mode=display">s=L-1-r</script><p>$L$表示最大的像素值。<br>作用是将像素值进行翻转，白色变为黑色，黑色变为白色。<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210207154347.png" alt="">  </p></li><li><p>对数变换  </p><script type="math/tex; mode=display">s=clog(1+r)</script><p>对数变换能够扩展低灰度值（突出过曝区域的细节）而压缩高灰度值（突出过暗区域的细节），从而增强图像的清晰度。<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210207154929.png" alt="">   </p></li><li><p>幂变换</p><script type="math/tex; mode=display">s=cr^γ</script><p>$γ$是幂指数，显示器中的伽玛校正(Gamma Correction)即调整该值使得显示器整体偏亮或偏暗。 当$0&lt;γ&lt;1$时，显示器偏暗，$γ&lt;1$时，显示器偏亮。<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210207155330.png" alt=""><br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210207155454.png" alt="">   </p></li><li><p>折线(Piecewise Linear Curves)<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210207155745.png" alt="">   </p></li></ul><h3 id="亮度直方图-Historgram"><a href="#亮度直方图-Historgram" class="headerlink" title="亮度直方图(Historgram)"></a>亮度直方图(Historgram)</h3><p>亮度直方图的横轴是像素值，纵轴是该像素值内的像素点个数，它反映了黑白图像整体的像素分布情况。<br>如果直方图在白色区域内比较集中，图像偏亮，直方图窄黑色区域内比较集中，图像偏暗。<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210207160828.png" alt=""><br>图像在直方图上的最大分布范围（即横轴的宽度）称为对比度(Contrast)，直方图窄的图像对比度低。通常情况下，对比度越高图像越清晰。<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210207160857.png" alt="">    </p><ul><li>直方图均衡(Historgram equalization)<br>直方图均衡是一种用于增强图像对比度的同时均衡图像亮度的方法（即拉宽和拖平直方图）。<br>直方图可以视为反映了每一个像素值在整个图像的占比关系（$\frac{n_w}{n}$，n表示图像像素点总数，$n_w$表示像素值为w的像素点数量），因此整个直方图可以被概率分布函数化：  <script type="math/tex; mode=display">p_r(w)=p(r=w)=\frac{n_w}{n},w=0,1,...,255</script>应用变换：  <script type="math/tex; mode=display">s=T(r)=(L-1)\int_0^rp_r(w)dw</script>使得:  <script type="math/tex; mode=display">P_s(s)=P_r(r)|\frac{dr}{ds}|=\frac{1}{L-1}</script><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210207162034.png" alt=""><br>由于w并不是连续的，因此最终的直方图并非是完全扁平的矩形。<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210207164743.png" alt=""></li><li>局部增强(Local enhancement)<br>对局部的一些像素群（例如以某个像素为中心$9 × 9$或$3 × 3$的像素）应用直方图均衡的方法称为局部增强。<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210207163241.png" alt="">   <h2 id="相邻处理（Neighborhood-Processing）"><a href="#相邻处理（Neighborhood-Processing）" class="headerlink" title="相邻处理（Neighborhood Processing）"></a>相邻处理（Neighborhood Processing）</h2>与点处理比较，虽然相邻处理的输入值仍然是一个像素值，但是输出值确实一个围绕输入像素值的像素集。（如下图所示）<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210208124611.png" alt=""><br>常见的一些相邻处理的方法：  </li><li>均值滤波  </li><li>最值滤波  </li><li>中值滤波（像素值按大小排列，取排序位于中间位置的像素值作为中值滤波后的像素值）<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210208124649.png" alt=""><br>▲上面的三张图依次是：原图（有一些细小噪点）、求平均、求中位数后的输出。  </li></ul><h3 id="滤波（Filtering）"><a href="#滤波（Filtering）" class="headerlink" title="滤波（Filtering）"></a>滤波（Filtering）</h3><p>滤波是一种应用于相邻处理的常见方法。<br>设以某个像素为中心的像素方阵称为<strong>核矩阵</strong>(Kernel/Mask matrix),以$W$记，核矩阵中的每一个像素值以$w(u,v)$表示。 将核矩阵照射至图像的某一区域$r$，使被照射区域中的像素值与对应的核矩阵中同位置的像素值一一相乘后全部相加，最后用一常数$C$调整，该过程被称为滤波。    </p><script type="math/tex; mode=display">s(x,y)=C∑_{(u,v)∈W}w(u,v)r(x+u,y+v)</script><p>整个过程可以用下图来表示：<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210208130628.png" alt=""><br>一次滤波结束后，核矩阵平移$α$个像素单位（称为<strong>步长</strong>(Padding)），照射图像的另一个区域，重复上述过程。    </p><ul><li><p>均值滤波<br>其核矩阵如下：   </p><script type="math/tex; mode=display">\frac{1}{n}×\begin{bmatrix} 1&1&...&1\\...&...&...&...\\ 1&1&...&1 \\ 1&1&...&1\end{bmatrix}</script><p>n表示方阵元素的数量。<br>这样最终的输出结果是取像素点周围领域的平均值作为响应输出，最终的图像会被模糊化。  </p></li><li><p>高斯滤波(Gaussian Filtering)<br>高斯滤波的核矩阵内的元素在三维上符合标准高斯/标准正态分布，且最高点在核矩阵中心处，如下图所示。<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210208131837.png" alt=""><br>其具体的计算公式为：  </p><script type="math/tex; mode=display">G(x,y)=\frac{1}{2πσ^2}e^{-\frac{x^2+y^2}{2σ^2}}</script><p>$σ$是标准高斯分布中的方差，$σ$较小时，图像的峰值窄且高。<br>例如当$σ=1.4$时，其核矩阵可以取：<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210208132110.png" alt=""><br>高斯滤波的作用是<strong>将图像模糊化</strong>，使图像呈现一种毛玻璃的质感。运用高斯滤波处理图像的方法又被称为<strong>高斯模糊</strong>(Gaussian Blurring)。<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210208132748.png" alt=""><br><strong>高斯模糊的重要作用是将图像中的噪点通过模糊化图像的方法移除。</strong></p></li></ul><h2 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h2><p><strong>卷积</strong>(Convolution)是一种常用于图像处理的方法。<br>设核矩阵(又被称为卷积核)的像素分布可以表示为$h$,原图的像素分布表示为$f$，卷积有如下公式：</p><script type="math/tex; mode=display">g(x)=\int_{-∞}^∞f(τ)h(x-τ)dτ</script><ul><li>卷积核的正则化<br>如果要使得图像的整体亮度在卷积前后不发生改变，卷积核必须被正则化，即卷积核内所有元素的和必须是1。</li></ul><h2 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h2><p>边缘（Edges）是图像中像素值变化急剧(Sharply)的部分，常见的边缘有如下图所示的四大类。<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210208134126.png" alt=""><br>边缘检测是以特殊的卷积核（称为算子（Operator））对图像进行处理。<br>常见的算子有如下几种：  </p><ul><li><p>Roberts算子<br>Roberts算子是两个能够强化图像的边缘部分的核矩阵：</p><script type="math/tex; mode=display">G_x=\begin{bmatrix}  +1&0\\0&-1   \end{bmatrix}</script><script type="math/tex; mode=display">G_y=\begin{bmatrix}  0&+1\\-1&0   \end{bmatrix}</script><p><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210208133900.png" alt="">    </p></li><li><p>索伯算子(Sobel’s Operator)<br>Sobel算子的两个卷积核形式：  </p><script type="math/tex; mode=display">\begin{bmatrix} -1&0&+1\\-2&0&+2\\-1&0&+1 \end{bmatrix}</script><script type="math/tex; mode=display">\begin{bmatrix}+1&+2&+1\\0&0&0\\-1&-2&-1\end{bmatrix}</script><p>两个卷积核的特征是卷积核正中的纵列或行列为0，用于检测图像的纵向/横向边缘。<br>PIL或者是OpenCV中有对应的库可以执行Sobel边缘检测。<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210208140605.png" alt="">    </p></li><li><p>拉普拉斯算子(Laplacian operator)<br>函数$F(x,y)$的梯度可由梯度公式得到：  </p><script type="math/tex; mode=display">G(x,y)=\frac{∂F(x,y)}{∂x}cos(σ)+\frac{∂F(x,y)}{∂y}sin(σ)</script><p>定义拉普拉斯算子（一阶）$▿f|(x_0,y_0)=(f_x(x_0,y_0),f_y(x_0,y_0))$，其二阶形式：</p><script type="math/tex; mode=display">▿^2f(x,y)=\frac{∂^2f(x,y)}{∂x^2}+\frac{∂^2f(x,y)}{∂y^2}</script><p>在x方向上可以近似由差分表示：  </p><script type="math/tex; mode=display">\frac{∂^2f(x,y)}{∂x^2}=f(x+1,y)+f(x-1,y)-2f(x,y)</script><p>在y方向上同理，最终得到二阶拉普拉斯算子的表达式：</p><script type="math/tex; mode=display">▿^2f(x,y)=f(x+1,y)+f(x-1,y)+f(x,y+1)+f(x,y-1)-4f(x,y)</script><p>得到拉普拉斯算子的卷积核形式：  </p><script type="math/tex; mode=display">\begin{bmatrix}  0&1&0\\1&-4&1\\0&1&0\end{bmatrix}</script></li><li><p>拉普拉斯-高斯算子（LoG operator）<br>由表达式：  </p><script type="math/tex; mode=display">▽^2g(x,y)=-\frac{1}{2πσ^4}(2-\frac{x^2+y^2}{σ^2})e^{-\frac{x^2+y^2}{2σ^2}}</script><p>所得到的算子的卷积核形式：<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210208141000.png" alt="">   </p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Machine Learning-NUS 2021</category>
      
      <category>讲义</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>3. 课后练习-图像处理</title>
    <link href="/2021/01/26/Machine%20Learning-NAU/3.a%20%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0/"/>
    <url>/2021/01/26/Machine%20Learning-NAU/3.a%20%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p><style><br>img{<br>    width: 40%;<br>    padding-left: 10%;<br>}</style></p><h1 id="课后练习2"><a href="#课后练习2" class="headerlink" title="课后练习2"></a>课后练习2</h1><p>Required libs:Numpy PIL Scipy Matplotlib cv2</p><h2 id="Q1-Write-a-python-script-to-open-the-“lena-png”-file-using-opencv"><a href="#Q1-Write-a-python-script-to-open-the-“lena-png”-file-using-opencv" class="headerlink" title="Q1. Write a python script to open the “lena.png” file using opencv."></a>Q1. Write a python script to open the “lena.png” file using opencv.</h2><ul><li>Display the opened image in a new window named “Display Lena”</li><li>Save the image to a new file named “lena_resaved.png”<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/lena.png" alt="">  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> cv2 <span class="hljs-keyword">as</span> cv<br>img = cv.imread(<span class="hljs-string">&quot;lena.png&quot;</span>) <span class="hljs-comment"># cv2.imread(&#x27;path&#x27;)  read the img</span><br>cv.imshow(<span class="hljs-string">&quot;Display Lena&quot;</span>,img) <span class="hljs-comment">#cv2.imshow(windowname,path)</span><br>cv.waitkey(<span class="hljs-number">0</span>) <span class="hljs-comment">#to let the window display until clicking/pressing</span><br>cv.imwrite(<span class="hljs-string">&quot;lena_resaved.png&quot;</span>,img) <span class="hljs-comment">#cv2.imwrite(filename,path,params)</span><br></code></pre></td></tr></table></figure><h2 id="Q2-Use-PIL-and-Matplotlib-libraries-for-Q2"><a href="#Q2-Use-PIL-and-Matplotlib-libraries-for-Q2" class="headerlink" title="Q2. Use PIL and Matplotlib libraries for Q2."></a>Q2. Use PIL and Matplotlib libraries for Q2.</h2>Use “lena.png” to perform following operations and save the images:  </li><li>Crop a section from the image whose vertices are (100,100), (100,400), (400,100), (400,400).<br>(hint: convert the cv2 image into PIL Image)  </li><li>Rotate the cropped image by 45 degrees counter-clockwise.</li><li>Perform histogram equalization on lena.png. (hint: use ImageOps.equalize from PIL)</li><li>Use matplotlib to plot the histogram figure for both original image and processed image.<br>(hint: use histogram() function in PIL)  </li><li>Perform Max Filtering, Min Filtering, and Median Filter on lena.png. (hint: PIL.ImageFilter)  </li><li>Perform Gaussian Blur with sigma equal to 3 and 5. (hint: PIL.ImageFilter)<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/bee.png" alt=""> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image <br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> ImageOps <br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> ImageFilter <span class="hljs-keyword">as</span> <span class="hljs-built_in">filter</span><br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt  <br><br>pil_img=Image.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;lena.png&quot;</span>) <span class="hljs-comment">#open img in pil </span><br><span class="hljs-comment">#(in cv2 lib, img is opened as array)</span><br><span class="hljs-comment"># load cv img: Image.fromarray()</span><br>pil_img.show() <span class="hljs-comment"># show the img</span><br>img_crop = pil_img.crop((<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">300</span>,<span class="hljs-number">300</span>)) <span class="hljs-comment">#crop((start point,hight,width))</span><br>img_crop.show() <span class="hljs-comment">#show the img</span><br><br>img_rota = img_crop.rotate(<span class="hljs-number">45</span>) <span class="hljs-comment">#rotate(degree)</span><br>img_rota.show()<br><br>img_eql=ImageOps.equalize(pil_img) <br><span class="hljs-comment">#ImageOps.equalize(path) histogram equalize the imge</span><br><br>plt.plot(<span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">256</span>),img_eql.histogram()) <br><span class="hljs-comment">#pyplot(aix,img) plot someting   </span><br><span class="hljs-comment">#img.histogram()  return the histogram</span><br>plt.show()<br>plt.show(rang(<span class="hljs-number">0</span>,<span class="hljs-number">256</span>),pil_img.histogram())<br>plt.show()  <br><br>img_max = pil_img.<span class="hljs-built_in">filter</span>(<span class="hljs-built_in">filter</span>.maxfilter()) <br><span class="hljs-comment">#filter.(Imagefilter.parm()) add filters</span><br>img_max.show()<br><br>img_min=pil_img.<span class="hljs-built_in">filter</span>(<span class="hljs-built_in">filter</span>.minfilter())<br>img_min.show()<br><br>img_mid=pil_img.<span class="hljs-built_in">filter</span>(<span class="hljs-built_in">filter</span>.medianfilter())<br>img_mid.show()<br><br><br>img_gus3=pil_img.<span class="hljs-built_in">filter</span>(<span class="hljs-built_in">filter</span>.gaussianblur(radius=<span class="hljs-number">3</span>))<br>img_gus3.show()<br><br>img_gus10=pil_img.<span class="hljs-built_in">filter</span>(<span class="hljs-built_in">filter</span>.gaussianblur(radius=<span class="hljs-number">10</span>))<br>img_gus10.show()<br><br></code></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210210191614.png" alt=""></li></ul><h2 id="Q3-Colour-space-conversion-Use-Python-OpenCV-functions-to-perform-following-operations-on"><a href="#Q3-Colour-space-conversion-Use-Python-OpenCV-functions-to-perform-following-operations-on" class="headerlink" title="Q3. Colour space conversion. Use Python OpenCV functions to perform following operations on"></a>Q3. Colour space conversion. Use Python OpenCV functions to perform following operations on</h2><p>“bee.png” and save the images at each step.</p><ul><li>Read the image.</li><li>Convert the image to HSV(<strong>Hu Satuation Value:包含了三个通道：单色(H)，饱和度(S)，灰度(V)</strong>) color space.</li><li>Perform histogram equalization on V channel by cv2.equalizeHist().</li><li>Convert the result image to BGR color space.</li><li>Show the image by cv2.imshow() and save the image.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> ImageOps <br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> ImageFilter <span class="hljs-keyword">as</span> <span class="hljs-built_in">filter</span><br><br>bee_img = cv2.imread(<span class="hljs-string">&quot;bee.png&quot;</span>)<br>bee_hsv = cv2.cvtColor(bee_img,cv2.COLOR_BGR2HSV)<br>bee_hsv.imshow()<br><br>bee_hsv[:,:,<span class="hljs-number">2</span>]= cv2.equalizeHist(bee_hsv[:,:,<span class="hljs-number">2</span>])<br><span class="hljs-comment"># 2 presents the channel 2: V</span><br>bee_rgb = cv2.cvtColor(bee_hsv,cv2.COLOR_HSV2BGR)<br>cv2.imshow(<span class="hljs-string">&quot;norm&quot;</span>,bee_rgb)<br><br>bee_img[:,:,<span class="hljs-number">2</span>]= cv2.equalizeHist(bee_rgb[:,:,<span class="hljs-number">2</span>])<br>bee_img = cv2.cvtColor(bee_hsv,cv2.COLOR_HSV2BGR)<br>cv2.imshow(<span class="hljs-string">&quot;rgb&quot;</span>,bee_img)<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Machine Learning-NUS 2021</category>
      
      <category>课后练习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2. 课后练习-数学方法</title>
    <link href="/2021/01/25/Machine%20Learning-NAU/2.%20a%20%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0/"/>
    <url>/2021/01/25/Machine%20Learning-NAU/2.%20a%20%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Math-Fundamentals-PDF"><a href="#Math-Fundamentals-PDF" class="headerlink" title="Math Fundamentals(PDF)"></a>Math Fundamentals(PDF)</h1><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220517203709.png width=100%>   </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220517203756.png width=100%>    </p><p><img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220517203826.png width=100%>     </p>]]></content>
    
    
    <categories>
      
      <category>Machine Learning-NUS 2021</category>
      
      <category>课后练习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2. 数学方法</title>
    <link href="/2021/01/25/Machine%20Learning-NAU/2.%20%E6%95%B0%E5%AD%A6%E6%96%B9%E6%B3%95/"/>
    <url>/2021/01/25/Machine%20Learning-NAU/2.%20%E6%95%B0%E5%AD%A6%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="数学方法"><a href="#数学方法" class="headerlink" title="数学方法"></a>数学方法</h1><h2 id="矩阵的运算"><a href="#矩阵的运算" class="headerlink" title="矩阵的运算"></a>矩阵的运算</h2><h3 id="矩阵的乘法"><a href="#矩阵的乘法" class="headerlink" title="矩阵的乘法"></a>矩阵的乘法</h3><p>矩阵的乘法规则：前一矩阵的行乘后一矩阵的纵列若A是一个$m \times n$的矩阵，B是一个$a \times b$的矩阵，那么矩阵乘法$A \times B$的结果将会是一个$n \times a$的矩阵</p><blockquote><p>要注意$A × B=0 ⇏A=0 ~or~ B=0$<br>$AB \not ={} BA$,但是$(AB)C=A(BC)$</p></blockquote><p>矩阵与向量的乘法可以改写,用如下例子来做表示：<br>$A=\left[\begin{smallmatrix}<br>1 &amp; 2 &amp; 1 \\\ -1 &amp; 0 &amp; 2<br>\end{smallmatrix}\right] B=\left[\begin{smallmatrix}1 \\\ -1 \\\ 1\end{smallmatrix}\right]$<br>有$A\times B=1×\left[\begin{smallmatrix}1 \\\ -1\end{smallmatrix}\right]+(-1)×\left[\begin{smallmatrix}2 \\\ 0\end{smallmatrix}\right]+1\times \left[\begin{smallmatrix}1 \\\ 2\end{smallmatrix}\right]$<br>称B是A的一组线性组合</p><h3 id="转置、对称"><a href="#转置、对称" class="headerlink" title="转置、对称"></a>转置、对称</h3><p>$A^T$表示A的转置，即A行列交换后的矩阵。<br>有$(AB)^{T}=B^{T}A^{T}$<br>方阵：A为一个正方形矩阵:$m×m$<br>单位矩阵：\对角线上的元素为1，其余元素为0的方阵，有$AI=IA=A$<br>若$A^T=A$,称A是一个对称矩阵(Symmetric matrix)，若$A^T=-A$，称A是一个交错矩阵(Skew-symmectric matrix)</p><h3 id="矩阵的逆"><a href="#矩阵的逆" class="headerlink" title="矩阵的逆"></a>矩阵的逆</h3><p>有矩阵$A^{-1}A=I$,称矩阵$A^{-1}$为矩阵A的逆。奇异矩阵不可逆。运算规律：</p><ol><li>$(AB)^{-1}=B^{-1}A^{-1}$</li><li>$(A^T)^{-1}=(A^{-1})^{T}$</li><li>$(A^{-1})^{-1}=A$</li></ol><h3 id="矩阵方程的解法"><a href="#矩阵方程的解法" class="headerlink" title="矩阵方程的解法"></a>矩阵方程的解法</h3><p>对于任何一个线性方程组可以改写成：</p><script type="math/tex; mode=display">Ax=b</script><p>A是系数矩阵，x是参数向量，b是方程组右边组成的常数向量<br>解方程只需要求出$x=Ab$</p><ul><li>线性无关<br>如果A的列向量$a_1,a_2,a_3…a_n$的线性组合为0：</li></ul><script type="math/tex; mode=display">\sum λ_ia_i=0</script><p>称这些向量是线性无关的。<br>A中线性无关列向量的最大数目表示A的秩(Rank)<br>$Nul(A)$表示线性齐次方程$Ax=0$的解集，它的维度称为零度(Nullity)<br>如果 $RanK(A)+Nullity(A)=columns~of~A$，可以判断A是可逆的。</p><h3 id="正交-Orthogonal-Perpenticular"><a href="#正交-Orthogonal-Perpenticular" class="headerlink" title="正交(Orthogonal/Perpenticular)"></a>正交(Orthogonal/Perpenticular)</h3><p>两个向量$x,y$,如果$x^Ty=0$，称这两个向量是正交的。<br>如果一个向量集$b_1,b_2,b_3…b_n$中的任意两个元素 $b_i^Tb_j=\begin{cases}<br>1, i=j \\ 0, i \not =j<br>\end{cases}$<br>称这个向量集是标准正交集(Orthonormal)<br>若矩阵Q，$Q^TQ=I$称Q是正交的，它所有的列向量都是正交的</p><h3 id="行列式计算"><a href="#行列式计算" class="headerlink" title="行列式计算"></a>行列式计算</h3><p>det(A)或者|A|记作A的行列式,在Python中可以用numpy库中的函数进行运算。计算性质：</p><ol><li>$det(AB)=det(A)det(B)$</li><li>$det(A^{-1})=\frac{1}{det(A)}$<br>所以det(A)=0时，A不可逆</li><li>$det(A^T)=det(A)$</li><li>$det(kA)=k^ndet(A)$,$A_{n \times n}$</li><li>$det(A)=Πλ_i$</li></ol><h3 id="特征值-特征向量"><a href="#特征值-特征向量" class="headerlink" title="特征值/特征向量"></a>特征值/特征向量</h3><p>若有$Ax=λx$,λ称为A的特征值(Eigenvalue)，x称为A的特征向量(Eigenvector)</p><blockquote><p>特征值可能是一个复数，矩阵的特征向量/特征值可能有几个是相同的<br>$kλ$和$kx$仍然是A的特征值和特征向量，所以默认解出的特征向量的模长(Norm)为1。</p></blockquote><ul><li>求解特征值/特征向量<br>通过$det(A-λI)=0$，求解$λ$,再代回$Ax-λx=0$求解x</li><li><p>谱分解(Spectral Theorem)<br>A所有的特征值和特征向量可以写成一个矩阵方程：</p><script type="math/tex; mode=display">A \begin{bmatrix}  x_1&x_2&...&x_n\end{bmatrix}=\begin{bmatrix}  x_1&x_2&...&x_n\end{bmatrix}\begin{bmatrix}  λ_1 &&&&\\ &λ_2\\&&λ_3\\&&&...\end{bmatrix}</script><p>$\begin{bmatrix}<br>λ_1 &amp;&amp;&amp;&amp;\\ &amp;λ_2\\&amp;&amp;λ_3\\&amp;&amp;&amp;…<br>\end{bmatrix}$ 称为A的对角矩阵(Diagonal matrix)$Λ$<br>记作$AE=EΛ$<br>如果E是可逆矩阵，$A=EΛE^{-1}$<br>如果A是对称矩阵，有$E^{-1}=E^T$,$A=EΛE^T$<br>在机器学习中，A常常是对称的，而且所有的特征值都是实数</p></li></ul><h3 id="迹-Trace"><a href="#迹-Trace" class="headerlink" title="迹(Trace)"></a>迹(Trace)</h3><p>矩阵A的\对角线元素的总和称为A的迹：</p><script type="math/tex; mode=display">tr(A)=\sum a_{ii}</script><p>它在数值上也等于所有特征值的和：</p><script type="math/tex; mode=display">tr(A)=\sum λ_{i}</script><p>计算性质：</p><ol><li>$tr(AB)=tr(BA)$</li><li>$tr(A+B)=tr(A)+tr(B)$</li></ol><h3 id="伪逆矩阵-Pseudo-inverse"><a href="#伪逆矩阵-Pseudo-inverse" class="headerlink" title="伪逆矩阵(Pseudo-inverse)"></a>伪逆矩阵(Pseudo-inverse)</h3><p>当A不可逆时，要解决$Ax=b$,转写为$x=A^{-1}b$的形式求解x看似不可能，因此构造矩阵$A^{+}$,使得$x=A^{+}b,Ax-b$的模长最小，$A^+$称为A的伪逆矩阵。</p><script type="math/tex; mode=display">A^+=(A^TA)^{-1}A^T</script><script type="math/tex; mode=display">A^+A=(A^TA)^{-1}A^TA=I</script><script type="math/tex; mode=display">AA^+=A (A^TA)^{-1}A^T\not=I</script><p>在Python中<code>pinv(A)</code>可以实现求解伪逆矩阵</p><h3 id="矩阵的导数"><a href="#矩阵的导数" class="headerlink" title="矩阵的导数"></a>矩阵的导数</h3><p>矩阵的导数满足如下性质：</p><ol><li>$\frac{d}{dx}Ax=A^T$</li><li>$\frac{dx}{dx}=I$</li><li>$\frac{y^Tx}{dx}=\frac{dx^Ty}{dx}=y$</li><li>$\frac{d(x^TAx)}{dx}=\begin{cases}<br>(A+A^T)x,\text{A is square}\\2Ax,\text{A is symmetrix}<br>\end{cases}$</li><li>$\frac{d(u^T(x)~v(x))}{dx}=[\frac{du^T}{dx}]v+[\frac{dv^T}{dx}]u$</li><li>$\frac{d~tr(A)}{dA}=I$</li><li>$\frac{det(A)}{dA}=det(A)(A^{-1})^T$</li></ol><ul><li><p>伪逆矩阵证明当A为奇异矩阵时，求解$Ax=b$:定义误差(error)$e=Ax-b$，要使得$|e|$尽可能小：设$y=|e|^2$，有：</p><script type="math/tex; mode=display">\begin{aligned}  y & =e^Te \\  & =(Ax-b)^T(Ax-b) \\  & =(Ax)^T(Ax)-(Ax)^Tb-b^T(Ax)+b^Tb \\  & =x^TA^TAx-2b^T(Ax)+b^Tb \\\end{aligned}</script><p>对y求导：$\frac{dy}{dx}=2A^TAx-2A^Tb+0$</p><blockquote><p>第一项，$A^TA$是一个对称矩阵，可以应用#4.<br>第二项，应用#3<br>第三项，$b^Tb$是一个常数</p></blockquote><p>令$\frac{dy}{dx}=2A^TAx-2A^Tb=0$：</p><script type="math/tex; mode=display">A^TAx=A^Tb</script><script type="math/tex; mode=display">(A^TA)^{-1}A^Tb=A^+b</script></li></ul><p>在Python中，<code>linalg.solve(A,B)</code>能够求解$x=A^+b$     </p><h2 id="概率论的基础概念"><a href="#概率论的基础概念" class="headerlink" title="概率论的基础概念"></a>概率论的基础概念</h2><ul><li>随机变量<br>随机实验是一种能够产生随机结果的可重复性实验，样本空间$S$表示随机实验中所有可能出现的结果构成的集合，事件(Event)是样本空间S的子集。<br>随机变量(Random variables)是将S对应到实数集的一种函数，概率分布函数(MPF)表示X在样本空间中所发生的概率与X之间的关系。概率密度函数(PDF)表示样本空间中概率分布的稠密程度。    </li><li><p>常见的随机分布<br>*具体翻阅概率论笔记，此处不再赘述。<br>两点分布(Bernouli)<br>几何分布(Geometric)<br>二项分布(Binomial)<br>泊松分布(Poisson)<br>均匀分布(Uniform)<br>指数分布(Exponential)<br>双指数分布(Laplace/Double Exponential): $F(x)=\frac{λ}{2}e^{-λ|x|},λ&gt;0$<br>正态分布(Gaussian/Normal)  </p></li><li><p>其他分布函数概念<br>联合概率密度/联合分布函数(Joint PDF)<br>边缘分布函数(Marginal PDF)<br>条件概率函数(Conditional PDF)   </p></li></ul><h2 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a>贝叶斯公式</h2><p>  全概率公式的逆公式，表示已知B事件发生的概率下，在A中某一个划分下发生的概率：</p><script type="math/tex; mode=display">P(A_i|B)=\frac{P(A_i)P(B|A_i)}{P(B)}=\frac{P(A_i)P(B|A_i)}{ΣP(A_i)P(B|A_i)}</script>]]></content>
    
    
    <categories>
      
      <category>Machine Learning-NUS 2021</category>
      
      <category>讲义</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1. 机器学习简介和Python的基本操作</title>
    <link href="/2021/01/23/Machine%20Learning-NAU/1.%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B%E5%92%8CPython%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2021/01/23/Machine%20Learning-NAU/1.%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B%E5%92%8CPython%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="机器学习简介和Python的基本操作"><a href="#机器学习简介和Python的基本操作" class="headerlink" title="机器学习简介和Python的基本操作"></a>机器学习简介和Python的基本操作</h1><h2 id="Before-the-course…"><a href="#Before-the-course…" class="headerlink" title="Before the course…"></a>Before the course…</h2><ul><li>Software and environment: Anaconda and Opencv  </li><li>Ultimate Project: Traffic Sign Recognition   </li><li>There’s a individual Quiz on lecture 5  </li></ul><h2 id="人工智能的产生"><a href="#人工智能的产生" class="headerlink" title="人工智能的产生"></a>人工智能的产生</h2><p>lines of codes programming forces people to find a way to teach the program to do things.<br>example: makeup transfer<br>example: auto ping-pong machine</p><h2 id="计算机视觉简介"><a href="#计算机视觉简介" class="headerlink" title="计算机视觉简介"></a>计算机视觉简介</h2><p>计算机视觉可以大致的被分为三个大类：  </p><ul><li>3D建模(3D Construction)<br>例子：敦煌莫高窟的3D建模（来自武汉大学）  </li><li>图像渲染(Image Rendering)<br>例子：Google Pixel<br>其搭载的增强现实算法能够对周围的图像进行实时渲染  </li><li>图像检测(Pattern Recongnition)<br> 例子：都灵的图像识别装置<br> 人们穿戴对应的设备行走，设备能够识别他周围的物品   </li></ul><p>计算机视觉可以在各个领域帮助到人们，在医学领域帮助医生识别X光片，在自动驾驶领域，自动驾驶汽车依靠车身上的传感器和相机识别道路上的物体，在体育竞技领域，计算机视觉能够帮助人们更好的训练运动员的运动姿势。世界上第一张人脸检测的图片由Dr.Sung Kah Kay在1996年完成。    </p><p>计算机科学的知识架构：<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210123230629.png" alt="">  </p><h2 id="Python-的基本操作"><a href="#Python-的基本操作" class="headerlink" title="Python 的基本操作"></a>Python 的基本操作</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>  Python 不需要编译，是机器学习的首选语言之一，有非常多的库能够被调用。<br>  Python支持超大的数字运算<br>  编译环境（IDE）：Anaconda， 适用于大数据环境    </p><blockquote><p>不要使用 Python 2.x  </p></blockquote><ul><li>Python的IDE思路：REPL<br><img src="https://raw.githubusercontent.com/l61012345/Pic/master/img/20210123231447.png" alt=""><br>Reading： 读取来自键盘等的输入<br>Evalueate： 将输入进行Evaluate，其结果通常是一个数值，这个数值最终会被编译器输出（Print）<br>在输出后，这个程序将等待下一次的输入，形成一个循环  <h3 id="赋值和函数定义"><a href="#赋值和函数定义" class="headerlink" title="赋值和函数定义"></a>赋值和函数定义</h3>Python可以不用声明变量的类型，直接对其进行赋值，其变量的赋值类型取决于赋值<br>Python支持同时对多个变量进行赋值：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Python">a,b=c,d <br>```  <br><br>定义函数的结构：  <br>``` Python<br>   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">functionname</span>(<span class="hljs-params">variable</span>):</span>  <br>      <span class="hljs-keyword">return</span> value<br>    <span class="hljs-comment"># 也可以不需要返回值</span><br></code></pre></td></tr></table></figure> 另一种定义方式：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python">    function= <span class="hljs-keyword">lambda</span> return_variable: options  <br>```  <br>例如：  <br>  ``` Python<br>   S= <span class="hljs-keyword">lambda</span> x: x*x  <br></code></pre></td></tr></table></figure>在Python中，函数的定义和调用有如下特点：</li></ul><ol><li>嵌套调用：<br><code>funcationname(funcationname(variable))</code>  </li><li>在Python中，变量可以传递给函数，<strong>函数也可以传递给变量</strong>。<br>例如：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">function</span> (<span class="hljs-params">n</span>):</span><br>    n*n<br>    <span class="hljs-keyword">return</span> n<br>foo=function(<span class="hljs-number">5</span>)<br><span class="hljs-comment"># 此时foo的类型是一个函数</span><br>foo(<span class="hljs-number">10</span>)<br><span class="hljs-comment"># &gt;&gt; 100</span><br></code></pre></td></tr></table></figure></li><li>可以在定义函数的部分嵌套定义其他函数：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">function</span>(<span class="hljs-params">variable1</span>):</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">subfuntion</span>(<span class="hljs-params">variable2</span>):</span><br>     <span class="hljs-keyword">return</span> variable2<br> <span class="hljs-keyword">return</span> variable1<br></code></pre></td></tr></table></figure><h3 id="条件结构-if-else"><a href="#条件结构-if-else" class="headerlink" title="条件结构(if-else)"></a>条件结构(if-else)</h3>条件语句的基本结构： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">if</span> conditon:<br>  options<br></code></pre></td></tr></table></figure>例如：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compare</span>(<span class="hljs-params">a,b</span>):</span><br>  <span class="hljs-keyword">if</span> a&gt;b:<br>    <span class="hljs-keyword">return</span> a<br>  <span class="hljs-keyword">return</span> b<br>compare(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br><span class="hljs-comment">#&gt;&gt; 4</span><br></code></pre></td></tr></table></figure>在条件语句中可以同时并存多个条件：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">if</span> condition1:<br>  options<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> condition2:<br>  options<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>  condtion3:<br>  options<br><span class="hljs-keyword">else</span>:<br>  options<br></code></pre></td></tr></table></figure><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3></li><li>通过函数定义的返回值来进行循环 (recursion)<br>例如：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">factorial</span>(<span class="hljs-params">n</span>):</span><br>  <span class="hljs-keyword">if</span> n==<span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>  <span class="hljs-keyword">return</span> n*factorial(n-<span class="hljs-number">1</span>)<br>factorial(<span class="hljs-number">5</span>)<br><span class="hljs-comment">#&gt;&gt; 120</span><br><span class="hljs-comment">#5*4*3*2*1</span><br></code></pre></td></tr></table></figure></li><li><p>通过for循环语句来进行循环(for-range) </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">for</span> innnervariable <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span> <span class="hljs-comment">#usually is range(a,b) a to b do n++</span><br>options<br></code></pre></td></tr></table></figure><p>例如：  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">factorial</span>(<span class="hljs-params">n</span>):</span><br> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>)<br>   result=result*n<br> <span class="hljs-keyword">return</span> result<br> factorial(<span class="hljs-number">5</span>) <br> <span class="hljs-comment">#&gt;&gt; 120  </span><br></code></pre></td></tr></table></figure><blockquote><p>要注意 <code>range(a,b)</code> 是不包括b的：  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span> (<span class="hljs-number">0</span>,<span class="hljs-number">4</span>)<br>   print(a) <br><span class="hljs-comment">#&gt;&gt; 3  </span><br></code></pre></td></tr></table></figure><p>这样的循环结构没有自增加（<code>x++</code>）的存在</p></blockquote></li><li><p>通过while语句进行循环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> (condition):<br>  options<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gcd</span>(<span class="hljs-params">a,b</span>):</span> <span class="hljs-comment">#最大公约数</span><br>  <span class="hljs-keyword">while</span> (b&gt;<span class="hljs-number">0</span>):<br>    r=a&amp;b<br>    a,b=b,r<br> <span class="hljs-keyword">return</span> a<br></code></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>在Pyhton中，字符串由双引号””或者单引号’’定义。<br>字符串支持加减法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-string">&#x27;hello&#x27;</span>+<span class="hljs-string">&#x27;world&#x27;</span><br><span class="hljs-comment">#&gt;&gt; &#x27;helloworld&#x27;</span><br></code></pre></td></tr></table></figure><p>也支持乘法（重复多次）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-string">&#x27;hello&#x27;</span>*<span class="hljs-number">3</span><br><span class="hljs-comment">#&gt;&gt; &#x27;hellohellohello&#x27; </span><br></code></pre></td></tr></table></figure><ul><li>字符串的传递<br>字符串可以传值给变量（类型是字符串），可以通过[起点：终点：步长]访问字符串中的特定位置的字符。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Python">a=<span class="hljs-string">&#x27;helloworld&#x27;</span><br>print(a[<span class="hljs-number">2</span>])<br><span class="hljs-comment">#&gt;&gt;&#x27;l&#x27;</span><br>print(a[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>])<br><span class="hljs-comment">#&gt;&gt;&#x27;hello&#x27;</span><br>&gt; Python 中的序号是从<span class="hljs-number">0</span>开始的<br>print(a[::-<span class="hljs-number">1</span>] )<br><span class="hljs-comment">#&gt;&gt;&#x27;dlrowolleh&#x27;</span><br>b=<span class="hljs-string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span><br>print(a[<span class="hljs-number">1</span>:<span class="hljs-number">15</span>:<span class="hljs-number">2</span>])<br><span class="hljs-comment">#&gt;&gt;&#x27;bdfhjln&#x27;</span><br></code></pre></td></tr></table></figure><code>len()</code>函数将返回字符串的长度<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-built_in">len</span>(hello)<br><span class="hljs-comment">#&gt;&gt; 5</span><br></code></pre></td></tr></table></figure>[]默认的访问顺序是从左到右，负号（-）表示从右到左的访问顺序。   <h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3>列表（list）是一种参数类型，例如：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python">x=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br><span class="hljs-built_in">type</span>(x)<br><span class="hljs-comment">#&gt;&gt; list</span><br></code></pre></td></tr></table></figure>列表用[]来表示，列表也可以嵌套。<br>列表中的元素可以是任何类型。<br>和字符串一样，可以用[]来访问列表中特定的某一个或者多个元素。    </li><li>列表的操作  </li></ul><ol><li>append()<br><code>append()</code>函数将在列表最后一位加上()内的字符串后，输出整个字符串<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python">x=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>x.append(<span class="hljs-number">2</span>)<br>print(x)<br><span class="hljs-comment">#&gt;&gt;[1,2,3,4,2]</span><br></code></pre></td></tr></table></figure></li><li>列表理解（list comprehension）<br>在列表的[]中填入生成列表的方法：<br>例如：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python">x=[a <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">8</span>)]<br><span class="hljs-built_in">print</span> x<br><span class="hljs-comment">#&gt;&gt; [1,2,3,4,5,6,7]</span><br>y=[square(a) <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> x]<br><span class="hljs-built_in">print</span> y<br><span class="hljs-comment">#&gt;&gt;[1,4,9,16,25,36,49]</span><br></code></pre></td></tr></table></figure>可以利用列表理解来过滤某些元素:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">iseven</span>(<span class="hljs-params">n</span>):</span><br>    <span class="hljs-keyword">return</span> n%<span class="hljs-number">2</span>==<span class="hljs-number">0</span><br>x=[a <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">8</span>)]<br>y=[square(a) <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> x <span class="hljs-keyword">if</span> iseven(a)]<br><span class="hljs-built_in">print</span> y<br><span class="hljs-comment">#&gt;&gt;[4,16,36]  </span><br></code></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>Machine Learning-NUS 2021</category>
      
      <category>讲义</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1. 课后练习-机器学习简介和Python的基本操作</title>
    <link href="/2021/01/23/Machine%20Learning-NAU/1.a%20%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0/"/>
    <url>/2021/01/23/Machine%20Learning-NAU/1.a%20%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="课后练习1"><a href="#课后练习1" class="headerlink" title="课后练习1"></a>课后练习1</h1><p>Solve the questions below by writing a Python function or script.   </p><h2 id="Q1-Add-up-the-numbers-from-100-to-200-and-output-their-sum-using-while-and-for-loops"><a href="#Q1-Add-up-the-numbers-from-100-to-200-and-output-their-sum-using-while-and-for-loops" class="headerlink" title="Q1. Add up the numbers from 100 to 200 and output their sum, using while and for loops."></a>Q1. Add up the numbers from 100 to 200 and output their sum, using while and for loops.</h2><p>for loop:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python">total = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>,<span class="hljs-number">201</span>): <span class="hljs-comment">#注意range不包括右边项</span><br>    total+=i<br>print(<span class="hljs-string">&quot;for loop sum:&quot;</span>,total)    <br></code></pre></td></tr></table></figure><br>while loop:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python">total=<span class="hljs-number">0</span><br>counter = <span class="hljs-number">100</span><br><span class="hljs-keyword">while</span> counter &lt; <span class="hljs-number">201</span>:<br>    total= total+counter <span class="hljs-comment">#++不能在python当中使用</span><br>    counter+=<span class="hljs-number">1</span> <span class="hljs-comment">#while 循环里面没有自增加</span><br>print(<span class="hljs-string">&#x27;for loop sum:&#x27;</span>,total)<br></code></pre></td></tr></table></figure></p><h2 id="Q2-Read-a-string-from-console-and-output-its-length-swap-its-cases（转换大小写）-convert-it-to-lower-case-and-upper-case-and-reverse-it-Hint-try-string-slice-with-step-1"><a href="#Q2-Read-a-string-from-console-and-output-its-length-swap-its-cases（转换大小写）-convert-it-to-lower-case-and-upper-case-and-reverse-it-Hint-try-string-slice-with-step-1" class="headerlink" title="Q2. Read a string from console and output its length, swap its cases（转换大小写）, convert it to lower case and upper case, and reverse it. (Hint: try string slice with step -1)"></a>Q2. Read a string from console and output its length, swap its cases（转换大小写）, convert it to lower case and upper case, and reverse it. (Hint: try string slice with step -1)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Python">s= <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;enter the string:&quot;</span>)<br>print(<span class="hljs-string">&quot;the length of the string:&quot;</span>,<span class="hljs-built_in">len</span>(s))<br><br>swap=<span class="hljs-built_in">str</span>.swapcase(s) <span class="hljs-comment">#str.swapcase() 转换大小写</span><br><br>print(<span class="hljs-string">&quot;swapcase is :&quot;</span>,swap)<br>print(<span class="hljs-string">&quot;lowercase:&quot;</span>,<span class="hljs-built_in">str</span>.lower(s)) <span class="hljs-comment">#str.lower/upper()</span><br>print(<span class="hljs-string">&quot;uppercase:&quot;</span>,<span class="hljs-built_in">str</span>.upper(s)) <br><br>print(<span class="hljs-string">&quot;reverse order:&quot;</span>,s[::-<span class="hljs-number">1</span>]) <span class="hljs-comment">#[起点:终点：步长]</span><br></code></pre></td></tr></table></figure><h2 id="Q3-Read-a-string-from-console-Split-the-string-on-space-delimiter-”-”-and-join-using-a-hyphen-”-”"><a href="#Q3-Read-a-string-from-console-Split-the-string-on-space-delimiter-”-”-and-join-using-a-hyphen-”-”" class="headerlink" title="Q3. Read a string from console. Split the string on space delimiter (” ”) and join using a hyphen (”-”)."></a>Q3. Read a string from console. Split the string on space delimiter (” ”) and join using a hyphen (”-”).</h2><p>(Example: input the string, ”this-is a string” and output as ”this is-a-string”)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python">s=<span class="hljs-string">&quot;hello world&quot;</span><br>print(<span class="hljs-string">&quot;replace:&quot;</span>,<span class="hljs-built_in">str</span>.replace(s,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;-&quot;</span>)) <span class="hljs-comment">#str.replace(string,&quot;&quot;,&quot;&quot;)交换前后元素</span><br></code></pre></td></tr></table></figure></p><h2 id="Q4-Learn-the-Python-list-operations-and-follow-the-commands-below"><a href="#Q4-Learn-the-Python-list-operations-and-follow-the-commands-below" class="headerlink" title="Q4. Learn the Python list operations and follow the commands below:"></a>Q4. Learn the Python list operations and follow the commands below:</h2><ul><li>Initialize an empty list L.  </li><li>Add 12, 8, 9 to the list.  </li><li>Insert 9 to the head of the list;  </li><li>Double the list. (e.g. change L = [1, 2, 3] to L = [1, 2, 3, 1, 2, 3])  </li><li>Remove all 8 in the list.  </li><li>Reverse the list.  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Python">L=[]<br>print(L)<br><br>L.append(<span class="hljs-number">12</span>) <span class="hljs-comment">#List.append() 列表在末尾添加</span><br>L.append(<span class="hljs-number">8</span>)<br>L.append(<span class="hljs-number">9</span>)<br>print(L)<br><br>L.insert(<span class="hljs-number">0</span>,<span class="hljs-number">9</span>) <span class="hljs-comment">#list.insert(position,element) 在列表的指定位置添加一个元素</span><br>L=[<span class="hljs-number">9</span>]+L <span class="hljs-comment">#另一种方式</span><br><br>L=L+L<br>print(L)<br>L=L*<span class="hljs-number">2</span> <span class="hljs-comment">#另一种方法</span><br>L=L.extend(L) <span class="hljs-comment">#list.extend(list) 在列表的末尾添加一个列表</span><br>print(L)   <br><br>number_eights=L.count(<span class="hljs-number">8</span>) <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,number_eight):<br>    L.remove(<span class="hljs-number">8</span>)  <span class="hljs-comment">#list.remove(element) 在列表中移除第一个【element】元素</span><br><span class="hljs-comment">#另一种解决办法</span><br><span class="hljs-keyword">while</span> <span class="hljs-number">8</span> <span class="hljs-keyword">in</span> L:<br>     L.remove(<span class="hljs-number">8</span>)<br><br>L.reverse() <span class="hljs-comment">#list.reverse() 列表内倒序</span><br>print(L)<br></code></pre></td></tr></table></figure><h1 id="Q5-Learn-Python-matrix-operations-by-completing-the-following-tasks"><a href="#Q5-Learn-Python-matrix-operations-by-completing-the-following-tasks" class="headerlink" title="Q5. Learn Python matrix operations by completing the following tasks:"></a>Q5. Learn Python matrix operations by completing the following tasks:</h1></li><li>Create a 3x2 matrix named A, with all ones.</li><li>Create a 3x2 matrix named B, where $𝐵 =\begin{bmatrix} 1&amp;2\\ 3&amp;4 \\ 5&amp;6 \end{bmatrix}$  </li><li>Print A and B.</li><li>Transpose A to be a 2x3 matrix.</li><li>Multiply matrix A with matrix B and store the output in matrix C.</li><li>Print the dimensions of C.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np <span class="hljs-comment">#import packagename 加载库  import packagename as nickname 加载并替换库的名字</span><br>A=np.ones(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">#numpy.ones(row,line)</span><br>print(A)  <br><br>B=np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]]) <span class="hljs-comment">#numpy.array() 创建矩阵，用法同左边</span><br>print(B)<br><br>print(A,B)<br><br>A=A.reshape((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)) <span class="hljs-comment">#numpy.reshape((row,line)) 重新改写矩阵的大小</span><br>A=np.transpose(A) <span class="hljs-comment">#numpy.transpose(matrix) 返回转置矩阵</span><br>print(A)<br><br>C=A @ B <span class="hljs-comment">#@ 矩阵叉乘</span><br>print(C.shape) <span class="hljs-comment">#matrix.shape 矩阵的大小</span><br></code></pre></td></tr></table></figure><h1 id="Q6-Use-𝑀-for-the-following-tasks"><a href="#Q6-Use-𝑀-for-the-following-tasks" class="headerlink" title="Q6. Use 𝑀 for the following tasks,"></a>Q6. Use 𝑀 for the following tasks,</h1><script type="math/tex; mode=display">𝑀 =\begin{bmatrix}−2&−4&2 \\ −2&1&2 \\ 4&2&5 \end{bmatrix}</script></li><li>Calculate the eigenvalues and eigenvectors for M. (hint: use numpy.linalg.eig)    </li><li>Use matplotlib to plot the eigenvalues in a graph.    </li><li>Save the eigenvalues into a file named “eig.npy” (hint: use numpy.save).   </li><li>Load the saved file into a new variable called load_eig and print the values.   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> plot <span class="hljs-keyword">as</span> plt<br>M=[[-<span class="hljs-number">1</span>,-<span class="hljs-number">4</span>,<span class="hljs-number">2</span>],[-<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>]]<br>eignval,eignvect=np.linalg,eig(M) <span class="hljs-comment">#numpy.linalg,eig(Matrix) 返回两个值，第一个是特征值，第二个是特征向量</span><br>print(eignval)<br><br>plt.plot(eignval)<br><br>np.save(<span class="hljs-string">&quot;eig&quot;</span>,eigval) <span class="hljs-comment">#numpy.save(&quot;filename&quot;,value) 将值在当前目录下以“filename.npy”储存</span><br><br>load.eig=np.load(<span class="hljs-string">&quot;eigval.npy&quot;</span>) <span class="hljs-comment">#numpy.load(&quot;path&quot;) 返回加载的文件</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Machine Learning-NUS 2021</category>
      
      <category>课后练习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>0. 课程简介</title>
    <link href="/2021/01/22/Machine%20Learning-NAU/0.%20%E8%AF%BE%E7%A8%8B%E7%AE%80%E4%BB%8B/"/>
    <url>/2021/01/22/Machine%20Learning-NAU/0.%20%E8%AF%BE%E7%A8%8B%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="课程简介"><a href="#课程简介" class="headerlink" title="课程简介"></a>课程简介</h1><p>课程：NUS2021: OTH927 Artificial Intelligence &amp; Machine Learning<br>（新加坡国立大学 2021 对外交流项目）<br>授课教师：Dr. Terence Sim (tsim@comp.nus.edu.sg) / Sanka Rasnayaka(Assistant) /Karen Boh(Assistant)  </p><p>本课程分为两部分： Lecture 和 Tutorial， 其中 Tutorial 内容为编程习题课。  </p>]]></content>
    
    
    <categories>
      
      <category>Machine Learning-NUS 2021</category>
      
      <category>讲义</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>about</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><ul><li>一名通信工程专业的本科生，现在正在以龟速看人工智能相关的公开课。   </li><li>成都人，现在在重庆。  </li><li>爱好是推理小说，到处吃吃吃（虽然最近因为各种事情都没啥时间做这些。）   </li><li>最近偶尔打打原神，抽到了甘雨，但是玩的很菜。     </li></ul><h2 id="关于这个博客"><a href="#关于这个博客" class="headerlink" title="关于这个博客"></a>关于这个博客</h2><p>因为要把笔记分享给团队的人看，但是团队里面就我一个人用markdown做笔记。一开始是把笔记上传到github上，但是github对于LaTeX公式的渲染实在是太糟糕，所以想到了用Hexo建个博客来放这些笔记。   </p><h2 id="Github-contributions"><a href="#Github-contributions" class="headerlink" title="Github contributions"></a>Github contributions</h2><p>项目对应的Github contributions， 由于对应的github账号大部分constributions都在维护本项目，因此可以看作是博客的更新频率。<br><img src="https://ghchart.rshah.org/l61012345" alt="Github chart" /></p><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>由于这个博客中大部分内容都是在当堂下课后下一节课上课之前由当堂上课笔记整理而成，写作时间比较紧凑，难免会出现疏漏和错误，在此感谢为这个博客做出过大量修订和反馈的朋友们。<br>在此列出一部分朋友的名字（化名）：  </p><ul><li>Xindi Huang  </li><li>林正/Kobayashi Hikari，他的博客在：<a href="https://www.zhenglinblog.top/">https://www.zhenglinblog.top/</a>.  </li><li>文丹丹老师  </li></ul>]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>photos</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<style>.ImageGrid {  width: 100%;  max-width: 1040px;  margin: 0 auto;  text-align: center;}.card {  overflow: hidden;  transition: .3s ease-in-out;  border-radius: 8px;  background-color: #efefef;  padding: 1.4px;}.ImageInCard img {  padding: 0;  border-radius: 8px;  width:100%;  height:100%;}@media (prefers-color-scheme: dark) {  .card {background-color: #333;}}</style><div id="imageTab"></div><div class="ImageGrid"></div>]]></content>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[[{"name":"壁纸","children":["4000.2992 7894758.jpg","5785.3857 adrian-Xft-JdC-Jbc-unsplash.jpg","4496.3000 agathe-marty-2cdvYh6ULCs-unsplash.jpg","5935.3957 andrew-leu-0F9pZKGOL2E-unsplash.jpg","3142.4713 ash-edmonds-uztw2giebSc-unsplash.jpg","3000.2002 clay-banks-u27Rrbs9Dwc-unsplash.jpg","4975.3317 cosmin-georgian-gd3ysFyrsTQ-unsplash.jpg","4896.3264 cristina-gottardi-CSpjU6hYo_0-unsplash.jpg","6000.3376 hiurich-granja-oL_nyLzmL1Q-unsplash.jpg","4178.3217 ismael-abelleira-MZ00oma1sn0-unsplash.jpg","5251.3496 louie-martinez-IocJwyqRv3M-unsplash.jpg","6240.4160 lu-xish-stDtoqwp7uQ-unsplash.jpg","5719.3720 manuel-cosentino-n--CMLApjfI-unsplash.jpg","3872.2581 matthieu-buhler-89nS8VZVf14-unsplash.jpg","2843.3554 meric-dagli-7NBO76G5JsE-unsplash.jpg","4002.2251 ningyu-he-sk34wh0H_Bg-unsplash.jpg","1920.1080 QQ图片20201130145132.jpg","640.640 QQ图片20210715200501.jpg","5911.3941 su-san-lee-E_eWwM29wfU-unsplash.jpg","3811.2518 susann-schuster-LuPimg1fGBQ-unsplash.jpg","7952.5304 tianshu-liu-aqZ3UAjs_M4-unsplash.jpg","5184.3888 tunafish-mayonnaise-GdipHzv_K_A-unsplash.jpg","1280.800 清+顾铨丹枫呦鹿图轴.jpg"]}]]]></content>
    
  </entry>
  
  
  
</search>

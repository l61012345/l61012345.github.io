{"version":3,"sources":["freecdn-main.js","main-js/src/hook.ts","core-lib/src/global.ts","core-lib/src/param-base.ts","core-lib/src/key-manager.ts","core-lib/src/manifest.ts","core-lib/src/url-conf.ts","core-lib/src/url-loader.ts","core-lib/src/file-conf.ts","core-lib/src/file-loader.ts","core-lib/src/updater.ts","core-lib/src/freecdn.ts","core-lib/src/promisex.ts","main-js/src/sw.ts","core-lib/src/param-mods/br.ts","core-lib/src/param-mods/bundle.ts","core-lib/src/param-mods/charset.ts","core-lib/src/param-mods/data.ts","core-lib/src/param-mods/expires.ts","core-lib/src/param-mods/hash.ts","core-lib/src/param-mods/headers.ts","core-lib/src/param-mods/open-timeout.ts","core-lib/src/param-mods/pos.ts","core-lib/src/param-mods/prefix.ts","core-lib/src/param-mods/recv-timeout.ts","core-lib/src/param-mods/referrer-policy.ts","core-lib/src/param-mods/req-headers.ts","core-lib/src/param-mods/size.ts","core-lib/src/param-mods/stream.ts","core-lib/src/param-mods/suffix.ts","core-lib/src/param-mods/valid-status.ts","core-lib/src/param-mods/xor.ts","core-lib/src/cache-manager.ts","core-lib/src/network.ts","core-lib/src/param-mods/mime/mime.ts","core-lib/src/param-mods/mime/mime-data.ts","core-lib/src/database.ts","core-lib/src/util.ts","core-lib/src/zone-host.ts"],"names":["Hook","func","obj","key","factory","oldFn","newFn","prop","getterFactory","setterFactory","desc","Object","getOwnPropertyDescriptor","defineProperty","MY_URL","location","href","MY_HOST","host","MY_ORIGIN","origin","ROOT_PATH","INTERNAL_PATH","URL","pathname","REG_IMG_EXTS","NATIVE_FETCH","fetch","EMPTY_BUF","Uint8Array","CRYPTO","crypto","subtle","gInited","ParamError","Error","constructor","message","super","ParamBase","onRequest","reqArgs","fileLoader","onResponse","resArgs","rawRes","onData","chunk","onEnd","onError","error","onAbort","reason","KeyManager","mKey","set","async","keyBase64","keyBin","base64Decode","importKey","name","namedCurve","verify","data","linePos","lastIndexOf","m","bytesToUtf8","subarray","match","signBin","dataBin","hash","REG_HEAD_LINE","Manifest","this","urlFileMap","Map","has","get","getParams","fileConf","parse","params","txt","parseFile","inc","cdn","FreeCDN","manifest","rets","getLines","map","fetchText","Promise","all","forEach","last","exec","toRelUrl","curr","index","length","part","substring","conf","FileConf","lastIndex","m0","m1","globalParams","UrlConf","fullUrl","fileParams","url","frag","getPair","static","nameClassMap","ParamData","bundle","ParamBundle","open_timeout","ParamOpenTimeout","recv_timeout","ParamRecvTimeout","referrer_policy","ParamReferrerPolicy","req_headers","ParamReqHeaders","valid_status","ParamValidStatus","headers","ParamHeaders","expires","ParamExpires","mime","ParamMime","charset","ParamCharset","pos","ParamPos","size","ParamSize","xor","ParamXor","br","ParamBr","prefix","ParamPrefix","suffix","ParamSuffix","ParamHash","stream","ParamStream","values","cls","i","priority","mergeMap","getHostFromUrl","hostParams","URLSearchParams","mods","k","v","console","warn","ret","parseConf","undefined","push","sort","a","b","UrlLoader","paramMods","abortCtrl","AbortController","isNetErr","isDone","isAborted","bytesRead","err","requestUnsafe","e","assert","mod","abort","rawReq","method","referrer","referrerPolicy","Headers","res","body","clone","arrayBuffer","isPromise","signal","req","Request","Network","status","statusText","reader","getReader","buf","READ","value","read","pauseSignal","pause","promisex","resume","resolve","REG_SUB_LINE","text","lines","urlConfs","line","test","urlConf","val","FILE_BACKUP_PARAMS","FileLoaderError","FileLoader","weightConf","range","urlLoaderSet","Set","delayTid","urlErrs","hasRange","opened","closed","r","parseReqRange","rangeBegin","rangeEnd","fileSize","backupParams","backupUrlConf","concat","begin","end","buildResRange","open","loadNextUrl","urlLoader","clearTimeout","getNextUrl","now","getTimeSec","weight","w","getUrlWeight","delay","getFileConfUrl","setTimeout","createUrlLoader","getBackupUrl","endsWith","add","exceed","delete","onOpen","request","EMPTY_PARAMS","Updater","manifestPath","onAvailable","urlWsMap","wsArgs","updating","manifestHash","pollingTimer","pollingInterval","lastTime","setSvcTimer","backupUrls","path","search","encodeURIComponent","manifestUrl","CacheManager","findCache","bin","getManifestFromCache","update","Date","updateUnsafe","fetchManifest","applyManifest","ctl","tid","cache","bytes","sha256","isArrayEqual","Response","addCache","applyConfs","parseBackupParam","interval","parseIntervalParam","setPollingInterval","svcUrls","parseServicesParam","setServices","splitList","str","num","parseTime","isNaN","clearInterval","setInterval","urls","ws","includes","onclose","close","createSvc","WebSocket","binaryType","onmessage","hashBin","enableCacheStorage","inited","updater","updateConf","parseWeightConf","input","init","FIND","urlObj","replace","file","mode","integrity","accept","redirect","dir","fileHash","hashParam","cacheable","findHash","promise","args","cacheRes","addHash","reject","controller","paused","checkPressure","desiredSize","ReadableStream","start","c","pull","cancel","enqueue","type","Blob","keyB64","globalInit","p","then","Sw","GLOBAL","self","mLoaderJsRes","mFreeCDN","mIniting","mResUrlMap","sharedModeHandler","loaderModeHandler","result","isSharedMode","FREECDN_SHARED_MODE","publicKey","Cache","prototype","put","reqs","tasks","WeakMap","getter","call","FREECDN_PUBLIC_KEY","Q","shift","setPublicKey","splice","loaderModeInit","log","main","state","BR_WASM_PATH","BR_GLUE_PATH","BR_MANIFEST","hasErr","timer","asmMod","locateFile","onRuntimeInitialized","inPtr","_AllocInBuf","outPtr","_AllocOutBuf","print","msg","printErr","onFetch","js","Function","fn","waitWasm","process","destory","asmObj","HEAPU8","_Init","outBufs","inBuf","avaiablelIn","availableOut","_Update","_GetErrorCode","_GetAvailableIn","_GetAvailableOut","len","outBuf","slice","_HasMoreOutput","concatBufs","_Destroy","packUrl","fileMap","cacheMap","loadPkg","redir","pkgBin","fetchBin","indexOf","confMap","parseJson","bodyBin","offset","entries","fileBuf","REG_TEXT_MIME","reuse","parseStrOrB64","seconds","time","rawMaxAge","_maxage","maxAge","append","blkLen","hashBins","queueArr","queueLen","hasData","hashes","blkLenStr","parseByteUnit","hashB64s","split","remain","head","blks","tail","blk","hashExp","pop","hashGot","exp","base64Encode","got","preserveAll","rawVal","Math","max","stopTimer","done","sum","n","t","REG_REFFERER_POLICY","policy","codes","Number","_a","ext","toLowerCase","extTypeMap","rawType","item","exts","mCache","reqInfo","delCache","caches","Database","opts","s","indexedDB","onsuccess","idb","db","onerror","onupgradeneeded","createObjectStore","table","getStore","record","enum","callback","openCursor","continue","transaction","objectStore","mDatabase","mUrlInfoMap","addUrlInfo","expire","info","HostInfo","lastDoneTime","lastErrTime","pending","errNum","reqNum","reqTimeAvg","reqTimeSum","mHostInfoMap","getHostInfo","hostWeightMap","urlInfo","hostInfo","delayScore","getHostWeight","t0","navigator","onLine","REG_NET_ERR","parseFetchError","cacheControl","t1","parseMaxAge","parseEntries","list","timeBase","performance","timeOrigin","responseEnd","responseStart","reqTime","requestStart","keyPath","getEntriesByType","PerformanceObserver","entryList","getEntries","observe","entryTypes","zone","language","zone0","weightParams","ZONE_HOST_SCORE","TEXT_ENCODER","TextEncoder","TEXT_DECODER","TextDecoder","decode","btoa","reduce","String","fromCharCode","bytesToAsc","atob","charCodeAt","JSON","trim","encode","utf8ToBytes","TIME_UNIT","ms","min","h","d","y","NaN","unit","kMG","bB","bufs","b1","b2","delim","dst","src","startsWith","digest"],"mappings":"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","file":"freecdn-main.min.js","sourcesContent":["\"use strict\";\n/**\n * JS Hook Util\n * example: https://codepen.io/etherdream/pen/WNoQQbG?editors=0012\n */\nvar Hook;\n(function (Hook) {\n    /**\n     * hook function\n     */\n    function func(obj, key, factory) {\n        const oldFn = obj[key];\n        if (!oldFn) {\n            return false;\n        }\n        const newFn = factory(oldFn);\n        obj[key] = newFn;\n        return true;\n    }\n    Hook.func = func;\n    /**\n     * hook property\n     */\n    function prop(obj, key, getterFactory, setterFactory) {\n        const desc = Object.getOwnPropertyDescriptor(obj, key);\n        if (!desc) {\n            return false;\n        }\n        if (getterFactory) {\n            func(desc, 'get', getterFactory);\n        }\n        if (setterFactory) {\n            func(desc, 'set', setterFactory);\n        }\n        Object.defineProperty(obj, key, desc);\n        return true;\n    }\n    Hook.prop = prop;\n})(Hook || (Hook = {}));\nconst IS_DEBUG = typeof RELEASE === 'undefined';\nconst DEFAULT_PARAMS = `\n@__default__\n expires=30s\n mime=auto\n open_timeout=10s\n valid_status=200\n`;\nconst DEFAULT_MANIFEST_PATH = '/freecdn-manifest.txt';\nconst MY_URL = location.href;\nconst MY_HOST = location.host;\nconst MY_ORIGIN = location.origin;\nconst ROOT_PATH = MY_ORIGIN + '/';\nconst INTERNAL_DIR = 'freecdn-internal/' + (IS_DEBUG ? 'dev' : VER);\nconst INTERNAL_PATH = new URL(INTERNAL_DIR, ROOT_PATH).pathname;\nconst REG_IMG_EXTS = /\\.(?:jpg|jpeg|png|apng|gif|ico|bmp)$/i;\nconst NATIVE_FETCH = fetch;\nconst EMPTY_BUF = new Uint8Array(0);\nconst CRYPTO = crypto.subtle;\nlet gInited;\nasync function globalInit() {\n    if (gInited) {\n        return gInited;\n    }\n    gInited = promisex();\n    await CacheManager.init();\n    await Network.init();\n    UrlConf.init();\n    gInited.resolve();\n    gInited = true;\n}\nclass ParamError extends Error {\n    constructor(message) {\n        super(message);\n    }\n}\nclass ParamBase {\n    onRequest(reqArgs, fileLoader) {\n    }\n    onResponse(resArgs, fileLoader, rawRes) {\n    }\n    onData(chunk) {\n        return chunk;\n    }\n    onEnd(chunk) {\n        return chunk;\n    }\n    onError(error) {\n    }\n    onAbort(reason) {\n    }\n}\nvar KeyManager;\n(function (KeyManager) {\n    let mKey;\n    async function set(keyBase64) {\n        const keyBin = base64Decode(keyBase64);\n        if (!keyBin) {\n            return;\n        }\n        mKey = await CRYPTO.importKey('spki', keyBin, {\n            name: 'ECDSA',\n            namedCurve: 'P-256',\n        }, false, ['verify']);\n    }\n    KeyManager.set = set;\n    async function verify(data) {\n        if (!mKey) {\n            return false;\n        }\n        const linePos = data.lastIndexOf(10); // 10 = '\\n'\n        const lineBin = data.subarray(linePos + 1);\n        const lineTxt = bytesToUtf8(lineBin);\n        const m = lineTxt.match(/# SIGN: ([A-Za-z0-9+/=]{88})$/);\n        if (!m) {\n            return false;\n        }\n        const signTxt = m[1];\n        const signBin = base64Decode(signTxt);\n        const dataBin = data.subarray(0, linePos);\n        return await CRYPTO.verify({\n            name: 'ECDSA',\n            hash: {\n                name: 'SHA-256'\n            },\n        }, mKey, signBin, dataBin);\n    }\n    KeyManager.verify = verify;\n})(KeyManager || (KeyManager = {}));\n//\n// 匹配清单中的文件块。例如：\n//\n// (http://foo/path/to/file)\n//    ...\n// (/path/to/file)\n//    ...\n// (@config)\n//    ...\n// 其中 $0 为文件名，内容部分只匹配不捕获，之后通过 lastIndex 截取\n//\nconst REG_HEAD_LINE = /^(?:\\/|https?:|@).*/mg;\nclass Manifest {\n    constructor() {\n        this.urlFileMap = new Map();\n    }\n    has(key) {\n        return this.urlFileMap.has(key);\n    }\n    get(key) {\n        return this.urlFileMap.get(key);\n    }\n    getParams(name) {\n        const fileConf = this.get(name);\n        if (fileConf) {\n            fileConf.parse();\n            return fileConf.params;\n        }\n    }\n    async parse(txt) {\n        this.parseFile(txt + DEFAULT_PARAMS);\n        const inc = this.urlFileMap.get('@include');\n        if (inc) {\n            const cdn = new FreeCDN();\n            cdn.manifest = this;\n            const urls = inc.getLines();\n            const rets = urls.map(cdn.fetchText, cdn);\n            const txts = await Promise.all(rets);\n            txts.forEach(this.parseFile, this);\n        }\n    }\n    parseFile(txt) {\n        // lazy parse\n        let name = '';\n        let last = 0;\n        for (;;) {\n            const m = REG_HEAD_LINE.exec(txt);\n            if (last > 0) {\n                if (name[0] !== '@') {\n                    name = toRelUrl(name);\n                }\n                const curr = m ? m.index : txt.length;\n                const part = txt.substring(last, curr);\n                const conf = new FileConf(name, part);\n                this.urlFileMap.set(name, conf);\n            }\n            if (!m) {\n                break;\n            }\n            name = m[0];\n            last = REG_HEAD_LINE.lastIndex;\n        }\n        const m0 = this.getParams('@__default__');\n        const m1 = this.getParams('@global');\n        this.globalParams = m1 ? new Map([...m0, ...m1]) : m0;\n    }\n}\nclass UrlConf {\n    constructor(fullUrl, fileParams) {\n        this.fileParams = fileParams;\n        [this.url, this.frag] = getPair(toRelUrl(fullUrl), '#');\n    }\n    static init() {\n        // 为了让代码更简洁，这里没有逐一引用各个参数对应的文件\n        // 如果该列表定义在全局，会出现依赖顺序的问题\n        this.nameClassMap = {\n            // 参数优先级（越前面的参数优先执行）\n            'data': ParamData,\n            'bundle': ParamBundle,\n            'open_timeout': ParamOpenTimeout,\n            'recv_timeout': ParamRecvTimeout,\n            'referrer_policy': ParamReferrerPolicy,\n            'req_headers': ParamReqHeaders,\n            'valid_status': ParamValidStatus,\n            'headers': ParamHeaders,\n            'expires': ParamExpires,\n            'mime': ParamMime,\n            'charset': ParamCharset,\n            'pos': ParamPos,\n            'size': ParamSize,\n            'xor': ParamXor,\n            'br': ParamBr,\n            'prefix': ParamPrefix,\n            'suffix': ParamSuffix,\n            'hash': ParamHash,\n            'stream': ParamStream,\n        };\n        Object.values(this.nameClassMap).forEach((cls, i) => {\n            cls.priority = i;\n        });\n    }\n    parse(manifest) {\n        // TODO: cache result\n        const params = new Map();\n        // 参数优先级: 全局参数 < 站点参数 < 文件参数 < URL 参数\n        mergeMap(params, manifest.globalParams);\n        // 站点参数\n        const host = this.url[0] === '/' ? MY_HOST : getHostFromUrl(this.url);\n        const hostParams = manifest.getParams('@host ' + host);\n        if (hostParams) {\n            mergeMap(params, hostParams);\n        }\n        // 文件参数\n        mergeMap(params, this.fileParams);\n        // URL 参数（定义在 # 后面）\n        if (this.frag) {\n            const urlParams = new URLSearchParams(this.frag);\n            mergeMap(params, urlParams);\n        }\n        const mods = [];\n        for (const [k, v] of params) {\n            const cls = UrlConf.nameClassMap[k];\n            if (!cls) {\n                console.warn('[FreeCDN/UrlConf] unknown param:', k);\n                continue;\n            }\n            const ret = cls.parseConf(v);\n            if (ret === undefined) {\n                continue;\n            }\n            if (typeof ret === 'string') {\n                console.warn('[FreeCDN/UrlConf] parseConf failed. mod:', k, 'err:', ret, 'conf:', v);\n                continue;\n            }\n            const obj = new cls(...ret);\n            mods.push(obj);\n        }\n        mods.sort((a, b) => a.constructor.priority -\n            b.constructor.priority);\n        return mods;\n    }\n}\nclass UrlLoader {\n    constructor(url, paramMods) {\n        this.url = url;\n        this.paramMods = paramMods;\n        this.abortCtrl = new AbortController();\n        this.isNetErr = false;\n        this.isDone = false;\n        this.isAborted = false;\n        this.bytesRead = 0;\n    }\n    async request(fileLoader) {\n        let err;\n        try {\n            err = await this.requestUnsafe(fileLoader);\n        }\n        catch (e) {\n            console.assert(e instanceof ParamError, e);\n            err = e;\n        }\n        if (err && !this.isAborted) {\n            for (const mod of this.paramMods) {\n                mod.onError(err);\n            }\n            this.onError(err);\n            // TODO: network.addError(err)\n            if (!this.isNetErr) {\n                this.abort(err);\n            }\n        }\n    }\n    async requestUnsafe(fileLoader) {\n        const { rawReq } = fileLoader;\n        const { method } = rawReq;\n        const reqArgs = {\n            method,\n            referrer: rawReq.referrer,\n            referrerPolicy: 'same-origin',\n            headers: new Headers(),\n        };\n        if (method === 'POST' || method === 'PUT') {\n            reqArgs.body = await rawReq.clone().arrayBuffer();\n        }\n        let res;\n        for (const mod of this.paramMods) {\n            // 可直接返回响应（例如 data 参数、bundle 参数）\n            const ret = mod.onRequest(reqArgs, fileLoader);\n            if (ret) {\n                // await is slow\n                // https://gist.github.com/EtherDream/52649e4939008e149d0cb3a944c055b7\n                res = isPromise(ret) ? await ret : ret;\n                if (res) {\n                    break;\n                }\n            }\n        }\n        if (!res) {\n            reqArgs.signal = this.abortCtrl.signal;\n            const req = new Request(this.url, reqArgs);\n            try {\n                res = await Network.fetch(req);\n            }\n            catch (err) {\n                this.isNetErr = true;\n                return err;\n            }\n        }\n        const resArgs = {\n            status: res.status,\n            statusText: res.statusText,\n            headers: new Headers(),\n        };\n        for (const mod of this.paramMods) {\n            mod.onResponse(resArgs, fileLoader, res);\n        }\n        this.onResponse(resArgs);\n        if (!res.body) {\n            return new Error('cors error');\n        }\n        const reader = res.body.getReader();\n        let buf;\n        READ: for (;;) {\n            try {\n                const { value } = await reader.read();\n                if (!value) {\n                    break;\n                }\n                buf = value;\n            }\n            catch (err) {\n                this.isNetErr = true;\n                return err;\n            }\n            for (const mod of this.paramMods) {\n                const ret = mod.onData(buf);\n                buf = isPromise(ret) ? await ret : ret;\n                if (buf.length === 0) {\n                    continue READ;\n                }\n            }\n            if (buf.length > 0) {\n                this.pauseSignal && await this.pauseSignal;\n                this.bytesRead += buf.length;\n                this.onData(buf);\n            }\n        } // READ NEXT\n        this.isDone = true;\n        buf = EMPTY_BUF;\n        for (const mod of this.paramMods) {\n            const ret = mod.onEnd(buf);\n            buf = isPromise(ret) ? await ret : ret;\n        }\n        if (buf.length > 0) {\n            this.pauseSignal && await this.pauseSignal;\n            this.bytesRead += buf.length;\n            this.onData(buf);\n        }\n        this.onEnd();\n    }\n    pause() {\n        console.assert(!this.pauseSignal);\n        this.pauseSignal = promisex();\n    }\n    resume() {\n        this.pauseSignal?.resolve();\n        this.pauseSignal = undefined;\n    }\n    abort(reason) {\n        if (this.isDone) {\n            return;\n        }\n        this.isAborted = true;\n        this.abortCtrl.abort();\n        for (const mod of this.paramMods) {\n            mod.onAbort(reason);\n        }\n    }\n}\n// 匹配缩进开头的行，捕获 trim 后的内容（排除 `#` 注释行）\nconst REG_SUB_LINE = /^\\s+([^#\\s].+?)\\s*$/mg;\nclass FileConf {\n    constructor(name, text) {\n        this.name = name;\n        this.text = text;\n    }\n    getLines() {\n        const lines = [];\n        for (;;) {\n            const m = REG_SUB_LINE.exec(this.text);\n            if (!m) {\n                break;\n            }\n            lines.push(m[1]);\n        }\n        this.text = '';\n        return lines;\n    }\n    parse() {\n        if (this.text === '') {\n            return;\n        }\n        const urlConfs = [];\n        const params = new Map();\n        for (const line of this.getLines()) {\n            if (/^https?:|^\\//.test(line)) {\n                const urlConf = new UrlConf(line, params);\n                urlConfs.push(urlConf);\n            }\n            else {\n                const [key, val] = getPair(line, '=');\n                if (val === undefined) {\n                    console.warn('[FreeCDN/FileConf] missing param value:', line);\n                    continue;\n                }\n                params.set(key, val);\n            }\n        }\n        this.params = params;\n        this.urlConfs = urlConfs;\n    }\n}\nconst FILE_BACKUP_PARAMS = [\n    'open_timeout',\n    'recv_timeout',\n    'hash',\n    'req_headers',\n    'valid_status',\n];\nclass FileLoaderError extends Error {\n    constructor(message) {\n        super(message);\n    }\n}\nclass FileLoader {\n    constructor(fileConf, rawReq, manifest, weightConf, range, suffix) {\n        this.fileConf = fileConf;\n        this.rawReq = rawReq;\n        this.manifest = manifest;\n        this.weightConf = weightConf;\n        this.range = range;\n        this.suffix = suffix;\n        this.urlLoaderSet = new Set();\n        this.delayTid = 0;\n        this.urlErrs = [];\n        this.hasRange = false;\n        this.opened = false;\n        this.closed = false;\n        this.bytesRead = 0;\n        if (range) {\n            const r = this.parseReqRange(range);\n            if (r) {\n                [this.rangeBegin, this.rangeEnd] = r;\n                this.hasRange = true;\n                this.bytesRead = this.rangeBegin;\n            }\n            const fileSize = fileConf.params.get('size');\n            if (fileSize) {\n                this.fileSize = +fileSize;\n            }\n        }\n        // 原始 URL 作为后备资源\n        let backupParams;\n        if (fileConf.params.has('data') || fileConf.params.has('bundle')) {\n            // 使用内嵌数据时，可保留所有参数\n            backupParams = fileConf.params;\n        }\n        else {\n            // 使用原始 URL 时禁止修改内容，例如 pos、xor 等操作\n            // 因此只保留白名单中的参数\n            const map = new Map();\n            for (const k of FILE_BACKUP_PARAMS) {\n                const v = fileConf.params.get(k);\n                if (v !== undefined) {\n                    map.set(k, v);\n                }\n            }\n            backupParams = map;\n        }\n        const backupUrlConf = new UrlConf(fileConf.name, backupParams);\n        this.urlConfs = fileConf.urlConfs.concat(backupUrlConf);\n    }\n    parseReqRange(range) {\n        // 目前只考虑 `bytes=begin-end` 和 `bytes=begin-` 格式\n        const m = range.match(/bytes=(\\d+)-(\\d*)/i);\n        if (!m) {\n            return;\n        }\n        const begin = +m[1];\n        const end = +m[2]; // +'' === 0\n        if (end !== 0 && end <= begin) {\n            return;\n        }\n        return [begin, end];\n    }\n    buildResRange(resArgs) {\n        let end = 0;\n        if (this.rangeEnd !== 0) {\n            end = this.rangeEnd - 1;\n        }\n        else if (this.fileSize) {\n            end = this.fileSize - 1;\n        }\n        const val = 'bytes ' + this.rangeBegin + '-' + end + '/' + (this.fileSize || '*');\n        // TODO: status 416\n        resArgs.status = 206;\n        resArgs.headers.set('content-range', val);\n    }\n    open() {\n        this.loadNextUrl();\n    }\n    pause() {\n        for (const urlLoader of this.urlLoaderSet) {\n            urlLoader.pause();\n        }\n    }\n    resume() {\n        for (const urlLoader of this.urlLoaderSet) {\n            urlLoader.resume();\n        }\n    }\n    abort(reason) {\n        for (const urlLoader of this.urlLoaderSet) {\n            urlLoader.abort(reason);\n        }\n        if (this.delayTid !== 0) {\n            clearTimeout(this.delayTid);\n        }\n    }\n    getNextUrl() {\n        const { urlConfs } = this;\n        const lastIndex = urlConfs.length - 1;\n        if (lastIndex === -1) {\n            return;\n        }\n        const now = getTimeSec();\n        let weight = -10000;\n        let index = 0;\n        urlConfs.forEach((conf, i) => {\n            const w = Network.getUrlWeight(conf.url, now, this.weightConf);\n            if (w > weight) {\n                weight = w;\n                index = i;\n            }\n        });\n        // 删除 urlConfs[index]\n        const conf = urlConfs[index];\n        urlConfs[index] = urlConfs[lastIndex];\n        urlConfs.length = lastIndex;\n        return { weight, conf };\n    }\n    loadNextUrl(delay = 0) {\n        const ret = this.getNextUrl();\n        if (!ret) {\n            if (this.urlLoaderSet.size === 0) {\n                const err = new FileLoaderError('failed to load: ' + this.getFileConfUrl());\n                err.urlErrs = this.urlErrs;\n                this.onError(err);\n            }\n            return;\n        }\n        const { weight, conf } = ret;\n        if (weight < 0 && delay > 0) {\n            // 并行加载多个备用 URL 时，推迟低权重的站点（例如当前站点、收费站点）\n            this.delayTid = setTimeout(() => {\n                this.delayTid = 0;\n                this.createUrlLoader(conf);\n            }, delay);\n            return;\n        }\n        this.createUrlLoader(conf);\n    }\n    getFileConfUrl() {\n        return this.fileConf.name + this.suffix;\n    }\n    getBackupUrl(url) {\n        if (url.endsWith('/')) {\n            return url + this.suffix;\n        }\n        return url;\n    }\n    createUrlLoader(urlConf) {\n        const url = this.getBackupUrl(urlConf.url);\n        const mods = urlConf.parse(this.manifest);\n        const urlLoader = new UrlLoader(url, mods);\n        this.urlLoaderSet.add(urlLoader);\n        urlLoader.onData = (chunk) => {\n            if (this.closed) {\n                return;\n            }\n            const add = urlLoader.bytesRead - this.bytesRead;\n            if (add <= 0) {\n                // 当前节点的进度落后于总进度，丢弃收到的数据\n                return;\n            }\n            if (add !== chunk.length) {\n                chunk = chunk.subarray(-add);\n            }\n            this.bytesRead = urlLoader.bytesRead;\n            if (this.rangeEnd) {\n                const exceed = this.bytesRead - this.rangeEnd;\n                if (exceed > 0) {\n                    chunk = chunk.subarray(0, -exceed);\n                    this.onData(chunk);\n                    urlLoader.onEnd();\n                    return;\n                }\n            }\n            this.onData(chunk);\n        };\n        urlLoader.onEnd = () => {\n            if (this.closed) {\n                return;\n            }\n            this.closed = true;\n            this.onEnd();\n            this.abort('TASK_DONE');\n        };\n        urlLoader.onError = (err) => {\n            this.urlErrs.push({ url: urlLoader.url, err });\n            this.urlLoaderSet.delete(urlLoader);\n            this.loadNextUrl();\n        };\n        urlLoader.onResponse = (resArgs) => {\n            if (this.opened) {\n                return;\n            }\n            if (this.hasRange) {\n                this.buildResRange(resArgs);\n            }\n            this.opened = true;\n            this.onOpen(resArgs);\n        };\n        urlLoader.request(this);\n    }\n}\nconst EMPTY_PARAMS = new Map();\nclass Updater {\n    constructor(manifestPath, onAvailable) {\n        this.onAvailable = onAvailable;\n        this.urlWsMap = new Map();\n        this.wsArgs = '';\n        this.updating = false;\n        this.manifestHash = EMPTY_BUF;\n        this.pollingTimer = 0;\n        this.pollingInterval = 300000 /* DEFAULT_INTERVAL */;\n        this.lastTime = 0;\n        this.setSvcTimer = 0;\n        this.backupUrls = [];\n        const url = new URL(manifestPath, MY_URL);\n        console.assert(url.host === MY_HOST);\n        const path = url.pathname + url.search;\n        if (path !== DEFAULT_MANIFEST_PATH) {\n            this.wsArgs = '?manifest=' + encodeURIComponent(path);\n        }\n        this.manifestUrl = path;\n    }\n    async getManifestFromCache() {\n        const res = await CacheManager.findCache(this.manifestUrl);\n        if (!res) {\n            return;\n        }\n        const buf = await res.arrayBuffer();\n        const bin = new Uint8Array(buf);\n        // 使用公钥校验缓存配置（缓存可被恶意脚本篡改）\n        if (!await KeyManager.verify(bin)) {\n            return;\n        }\n        const txt = bytesToUtf8(bin);\n        const manifest = new Manifest();\n        await manifest.parse(txt);\n        return manifest;\n    }\n    async init() {\n        const manifest = await this.getManifestFromCache();\n        if (manifest) {\n            // 先使用本地缓存的配置\n            this.onAvailable(manifest);\n        }\n        await this.update();\n    }\n    async update() {\n        if (this.updating) {\n            return true;\n        }\n        const now = Date.now();\n        if (now - this.lastTime < 1000 /* MIN_INTERVAL */) {\n            return true;\n        }\n        this.lastTime = now;\n        this.updating = true;\n        try {\n            return await this.updateUnsafe();\n        }\n        catch (err) {\n            console.error('[FreeCDN/Updater] update err:', err);\n            return false;\n        }\n        finally {\n            this.updating = false;\n        }\n    }\n    async updateUnsafe() {\n        // from current site\n        const data = await this.fetchManifest(this.manifestUrl);\n        if (data) {\n            await this.applyManifest(data);\n            return true;\n        }\n        console.warn('[FreeCDN/Updater] failed to fetch 1st manifest:', this.manifestUrl);\n        if (this.backupUrls.length === 0) {\n            console.warn('[FreeCDN/Updater] no backup url');\n            return false;\n        }\n        // from backup sites\n        for (const url of this.backupUrls) {\n            const data = await this.fetchManifest(url);\n            if (!data) {\n                console.warn('[FreeCDN/Updater] failed to fetch 3rd manifest:', url);\n                continue;\n            }\n            if (!await KeyManager.verify(data)) {\n                console.warn('[FreeCDN/Updater] failed to verify 3rd manifest:', url);\n                continue;\n            }\n            await this.applyManifest(data);\n            return true;\n        }\n        console.warn('[FreeCDN/Updater] failed to reload');\n        return false;\n    }\n    async fetchManifest(url) {\n        const ctl = new AbortController();\n        const tid = setTimeout(() => {\n            ctl.abort();\n        }, 3000 /* FETCH_TIMEOUT */);\n        const req = new Request(url, {\n            // https://developer.mozilla.org/en-US/docs/Web/API/Request/cache\n            cache: 'no-cache',\n            signal: ctl.signal,\n        });\n        try {\n            const res = await Network.fetch(req);\n            const bin = await res.arrayBuffer();\n            return new Uint8Array(bin);\n        }\n        catch {\n        }\n        finally {\n            clearTimeout(tid);\n        }\n    }\n    async applyManifest(bytes) {\n        const hash = await sha256(bytes);\n        if (isArrayEqual(this.manifestHash, hash)) {\n            return;\n        }\n        this.manifestHash = hash;\n        // 缓存最新的清单内容\n        const res = new Response(bytes);\n        res.headers.set('content-length', bytes.length + '');\n        CacheManager.addCache(this.manifestUrl, res);\n        const manifest = new Manifest();\n        const txt = bytesToUtf8(bytes);\n        await manifest.parse(txt);\n        this.onAvailable(manifest);\n    }\n    applyConfs(params) {\n        this.backupUrls = this.parseBackupParam(params);\n        const interval = this.parseIntervalParam(params);\n        this.setPollingInterval(interval);\n        const svcUrls = this.parseServicesParam(params);\n        if (this.setSvcTimer > 0) {\n            clearTimeout(this.setSvcTimer);\n        }\n        // 延时开启，减少对业务的性能影响\n        this.setSvcTimer = setTimeout(() => {\n            this.setSvcTimer = 0;\n            this.setServices(svcUrls);\n        }, 5000 /* SET_SVC_DELAY */);\n    }\n    parseBackupParam(params) {\n        const str = params.get('backup') || '';\n        return splitList(str);\n    }\n    parseIntervalParam(params) {\n        const str = params.get('interval');\n        if (str) {\n            const num = parseTime(str);\n            if (!isNaN(num)) {\n                return num;\n            }\n            console.warn('[FreeCDN/Updater] invalid interval:', str);\n        }\n        return 300000 /* DEFAULT_INTERVAL */;\n    }\n    parseServicesParam(params) {\n        const str = params.get('services') || '';\n        return splitList(str);\n    }\n    setPollingInterval(interval) {\n        if (this.pollingInterval === interval) {\n            return;\n        }\n        this.pollingInterval === interval;\n        if (this.pollingTimer) {\n            clearInterval(this.pollingTimer);\n        }\n        if (interval > 0) {\n            this.pollingTimer = setInterval(() => {\n                this.update();\n            }, interval);\n        }\n    }\n    setServices(urls) {\n        for (const [url, ws] of this.urlWsMap) {\n            if (!urls.includes(url)) {\n                ws.onclose = null;\n                ws.close();\n                this.urlWsMap.delete(url);\n            }\n        }\n        for (const url of urls) {\n            if (!this.urlWsMap.has(url)) {\n                this.createSvc(url);\n            }\n        }\n    }\n    createSvc(url) {\n        const ws = new WebSocket(url + this.wsArgs);\n        ws.binaryType = 'arraybuffer';\n        ws.onmessage = (e) => {\n            const hashBin = new Uint8Array(e.data);\n            if (isArrayEqual(this.manifestHash, hashBin)) {\n                return;\n            }\n            this.update();\n        };\n        ws.onclose = () => {\n            this.urlWsMap.delete(url);\n            setTimeout(() => {\n                this.createSvc(url);\n            }, 20000 /* WS_RETRY_DELAY */);\n        };\n        this.urlWsMap.set(url, ws);\n    }\n}\n///<reference path=\"global.ts\"/>\n///<reference path=\"param-base.ts\"/>\n///<reference path=\"key-manager.ts\"/>\n///<reference path=\"manifest.ts\"/>\n///<reference path=\"url-conf.ts\"/>\n///<reference path=\"url-loader.ts\"/>\n///<reference path=\"file-conf.ts\"/>\n///<reference path=\"file-loader.ts\"/>\n///<reference path=\"updater.ts\"/>\nclass FreeCDN {\n    constructor(manifestUrl) {\n        this.enableCacheStorage = true;\n        this.weightConf = new Map();\n        this.inited = false;\n        if (!manifestUrl) {\n            return;\n        }\n        const updater = new Updater(manifestUrl, manifest => {\n            this.manifest = manifest;\n            const updateConf = manifest.getParams('@update') || EMPTY_PARAMS;\n            updater.applyConfs(updateConf);\n            // 权重参数\n            this.weightConf = Network.parseWeightConf(manifest);\n        });\n        this.updater = updater;\n    }\n    async fetch(input, init) {\n        const req = (input instanceof Request && !init)\n            ? input\n            : new Request(input, init);\n        if (!/^https?:/.test(req.url)) {\n            return NATIVE_FETCH(req);\n        }\n        const { manifest } = this;\n        if (!manifest) {\n            return Network.fetch(req);\n        }\n        let fileConf;\n        let suffix = '';\n        FIND: for (;;) {\n            const urlObj = new URL(req.url);\n            // 同源 URL 使用相对路径，不同源使用完整路径（和清单中格式保持一致）\n            const prefix = urlObj.origin === MY_ORIGIN ? '' : urlObj.origin;\n            // 带参数的 URL 尝试完整匹配\n            if (urlObj.search) {\n                fileConf = manifest.get(prefix + urlObj.pathname + urlObj.search);\n                if (fileConf) {\n                    break;\n                }\n            }\n            // 合并路径中连续的 `/`\n            const path = urlObj.pathname.replace(/\\/{2,}/g, '/');\n            const file = prefix + path;\n            // 优先使用 avif、webp 版本\n            if (REG_IMG_EXTS.test(file) && req.mode !== 'cors' && !req.integrity) {\n                const accept = req.headers.get('accept') || '';\n                if (accept.includes('image/avif')) {\n                    fileConf = manifest.get(file + '.avif');\n                    if (fileConf) {\n                        break;\n                    }\n                }\n                if (accept.includes('image/webp')) {\n                    fileConf = manifest.get(file + '.webp');\n                    if (fileConf) {\n                        break;\n                    }\n                }\n            }\n            fileConf = manifest.get(file);\n            if (fileConf) {\n                break;\n            }\n            if (file.endsWith('/')) {\n                fileConf = manifest.get(file + 'index.html');\n                if (fileConf) {\n                    break;\n                }\n            }\n            // 重定向到 `/` 结尾的路径\n            if (manifest.has(file + '/index.html')) {\n                return Response.redirect(file + '/');\n            }\n            // 目录匹配\n            // 尾部保存到 suffix 变量。例如访问 /path/to/file?a=1\n            // 清单若存在 /path/ 文件，suffix 则为 `to/file?a=1`\n            // 删除末尾的文件名。保持 `/` 结尾\n            let dir = path.replace(/[^/]*$/, '');\n            for (;;) {\n                fileConf = manifest.get(prefix + dir);\n                if (fileConf) {\n                    suffix = path.substring(dir.length) + urlObj.search;\n                    break FIND;\n                }\n                if (dir === '/') {\n                    break;\n                }\n                // 删除末尾的目录名。保持 `/` 结尾\n                dir = dir.replace(/[^/]+\\/$/, '');\n            }\n            // 清单中无匹配，直接转发\n            return Network.fetch(req);\n        }\n        fileConf.parse();\n        let fileHash = '';\n        const hashParam = fileConf.params.get('hash');\n        if (hashParam && hashParam.length === 44 /* SHA256_B64 */) {\n            fileHash = hashParam;\n        }\n        const range = req.headers.get('range');\n        const cacheable = this.enableCacheStorage && fileHash && !range;\n        if (cacheable) {\n            const res = await CacheManager.findHash(fileHash);\n            if (res) {\n                return res;\n            }\n        }\n        const fileLoader = new FileLoader(fileConf, req, manifest, this.weightConf, range, suffix);\n        const promise = promisex();\n        // 如果文件只有一个 hash 则不用流模式（必须完整下载才能校验 hash）\n        if (fileHash) {\n            fileLoader.onOpen = (args) => {\n                fileLoader.onData = (body) => {\n                    const res = new Response(body, args);\n                    if (cacheable && body.length < 1024 * 1024 * 5) {\n                        const cacheRes = res.clone();\n                        // 字段可在控制台列表中显示，方便调试\n                        cacheRes.headers.set('content-length', body.length + '');\n                        cacheRes.headers.set('x-raw-url', req.url);\n                        CacheManager.addHash(fileHash, cacheRes);\n                    }\n                    promise.resolve(res);\n                };\n            };\n            fileLoader.onError = (err) => {\n                console.warn('[FreeCDN]', err.message, err.urlErrs);\n                promise.reject(err);\n            };\n            fileLoader.onEnd = () => {\n            };\n            fileLoader.open();\n            return promise;\n        }\n        // 如果文件有多个 hash 或没有 hash，可使用流模式\n        let controller;\n        let paused = false;\n        const checkPressure = () => {\n            const { desiredSize } = controller;\n            if (desiredSize === null) {\n                return;\n            }\n            if (desiredSize <= 0) {\n                if (!paused) {\n                    fileLoader.pause();\n                    paused = true;\n                }\n            }\n            else {\n                if (paused) {\n                    fileLoader.resume();\n                    paused = false;\n                }\n            }\n        };\n        const stream = new ReadableStream({\n            start(c) {\n                controller = c;\n            },\n            pull() {\n                checkPressure();\n            },\n            cancel(reason) {\n                console.warn('[FreeCDN] stream cancel:', reason);\n                fileLoader.abort(reason);\n            },\n        });\n        fileLoader.onData = (chunk) => {\n            controller.enqueue(chunk);\n            checkPressure();\n        };\n        fileLoader.onEnd = () => {\n            controller.close();\n        };\n        fileLoader.onError = (err) => {\n            controller.error();\n            console.warn('[FreeCDN]', err.message, err.urlErrs);\n            promise.reject(err);\n        };\n        fileLoader.onOpen = (args) => {\n            const res = new Response(stream, args);\n            promise.resolve(res);\n        };\n        fileLoader.open();\n        return promise;\n    }\n    async fetchText(url) {\n        const res = await this.fetch(url);\n        return res.text();\n    }\n    async fetchBin(url) {\n        const res = await this.fetch(url);\n        const buf = await res.arrayBuffer();\n        return new Uint8Array(buf);\n    }\n    async fetchBlob(url) {\n        const res = await this.fetch(url);\n        const buf = await res.arrayBuffer();\n        const type = res.headers.get('content-type') || '';\n        return new Blob([buf], { type });\n    }\n    async update() {\n        if (this.updater) {\n            return this.updater.update();\n        }\n        return false;\n    }\n    async setPublicKey(keyB64) {\n        if (keyB64.length !== 124 /* PUBKEY_B64 */) {\n            keyB64 = `MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE${keyB64}==`;\n        }\n        await KeyManager.set(keyB64);\n    }\n    async init() {\n        console.assert(!this.inited);\n        this.inited = true;\n        await globalInit();\n        if (this.updater) {\n            await this.updater.init();\n        }\n    }\n}\n// non-callback style Promise\nfunction promisex() {\n    let resolve;\n    let reject;\n    const p = new Promise((a, b) => {\n        resolve = a;\n        reject = b;\n    });\n    // @ts-ignore\n    p.resolve = resolve;\n    // @ts-ignore\n    p.reject = reject;\n    return p;\n}\n// faster than instanceof\nfunction isPromise(obj) {\n    return typeof obj.then === 'function';\n}\n///<reference path=\"../../core-lib/src/freecdn.ts\"/>\n///<reference path=\"../../core-lib/src/promisex.ts\"/>\n///<reference path=\"hook.ts\"/>\nvar Sw;\n(function (Sw) {\n    const GLOBAL = self;\n    const mLoaderJsRes = new Response('/* freecdn is installed */', {\n        headers: {\n            'content-type': 'text/javascript',\n            'cache-control': 'max-age=3600',\n        },\n    });\n    let mFreeCDN;\n    let mIniting;\n    let mResUrlMap;\n    // 共享模式（脚本通过业务方的 SW 引入）\n    function sharedModeInit() {\n        Hook.func(GLOBAL, 'fetch', oldFn => sharedModeHandler);\n        Hook.func(Cache.prototype, 'add', oldFn => async function (req) {\n            const res = await sharedModeHandler(req);\n            await this.put(req, res);\n        });\n        Hook.func(Cache.prototype, 'addAll', oldFn => async function (reqs) {\n            const tasks = reqs.map(req => this.add(req));\n            await Promise.all(tasks);\n        });\n        mResUrlMap = new WeakMap();\n        // 由于自定义的 Response 对象 url 为空，因此通过 hook 的方式保留原始 url\n        Hook.prop(Response.prototype, 'url', getter => function () {\n            return mResUrlMap.get(this) || getter.call(this);\n        }, \n        /* setter */ null);\n        Hook.func(Response.prototype, 'clone', oldFn => function () {\n            const res = oldFn.call(this);\n            const url = mResUrlMap.get(this);\n            if (url) {\n                mResUrlMap.set(res, url);\n            }\n            return res;\n        });\n    }\n    async function sharedModeHandler(input, init) {\n        if (mIniting) {\n            // freecdn 仍在初始化中（例如加载清单文件）\n            await mIniting;\n        }\n        const req = (input instanceof Request && !init)\n            ? input\n            : new Request(input, init);\n        const res = await mFreeCDN.fetch(req);\n        mResUrlMap.set(res, req.url);\n        return res;\n    }\n    // 独占模式（通过 freecdn-loader.min.js 引入）\n    function loaderModeInit() {\n        // 重写 Q.push，这样 loader-js 可直接传递 event 和 promise\n        Q.push = loaderModeHandler;\n        while (Q.length) {\n            const args = Q.splice(0, 3);\n            loaderModeHandler(...args);\n        }\n    }\n    function loaderModeHandler(e, resolve, reject) {\n        const req = e.request;\n        // debug\n        if (req.url.endsWith('/freecdn-update')) {\n            mFreeCDN.update().then(result => {\n                const res = new Response('updated. success: ' + result, {\n                    headers: {\n                        'content-type': 'text/html',\n                    },\n                });\n                resolve(res);\n            });\n            return;\n        }\n        if (req.url === MY_URL) {\n            resolve(mLoaderJsRes.clone());\n            return;\n        }\n        mFreeCDN.fetch(req).then(resolve, reject);\n    }\n    async function main() {\n        mFreeCDN = new FreeCDN('freecdn-manifest.txt');\n        const isSharedMode = !!GLOBAL.FREECDN_SHARED_MODE;\n        let publicKey;\n        if (isSharedMode) {\n            mFreeCDN.enableCacheStorage = false;\n            mIniting = promisex();\n            // 在此之前不要使用 await，否则安装 hook 会被推迟，导致初始化时无法触发 hook\n            sharedModeInit();\n            publicKey = GLOBAL.FREECDN_PUBLIC_KEY;\n        }\n        else {\n            publicKey = Q.shift();\n        }\n        if (publicKey) {\n            await mFreeCDN.setPublicKey(publicKey);\n        }\n        await mFreeCDN.init();\n        if (isSharedMode) {\n            mIniting?.resolve();\n            mIniting = null;\n        }\n        else {\n            loaderModeInit();\n        }\n        console.log('[FreeCDN] service worker inited');\n    }\n    main();\n})(Sw || (Sw = {}));\nclass ParamBr extends ParamBase {\n    constructor() {\n        super();\n        this.state = 0;\n    }\n    static async init() {\n        if (this.signal) {\n            return;\n        }\n        this.signal = promisex();\n        const BR_WASM_PATH = `${INTERNAL_PATH}/br/br.wasm`;\n        const BR_GLUE_PATH = `${INTERNAL_PATH}/br/` + (IS_DEBUG ? 'br.js' : 'br.min.js');\n        const BR_MANIFEST = IS_DEBUG ? '' : `\n${BR_WASM_PATH}\n\thttps://cdn.jsdelivr.net/npm/freecdn-js@${VER}/dist/br/br.wasm\n\thttps://unpkg.com/freecdn-js@${VER}/dist/br/br.wasm\n\thttps://code.bdstatic.com/npm/freecdn-js@${VER}/dist/br/br.wasm\n\thttps://npm.elemecdn.com/freecdn-js@${VER}/dist/br/br.wasm\n\thash=${BR_WASM_HASH}\n\n${BR_GLUE_PATH}\n\thttps://cdn.jsdelivr.net/npm/freecdn-js@${VER}/dist/br/br.min.js\n\thttps://unpkg.com/freecdn-js@${VER}/dist/br/br.min.js\n\thttps://code.bdstatic.com/npm/freecdn-js@${VER}/dist/br/br.min.js\n\thttps://npm.elemecdn.com/freecdn-js@${VER}/dist/br/br.min.js\n\thash=${BR_GLUE_HASH}\n`;\n        const onError = () => {\n            this.hasErr = true;\n            this.signal?.resolve();\n        };\n        const timer = setTimeout(onError, 20000 /* WASM_LOAD_TIMEOUT */);\n        const asmMod = {\n            locateFile: () => BR_WASM_PATH,\n            onRuntimeInitialized: () => {\n                this.inPtr = asmMod._AllocInBuf(131072 /* IN_BUF_LEN */);\n                this.outPtr = asmMod._AllocOutBuf(524288 /* OUT_BUF_LEN */);\n                clearTimeout(timer);\n                this.signal?.resolve();\n                this.signal = undefined;\n            },\n            onAbort: (reason) => {\n                console.warn('[FreeCDN/Br] wasm onAbort:', reason);\n                onError();\n            },\n            print: (msg) => {\n                console.warn('[FreeCDN/Br] wasm print:', msg);\n            },\n            printErr: (err) => {\n                console.warn('[FreeCDN/Br] wasm printErr:', err);\n            },\n        };\n        const manifest = new Manifest();\n        await manifest.parse(BR_MANIFEST);\n        const cdn = new FreeCDN();\n        cdn.manifest = manifest;\n        const onFetch = async (...args) => {\n            try {\n                return await cdn.fetch(...args);\n            }\n            catch (err) {\n                console.warn('[FreeCDN/Br] failed to load wasm');\n                onError();\n                throw err;\n            }\n        };\n        try {\n            const js = await cdn.fetchText(BR_GLUE_PATH);\n            const fn = Function('Module', 'fetch', js);\n            fn(asmMod, onFetch);\n        }\n        catch {\n            console.warn('[FreeCDN/Br] failed to execute glue js');\n            onError();\n            return;\n        }\n        this.asmMod = asmMod;\n    }\n    static parseConf(conf) {\n        if (conf === 'off') {\n            return;\n        }\n        if (conf === 'on') {\n            if (!this.asmMod) {\n                this.init();\n            }\n            return [];\n        }\n        return 'invalid value';\n    }\n    async onData(chunk) {\n        if (ParamBr.signal) {\n            await this.waitWasm();\n        }\n        return this.process(chunk);\n    }\n    async onEnd(chunk) {\n        if (ParamBr.signal) {\n            await this.waitWasm();\n        }\n        // ???\n        let buf = EMPTY_BUF;\n        if (chunk.length > 0) {\n            buf = this.process(chunk);\n        }\n        this.destory();\n        return buf;\n    }\n    async waitWasm() {\n        await ParamBr.signal;\n        if (ParamBr.hasErr) {\n            throw new ParamError('failed to load br decoder');\n        }\n    }\n    process(chunk) {\n        const asmObj = ParamBr.asmMod;\n        const HEAPU8 = asmObj.HEAPU8;\n        if (this.state === 0) {\n            this.state = asmObj._Init();\n        }\n        const outBufs = [];\n        for (let p = 0; p < chunk.length; p += 131072 /* IN_BUF_LEN */) {\n            const inBuf = chunk.subarray(p, p + 131072 /* IN_BUF_LEN */);\n            HEAPU8.set(inBuf, ParamBr.inPtr);\n            let avaiablelIn = inBuf.length;\n            let availableOut = 0;\n            do {\n                const ret = asmObj._Update(this.state, 0, avaiablelIn);\n                if (ret === 0 /* ERROR */) {\n                    const err = asmObj._GetErrorCode();\n                    this.destory();\n                    throw new ParamError('br decode failed. code: ' + err);\n                }\n                avaiablelIn = asmObj._GetAvailableIn();\n                availableOut = asmObj._GetAvailableOut();\n                const len = 524288 /* OUT_BUF_LEN */ - availableOut;\n                if (len === 0) {\n                    continue;\n                }\n                // use slice (copy), not subarray (ref)\n                const outBuf = HEAPU8.slice(ParamBr.outPtr, ParamBr.outPtr + len);\n                outBufs.push(outBuf);\n            } while (asmObj._HasMoreOutput(this.state));\n        }\n        if (outBufs.length === 1) {\n            return outBufs[0];\n        }\n        return concatBufs(outBufs);\n    }\n    destory() {\n        ParamBr.asmMod._Destroy(this.state);\n    }\n}\nParamBr.hasErr = false;\nclass ParamBundle extends ParamBase {\n    constructor(packUrl) {\n        super();\n        this.packUrl = packUrl;\n    }\n    static parseConf(conf) {\n        if (conf === 'off') {\n            return;\n        }\n        if (!/^https?:|^\\//.test(conf)) {\n            return 'invalid url';\n        }\n        return [conf];\n    }\n    async onRequest(reqArgs, fileLoader) {\n        let fileMap;\n        const r = ParamBundle.cacheMap.get(this.packUrl);\n        if (r === undefined) {\n            const map = await this.loadPkg(fileLoader.manifest);\n            if (!map) {\n                return;\n            }\n            fileMap = map;\n        }\n        else if (isPromise(r)) {\n            fileMap = await r;\n        }\n        else {\n            fileMap = r;\n        }\n        const path = fileLoader.suffix;\n        const res = fileMap.get(path);\n        if (res) {\n            return res.clone();\n        }\n        if (path === '') {\n            const res = fileMap.get('index.html');\n            if (res) {\n                fileLoader.suffix = 'index.html';\n                return res.clone();\n            }\n        }\n        if (path.endsWith('/')) {\n            const res = fileMap.get(path + 'index.html');\n            if (res) {\n                fileLoader.suffix = path + 'index.html';\n                return res.clone();\n            }\n        }\n        if (fileMap.has(path + '/index.html')) {\n            fileLoader.suffix = path + '/index.html';\n            const redir = fileLoader.fileConf.name + path + '/';\n            return new Response(`<meta http-equiv=\"Refresh\" content=\"0;url=${redir}\">`);\n        }\n    }\n    async loadPkg(manifest) {\n        const fileMap = new Map();\n        const signal = promisex();\n        ParamBundle.cacheMap.set(this.packUrl, signal);\n        // TODO: support stream\n        let pkgBin;\n        try {\n            if (manifest.has(this.packUrl)) {\n                const cdn = new FreeCDN();\n                cdn.manifest = manifest;\n                pkgBin = await cdn.fetchBin(this.packUrl);\n            }\n            else {\n                // 资源包不在清单中，或不是普通文件（例如是目录），则直接加载，防止循环依赖\n                const res = await NATIVE_FETCH(this.packUrl);\n                const buf = await res.arrayBuffer();\n                pkgBin = new Uint8Array(buf);\n            }\n        }\n        catch {\n            this.warn('failed to load');\n            return;\n        }\n        const pos = pkgBin.indexOf(13 /* '\\r' */);\n        if (pos === -1) {\n            this.warn('missing header');\n            return;\n        }\n        const confBin = pkgBin.subarray(0, pos);\n        const confMap = parseJson(bytesToUtf8(confBin));\n        if (!confMap) {\n            this.warn('invalid header');\n            return;\n        }\n        const bodyBin = pkgBin.subarray(pos + 1);\n        let offset = 0;\n        for (const [file, conf] of Object.entries(confMap)) {\n            const len = +conf['content-length'];\n            if (!(len >= 0)) {\n                this.warn('invalid content-length');\n                return;\n            }\n            if (offset + len > bodyBin.length) {\n                this.warn('invalid offset');\n                return;\n            }\n            const fileBuf = bodyBin.subarray(offset, offset + len);\n            const res = new Response(fileBuf, {\n                headers: confMap[file]\n            });\n            fileMap.set(file, res);\n            offset += len;\n        }\n        ParamBundle.cacheMap.set(this.packUrl, fileMap);\n        signal.resolve(fileMap);\n        return fileMap;\n    }\n    warn(msg) {\n        console.warn('[FreeCDN/Bundle]', msg, this.packUrl);\n    }\n}\nParamBundle.cacheMap = new Map();\nconst REG_TEXT_MIME = /^text\\/|^application\\/(?:javascript|json)|\\+xml$/;\nclass ParamCharset extends ParamBase {\n    constructor(charset) {\n        super();\n        this.charset = charset;\n    }\n    static parseConf(conf) {\n        if (conf !== 'off') {\n            return [conf];\n        }\n    }\n    onResponse(resArgs) {\n        const type = resArgs.headers.get('content-type') || '';\n        if (REG_TEXT_MIME.test(type)) {\n            resArgs.headers.set('content-type', type + '; charset=' + this.charset);\n        }\n    }\n}\nParamCharset.reuse = true;\nclass ParamData extends ParamBase {\n    constructor(bytes) {\n        super();\n        this.bytes = bytes;\n    }\n    static parseConf(conf) {\n        const bytes = parseStrOrB64(conf);\n        if (!bytes) {\n            return 'invalid format';\n        }\n        return [bytes];\n    }\n    onRequest() {\n        return new Response(this.bytes);\n    }\n}\nParamData.reuse = true;\nclass ParamExpires extends ParamBase {\n    constructor(seconds) {\n        super();\n        this.seconds = seconds;\n    }\n    static parseConf(conf) {\n        const time = parseTime(conf);\n        if (isNaN(time)) {\n            return 'invalid time format';\n        }\n        const seconds = time / 1000 | 0;\n        return [seconds];\n    }\n    onResponse(resArgs, fileLoader, rawRes) {\n        // 过期时间不小于实际值，防止经常变化的资源无法及时更新\n        const rawMaxAge = rawRes._maxage;\n        const maxAge = rawMaxAge < this.seconds ? rawMaxAge : this.seconds;\n        resArgs.headers.append('cache-control', 'max-age=' + maxAge);\n    }\n}\nParamExpires.reuse = true;\nclass ParamHash extends ParamBase {\n    constructor(blkLen, hashBins) {\n        super();\n        this.blkLen = blkLen;\n        this.hashBins = hashBins;\n        this.queueArr = [];\n        this.queueLen = 0;\n        this.hasData = false;\n    }\n    static parseConf(conf) {\n        // conf format:\n        // [blksize;]hash1,hash2,...\n        let blkLen = 1e9;\n        let hashes = conf;\n        const pos = conf.indexOf(';');\n        if (pos > 0) {\n            const blkLenStr = conf.substring(0, pos);\n            hashes = conf.substring(pos + 1);\n            blkLen = parseByteUnit(blkLenStr);\n            if (isNaN(blkLen)) {\n                return 'invalid block length';\n            }\n        }\n        const hashBins = [];\n        const hashB64s = hashes.split(',');\n        // 倒序存储，之后 pop 取出\n        for (let i = hashB64s.length - 1; i !== -1; i--) {\n            const bin = base64Decode(hashB64s[i]);\n            if (!bin || bin.length !== 32 /* SHA256_BIN */) {\n                return 'invalid block hash';\n            }\n            hashBins.push(bin);\n        }\n        return [blkLen, hashBins];\n    }\n    async onData(chunk) {\n        this.hasData = true;\n        this.queueLen += chunk.length;\n        if (this.queueLen > 67108864 /* MAX_QUEUE_LEN */) {\n            throw new ParamError('max queue length exceeded');\n        }\n        if (this.queueLen >= this.blkLen) {\n            // let queueLen be integer multiple of blkLen\n            const remain = this.queueLen % this.blkLen;\n            if (remain) {\n                const head = chunk.subarray(0, -remain);\n                this.queueArr.push(head);\n                this.queueLen -= remain;\n            }\n            else {\n                this.queueArr.push(chunk);\n            }\n            const blks = await this.pull();\n            this.queueLen = remain;\n            if (remain) {\n                const tail = chunk.subarray(-remain);\n                this.queueArr.push(tail);\n            }\n            return blks;\n        }\n        this.queueArr.push(chunk);\n        return EMPTY_BUF;\n    }\n    async onEnd(chunk) {\n        if (chunk.length > 0) {\n            this.queueLen += chunk.length;\n            this.queueArr.push(chunk);\n        }\n        if (this.queueLen === 0) {\n            if (!this.hasData) {\n                await this.verify(EMPTY_BUF);\n            }\n            return EMPTY_BUF;\n        }\n        return this.pull();\n    }\n    async pull() {\n        const blks = concatBufs(this.queueArr, this.queueLen);\n        this.queueArr.length = 0;\n        for (let p = 0; p < blks.length; p += this.blkLen) {\n            const blk = blks.subarray(p, p + this.blkLen);\n            await this.verify(blk);\n        }\n        return blks;\n    }\n    async verify(blk) {\n        const hashExp = this.hashBins.pop();\n        if (!hashExp) {\n            throw new ParamError('missing hash');\n        }\n        const hashGot = await sha256(blk);\n        if (!isArrayEqual(hashExp, hashGot)) {\n            const exp = base64Encode(hashExp);\n            const got = base64Encode(hashGot);\n            throw new ParamError(`hash incorrect. expected: ${exp}, but got: ${got}`);\n        }\n    }\n}\nclass ParamHeaders extends ParamBase {\n    constructor(headers, preserveAll) {\n        super();\n        this.headers = headers;\n        this.preserveAll = preserveAll;\n    }\n    static parseConf(conf) {\n        return ParamReqHeaders.parse(conf);\n    }\n    onResponse(resArgs, fileLoader, rawRes) {\n        if (this.preserveAll) {\n            for (const [k, v] of rawRes.headers) {\n                resArgs.headers.set(k, v);\n            }\n            for (const [k, v] of this.headers) {\n                resArgs.headers.set(k, v);\n            }\n            return;\n        }\n        for (const [k, v] of this.headers) {\n            if (v === '') {\n                // preserve\n                const rawVal = rawRes.headers.get(k);\n                if (rawVal !== null) {\n                    resArgs.headers.set(k, rawVal);\n                }\n            }\n            else {\n                // add\n                resArgs.headers.set(k, v);\n            }\n        }\n    }\n}\nParamHeaders.reuse = true;\nclass ParamOpenTimeout extends ParamBase {\n    constructor(time) {\n        super();\n        this.time = time;\n        this.tid = 0;\n    }\n    static parseConf(conf) {\n        const time = parseTime(conf);\n        if (isNaN(time)) {\n            return 'invalid time format';\n        }\n        return [time];\n    }\n    onRequest(reqArgs, fileLoader) {\n        this.tid = setTimeout(() => {\n            const delay = Math.max(this.time, 5000);\n            fileLoader.loadNextUrl(delay);\n        }, this.time);\n    }\n    onResponse() {\n        this.stopTimer();\n    }\n    onError() {\n        this.stopTimer();\n    }\n    onAbort() {\n        this.stopTimer();\n    }\n    stopTimer() {\n        if (this.tid > 0) {\n            clearTimeout(this.tid);\n            this.tid = 0;\n        }\n    }\n}\nclass ParamPos extends ParamBase {\n    constructor(pos) {\n        super();\n        this.remain = pos;\n    }\n    static parseConf(conf) {\n        const begin = parseByteUnit(conf);\n        if (isNaN(begin)) {\n            return 'invalid byte format';\n        }\n        if (begin === 0) {\n            return;\n        }\n        return [begin];\n    }\n    onData(chunk) {\n        if (this.remain <= 0) {\n            return chunk;\n        }\n        const remain = (this.remain -= chunk.length);\n        if (remain >= 0) {\n            return EMPTY_BUF;\n        }\n        // if remain < 0, return last -remain bytes\n        return chunk.subarray(remain);\n    }\n    onEnd(chunk) {\n        return this.onData(chunk);\n    }\n}\nclass ParamPrefix extends ParamBase {\n    constructor(bytes) {\n        super();\n        this.bytes = bytes;\n        this.done = false;\n    }\n    static parseConf(conf) {\n        const bytes = parseStrOrB64(conf);\n        if (!bytes) {\n            return 'invalid format';\n        }\n        return [bytes];\n    }\n    onData(chunk) {\n        if (this.done) {\n            return chunk;\n        }\n        this.done = true;\n        return concatBufs([this.bytes, chunk]);\n    }\n    onEnd(chunk) {\n        // for empty file\n        return this.onData(chunk);\n    }\n}\nclass ParamRecvTimeout extends ParamBase {\n    constructor(bytes, time) {\n        super();\n        this.bytes = bytes;\n        this.time = time;\n        this.tid = 0;\n        this.sum = 0;\n    }\n    static parseConf(conf) {\n        const [n, t] = conf.split('/');\n        const bytes = parseByteUnit(n);\n        const time = parseTime(t);\n        if (isNaN(bytes)) {\n            return 'invalid byte format';\n        }\n        if (isNaN(time)) {\n            return 'invalid time format';\n        }\n        return [bytes, time];\n    }\n    onRequest(reqArgs, fileLoader) {\n        this.fileLoader = fileLoader;\n    }\n    onResponse() {\n        this.tid = setInterval(() => {\n            if (this.sum <= this.bytes) {\n                this.stopTimer();\n                this.fileLoader.loadNextUrl();\n            }\n            this.sum = 0;\n        }, this.time);\n    }\n    onData(chunk) {\n        this.sum += chunk.length;\n        return chunk;\n    }\n    onEnd(chunk) {\n        this.stopTimer();\n        return chunk;\n    }\n    onError() {\n        this.stopTimer();\n    }\n    onAbort() {\n        this.stopTimer();\n    }\n    stopTimer() {\n        if (this.tid > 0) {\n            clearInterval(this.tid);\n            this.tid = 0;\n        }\n    }\n}\nconst REG_REFFERER_POLICY = /^(?:no-referrer|unsafe-url|origin|same-origin|strict-origin|no-referrer-when-downgrade|origin-when-cross-origin|strict-origin-when-cross-origin)$/;\nclass ParamReferrerPolicy extends ParamBase {\n    constructor(policy) {\n        super();\n        this.policy = policy;\n    }\n    static parseConf(conf) {\n        if (conf === 'raw') {\n            return [''];\n        }\n        if (!REG_REFFERER_POLICY.test(conf)) {\n            return 'invalid value';\n        }\n        return [conf];\n    }\n    onRequest(reqArgs, fileLoader) {\n        reqArgs.referrerPolicy = this.policy || fileLoader.rawReq.referrerPolicy;\n    }\n}\nParamReferrerPolicy.reuse = true;\nclass ParamReqHeaders extends ParamBase {\n    constructor(headers, preserveAll) {\n        super();\n        this.headers = headers;\n        this.preserveAll = preserveAll;\n    }\n    static parse(conf) {\n        const headers = [];\n        let preserveAll = false;\n        // {\"header-to-preserve\": \"\", \"header-to-add\": \"val\"}\n        const map = parseJson(conf);\n        if (typeof map !== 'object') {\n            return 'invalid format';\n        }\n        for (const [k, v] of Object.entries(map)) {\n            if (k === '*') {\n                preserveAll = true;\n            }\n            else {\n                headers.push([k, v + '']);\n            }\n        }\n        return [headers, preserveAll];\n    }\n    static parseConf(conf) {\n        return this.parse(conf);\n    }\n    onRequest(reqArgs, fileLoader) {\n        const { rawReq } = fileLoader;\n        if (this.preserveAll) {\n            for (const [k, v] of rawReq.headers) {\n                reqArgs.headers.set(k, v);\n            }\n            for (const [k, v] of this.headers) {\n                reqArgs.headers.set(k, v);\n            }\n            return;\n        }\n        for (const [k, v] of this.headers) {\n            if (k === 'referer') {\n                reqArgs.referrer = v || rawReq.referrer;\n                continue;\n            }\n            if (v === '') {\n                // preserve\n                const rawVal = rawReq.headers.get(k);\n                if (rawVal !== null) {\n                    reqArgs.headers.set(k, rawVal);\n                }\n            }\n            else {\n                // add\n                reqArgs.headers.set(k, v);\n            }\n        }\n    }\n}\nParamReqHeaders.reuse = true;\nclass ParamSize extends ParamBase {\n    constructor(size) {\n        super();\n        this.remain = size;\n    }\n    static parseConf(conf) {\n        const size = parseByteUnit(conf);\n        if (isNaN(size)) {\n            return 'invalid byte format';\n        }\n        return [size];\n    }\n    onData(chunk) {\n        if (this.remain <= 0) {\n            return EMPTY_BUF;\n        }\n        const remain = (this.remain -= chunk.length);\n        if (remain >= 0) {\n            return chunk;\n        }\n        // remain < 0, return [0, END + remain)\n        return chunk.subarray(0, remain);\n    }\n    onEnd(chunk) {\n        return this.onData(chunk);\n    }\n}\nclass ParamStream extends ParamBase {\n    constructor() {\n        super();\n        this.queueArr = [];\n        this.queueLen = 0;\n    }\n    static parseConf(conf) {\n        if (conf === 'on') {\n            // default\n            return;\n        }\n        if (conf === 'off') {\n            return [];\n        }\n        return 'invalid value';\n    }\n    onData(chunk) {\n        this.queueLen += chunk.length;\n        if (this.queueLen > 67108864 /* MAX_QUEUE_LEN */) {\n            throw new ParamError('max queue length exceeded');\n        }\n        this.queueArr.push(chunk);\n        return EMPTY_BUF;\n    }\n    onEnd(chunk) {\n        if (chunk.length > 0) {\n            // unlikely\n            this.onData(chunk);\n        }\n        return concatBufs(this.queueArr, this.queueLen);\n    }\n}\nclass ParamSuffix extends ParamBase {\n    constructor(bytes) {\n        super();\n        this.bytes = bytes;\n    }\n    static parseConf(conf) {\n        const bytes = parseStrOrB64(conf);\n        if (!bytes) {\n            return 'invalid format';\n        }\n        return [bytes];\n    }\n    onEnd(chunk) {\n        if (chunk.length === 0) {\n            return this.bytes;\n        }\n        return concatBufs([chunk, this.bytes]);\n    }\n}\nParamSuffix.reuse = true;\nclass ParamValidStatus extends ParamBase {\n    constructor(codes) {\n        super();\n        this.codes = codes;\n    }\n    static parseConf(conf) {\n        if (conf === '*') {\n            return;\n        }\n        const codes = conf.split(',').map(Number);\n        return [codes];\n    }\n    onResponse(resArgs, fileLoader, rawRes) {\n        if (!this.codes.includes(rawRes.status)) {\n            throw new ParamError('invalid http status: ' + rawRes.status);\n        }\n    }\n}\nParamValidStatus.reuse = true;\nclass ParamXor extends ParamBase {\n    constructor(key) {\n        super();\n        this.key = key;\n    }\n    static parseConf(conf) {\n        const key = +conf | 0;\n        if (key < 0 || key > 255) {\n            return 'invalid value';\n        }\n        return [key];\n    }\n    onData(chunk) {\n        // TODO: u32 optimize\n        for (let i = 0; i < chunk.length; i++) {\n            chunk[i] ^= this.key;\n        }\n        return chunk;\n    }\n    onEnd(chunk) {\n        return this.onData(chunk);\n    }\n}\nParamXor.reuse = true;\nconst MIME_DATA = 'application/andrew-inset:ez;application/applixware:aw;application/atom+xml:atom;application/atomcat+xml:atomcat;application/atomdeleted+xml:atomdeleted;application/atomsvc+xml:atomsvc;application/atsc-dwd+xml:dwd;application/atsc-held+xml:held;application/atsc-rsat+xml:rsat;application/bdoc:bdoc;application/calendar+xml:xcs;application/ccxml+xml:ccxml;application/cdfx+xml:cdfx;application/cdmi-capability:cdmia;application/cdmi-container:cdmic;application/cdmi-domain:cdmid;application/cdmi-object:cdmio;application/cdmi-queue:cdmiq;application/cu-seeme:cu;application/dash+xml:mpd;application/davmount+xml:davmount;application/docbook+xml:dbk;application/dssc+der:dssc;application/dssc+xml:xdssc;application/ecmascript:ecma,es;application/emma+xml:emma;application/emotionml+xml:emotionml;application/epub+zip:epub;application/exi:exi;application/fdt+xml:fdt;application/font-tdpfr:pfr;application/geo+json:geojson;application/gml+xml:gml;application/gpx+xml:gpx;application/gxf:gxf;application/gzip:gz;application/hjson:hjson;application/hyperstudio:stk;application/inkml+xml:ink,inkml;application/ipfix:ipfix;application/its+xml:its;application/java-archive:jar,war,ear;application/java-serialized-object:ser;application/java-vm:class;application/javascript:js,mjs;application/json:json,map;application/json5:json5;application/jsonml+json:jsonml;application/ld+json:jsonld;application/lgr+xml:lgr;application/lost+xml:lostxml;application/mac-binhex40:hqx;application/mac-compactpro:cpt;application/mads+xml:mads;application/manifest+json:webmanifest;application/marc:mrc;application/marcxml+xml:mrcx;application/mathematica:ma,nb,mb;application/mathml+xml:mathml;application/mbox:mbox;application/mediaservercontrol+xml:mscml;application/metalink+xml:metalink;application/metalink4+xml:meta4;application/mets+xml:mets;application/mmt-aei+xml:maei;application/mmt-usd+xml:musd;application/mods+xml:mods;application/mp21:m21,mp21;application/mp4:mp4s,m4p;application/mrb-consumer+xml:xdf;application/mrb-publish+xml:xdf;application/msword:doc,dot;application/mxf:mxf;application/n-quads:nq;application/n-triples:nt;application/node:cjs;application/octet-stream:bin,dms,lrf,mar,so,dist,distz,pkg,bpk,dump,elc,deploy,exe,dll,deb,dmg,iso,img,msi,msp,msm,buffer;application/oda:oda;application/oebps-package+xml:opf;application/ogg:ogx;application/omdoc+xml:omdoc;application/onenote:onetoc,onetoc2,onetmp,onepkg;application/oxps:oxps;application/p2p-overlay+xml:relo;application/patch-ops-error+xml:xer;application/pdf:pdf;application/pgp-encrypted:pgp;application/pgp-signature:asc,sig;application/pics-rules:prf;application/pkcs10:p10;application/pkcs7-mime:p7m,p7c;application/pkcs7-signature:p7s;application/pkcs8:p8;application/pkix-attr-cert:ac;application/pkix-cert:cer;application/pkix-crl:crl;application/pkix-pkipath:pkipath;application/pkixcmp:pki;application/pls+xml:pls;application/postscript:ai,eps,ps;application/provenance+xml:provx;application/pskc+xml:pskcxml;application/raml+yaml:raml;application/rdf+xml:rdf,owl;application/reginfo+xml:rif;application/relax-ng-compact-syntax:rnc;application/resource-lists+xml:rl;application/resource-lists-diff+xml:rld;application/rls-services+xml:rs;application/route-apd+xml:rapd;application/route-s-tsid+xml:sls;application/route-usd+xml:rusd;application/rpki-ghostbusters:gbr;application/rpki-manifest:mft;application/rpki-roa:roa;application/rsd+xml:rsd;application/rss+xml:rss;application/rtf:rtf;application/sbml+xml:sbml;application/scvp-cv-request:scq;application/scvp-cv-response:scs;application/scvp-vp-request:spq;application/scvp-vp-response:spp;application/sdp:sdp;application/senml+xml:senmlx;application/sensml+xml:sensmlx;application/set-payment-initiation:setpay;application/set-registration-initiation:setreg;application/shf+xml:shf;application/sieve:siv,sieve;application/smil+xml:smi,smil;application/sparql-query:rq;application/sparql-results+xml:srx;application/srgs:gram;application/srgs+xml:grxml;application/sru+xml:sru;application/ssdl+xml:ssdl;application/ssml+xml:ssml;application/swid+xml:swidtag;application/tei+xml:tei,teicorpus;application/thraud+xml:tfi;application/timestamped-data:tsd;application/toml:toml;application/ttml+xml:ttml;application/ubjson:ubj;application/urc-ressheet+xml:rsheet;application/urc-targetdesc+xml:td;application/voicexml+xml:vxml;application/wasm:wasm;application/widget:wgt;application/winhlp:hlp;application/wsdl+xml:wsdl;application/wspolicy+xml:wspolicy;application/xaml+xml:xaml;application/xcap-att+xml:xav;application/xcap-caps+xml:xca;application/xcap-diff+xml:xdf;application/xcap-el+xml:xel;application/xcap-error+xml:xer;application/xcap-ns+xml:xns;application/xenc+xml:xenc;application/xhtml+xml:xhtml,xht;application/xliff+xml:xlf;application/xml:xml,xsl,xsd,rng;application/xml-dtd:dtd;application/xop+xml:xop;application/xproc+xml:xpl;application/xslt+xml:xsl,xslt;application/xspf+xml:xspf;application/xv+xml:mxml,xhvml,xvml,xvm;application/yang:yang;application/yin+xml:yin;application/zip:zip;audio/3gpp:3gpp;audio/adpcm:adp;audio/amr:amr;audio/basic:au,snd;audio/midi:mid,midi,kar,rmi;audio/mobile-xmf:mxmf;audio/mp3:mp3;audio/mp4:m4a,mp4a;audio/mpeg:mpga,mp2,mp2a,mp3,m2a,m3a;audio/ogg:oga,ogg,spx,opus;audio/s3m:s3m;audio/silk:sil;audio/wav:wav;audio/wave:wav;audio/webm:weba;audio/xm:xm;font/collection:ttc;font/otf:otf;font/ttf:ttf;font/woff:woff;font/woff2:woff2;image/aces:exr;image/apng:apng;image/avif:avif;image/bmp:bmp;image/cgm:cgm;image/dicom-rle:drle;image/emf:emf;image/fits:fits;image/g3fax:g3;image/gif:gif;image/heic:heic;image/heic-sequence:heics;image/heif:heif;image/heif-sequence:heifs;image/hej2k:hej2;image/hsj2:hsj2;image/ief:ief;image/jls:jls;image/jp2:jp2,jpg2;image/jpeg:jpeg,jpg,jpe;image/jph:jph;image/jphc:jhc;image/jpm:jpm;image/jpx:jpx,jpf;image/jxr:jxr;image/jxra:jxra;image/jxrs:jxrs;image/jxs:jxs;image/jxsc:jxsc;image/jxsi:jxsi;image/jxss:jxss;image/ktx:ktx;image/ktx2:ktx2;image/png:png;image/sgi:sgi;image/svg+xml:svg,svgz;image/t38:t38;image/tiff:tif,tiff;image/tiff-fx:tfx;image/webp:webp;image/wmf:wmf;message/disposition-notification:disposition-notification;message/global:u8msg;message/global-delivery-status:u8dsn;message/global-disposition-notification:u8mdn;message/global-headers:u8hdr;message/rfc822:eml,mime;model/3mf:3mf;model/gltf+json:gltf;model/gltf-binary:glb;model/iges:igs,iges;model/mesh:msh,mesh,silo;model/mtl:mtl;model/obj:obj;model/stl:stl;model/vrml:wrl,vrml;model/x3d+binary:x3db,x3dbz;model/x3d+fastinfoset:x3db;model/x3d+vrml:x3dv,x3dvz;model/x3d+xml:x3d,x3dz;model/x3d-vrml:x3dv;text/cache-manifest:appcache,manifest;text/calendar:ics,ifb;text/coffeescript:coffee,litcoffee;text/css:css;text/csv:csv;text/html:html,htm,shtml;text/jade:jade;text/jsx:jsx;text/less:less;text/markdown:markdown,md;text/mathml:mml;text/mdx:mdx;text/n3:n3;text/plain:txt,text,conf,def,list,log,in,ini;text/richtext:rtx;text/rtf:rtf;text/sgml:sgml,sgm;text/shex:shex;text/slim:slim,slm;text/spdx:spdx;text/stylus:stylus,styl;text/tab-separated-values:tsv;text/troff:t,tr,roff,man,me,ms;text/turtle:ttl;text/uri-list:uri,uris,urls;text/vcard:vcard;text/vtt:vtt;text/xml:xml;text/yaml:yaml,yml;video/3gpp:3gp,3gpp;video/3gpp2:3g2;video/h261:h261;video/h263:h263;video/h264:h264;video/iso.segment:m4s;video/jpeg:jpgv;video/jpm:jpm,jpgm;video/mj2:mj2,mjp2;video/mp2t:ts;video/mp4:mp4,mp4v,mpg4;video/mpeg:mpeg,mpg,mpe,m1v,m2v;video/ogg:ogv;video/quicktime:qt,mov;video/webm:webm';\nvar _a;\nclass ParamMime extends ParamBase {\n    constructor(mime) {\n        super();\n        this.mime = mime;\n    }\n    static parseConf(conf) {\n        if (conf === 'auto') {\n            // likely\n            return [''];\n        }\n        return [conf];\n    }\n    onResponse(resArgs, fileLoader, rawRes) {\n        let type;\n        if (this.mime === '') {\n            const url = fileLoader.getFileConfUrl();\n            if (!url.includes('?')) {\n                const m = url.match(/\\.(\\w+)$/);\n                if (m) {\n                    const ext = m[1].toLowerCase();\n                    type = ParamMime.extTypeMap.get(ext);\n                }\n            }\n            if (!type) {\n                const rawType = rawRes.headers.get('content-type');\n                if (rawType) {\n                    type = getPair(rawType, ';')[0];\n                }\n                else {\n                    type = 'application/octet-stream';\n                }\n            }\n        }\n        else {\n            type = this.mime;\n        }\n        resArgs.headers.set('content-type', type);\n    }\n}\n_a = ParamMime;\nParamMime.reuse = true;\n(() => {\n    const map = new Map();\n    for (const item of MIME_DATA.split(';')) {\n        const [mime, exts] = getPair(item, ':');\n        for (const ext of exts.split(',')) {\n            map.set(ext, mime);\n        }\n    }\n    _a.extTypeMap = map;\n})();\nvar CacheManager;\n(function (CacheManager) {\n    let mCache;\n    // TODO: LRU\n    async function init() {\n        if (!mCache) {\n            mCache = await caches.open('.freecdn');\n        }\n    }\n    CacheManager.init = init;\n    async function findHash(hash) {\n        const res = await findCache('/' + hash);\n        if (!res) {\n            return;\n        }\n        const buf = await res.clone().arrayBuffer();\n        const bin = new Uint8Array(buf);\n        const hashGot = await sha256(bin);\n        const hashExp = base64Decode(hash);\n        if (!hashExp) {\n            return;\n        }\n        if (!isArrayEqual(hashGot, hashExp)) {\n            console.warn('[FreeCDN/CacheManager] bad cache:', hash);\n            delCache('/' + hash);\n            return;\n        }\n        return res;\n    }\n    CacheManager.findHash = findHash;\n    async function addHash(hash, res) {\n        await addCache('/' + hash, res);\n    }\n    CacheManager.addHash = addHash;\n    function findCache(reqInfo) {\n        return mCache.match(reqInfo);\n    }\n    CacheManager.findCache = findCache;\n    async function addCache(reqInfo, res) {\n        try {\n            await mCache.put(reqInfo, res);\n        }\n        catch {\n        }\n    }\n    CacheManager.addCache = addCache;\n    function delCache(reqInfo) {\n        return mCache.delete(reqInfo);\n    }\n    CacheManager.delCache = delCache;\n})(CacheManager || (CacheManager = {}));\nclass Database {\n    constructor(name) {\n        this.name = name;\n    }\n    open(opts) {\n        const s = promisex();\n        const req = indexedDB.open(this.name);\n        req.onsuccess = () => {\n            const idb = req.result;\n            this.db = idb;\n            idb.onclose = () => {\n                console.warn('[FreeCDN/Database] indexedDB disconnected, reopen...');\n                this.open(opts);\n            };\n            s.resolve();\n        };\n        req.onerror = (e) => {\n            console.warn('[FreeCDN/Database] indexedDB open error:', e);\n            s.reject(req.error);\n        };\n        req.onupgradeneeded = () => {\n            const idb = req.result;\n            for (const [k, v] of Object.entries(opts)) {\n                idb.createObjectStore(k, v);\n            }\n        };\n        return s;\n    }\n    close() {\n        this.db.close();\n    }\n    get(table, key) {\n        const s = promisex();\n        const obj = this.getStore(table, 'readonly');\n        const req = obj.get(key);\n        req.onsuccess = () => {\n            s.resolve(req.result);\n        };\n        req.onerror = () => {\n            s.reject(req.error);\n        };\n        return s;\n    }\n    put(table, record) {\n        const s = promisex();\n        const obj = this.getStore(table, 'readwrite');\n        const req = obj.put(record);\n        req.onsuccess = () => {\n            s.resolve();\n        };\n        req.onerror = () => {\n            s.reject(req.error);\n        };\n        return s;\n    }\n    delete(table, key) {\n        const s = promisex();\n        const obj = this.getStore(table, 'readwrite');\n        const req = obj.delete(key);\n        req.onsuccess = () => {\n            s.resolve();\n        };\n        req.onerror = () => {\n            s.reject(req.error);\n        };\n        return s;\n    }\n    enum(table, callback, ...args) {\n        const s = promisex();\n        const obj = this.getStore(table, 'readonly');\n        const req = obj.openCursor(...args);\n        req.onsuccess = () => {\n            const { result } = req;\n            if (!result) {\n                s.resolve();\n                return;\n            }\n            const ret = callback(result.value);\n            if (ret !== false) {\n                result.continue();\n            }\n        };\n        req.onerror = () => {\n            s.reject(req.error);\n        };\n        return s;\n    }\n    getStore(table, mode) {\n        return this.db\n            .transaction(table, mode)\n            .objectStore(table);\n    }\n}\nvar Network;\n(function (Network) {\n    const mDatabase = new Database('.freecdn');\n    const mUrlInfoMap = new Map();\n    function addUrlInfo(url, status, expire) {\n        if (mUrlInfoMap.has(url)) {\n            return;\n        }\n        const info = { url, status, expire };\n        mUrlInfoMap.set(url, info);\n        mDatabase.put('cache', info);\n    }\n    class HostInfo {\n        constructor() {\n            this.lastDoneTime = 0;\n            this.lastErrTime = 0;\n            this.pending = 0;\n            // public protocol = 1\n            this.errNum = 0;\n            this.reqNum = 0;\n            this.reqTimeAvg = -1;\n            this.reqTimeSum = 0;\n            // public speedAvg = 0\n            // public speedSum = 0\n        }\n    }\n    const mHostInfoMap = new Map();\n    function getHostInfo(host) {\n        let info = mHostInfoMap.get(host);\n        if (!info) {\n            info = new HostInfo();\n            mHostInfoMap.set(host, info);\n        }\n        return info;\n    }\n    function getHostWeight(hostInfo, now) {\n        // TODO: ...\n        if (hostInfo.reqTimeAvg !== -1) {\n            const delayScore = 100 - hostInfo.reqTimeAvg * 0.2;\n            return Math.max(delayScore, 10);\n        }\n        return 50;\n    }\n    function getUrlWeight(url, now, hostWeightMap) {\n        const urlInfo = mUrlInfoMap.get(url);\n        if (urlInfo && urlInfo.expire < now) {\n            if (urlInfo.status !== 200) {\n                return -2;\n            }\n            // 该 URL 之前加载过\n            // expire 值越大，已过期的概率越小，权重越高\n            return 100 + urlInfo.expire;\n        }\n        // 当前站点默认权重 -1，低于免费站点，减少流量成本\n        if (url[0] === '/') {\n            return hostWeightMap.get(MY_HOST) ?? -1;\n        }\n        const host = getHostFromUrl(url);\n        const hostInfo = mHostInfoMap.get(host);\n        if (!hostInfo) {\n            return hostWeightMap.get(host) ?? 50;\n        }\n        return getHostWeight(hostInfo, now);\n    }\n    Network.getUrlWeight = getUrlWeight;\n    async function fetch(req) {\n        const host = getHostFromUrl(req.url);\n        const hostInfo = getHostInfo(host);\n        hostInfo.pending++;\n        const t0 = getTimeSec();\n        let res;\n        try {\n            res = await NATIVE_FETCH(req);\n        }\n        catch (err) {\n            parseFetchError(err, req, hostInfo, t0);\n            throw err;\n        }\n        finally {\n            hostInfo.pending--;\n        }\n        const maxAge = parseMaxAge(res.headers, t0);\n        switch (res.status) {\n            case 200:\n                if (req.cache !== 'no-store') {\n                    if (maxAge > 60) {\n                        addUrlInfo(res.url, 200, t0 + maxAge);\n                    }\n                }\n                break;\n            case 404:\n                addUrlInfo(res.url, 404, t0 + maxAge);\n                break;\n        }\n        // 过期时间会在 expires 参数中会用到，避免重复分析\n        res._maxage = maxAge;\n        return res;\n    }\n    Network.fetch = fetch;\n    const REG_NET_ERR = /^Failed to fetch|^NetworkError|^Could not connect/;\n    function parseFetchError(err, req, hostInfo, t0) {\n        if (!navigator.onLine) {\n            return;\n        }\n        if (!REG_NET_ERR.test(err.message)) {\n            return;\n        }\n        if (req.cache === 'only-if-cached') {\n            return;\n        }\n        hostInfo.errNum++;\n        hostInfo.lastErrTime = t0;\n    }\n    function parseMaxAge(headers, t0) {\n        const cacheControl = headers.get('cache-control');\n        if (cacheControl !== null) {\n            if (cacheControl.includes('no-cache')) {\n                return 0;\n            }\n            const m = cacheControl.match(/max-age=\"?(\\d+)\"?/);\n            if (m) {\n                return +m[1];\n            }\n        }\n        const expires = headers.get('expires');\n        if (expires !== null) {\n            const t1 = Date.parse(expires) / 1000;\n            if (t1) {\n                return (t1 - t0) | 0;\n            }\n        }\n        return 300 /* DEFAULT_MAX_AGE */;\n    }\n    function parseEntries(list) {\n        const timeBase = performance.timeOrigin;\n        for (const record of list) {\n            const host = getHostFromUrl(record.name);\n            const info = getHostInfo(host);\n            info.reqNum++;\n            info.lastDoneTime = timeBase + record.responseEnd;\n            // time-allow-origin\n            if (record.responseStart > 0) {\n                const reqTime = record.responseStart - record.requestStart;\n                info.reqTimeSum += reqTime;\n                info.reqTimeAvg = info.reqTimeSum / info.reqNum;\n            }\n        }\n    }\n    async function init() {\n        await mDatabase.open({\n            'cache': {\n                keyPath: 'url'\n            },\n        });\n        const now = getTimeSec();\n        // 读取 URL 历史信息\n        await mDatabase.enum('cache', (item) => {\n            if (item.expire < now) {\n                mDatabase.delete('cache', item.url);\n                return;\n            }\n            mUrlInfoMap.set(item.url, item);\n        });\n        // 跟踪每个 URL 的性能指标\n        const entries = performance.getEntriesByType('resource');\n        parseEntries(entries);\n        const observer = new PerformanceObserver(entryList => {\n            const entries = entryList.getEntries();\n            parseEntries(entries);\n        });\n        observer.observe({\n            entryTypes: ['resource']\n        });\n    }\n    Network.init = init;\n    function parseWeightConf(manifest) {\n        const zone = navigator.language.toLowerCase();\n        const zone0 = zone.split('-')[0];\n        const weightParams = manifest.getParams('@weight ' + zone) ||\n            manifest.getParams('@weight ' + zone0) ||\n            manifest.getParams('@weight');\n        if (!weightParams) {\n            const obj = ZONE_HOST_SCORE[zone] || ZONE_HOST_SCORE['*'];\n            return new Map(Object.entries(obj));\n        }\n        const map = new Map();\n        for (const [k, v] of weightParams) {\n            const num = +v;\n            if (isNaN(num)) {\n                continue;\n            }\n            map.set(k, num);\n        }\n        return map;\n    }\n    Network.parseWeightConf = parseWeightConf;\n})(Network || (Network = {}));\nconst TEXT_ENCODER = new TextEncoder();\nconst TEXT_DECODER = new TextDecoder();\nfunction utf8ToBytes(str) {\n    return TEXT_ENCODER.encode(str);\n}\nfunction bytesToUtf8(bytes) {\n    return TEXT_DECODER.decode(bytes);\n}\nfunction bytesToAsc(bytes) {\n    return bytes.reduce((s, v) => s + String.fromCharCode(v), '');\n}\nfunction base64Encode(bytes) {\n    return btoa(bytesToAsc(bytes));\n}\nfunction base64Decode(str) {\n    try {\n        str = atob(str);\n    }\n    catch {\n        return;\n    }\n    const bin = new Uint8Array(str.length);\n    for (let i = 0; i < bin.length; i++) {\n        bin[i] = str.charCodeAt(i);\n    }\n    return bin;\n}\nfunction parseJson(str) {\n    try {\n        return JSON.parse(str);\n    }\n    catch {\n    }\n}\nfunction splitList(str) {\n    str = str.trim();\n    if (!str) {\n        return [];\n    }\n    return str.split(/\\s+/);\n}\nfunction parseStrOrB64(str) {\n    // json string\n    if (str[0] === '\"') {\n        str = parseJson(str);\n        if (str === undefined) {\n            return;\n        }\n        return utf8ToBytes(str);\n    }\n    // base64\n    return base64Decode(str);\n}\nconst TIME_UNIT = {\n    '': 1,\n    'ms': 1,\n    's': 1000,\n    'min': 1000 * 60,\n    'h': 1000 * 3600,\n    'd': 1000 * 3600 * 24,\n    'y': 1000 * 3600 * 24 * 365,\n};\nfunction parseTime(str) {\n    const m = str.match(/^([\\d.]{1,9})(y|d|h|min|s|ms|)$/);\n    if (!m) {\n        return NaN;\n    }\n    const [, num, unit] = m;\n    return +num * TIME_UNIT[unit];\n}\nfunction parseByteUnit(str) {\n    const m = str.match(/^([\\d.]{1,9})(k|K|M|G|)(i|)(b|B|)$/);\n    if (!m) {\n        return NaN;\n    }\n    const [, num, kMG, i, bB] = m;\n    const exponent = kMG === 'k' ? 1 :\n        kMG === 'K' ? 1 :\n            kMG === 'M' ? 2 :\n                kMG === 'G' ? 3 : 0;\n    const base = i ? 1024 : 1000;\n    const unit = bB === 'b' ? 8 : 1;\n    return +num * base ** exponent / unit;\n}\nfunction getTimeSec() {\n    return Date.now() / 1000 | 0;\n}\nfunction concatBufs(bufs, size = 0) {\n    if (size === 0) {\n        for (const v of bufs) {\n            size += v.length;\n        }\n    }\n    const ret = new Uint8Array(size);\n    let pos = 0;\n    for (const v of bufs) {\n        ret.set(v, pos);\n        pos += v.length;\n    }\n    return ret;\n}\nfunction isArrayEqual(b1, b2) {\n    if (b1.length !== b2.length) {\n        return false;\n    }\n    for (let i = 0; i < b1.length; i++) {\n        if (b1[i] !== b2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction getPair(str, delim) {\n    const pos = str.indexOf(delim);\n    if (pos === -1) {\n        return [str];\n    }\n    return [\n        str.substring(0, pos),\n        str.substring(pos + delim.length)\n    ];\n}\nfunction mergeMap(dst, src) {\n    for (const [k, v] of src) {\n        dst.set(k, v);\n    }\n}\n/**\n * @param url absolute or relative url\n */\nfunction stripUrlQuery(url) {\n    const pos = url.indexOf('?');\n    if (pos === -1) {\n        return url;\n    }\n    return url.substring(0, pos);\n}\n/**\n * @param url absolute url\n */\nfunction getHostFromUrl(url) {\n    const m = url.match(/^https?:\\/\\/([^/]+)/);\n    return m[1];\n}\n/**\n * @param url absolute or relative url\n */\nfunction toRelUrl(url) {\n    if (url.startsWith(ROOT_PATH)) {\n        return url.substring(MY_ORIGIN.length);\n    }\n    return url;\n}\nasync function sha256(buf) {\n    const ret = await CRYPTO.digest('SHA-256', buf);\n    return new Uint8Array(ret);\n}\nconst ZONE_HOST_SCORE = {\n    'zh-cn': {\n        'ajax.cdnjs.com': 50,\n        'cdnjs.cloudflare.com': 50,\n        'cdn.jsdelivr.net': 80,\n        'raw.githubusercontent.com': 10,\n        'cdnjs.loli.net': 70,\n        'lib.baomitu.com': 80,\n        'lf6-cdn-tos.bytecdntp.com': 90,\n        'cdn.staticfile.org': 90,\n        'cdn.bootcss.com': 10,\n        'cdn.bootcdn.net': 80,\n        'unpkg.com': 50,\n        'g.alicdn.com': 90,\n        'pagecdn.io': 20,\n        'ajax.aspnetcdn.com': 60,\n        'ajax.googleapis.com': 10,\n        'code.jquery.com': 20,\n        'stackpath.bootstrapcdn.com': 30,\n        'maxcdn.bootstrapcdn.com': 30,\n        'cdn.datatables.net': 40,\n        'twemoji.maxcdn.com': 40,\n    },\n    '*': {\n        'ajax.cdnjs.com': 90,\n        'cdnjs.cloudflare.com': 90,\n        'cdn.jsdelivr.net': 40,\n        'raw.githubusercontent.com': 10,\n        'cdnjs.loli.net': 40,\n        'lib.baomitu.com': 20,\n        'lf6-cdn-tos.bytecdntp.com': 40,\n        'cdn.staticfile.org': 20,\n        'cdn.bootcss.com': 10,\n        'cdn.bootcdn.net': 20,\n        'unpkg.com': 40,\n        'g.alicdn.com': 30,\n        'pagecdn.io': 40,\n        'ajax.aspnetcdn.com': 70,\n        'ajax.googleapis.com': 90,\n        'code.jquery.com': 50,\n        'stackpath.bootstrapcdn.com': 40,\n        'maxcdn.bootstrapcdn.com': 50,\n        'cdn.datatables.net': 50,\n        'twemoji.maxcdn.com': 50,\n    },\n};\n\n//# sourceMappingURL=freecdn-main.js.map\n","/**\n * JS Hook Util\n * example: https://codepen.io/etherdream/pen/WNoQQbG?editors=0012\n */\nnamespace Hook {\n  /**\n   * hook function\n   */\n  export function func<\n    T, K extends keyof T,\n\n    // T[K] must be a function\n    F = T[K] extends (...args: infer P) => infer R\n      ? (this: T, ...args: P) => R\n      : never\n  >(\n    obj: T,\n    key: K,\n    factory: (oldFn: F) => F\n  ) {\n    const oldFn: F = obj[key] as any\n    if (!oldFn) {\n      return false\n    }\n    const newFn = factory(oldFn)\n    obj[key] = newFn as any\n    return true\n  }\n\n  /**\n   * hook property\n   */\n  export function prop<\n    T, K extends keyof T,\n\n    GETTER extends (this: T) => T[K],\n    SETTER extends (this: T, value: T[K]) => void,\n\n    GETTER_FACTORY extends (oldGetter: GETTER) => GETTER,\n    SETTER_FACTORY extends (oldSetter: SETTER) => SETTER,\n  >(\n    obj: T,\n    key: K,\n    getterFactory: GETTER_FACTORY | null,\n    setterFactory: SETTER_FACTORY | null,\n  ) {\n    const desc = Object.getOwnPropertyDescriptor(obj, key)\n    if (!desc) {\n      return false\n    }\n    if (getterFactory) {\n      func(desc, 'get', getterFactory)\n    }\n    if (setterFactory) {\n      func(desc, 'set', setterFactory)\n    }\n    Object.defineProperty(obj, key, desc)\n    return true\n  }\n}\n","declare const VER: string\ndeclare const RELEASE: never\nconst IS_DEBUG = typeof RELEASE === 'undefined'\n\n\nconst DEFAULT_PARAMS = `\n@__default__\n expires=30s\n mime=auto\n open_timeout=10s\n valid_status=200\n`\nconst DEFAULT_MANIFEST_PATH = '/freecdn-manifest.txt'\nconst MY_URL = location.href\nconst MY_HOST = location.host\nconst MY_ORIGIN = location.origin\nconst ROOT_PATH = MY_ORIGIN + '/'\n\nconst INTERNAL_DIR = 'freecdn-internal/' + (IS_DEBUG ? 'dev' : VER)\nconst INTERNAL_PATH = new URL(INTERNAL_DIR, ROOT_PATH).pathname\nconst REG_IMG_EXTS = /\\.(?:jpg|jpeg|png|apng|gif|ico|bmp)$/i\n\nconst enum LEN {\n  SHA256_BIN = 32,\n  SHA256_B64 = 44,\n  PUBKEY_B64 = 124,\n}\n\ntype params_t = ReadonlyMap<string, string>\n\nconst NATIVE_FETCH = fetch\nconst EMPTY_BUF = new Uint8Array(0)\n\nconst CRYPTO = crypto.subtle\n\n\nlet gInited: boolean | PromiseX\n\nasync function globalInit() {\n  if (gInited) {\n    return gInited\n  }\n  gInited = promisex()\n\n  await CacheManager.init()\n  await Network.init()\n  UrlConf.init()\n\n  gInited.resolve()\n  gInited = true\n}","interface RequestArgs extends RequestInit {\n  headers: Headers\n}\n\ninterface ResponseArgs extends ResponseInit {\n  headers: Headers\n  status: number\n  statusText: string\n}\n\nclass ParamError extends Error {\n  public constructor(message: string) {\n    super(message)\n  }\n}\n\nabstract class ParamBase {\n  public onRequest(reqArgs: RequestArgs, fileLoader: FileLoader) : may_async<Response | void> {\n  }\n\n  public onResponse(resArgs: ResponseArgs, fileLoader: FileLoader, rawRes: Response) : void {\n  }\n\n  public onData(chunk: Uint8Array) : may_async<Uint8Array> {\n    return chunk\n  }\n\n  public onEnd(chunk: Uint8Array) : may_async<Uint8Array> {\n    return chunk\n  }\n\n  public onError(error: any) : void {\n  }\n\n  public onAbort(reason: any) : void {\n  }\n}\n\ninterface ParamSub {\n  new(...args: any[]) : ParamBase\n\n  reuse?: boolean\n\n  parseConf(conf: string) :\n    any[] |     // construct args\n    string |    // error info\n    undefined   // off\n\n  priority?: number\n}","namespace KeyManager {\n  let mKey: CryptoKey\n\n\n  export async function set(keyBase64: string) {\n    const keyBin = base64Decode(keyBase64)\n    if (!keyBin) {\n      return\n    }\n    mKey = await CRYPTO.importKey('spki', keyBin, {\n      name: 'ECDSA',\n      namedCurve: 'P-256',\n    }, false, ['verify'])\n  }\n\n  export async function verify(data: Uint8Array) {\n    if (!mKey) {\n      return false\n    }\n    const linePos = data.lastIndexOf(10)  // 10 = '\\n'\n    const lineBin = data.subarray(linePos + 1)\n    const lineTxt = bytesToUtf8(lineBin)\n\n    const m = lineTxt.match(/# SIGN: ([A-Za-z0-9+/=]{88})$/)\n    if (!m) {\n      return false\n    }\n    const signTxt = m[1]\n    const signBin = base64Decode(signTxt) as Uint8Array\n    const dataBin = data.subarray(0, linePos)\n\n    return await CRYPTO.verify({\n      name: 'ECDSA',\n      hash: {\n        name: 'SHA-256'\n      },\n    }, mKey, signBin, dataBin)\n  }\n}","//\n// 匹配清单中的文件块。例如：\n//\n// (http://foo/path/to/file)\n//    ...\n// (/path/to/file)\n//    ...\n// (@config)\n//    ...\n// 其中 $0 为文件名，内容部分只匹配不捕获，之后通过 lastIndex 截取\n//\nconst REG_HEAD_LINE = /^(?:\\/|https?:|@).*/mg\n\n\nclass Manifest {\n  private readonly urlFileMap = new Map<string, FileConf>()\n  public globalParams!: params_t\n\n\n  public has(key: string) {\n    return this.urlFileMap.has(key)\n  }\n\n  public get(key: string) {\n    return this.urlFileMap.get(key)\n  }\n\n  public getParams(name: string) {\n    const fileConf = this.get(name)\n    if (fileConf) {\n      fileConf.parse()\n      return fileConf.params\n    }\n  }\n\n  public async parse(txt: string) {\n    this.parseFile(txt + DEFAULT_PARAMS)\n\n    const inc = this.urlFileMap.get('@include')\n    if (inc) {\n      const cdn = new FreeCDN()\n      cdn.manifest = this\n\n      const urls = inc.getLines()\n      const rets = urls.map(cdn.fetchText, cdn)\n      const txts = await Promise.all(rets)\n      txts.forEach(this.parseFile, this)\n    }\n  }\n\n  private parseFile(txt: string) {\n    // lazy parse\n    let name = ''\n    let last = 0\n\n    for (;;) {\n      const m = REG_HEAD_LINE.exec(txt)\n      if (last > 0) {\n        if (name[0] !== '@') {\n          name = toRelUrl(name)\n        }\n        const curr = m ? m.index : txt.length\n        const part = txt.substring(last, curr)\n        const conf = new FileConf(name, part)\n\n        this.urlFileMap.set(name, conf)\n      }\n      if (!m) {\n        break\n      }\n      name = m[0]\n      last = REG_HEAD_LINE.lastIndex\n    }\n\n    const m0 = this.getParams('@__default__') as params_t\n    const m1 = this.getParams('@global')\n\n    this.globalParams = m1 ? new Map([...m0, ...m1]) : m0\n  }\n}\n","class UrlConf {\n  private static nameClassMap: {[name: string] : ParamSub}\n\n  public static init() {\n    // 为了让代码更简洁，这里没有逐一引用各个参数对应的文件\n    // 如果该列表定义在全局，会出现依赖顺序的问题\n    this.nameClassMap = {\n      // 参数优先级（越前面的参数优先执行）\n      'data': ParamData,\n      'bundle': ParamBundle,\n\n      'open_timeout': ParamOpenTimeout,\n      'recv_timeout': ParamRecvTimeout,\n      'referrer_policy': ParamReferrerPolicy,\n      'req_headers': ParamReqHeaders,\n      'valid_status': ParamValidStatus,\n\n      'headers': ParamHeaders,\n      'expires': ParamExpires,\n      'mime': ParamMime,\n      'charset': ParamCharset,\n\n      'pos': ParamPos,\n      'size': ParamSize,\n      'xor': ParamXor,\n      'br': ParamBr,\n\n      'prefix': ParamPrefix,\n      'suffix': ParamSuffix,\n      'hash': ParamHash,\n      'stream': ParamStream,\n    }\n    Object.values(this.nameClassMap).forEach((cls, i) => {\n      cls.priority = i\n    })\n  }\n\n  // 不带片段部分的 URL（可以是相对路径）\n  public readonly url: string\n\n  // URL 片段部分\n  public readonly frag: string | undefined\n\n\n  public constructor(\n    fullUrl: string,\n    private readonly fileParams: params_t\n  ) {\n    [this.url, this.frag] = getPair(toRelUrl(fullUrl), '#')\n  }\n\n  public parse(manifest: Manifest) {\n    // TODO: cache result\n    const params = new Map<string, string>()\n\n    // 参数优先级: 全局参数 < 站点参数 < 文件参数 < URL 参数\n    mergeMap(params, manifest.globalParams)\n\n    // 站点参数\n    const host = this.url[0] === '/' ? MY_HOST : getHostFromUrl(this.url)\n    const hostParams = manifest.getParams('@host ' + host)\n    if (hostParams) {\n      mergeMap(params, hostParams)\n    }\n\n    // 文件参数\n    mergeMap(params, this.fileParams)\n\n    // URL 参数（定义在 # 后面）\n    if (this.frag) {\n      const urlParams = new URLSearchParams(this.frag)\n      mergeMap(params, urlParams)\n    }\n\n    const mods: ParamBase[] = []\n\n    for (const [k, v] of params) {\n      const cls = UrlConf.nameClassMap[k]\n      if (!cls) {\n        console.warn('[FreeCDN/UrlConf] unknown param:', k)\n        continue\n      }\n      const ret = cls.parseConf(v)\n      if (ret === undefined) {\n        continue\n      }\n      if (typeof ret === 'string') {\n        console.warn('[FreeCDN/UrlConf] parseConf failed. mod:', k, 'err:', ret, 'conf:', v)\n        continue\n      }\n      const obj = new cls(...ret)\n      mods.push(obj)\n    }\n\n    mods.sort((a, b) =>\n      ((a.constructor as ParamSub).priority as number) -\n      ((b.constructor as ParamSub).priority as number)\n    )\n    return mods\n  }\n}\n","class UrlLoader {\n  private readonly abortCtrl = new AbortController()\n\n  private pauseSignal: PromiseX | undefined\n  private isNetErr = false\n  private isDone = false\n  private isAborted = false\n\n  public bytesRead = 0\n  public onResponse!: (args: ResponseArgs) => void\n  public onData!: (chunk: Uint8Array) => void\n  public onEnd!: () => void\n  public onError!: (err: Error) => void\n\n\n  public constructor(\n    public readonly url: string,\n    private readonly paramMods: ParamBase[]) {\n  }\n\n  public async request(fileLoader: FileLoader) {\n    let err: any\n    try {\n      err = await this.requestUnsafe(fileLoader)\n    } catch (e) {\n      console.assert(e instanceof ParamError, e)\n      err = e\n    }\n\n    if (err && !this.isAborted) {\n      for (const mod of this.paramMods) {\n        mod.onError(err)\n      }\n      this.onError(err)\n\n      // TODO: network.addError(err)\n\n      if (!this.isNetErr) {\n        this.abort(err)\n      }\n    }\n  }\n\n  private async requestUnsafe(fileLoader: FileLoader) {\n    const {rawReq} = fileLoader\n    const {method} = rawReq\n    const reqArgs: RequestArgs = {\n      method,\n      referrer: rawReq.referrer,\n      referrerPolicy: 'same-origin',\n      headers: new Headers(),\n    }\n\n    if (method === 'POST' || method === 'PUT') {\n      reqArgs.body = await rawReq.clone().arrayBuffer()\n    }\n\n    let res: Response | void\n\n    for (const mod of this.paramMods) {\n      // 可直接返回响应（例如 data 参数、bundle 参数）\n      const ret = mod.onRequest(reqArgs, fileLoader)\n      if (ret) {\n        // await is slow\n        // https://gist.github.com/EtherDream/52649e4939008e149d0cb3a944c055b7\n        res = isPromise(ret) ? await ret : ret\n        if (res) {\n          break\n        }\n      }\n    }\n\n    if (!res) {\n      reqArgs.signal = this.abortCtrl.signal\n\n      const req = new Request(this.url, reqArgs)\n      try {\n        res = await Network.fetch(req)\n      } catch (err) {\n        this.isNetErr = true\n        return err\n      }\n    }\n\n    const resArgs: ResponseArgs = {\n      status: res.status,\n      statusText: res.statusText,\n      headers: new Headers(),\n    }\n    for (const mod of this.paramMods) {\n      mod.onResponse(resArgs, fileLoader, res)\n    }\n    this.onResponse(resArgs)\n\n    if (!res.body) {\n      return new Error('cors error')\n    }\n    const reader = res.body.getReader()\n    let buf: Uint8Array\n\n    READ: for (;;) {\n      try {\n        const {value} = await reader.read()\n        if (!value) {\n          break\n        }\n        buf = value\n      } catch (err) {\n        this.isNetErr = true\n        return err\n      }\n\n      for (const mod of this.paramMods) {\n        const ret = mod.onData(buf)\n        buf = isPromise(ret) ? await ret : ret\n        if (buf.length === 0) {\n          continue READ\n        }\n      }\n\n      if (buf.length > 0) {\n        this.pauseSignal && await this.pauseSignal\n        this.bytesRead += buf.length\n        this.onData(buf)\n      }\n    } // READ NEXT\n\n    this.isDone = true\n    buf = EMPTY_BUF\n\n    for (const mod of this.paramMods) {\n      const ret = mod.onEnd(buf)\n      buf = isPromise(ret) ? await ret : ret\n    }\n\n    if (buf.length > 0) {\n      this.pauseSignal && await this.pauseSignal\n      this.bytesRead += buf.length\n      this.onData(buf)\n    }\n\n    this.onEnd()\n  }\n\n  public pause() {\n    console.assert(!this.pauseSignal)\n    this.pauseSignal = promisex()\n  }\n\n  public resume() {\n    this.pauseSignal?.resolve()\n    this.pauseSignal = undefined\n  }\n\n  public abort(reason: any) {\n    if (this.isDone) {\n      return\n    }\n    this.isAborted = true\n    this.abortCtrl.abort()\n\n    for (const mod of this.paramMods) {\n      mod.onAbort(reason)\n    }\n  }\n}\n","// 匹配缩进开头的行，捕获 trim 后的内容（排除 `#` 注释行）\nconst REG_SUB_LINE = /^\\s+([^#\\s].+?)\\s*$/mg\n\n\nclass FileConf {\n  public urlConfs!: readonly UrlConf[]\n  public params!: params_t\n\n\n  public constructor(\n    public readonly name: string,\n    private text: string\n  ) {\n  }\n\n  public getLines() {\n    const lines: string[] = []\n    for (;;) {\n      const m = REG_SUB_LINE.exec(this.text)\n      if (!m) {\n        break\n      }\n      lines.push(m[1])\n    }\n    this.text = ''\n    return lines\n  }\n\n  public parse() {\n    if (this.text === '') {\n      return\n    }\n    const urlConfs: UrlConf[] = []\n    const params = new Map<string, string>()\n\n    for (const line of this.getLines()) {\n      if (/^https?:|^\\//.test(line)) {\n        const urlConf = new UrlConf(line, params)\n        urlConfs.push(urlConf)\n      } else {\n        const [key, val] = getPair(line, '=')\n        if (val === undefined) {\n          console.warn('[FreeCDN/FileConf] missing param value:', line)\n          continue\n        }\n        params.set(key, val)\n      }\n    }\n    this.params = params\n    this.urlConfs = urlConfs\n  }\n}\n","const FILE_BACKUP_PARAMS = [\n  'open_timeout',\n  'recv_timeout',\n  'hash',\n  'req_headers',\n  'valid_status',\n]\n\nclass FileLoaderError extends Error {\n  public constructor(message: string) {\n    super(message)\n  }\n  public urlErrs!: {url: string, err: Error}[]\n}\n\n\nclass FileLoader {\n  private readonly urlConfs: UrlConf[]\n  private readonly urlLoaderSet = new Set<UrlLoader>()\n\n  private delayTid = 0\n  private urlErrs: {url: string, err: Error}[] = []\n\n  private readonly hasRange: boolean = false\n  private readonly rangeBegin!: number\n  private readonly rangeEnd!: number\n  private readonly fileSize!: number\n\n  private opened = false\n  private closed = false\n  private bytesRead = 0\n\n  public onOpen!: (args: ResponseArgs) => void\n  public onData!: (chunk: Uint8Array) => void\n  public onEnd!: () => void\n  public onError!: (err: FileLoaderError) => void\n\n\n  public constructor(\n    public readonly fileConf: FileConf,\n    public readonly rawReq: Request,\n    public readonly manifest: Manifest,\n    public readonly weightConf: Map<string, number>,\n    public range: string | null,\n    public suffix: string\n  ) {\n    if (range) {\n      const r = this.parseReqRange(range)\n      if (r) {\n        [this.rangeBegin, this.rangeEnd] = r\n        this.hasRange = true\n        this.bytesRead = this.rangeBegin\n      }\n\n      const fileSize = fileConf.params.get('size')\n      if (fileSize) {\n        this.fileSize = +fileSize\n      }\n    }\n\n    // 原始 URL 作为后备资源\n    let backupParams: params_t\n\n    if (fileConf.params.has('data') || fileConf.params.has('bundle')) {\n      // 使用内嵌数据时，可保留所有参数\n      backupParams = fileConf.params\n    } else {\n      // 使用原始 URL 时禁止修改内容，例如 pos、xor 等操作\n      // 因此只保留白名单中的参数\n      const map = new Map<string, string>()\n      for (const k of FILE_BACKUP_PARAMS) {\n        const v = fileConf.params.get(k)\n        if (v !== undefined) {\n          map.set(k, v)\n        }\n      }\n      backupParams = map\n    }\n    const backupUrlConf = new UrlConf(fileConf.name, backupParams)\n\n    this.urlConfs = fileConf.urlConfs.concat(backupUrlConf)\n  }\n\n  private parseReqRange(range: string) {\n    // 目前只考虑 `bytes=begin-end` 和 `bytes=begin-` 格式\n    const m = range.match(/bytes=(\\d+)-(\\d*)/i)\n    if (!m) {\n      return\n    }\n    const begin = +m[1]\n    const end = +m[2]   // +'' === 0\n\n    if (end !== 0 && end <= begin) {\n      return\n    }\n    return [begin, end]\n  }\n\n  private buildResRange(resArgs: ResponseArgs) {\n    let end = 0\n    if (this.rangeEnd !== 0) {\n      end = this.rangeEnd - 1\n    } else if (this.fileSize) {\n      end = this.fileSize - 1\n    }\n    const val = 'bytes ' + this.rangeBegin + '-' + end + '/' + (this.fileSize || '*')\n\n    // TODO: status 416\n    resArgs.status = 206\n    resArgs.headers.set('content-range', val)\n  }\n\n  public open() {\n    this.loadNextUrl()\n  }\n\n  public pause() {\n    for (const urlLoader of this.urlLoaderSet) {\n      urlLoader.pause()\n    }\n  }\n\n  public resume() {\n    for (const urlLoader of this.urlLoaderSet) {\n      urlLoader.resume()\n    }\n  }\n\n  public abort(reason: any) {\n    for (const urlLoader of this.urlLoaderSet) {\n      urlLoader.abort(reason)\n    }\n    if (this.delayTid !== 0) {\n      clearTimeout(this.delayTid)\n    }\n  }\n\n  private getNextUrl() {\n    const {urlConfs} = this\n    const lastIndex = urlConfs.length - 1\n    if (lastIndex === -1) {\n      return\n    }\n    const now = getTimeSec()\n    let weight = -10000\n    let index = 0\n\n    urlConfs.forEach((conf, i) => {\n      const w = Network.getUrlWeight(conf.url, now, this.weightConf)\n      if (w > weight) {\n        weight = w\n        index = i\n      }\n    })\n\n    // 删除 urlConfs[index]\n    const conf = urlConfs[index]\n    urlConfs[index] = urlConfs[lastIndex]\n    urlConfs.length = lastIndex\n\n    return {weight, conf}\n  }\n\n  public loadNextUrl(delay = 0) {\n    const ret = this.getNextUrl()\n    if (!ret) {\n      if (this.urlLoaderSet.size === 0) {\n        const err = new FileLoaderError('failed to load: ' + this.getFileConfUrl())\n        err.urlErrs = this.urlErrs\n        this.onError(err)\n      }\n      return\n    }\n    const {weight, conf} = ret\n\n    if (weight < 0 && delay > 0) {\n      // 并行加载多个备用 URL 时，推迟低权重的站点（例如当前站点、收费站点）\n      this.delayTid = setTimeout(() => {\n        this.delayTid = 0\n        this.createUrlLoader(conf)\n      }, delay)\n      return\n    }\n    this.createUrlLoader(conf)\n  }\n\n  public getFileConfUrl() {\n    return this.fileConf.name + this.suffix\n  }\n\n  private getBackupUrl(url: string) {\n    if (url.endsWith('/')) {\n      return url + this.suffix\n    }\n    return url\n  }\n\n  private createUrlLoader(urlConf: UrlConf) {\n    const url = this.getBackupUrl(urlConf.url)\n    const mods = urlConf.parse(this.manifest)\n\n    const urlLoader = new UrlLoader(url, mods)\n    this.urlLoaderSet.add(urlLoader)\n\n    urlLoader.onData = (chunk) => {\n      if (this.closed) {\n        return\n      }\n      const add = urlLoader.bytesRead - this.bytesRead\n      if (add <= 0) {\n        // 当前节点的进度落后于总进度，丢弃收到的数据\n        return\n      }\n      if (add !== chunk.length) {\n        chunk = chunk.subarray(-add)\n      }\n      this.bytesRead = urlLoader.bytesRead\n\n      if (this.rangeEnd) {\n        const exceed = this.bytesRead - this.rangeEnd\n        if (exceed > 0) {\n          chunk = chunk.subarray(0, -exceed)\n          this.onData(chunk)\n          urlLoader.onEnd()\n          return\n        }\n      }\n      this.onData(chunk)\n    }\n\n    urlLoader.onEnd = () => {\n      if (this.closed) {\n        return\n      }\n      this.closed = true\n      this.onEnd()\n      this.abort('TASK_DONE')\n    }\n\n    urlLoader.onError = (err) => {\n      this.urlErrs.push({url: urlLoader.url, err})\n      this.urlLoaderSet.delete(urlLoader)\n      this.loadNextUrl()\n    }\n\n    urlLoader.onResponse = (resArgs) => {\n      if (this.opened) {\n        return\n      }\n      if (this.hasRange) {\n        this.buildResRange(resArgs)\n      }\n      this.opened = true\n      this.onOpen(resArgs)\n    }\n\n    urlLoader.request(this)\n  }\n}\n","const enum UpdaterConf {\n  FETCH_TIMEOUT = 1000 * 3,\n\n  DEFAULT_INTERVAL = 1000 * 300,\n  MIN_INTERVAL = 1000,\n\n  SET_SVC_DELAY = 1000 * 5,\n  WS_RETRY_DELAY = 1000 * 20,\n}\n\nconst EMPTY_PARAMS: params_t = new Map()\n\n\nclass Updater {\n  private readonly manifestUrl: string\n  private readonly urlWsMap = new Map<string, WebSocket>()\n  private readonly wsArgs: string = ''\n\n  private updating = false\n  private manifestHash = EMPTY_BUF\n  private pollingTimer = 0\n  private pollingInterval = UpdaterConf.DEFAULT_INTERVAL\n  private lastTime = 0\n  private setSvcTimer = 0\n  private backupUrls: string[] = []\n\n\n  public constructor(\n    manifestPath: string,\n    private onAvailable: (manifest: Manifest) => void\n  ) {\n    const url = new URL(manifestPath, MY_URL)\n    console.assert(url.host === MY_HOST)\n\n    const path = url.pathname + url.search\n    if (path !== DEFAULT_MANIFEST_PATH) {\n      this.wsArgs = '?manifest=' + encodeURIComponent(path)\n    }\n    this.manifestUrl = path\n  }\n\n  private async getManifestFromCache() {\n    const res = await CacheManager.findCache(this.manifestUrl)\n    if (!res) {\n      return\n    }\n    const buf = await res.arrayBuffer()\n    const bin = new Uint8Array(buf)\n\n    // 使用公钥校验缓存配置（缓存可被恶意脚本篡改）\n    if (!await KeyManager.verify(bin)) {\n      return\n    }\n    const txt = bytesToUtf8(bin)\n    const manifest = new Manifest()\n    await manifest.parse(txt)\n    return manifest\n  }\n\n  public async init() {\n    const manifest = await this.getManifestFromCache()\n    if (manifest) {\n      // 先使用本地缓存的配置\n      this.onAvailable(manifest)\n    }\n    await this.update()\n  }\n\n  public async update() {\n    if (this.updating) {\n      return true\n    }\n    const now = Date.now()\n    if (now - this.lastTime < UpdaterConf.MIN_INTERVAL) {\n      return true\n    }\n    this.lastTime = now\n    this.updating = true\n    try {\n      return await this.updateUnsafe()\n    } catch (err) {\n      console.error('[FreeCDN/Updater] update err:', err)\n      return false\n    } finally {\n      this.updating = false\n    }\n  }\n\n  private async updateUnsafe() {\n    // from current site\n    const data = await this.fetchManifest(this.manifestUrl)\n    if (data) {\n      await this.applyManifest(data)\n      return true\n    }\n    console.warn('[FreeCDN/Updater] failed to fetch 1st manifest:', this.manifestUrl)\n\n    if (this.backupUrls.length === 0) {\n      console.warn('[FreeCDN/Updater] no backup url')\n      return false\n    }\n\n    // from backup sites\n    for (const url of this.backupUrls) {\n      const data = await this.fetchManifest(url)\n      if (!data) {\n        console.warn('[FreeCDN/Updater] failed to fetch 3rd manifest:', url)\n        continue\n      }\n      if (!await KeyManager.verify(data)) {\n        console.warn('[FreeCDN/Updater] failed to verify 3rd manifest:', url)\n        continue\n      }\n      await this.applyManifest(data)\n      return true\n    }\n    console.warn('[FreeCDN/Updater] failed to reload')\n    return false\n  }\n\n  private async fetchManifest(url: string) {\n    const ctl = new AbortController()\n    const tid = setTimeout(() => {\n      ctl.abort()\n    }, UpdaterConf.FETCH_TIMEOUT)\n\n    const req = new Request(url, {\n      // https://developer.mozilla.org/en-US/docs/Web/API/Request/cache\n      cache: 'no-cache',\n      signal: ctl.signal,\n    })\n    try {\n      const res = await Network.fetch(req)\n      const bin = await res.arrayBuffer()\n      return new Uint8Array(bin)\n    } catch {\n    } finally {\n      clearTimeout(tid)\n    }\n  }\n\n  private async applyManifest(bytes: Uint8Array) {\n    const hash = await sha256(bytes)\n    if (isArrayEqual(this.manifestHash, hash)) {\n      return\n    }\n    this.manifestHash = hash\n\n    // 缓存最新的清单内容\n    const res = new Response(bytes)\n    res.headers.set('content-length', bytes.length + '')\n    CacheManager.addCache(this.manifestUrl, res)\n\n    const manifest = new Manifest()\n    const txt = bytesToUtf8(bytes)\n\n    await manifest.parse(txt)\n    this.onAvailable(manifest)\n  }\n\n  public applyConfs(params: params_t) {\n    this.backupUrls = this.parseBackupParam(params)\n\n    const interval = this.parseIntervalParam(params)\n    this.setPollingInterval(interval)\n\n    const svcUrls = this.parseServicesParam(params)\n    if (this.setSvcTimer > 0) {\n      clearTimeout(this.setSvcTimer)\n    }\n    // 延时开启，减少对业务的性能影响\n    this.setSvcTimer = setTimeout(() => {\n      this.setSvcTimer = 0\n      this.setServices(svcUrls)\n    }, UpdaterConf.SET_SVC_DELAY)\n  }\n\n  private parseBackupParam(params: params_t) {\n    const str = params.get('backup') || ''\n    return splitList(str)\n  }\n\n  private parseIntervalParam(params: params_t) {\n    const str = params.get('interval')\n    if (str) {\n      const num = parseTime(str)\n      if (!isNaN(num)) {\n        return num\n      }\n      console.warn('[FreeCDN/Updater] invalid interval:', str)\n    }\n    return UpdaterConf.DEFAULT_INTERVAL\n  }\n\n  private parseServicesParam(params: params_t) {\n    const str = params.get('services') || ''\n    return splitList(str)\n  }\n\n  private setPollingInterval(interval: number) {\n    if (this.pollingInterval === interval) {\n      return\n    }\n    this.pollingInterval === interval\n\n    if (this.pollingTimer) {\n      clearInterval(this.pollingTimer)\n    }\n    if (interval > 0) {\n      this.pollingTimer = setInterval(() => {\n        this.update()\n      }, interval)\n    }\n  }\n\n  private setServices(urls: string[]) {\n    for (const [url, ws] of this.urlWsMap) {\n      if (!urls.includes(url)) {\n        ws.onclose = null\n        ws.close()\n        this.urlWsMap.delete(url)\n      }\n    }\n    for (const url of urls) {\n      if (!this.urlWsMap.has(url)) {\n        this.createSvc(url)\n      }\n    }\n  }\n\n  private createSvc(url: string) {\n    const ws = new WebSocket(url + this.wsArgs)\n    ws.binaryType = 'arraybuffer'\n    ws.onmessage = (e) => {\n      const hashBin = new Uint8Array(e.data)\n      if (isArrayEqual(this.manifestHash, hashBin)) {\n        return\n      }\n      this.update()\n    }\n    ws.onclose = () => {\n      this.urlWsMap.delete(url)\n\n      setTimeout(() => {\n        this.createSvc(url)\n      }, UpdaterConf.WS_RETRY_DELAY)\n    }\n    this.urlWsMap.set(url, ws)\n  }\n}","///<reference path=\"global.ts\"/>\n///<reference path=\"param-base.ts\"/>\n///<reference path=\"key-manager.ts\"/>\n///<reference path=\"manifest.ts\"/>\n///<reference path=\"url-conf.ts\"/>\n///<reference path=\"url-loader.ts\"/>\n///<reference path=\"file-conf.ts\"/>\n///<reference path=\"file-loader.ts\"/>\n///<reference path=\"updater.ts\"/>\n\n\nclass FreeCDN {\n  public enableCacheStorage = true\n  public manifest: Manifest | undefined\n\n  private readonly updater: Updater | undefined\n  private weightConf = new Map<string, number>()\n  private inited = false\n\n\n  public constructor(manifestUrl?: string) {\n    if (!manifestUrl) {\n      return\n    }\n    const updater = new Updater(manifestUrl, manifest => {\n      this.manifest = manifest\n\n      const updateConf = manifest.getParams('@update') || EMPTY_PARAMS\n      updater.applyConfs(updateConf)\n\n      // 权重参数\n      this.weightConf = Network.parseWeightConf(manifest)\n    })\n\n    this.updater = updater\n  }\n\n  public async fetch(input: RequestInfo, init?: RequestInit) {\n    const req = (input instanceof Request && !init)\n      ? input\n      : new Request(input, init)\n\n    if (!/^https?:/.test(req.url)) {\n      return NATIVE_FETCH(req)\n    }\n\n    const {manifest} = this\n    if (!manifest) {\n      return Network.fetch(req)\n    }\n\n    let fileConf: FileConf | undefined\n    let suffix = ''\n\n    FIND: for (;;) {\n      const urlObj = new URL(req.url)\n\n      // 同源 URL 使用相对路径，不同源使用完整路径（和清单中格式保持一致）\n      const prefix = urlObj.origin === MY_ORIGIN ? '' : urlObj.origin\n\n      // 带参数的 URL 尝试完整匹配\n      if (urlObj.search) {\n        fileConf = manifest.get(prefix + urlObj.pathname + urlObj.search)\n        if (fileConf) {\n          break\n        }\n      }\n\n      // 合并路径中连续的 `/`\n      const path = urlObj.pathname.replace(/\\/{2,}/g, '/')\n      const file = prefix + path\n\n      // 优先使用 avif、webp 版本\n      if (REG_IMG_EXTS.test(file) && req.mode !== 'cors' && !req.integrity) {\n        const accept = req.headers.get('accept') || ''\n        if (accept.includes('image/avif')) {\n          fileConf = manifest.get(file + '.avif')\n          if (fileConf) {\n            break\n          }\n        }\n        if (accept.includes('image/webp')) {\n          fileConf = manifest.get(file + '.webp')\n          if (fileConf) {\n            break\n          }\n        }\n      }\n\n      fileConf = manifest.get(file)\n      if (fileConf) {\n        break\n      }\n      if (file.endsWith('/')) {\n        fileConf = manifest.get(file + 'index.html')\n        if (fileConf) {\n          break\n        }\n      }\n      // 重定向到 `/` 结尾的路径\n      if (manifest.has(file + '/index.html')) {\n        return Response.redirect(file + '/')\n      }\n\n      // 目录匹配\n      // 尾部保存到 suffix 变量。例如访问 /path/to/file?a=1\n      // 清单若存在 /path/ 文件，suffix 则为 `to/file?a=1`\n\n      // 删除末尾的文件名。保持 `/` 结尾\n      let dir = path.replace(/[^/]*$/, '')\n\n      for (;;) {\n        fileConf = manifest.get(prefix + dir)\n        if (fileConf) {\n          suffix = path.substring(dir.length) + urlObj.search\n          break FIND\n        }\n        if (dir === '/') {\n          break\n        }\n        // 删除末尾的目录名。保持 `/` 结尾\n        dir = dir.replace(/[^/]+\\/$/, '')\n      }\n\n      // 清单中无匹配，直接转发\n      return Network.fetch(req)\n    }\n\n    fileConf.parse()\n\n    let fileHash = ''\n    const hashParam = fileConf.params.get('hash')\n    if (hashParam && hashParam.length === LEN.SHA256_B64) {\n      fileHash = hashParam\n    }\n\n    const range = req.headers.get('range')\n\n    const cacheable = this.enableCacheStorage && fileHash && !range\n    if (cacheable) {\n      const res = await CacheManager.findHash(fileHash)\n      if (res) {\n        return res\n      }\n    }\n\n    const fileLoader = new FileLoader(fileConf, req, manifest, this.weightConf, range, suffix)\n    const promise = promisex<Response>()\n\n    // 如果文件只有一个 hash 则不用流模式（必须完整下载才能校验 hash）\n    if (fileHash) {\n      fileLoader.onOpen = (args) => {\n        fileLoader.onData = (body) => {\n          const res = new Response(body, args)\n          if (cacheable && body.length < 1024 * 1024 * 5) {\n            const cacheRes = res.clone()\n            // 字段可在控制台列表中显示，方便调试\n            cacheRes.headers.set('content-length', body.length + '')\n            cacheRes.headers.set('x-raw-url', req.url)\n            CacheManager.addHash(fileHash, cacheRes)\n          }\n          promise.resolve(res)\n        }\n      }\n      fileLoader.onError = (err) => {\n        console.warn('[FreeCDN]', err.message, err.urlErrs)\n        promise.reject(err)\n      }\n      fileLoader.onEnd = () => {\n      }\n      fileLoader.open()\n      return promise\n    }\n\n    // 如果文件有多个 hash 或没有 hash，可使用流模式\n    let controller: ReadableStreamDefaultController\n    let paused = false\n\n    const checkPressure = () => {\n      const {desiredSize} = controller\n      if (desiredSize === null) {\n        return\n      }\n      if (desiredSize <= 0) {\n        if (!paused) {\n          fileLoader.pause()\n          paused = true\n        }\n      } else {\n        if (paused) {\n          fileLoader.resume()\n          paused = false\n        }\n      }\n    }\n\n    const stream = new ReadableStream({\n      start(c: typeof controller) {\n        controller = c\n      },\n      pull() {\n        checkPressure()\n      },\n      cancel(reason: any) {\n        console.warn('[FreeCDN] stream cancel:', reason)\n        fileLoader.abort(reason)\n      },\n    })\n\n    fileLoader.onData = (chunk) => {\n      controller.enqueue(chunk)\n      checkPressure()\n    }\n    fileLoader.onEnd = () => {\n      controller.close()\n    }\n    fileLoader.onError = (err) => {\n      controller.error()\n      console.warn('[FreeCDN]', err.message, err.urlErrs)\n      promise.reject(err)\n    }\n    fileLoader.onOpen = (args) => {\n      const res = new Response(stream, args)\n      promise.resolve(res)\n    }\n    fileLoader.open()\n    return promise\n  }\n\n  public async fetchText(url: string) {\n    const res = await this.fetch(url)\n    return res.text()\n  }\n\n  public async fetchBin(url: string) {\n    const res = await this.fetch(url)\n    const buf = await res.arrayBuffer()\n    return new Uint8Array(buf)\n  }\n\n  public async fetchBlob(url: string) {\n    const res = await this.fetch(url)\n    const buf = await res.arrayBuffer()\n    const type = res.headers.get('content-type') || ''\n    return new Blob([buf], {type})\n  }\n\n  public async update() {\n    if (this.updater) {\n      return this.updater.update()\n    }\n    return false\n  }\n\n  public async setPublicKey(keyB64: string) {\n    if (keyB64.length !== LEN.PUBKEY_B64) {\n      keyB64 = `MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE${keyB64}==`\n    }\n    await KeyManager.set(keyB64)\n  }\n\n  public async init() {\n    console.assert(!this.inited)\n    this.inited = true\n\n    await globalInit()\n\n    if (this.updater) {\n      await this.updater.init()\n    }\n  }\n}","//\n// Promise Utils\n//\ntype may_async<T> = T | Promise<T>\n\ntype resolve_t<T> = (value: may_async<T>) => void\ntype reject_t = (reason?: any) => void\n\n\ninterface PromiseX<T = void> extends Promise<T> {\n  readonly resolve: resolve_t<T>\n  readonly reject: reject_t\n}\n\n// non-callback style Promise\nfunction promisex<T = void>() : PromiseX<T> {\n  let resolve: resolve_t<T>\n  let reject: reject_t\n\n  const p = new Promise((a, b) => {\n    resolve = a\n    reject = b\n  }) as PromiseX<T>\n\n  // @ts-ignore\n  p.resolve = resolve\n\n  // @ts-ignore\n  p.reject = reject\n\n  return p\n}\n\n// faster than instanceof\nfunction isPromise(obj: any /* except nullable */ | Promise<any>) : obj is Promise<any> {\n  return typeof obj.then === 'function'\n}","///<reference path=\"../../core-lib/src/freecdn.ts\"/>\n///<reference path=\"../../core-lib/src/promisex.ts\"/>\n///<reference path=\"hook.ts\"/>\n\n\ndeclare const Q: any[]\n\n\nnamespace Sw {\n  const GLOBAL: ServiceWorkerGlobalScope = self as any\n\n  const mLoaderJsRes = new Response('/* freecdn is installed */', {\n    headers: {\n      'content-type': 'text/javascript',\n      'cache-control': 'max-age=3600',\n    },\n  })\n\n  let mFreeCDN: FreeCDN\n\n  let mIniting: PromiseX | null\n  let mResUrlMap: WeakMap<Response, string>\n\n\n  // 共享模式（脚本通过业务方的 SW 引入）\n  function sharedModeInit() {\n    Hook.func(GLOBAL, 'fetch', oldFn => sharedModeHandler)\n\n    Hook.func(Cache.prototype, 'add', oldFn => async function(req) {\n      const res = await sharedModeHandler(req)\n      await this.put(req, res)\n    })\n\n    Hook.func(Cache.prototype, 'addAll', oldFn => async function(reqs) {\n      const tasks = reqs.map(req => this.add(req))\n      await Promise.all(tasks)\n    })\n\n    mResUrlMap = new WeakMap()\n\n    // 由于自定义的 Response 对象 url 为空，因此通过 hook 的方式保留原始 url\n    Hook.prop(Response.prototype, 'url',\n      getter => function() {\n        return mResUrlMap.get(this) || getter.call(this)\n      },\n      /* setter */ null\n    )\n\n    Hook.func(Response.prototype, 'clone', oldFn => function() {\n      const res = oldFn.call(this)\n      const url = mResUrlMap.get(this)\n      if (url) {\n        mResUrlMap.set(res, url)\n      }\n      return res\n    })\n  }\n\n  async function sharedModeHandler(input: RequestInfo, init?: RequestInit) {\n    if (mIniting) {\n      // freecdn 仍在初始化中（例如加载清单文件）\n      await mIniting\n    }\n    const req = (input instanceof Request && !init)\n      ? input\n      : new Request(input, init)\n\n    const res = await mFreeCDN.fetch(req)\n    mResUrlMap.set(res, req.url)\n    return res\n  }\n\n  // 独占模式（通过 freecdn-loader.min.js 引入）\n  function loaderModeInit() {\n    type tuple = Parameters<typeof loaderModeHandler>\n\n    // 重写 Q.push，这样 loader-js 可直接传递 event 和 promise\n    Q.push = loaderModeHandler as any\n\n    while (Q.length) {\n      const args = Q.splice(0, 3) as tuple\n      loaderModeHandler(...args)\n    }\n  }\n\n  function loaderModeHandler(\n    e: FetchEvent,\n    resolve: resolve_t<Response>,\n    reject: reject_t,\n  ) {\n    const req = e.request\n\n    // debug\n    if (req.url.endsWith('/freecdn-update')) {\n      mFreeCDN.update().then(result => {\n        const res = new Response('updated. success: ' + result, {\n          headers: {\n            'content-type': 'text/html',\n          },\n        })\n        resolve(res)\n      })\n      return\n    }\n\n    if (req.url === MY_URL) {\n      resolve(mLoaderJsRes.clone())\n      return\n    }\n\n    mFreeCDN.fetch(req).then(resolve, reject)\n  }\n\n  async function main() {\n    mFreeCDN = new FreeCDN('freecdn-manifest.txt')\n\n    const isSharedMode = !!(GLOBAL as any).FREECDN_SHARED_MODE\n\n    let publicKey: string | undefined\n\n    if (isSharedMode) {\n      mFreeCDN.enableCacheStorage = false\n      mIniting = promisex()\n\n      // 在此之前不要使用 await，否则安装 hook 会被推迟，导致初始化时无法触发 hook\n      sharedModeInit()\n      publicKey = (GLOBAL as any).FREECDN_PUBLIC_KEY\n    } else {\n      publicKey = Q.shift()\n    }\n\n    if (publicKey) {\n      await mFreeCDN.setPublicKey(publicKey)\n    }\n    await mFreeCDN.init()\n\n    if (isSharedMode) {\n      mIniting?.resolve()\n      mIniting = null\n    } else {\n      loaderModeInit()\n    }\n\n    console.log('[FreeCDN] service worker inited')\n  }\n  main()\n}","declare const BR_GLUE_HASH: string\ndeclare const BR_WASM_HASH: string\n\nconst enum ParamBrConf {\n  WASM_LOAD_TIMEOUT = 1000 * 20,\n  IN_BUF_LEN = 1024 * 128,\n  OUT_BUF_LEN = 1024 * 512,\n}\n\nclass ParamBr extends ParamBase {\n  private static hasErr = false\n  private static signal: PromiseX | undefined\n  private static asmMod: any\n\n  private static inPtr: number\n  private static outPtr: number\n\n\n  private static async init() {\n    if (this.signal) {\n      return\n    }\n    this.signal = promisex()\n\n    const BR_WASM_PATH = `${INTERNAL_PATH}/br/br.wasm`\n    const BR_GLUE_PATH = `${INTERNAL_PATH}/br/` + (IS_DEBUG ? 'br.js' : 'br.min.js')\n\n    const BR_MANIFEST = IS_DEBUG ? '' : `\n${BR_WASM_PATH}\n\thttps://cdn.jsdelivr.net/npm/freecdn-js@${VER}/dist/br/br.wasm\n\thttps://unpkg.com/freecdn-js@${VER}/dist/br/br.wasm\n\thttps://code.bdstatic.com/npm/freecdn-js@${VER}/dist/br/br.wasm\n\thttps://npm.elemecdn.com/freecdn-js@${VER}/dist/br/br.wasm\n\thash=${BR_WASM_HASH}\n\n${BR_GLUE_PATH}\n\thttps://cdn.jsdelivr.net/npm/freecdn-js@${VER}/dist/br/br.min.js\n\thttps://unpkg.com/freecdn-js@${VER}/dist/br/br.min.js\n\thttps://code.bdstatic.com/npm/freecdn-js@${VER}/dist/br/br.min.js\n\thttps://npm.elemecdn.com/freecdn-js@${VER}/dist/br/br.min.js\n\thash=${BR_GLUE_HASH}\n`\n    const onError = () => {\n      this.hasErr = true\n      this.signal?.resolve()\n    }\n    const timer = setTimeout(onError, ParamBrConf.WASM_LOAD_TIMEOUT)\n\n    const asmMod: any = {\n      locateFile: () => BR_WASM_PATH,\n      onRuntimeInitialized: () => {\n        this.inPtr = asmMod._AllocInBuf(ParamBrConf.IN_BUF_LEN)\n        this.outPtr = asmMod._AllocOutBuf(ParamBrConf.OUT_BUF_LEN)\n\n        clearTimeout(timer)\n        this.signal?.resolve()\n        this.signal = undefined\n      },\n      onAbort: (reason: any) => {\n        console.warn('[FreeCDN/Br] wasm onAbort:', reason)\n        onError()\n      },\n      print: (msg: any) => {\n        console.warn('[FreeCDN/Br] wasm print:', msg)\n      },\n      printErr: (err: any) => {\n        console.warn('[FreeCDN/Br] wasm printErr:', err)\n      },\n    }\n\n    const manifest = new Manifest()\n    await manifest.parse(BR_MANIFEST)\n\n    const cdn = new FreeCDN()\n    cdn.manifest = manifest\n\n    const onFetch: typeof cdn.fetch = async (...args) => {\n      try {\n        return await cdn.fetch(...args)\n      } catch (err) {\n        console.warn('[FreeCDN/Br] failed to load wasm')\n        onError()\n        throw err\n      }\n    }\n    try {\n      const js = await cdn.fetchText(BR_GLUE_PATH)\n      const fn = Function('Module', 'fetch', js)\n      fn(asmMod, onFetch)\n    } catch {\n      console.warn('[FreeCDN/Br] failed to execute glue js')\n      onError()\n      return\n    }\n    this.asmMod = asmMod\n  }\n\n  public static parseConf(conf: string) {\n    if (conf === 'off') {\n      return\n    }\n    if (conf === 'on') {\n      if (!this.asmMod) {\n        this.init()\n      }\n      return []\n    }\n    return 'invalid value'\n  }\n\n\n  private state = 0\n\n  public constructor() {\n    super()\n  }\n\n  public async onData(chunk: Uint8Array) {\n    if (ParamBr.signal) {\n      await this.waitWasm()\n    }\n    return this.process(chunk)\n  }\n\n  public async onEnd(chunk: Uint8Array) {\n    if (ParamBr.signal) {\n      await this.waitWasm()\n    }\n    // ???\n    let buf = EMPTY_BUF\n    if (chunk.length > 0) {\n      buf = this.process(chunk)\n    }\n    this.destory()\n    return buf\n  }\n\n  private async waitWasm() {\n    await ParamBr.signal\n    if (ParamBr.hasErr) {\n      throw new ParamError('failed to load br decoder')\n    }\n  }\n\n  private process(chunk: Uint8Array) {\n    // brotli/c/include/decode.h\n    const enum RET {\n      ERROR = 0,\n      SUCCESS = 1,\n      NEEDS_MORE_INPUT = 2,\n      NEEDS_MORE_OUTPUT = 3\n    }\n    const asmObj = ParamBr.asmMod\n    const HEAPU8 = asmObj.HEAPU8 as Uint8Array\n\n    if (this.state === 0) {\n      this.state = asmObj._Init()\n    }\n\n    const outBufs: Uint8Array[] = []\n\n    for (let p = 0; p < chunk.length; p += ParamBrConf.IN_BUF_LEN) {\n      const inBuf = chunk.subarray(p, p + ParamBrConf.IN_BUF_LEN)\n      HEAPU8.set(inBuf, ParamBr.inPtr)\n\n      let avaiablelIn = inBuf.length\n      let availableOut = 0\n      do {\n        const ret = asmObj._Update(this.state, 0, avaiablelIn)\n\n        if (ret === RET.ERROR) {\n          const err = asmObj._GetErrorCode()\n          this.destory()\n          throw new ParamError('br decode failed. code: ' + err)\n        }\n        avaiablelIn = asmObj._GetAvailableIn()\n        availableOut = asmObj._GetAvailableOut()\n\n        const len = ParamBrConf.OUT_BUF_LEN - availableOut\n        if (len === 0) {\n          continue\n        }\n        // use slice (copy), not subarray (ref)\n        const outBuf = HEAPU8.slice(ParamBr.outPtr, ParamBr.outPtr + len)\n        outBufs.push(outBuf)\n      } while (asmObj._HasMoreOutput(this.state))\n    }\n\n    if (outBufs.length === 1) {\n      return outBufs[0]\n    }\n    return concatBufs(outBufs)\n  }\n\n  private destory() {\n    ParamBr.asmMod._Destroy(this.state)\n  }\n}\n","type bundle_file_map_t = Map<string /* path */, Response>\n\nclass ParamBundle extends ParamBase {\n\n  public static parseConf(conf: string) {\n    if (conf === 'off') {\n      return\n    }\n    if (!/^https?:|^\\//.test(conf)) {\n      return 'invalid url'\n    }\n    return [conf]\n  }\n\n  private static cacheMap = new Map<string /* pkgUrl */,\n    may_async<bundle_file_map_t>\n  >()\n\n\n  public constructor(\n    private readonly packUrl: string\n  ) {\n    super()\n  }\n\n  public async onRequest(reqArgs: RequestArgs, fileLoader: FileLoader) {\n    let fileMap: bundle_file_map_t\n\n    const r = ParamBundle.cacheMap.get(this.packUrl)\n    if (r === undefined) {\n      const map = await this.loadPkg(fileLoader.manifest)\n      if (!map) {\n        return\n      }\n      fileMap = map\n    } else if (isPromise(r)) {\n      fileMap = await r\n    } else {\n      fileMap = r\n    }\n\n    const path = fileLoader.suffix\n    const res = fileMap.get(path)\n    if (res) {\n      return res.clone()\n    }\n    if (path === '') {\n      const res = fileMap.get('index.html')\n      if (res) {\n        fileLoader.suffix = 'index.html'\n        return res.clone()\n      }\n    }\n    if (path.endsWith('/')) {\n      const res = fileMap.get(path + 'index.html')\n      if (res) {\n        fileLoader.suffix = path + 'index.html'\n        return res.clone()\n      }\n    }\n    if (fileMap.has(path + '/index.html')) {\n      fileLoader.suffix = path + '/index.html'\n      const redir = fileLoader.fileConf.name + path + '/'\n      return new Response(`<meta http-equiv=\"Refresh\" content=\"0;url=${redir}\">`)\n    }\n  }\n\n  private async loadPkg(manifest: Manifest) {\n    type conf_t = {\n      [file: string]: {\n        [headerName: string] : string | number\n      }\n    }\n    const fileMap: bundle_file_map_t = new Map()\n    const signal = promisex<bundle_file_map_t>()\n\n    ParamBundle.cacheMap.set(this.packUrl, signal)\n\n    // TODO: support stream\n\n    let pkgBin: Uint8Array\n    try {\n      if (manifest.has(this.packUrl)) {\n        const cdn = new FreeCDN()\n        cdn.manifest = manifest\n        pkgBin = await cdn.fetchBin(this.packUrl)\n      } else {\n        // 资源包不在清单中，或不是普通文件（例如是目录），则直接加载，防止循环依赖\n        const res = await NATIVE_FETCH(this.packUrl)\n        const buf = await res.arrayBuffer()\n        pkgBin = new Uint8Array(buf)\n      }\n    } catch {\n      this.warn('failed to load')\n      return\n    }\n\n    const pos = pkgBin.indexOf(13 /* '\\r' */)\n    if (pos === -1) {\n      this.warn('missing header')\n      return\n    }\n    const confBin = pkgBin.subarray(0, pos)\n    const confMap: conf_t = parseJson(bytesToUtf8(confBin))\n    if (!confMap) {\n      this.warn('invalid header')\n      return\n    }\n\n    const bodyBin = pkgBin.subarray(pos + 1)\n    let offset = 0\n\n    for (const [file, conf] of Object.entries(confMap)) {\n      const len = +conf['content-length']\n      if (!(len >= 0)) {\n        this.warn('invalid content-length')\n        return\n      }\n      if (offset + len > bodyBin.length) {\n        this.warn('invalid offset')\n        return\n      }\n      const fileBuf = bodyBin.subarray(offset, offset + len)\n      const res = new Response(fileBuf, {\n        headers: confMap[file] as HeadersInit\n      })\n      fileMap.set(file, res)\n\n      offset += len\n    }\n\n    ParamBundle.cacheMap.set(this.packUrl, fileMap)\n    signal.resolve(fileMap)\n    return fileMap\n  }\n\n  private warn(msg: string) {\n    console.warn('[FreeCDN/Bundle]', msg, this.packUrl)\n  }\n}","const REG_TEXT_MIME = /^text\\/|^application\\/(?:javascript|json)|\\+xml$/\n\n\nclass ParamCharset extends ParamBase {\n  public static reuse = true\n\n  public static parseConf(conf: string) {\n    if (conf !== 'off') {\n      return [conf]\n    }\n  }\n\n\n  public constructor(\n    private readonly charset: string\n  ) {\n    super()\n  }\n\n  public onResponse(resArgs: ResponseArgs) {\n    const type = resArgs.headers.get('content-type') || ''\n    if (REG_TEXT_MIME.test(type)) {\n      resArgs.headers.set('content-type', type + '; charset=' + this.charset)\n    }\n  }\n}\n","class ParamData extends ParamBase {\n  public static reuse = true\n\n  public static parseConf(conf: string) {\n    const bytes = parseStrOrB64(conf)\n    if (!bytes) {\n      return 'invalid format'\n    }\n    return [bytes]\n  }\n\n\n  public constructor(\n    private readonly bytes: Uint8Array\n  ) {\n    super()\n  }\n\n  public onRequest() {\n    return new Response(this.bytes)\n  }\n}\n","class ParamExpires extends ParamBase {\n  public static reuse = true\n\n  public static parseConf(conf: string) {\n    const time = parseTime(conf)\n    if (isNaN(time)) {\n      return 'invalid time format'\n    }\n    const seconds = time / 1000 | 0\n    return [seconds]\n  }\n\n\n  public constructor(\n    private readonly seconds: number\n  ) {\n    super()\n  }\n\n  public onResponse(resArgs: ResponseArgs, fileLoader: FileLoader, rawRes: Response) {\n    // 过期时间不小于实际值，防止经常变化的资源无法及时更新\n    const rawMaxAge = (rawRes as any)._maxage\n    const maxAge = rawMaxAge < this.seconds ? rawMaxAge : this.seconds\n\n    resArgs.headers.append('cache-control', 'max-age=' + maxAge)\n  }\n}\n","const enum ParamHashConf {\n  MAX_QUEUE_LEN = 64 * 1024 * 1024\n}\n\nclass ParamHash extends ParamBase {\n\n  public static parseConf(conf: string) {\n    // conf format:\n    // [blksize;]hash1,hash2,...\n    let blkLen = 1e9\n    let hashes = conf\n\n    const pos = conf.indexOf(';')\n    if (pos > 0) {\n      const blkLenStr = conf.substring(0, pos)\n      hashes = conf.substring(pos + 1)\n      blkLen = parseByteUnit(blkLenStr)\n      if (isNaN(blkLen)) {\n        return 'invalid block length'\n      }\n    }\n    const hashBins: Uint8Array[] = []\n    const hashB64s = hashes.split(',')\n\n    // 倒序存储，之后 pop 取出\n    for (let i = hashB64s.length - 1; i !== -1; i--) {\n      const bin = base64Decode(hashB64s[i])\n      if (!bin || bin.length !== LEN.SHA256_BIN) {\n        return 'invalid block hash'\n      }\n      hashBins.push(bin)\n    }\n    return [blkLen, hashBins]\n  }\n\n\n  private readonly queueArr: Uint8Array[] = []\n  private queueLen = 0\n  private hasData = false\n\n  public constructor(\n    private readonly blkLen: number,\n    private readonly hashBins: Uint8Array[]\n  ) {\n    super()\n  }\n\n  public async onData(chunk: Uint8Array) {\n    this.hasData = true\n    this.queueLen += chunk.length\n\n    if (this.queueLen > ParamHashConf.MAX_QUEUE_LEN) {\n      throw new ParamError('max queue length exceeded')\n    }\n\n    if (this.queueLen >= this.blkLen) {\n      // let queueLen be integer multiple of blkLen\n      const remain = this.queueLen % this.blkLen\n      if (remain) {\n        const head = chunk.subarray(0, -remain)\n        this.queueArr.push(head)\n        this.queueLen -= remain\n      } else {\n        this.queueArr.push(chunk)\n      }\n      const blks = await this.pull()\n      this.queueLen = remain\n\n      if (remain) {\n        const tail = chunk.subarray(-remain)\n        this.queueArr.push(tail)\n      }\n      return blks\n    }\n\n    this.queueArr.push(chunk)\n    return EMPTY_BUF\n  }\n\n  public async onEnd(chunk: Uint8Array) {\n    if (chunk.length > 0) {\n      this.queueLen += chunk.length\n      this.queueArr.push(chunk)\n    }\n    if (this.queueLen === 0) {\n      if (!this.hasData) {\n        await this.verify(EMPTY_BUF)\n      }\n      return EMPTY_BUF\n    }\n    return this.pull()\n  }\n\n  private async pull() {\n    const blks = concatBufs(this.queueArr, this.queueLen)\n    this.queueArr.length = 0\n\n    for (let p = 0; p < blks.length; p += this.blkLen) {\n      const blk = blks.subarray(p, p + this.blkLen)\n      await this.verify(blk)\n    }\n    return blks\n  }\n\n  private async verify(blk: Uint8Array) {\n    const hashExp = this.hashBins.pop()\n    if (!hashExp) {\n      throw new ParamError('missing hash')\n    }\n    const hashGot = await sha256(blk)\n\n    if (!isArrayEqual(hashExp, hashGot)) {\n      const exp = base64Encode(hashExp)\n      const got = base64Encode(hashGot)\n      throw new ParamError(`hash incorrect. expected: ${exp}, but got: ${got}`)\n    }\n  }\n}\n","class ParamHeaders extends ParamBase {\n  public static reuse = true\n\n  public static parseConf(conf: string) {\n    return ParamReqHeaders.parse(conf)\n  }\n\n\n  public constructor(\n    private readonly headers: readonly [string, string][],\n    private readonly preserveAll: boolean\n  ) {\n    super()\n  }\n\n  public onResponse(resArgs: ResponseArgs, fileLoader: FileLoader, rawRes: Response) {\n    if (this.preserveAll) {\n      for (const [k, v] of rawRes.headers) {\n        resArgs.headers.set(k, v)\n      }\n      for (const [k, v] of this.headers) {\n        resArgs.headers.set(k, v)\n      }\n      return\n    }\n\n    for (const [k, v] of this.headers) {\n      if (v === '') {\n        // preserve\n        const rawVal = rawRes.headers.get(k)\n        if (rawVal !== null) {\n          resArgs.headers.set(k, rawVal)\n        }\n      } else {\n        // add\n        resArgs.headers.set(k, v)\n      }\n    }\n  }\n}\n","class ParamOpenTimeout extends ParamBase {\n\n  public static parseConf(conf: string) {\n    const time = parseTime(conf)\n    if (isNaN(time)) {\n      return 'invalid time format'\n    }\n    return [time]\n  }\n\n\n  private tid = 0\n\n\n  public constructor(\n    private readonly time: number,\n  ) {\n    super()\n  }\n\n  public onRequest(reqArgs: RequestArgs, fileLoader: FileLoader) {\n    this.tid = setTimeout(() => {\n      const delay = Math.max(this.time, 5000)\n      fileLoader.loadNextUrl(delay)\n    }, this.time)\n  }\n\n  public onResponse() {\n    this.stopTimer()\n  }\n\n  public onError() {\n    this.stopTimer()\n  }\n\n  public onAbort() {\n    this.stopTimer()\n  }\n\n  private stopTimer() {\n    if (this.tid > 0) {\n      clearTimeout(this.tid)\n      this.tid = 0\n    }\n  }\n}\n","class ParamPos extends ParamBase {\n\n  public static parseConf(conf: string) {\n    const begin = parseByteUnit(conf)\n    if (isNaN(begin)) {\n      return 'invalid byte format'\n    }\n    if (begin === 0) {\n      return\n    }\n    return [begin]\n  }\n\n\n  private remain: number\n\n\n  public constructor(pos: number) {\n    super()\n    this.remain = pos\n  }\n\n  public onData(chunk: Uint8Array) {\n    if (this.remain <= 0) {\n      return chunk\n    }\n    const remain = (this.remain -= chunk.length)\n    if (remain >= 0) {\n      return EMPTY_BUF\n    }\n    // if remain < 0, return last -remain bytes\n    return chunk.subarray(remain)\n  }\n\n  public onEnd(chunk: Uint8Array) {\n    return this.onData(chunk)\n  }\n}","class ParamPrefix extends ParamBase {\n\n  public static parseConf(conf: string) {\n    const bytes = parseStrOrB64(conf)\n    if (!bytes) {\n      return 'invalid format'\n    }\n    return [bytes]\n  }\n\n\n  private done = false\n\n  public constructor(\n    private readonly bytes: Uint8Array\n  ) {\n    super()\n  }\n\n  public onData(chunk: Uint8Array) {\n    if (this.done) {\n      return chunk\n    }\n    this.done = true\n    return concatBufs([this.bytes, chunk])\n  }\n\n  public onEnd(chunk: Uint8Array) {\n    // for empty file\n    return this.onData(chunk)\n  }\n}\n","class ParamRecvTimeout extends ParamBase {\n\n  public static parseConf(conf: string) {\n    const [n, t] = conf.split('/')\n    const bytes = parseByteUnit(n)\n    const time = parseTime(t)\n    if (isNaN(bytes)) {\n      return 'invalid byte format'\n    }\n    if (isNaN(time)) {\n      return 'invalid time format'\n    }\n    return [bytes, time]\n  }\n\n\n  private fileLoader!: FileLoader\n  private tid = 0\n  private sum = 0\n\n  public constructor(\n    private readonly bytes: number,\n    private readonly time: number,\n  ) {\n    super()\n  }\n\n  public onRequest(reqArgs: RequestArgs, fileLoader: FileLoader) {\n    this.fileLoader = fileLoader\n  }\n\n  public onResponse() {\n    this.tid = setInterval(() => {\n      if (this.sum <= this.bytes) {\n        this.stopTimer()\n        this.fileLoader.loadNextUrl()\n      }\n      this.sum = 0\n    }, this.time)\n  }\n\n  public onData(chunk: Uint8Array) {\n    this.sum += chunk.length\n    return chunk\n  }\n\n  public onEnd(chunk: Uint8Array) {\n    this.stopTimer()\n    return chunk\n  }\n\n  public onError() {\n    this.stopTimer()\n  }\n\n  public onAbort() {\n    this.stopTimer()\n  }\n\n  private stopTimer() {\n    if (this.tid > 0) {\n      clearInterval(this.tid)\n      this.tid = 0\n    }\n  }\n}\n","const REG_REFFERER_POLICY = /^(?:no-referrer|unsafe-url|origin|same-origin|strict-origin|no-referrer-when-downgrade|origin-when-cross-origin|strict-origin-when-cross-origin)$/\n\n\nclass ParamReferrerPolicy extends ParamBase {\n  public static reuse = true\n\n  public static parseConf(conf: string) {\n    if (conf === 'raw') {\n      return ['']\n    }\n    if (!REG_REFFERER_POLICY.test(conf)) {\n      return 'invalid value'\n    }\n    return [conf]\n  }\n\n\n  public constructor(\n    private readonly policy: ReferrerPolicy\n  ) {\n    super()\n  }\n\n  public onRequest(reqArgs: RequestArgs, fileLoader: FileLoader) {\n    reqArgs.referrerPolicy = this.policy || fileLoader.rawReq.referrerPolicy\n  }\n}\n","class ParamReqHeaders extends ParamBase {\n  public static reuse = true\n\n  public static parse(conf: string) {\n    const headers: [string, string][] = []\n    let preserveAll = false\n\n    // {\"header-to-preserve\": \"\", \"header-to-add\": \"val\"}\n    const map = parseJson(conf)\n    if (typeof map !== 'object') {\n      return 'invalid format'\n    }\n    for (const [k, v] of Object.entries(map)) {\n      if (k === '*') {\n        preserveAll = true\n      } else {\n        headers.push([k, v + ''])\n      }\n    }\n    return [headers, preserveAll]\n  }\n\n  public static parseConf(conf: string) {\n    return this.parse(conf)\n  }\n\n\n  public constructor(\n    private readonly headers: readonly [string, string][],\n    private readonly preserveAll: boolean\n  ) {\n    super()\n  }\n\n  public onRequest(reqArgs: RequestArgs, fileLoader: FileLoader) {\n    const {rawReq} = fileLoader\n\n    if (this.preserveAll) {\n      for (const [k, v] of rawReq.headers) {\n        reqArgs.headers.set(k, v)\n      }\n      for (const [k, v] of this.headers) {\n        reqArgs.headers.set(k, v)\n      }\n      return\n    }\n\n    for (const [k, v] of this.headers) {\n      if (k === 'referer') {\n        reqArgs.referrer = v || rawReq.referrer\n        continue\n      }\n      if (v === '') {\n        // preserve\n        const rawVal = rawReq.headers.get(k)\n        if (rawVal !== null) {\n          reqArgs.headers.set(k, rawVal)\n        }\n      } else {\n        // add\n        reqArgs.headers.set(k, v)\n      }\n    }\n  }\n}\n","class ParamSize extends ParamBase {\n\n  public static parseConf(conf: string) {\n    const size = parseByteUnit(conf)\n    if (isNaN(size)) {\n      return 'invalid byte format'\n    }\n    return [size]\n  }\n\n\n  private remain: number\n\n  public constructor(size: number) {\n    super()\n    this.remain = size\n  }\n\n  public onData(chunk: Uint8Array) {\n    if (this.remain <= 0) {\n      return EMPTY_BUF\n    }\n    const remain = (this.remain -= chunk.length)\n    if (remain >= 0) {\n      return chunk\n    }\n    // remain < 0, return [0, END + remain)\n    return chunk.subarray(0, remain)\n  }\n\n  public onEnd(chunk: Uint8Array) {\n    return this.onData(chunk)\n  }\n}\n","const enum ParamStreamConf {\n  MAX_QUEUE_LEN = 64 * 1024 * 1024\n}\n\nclass ParamStream extends ParamBase {\n\n  public static parseConf(conf: string) {\n    if (conf === 'on') {\n      // default\n      return\n    }\n    if (conf === 'off') {\n      return []\n    }\n    return 'invalid value'\n  }\n\n\n  private readonly queueArr: Uint8Array[] = []\n  private queueLen = 0\n\n  public constructor() {\n    super()\n  }\n\n  public onData(chunk: Uint8Array) {\n    this.queueLen += chunk.length\n    if (this.queueLen > ParamStreamConf.MAX_QUEUE_LEN) {\n      throw new ParamError('max queue length exceeded')\n    }\n    this.queueArr.push(chunk)\n    return EMPTY_BUF\n  }\n\n  public onEnd(chunk: Uint8Array) {\n    if (chunk.length > 0) {\n      // unlikely\n      this.onData(chunk)\n    }\n    return concatBufs(this.queueArr, this.queueLen)\n  }\n}\n","class ParamSuffix extends ParamBase {\n  public static reuse = true\n\n  public static parseConf(conf: string) {\n    const bytes = parseStrOrB64(conf)\n    if (!bytes) {\n      return 'invalid format'\n    }\n    return [bytes]\n  }\n\n\n  public constructor(\n    private readonly bytes: Uint8Array\n  ) {\n    super()\n  }\n\n  public onEnd(chunk: Uint8Array) {\n    if (chunk.length === 0) {\n      return this.bytes\n    }\n    return concatBufs([chunk, this.bytes])\n  }\n}\n","class ParamValidStatus extends ParamBase {\n  public static reuse = true\n\n  public static parseConf(conf: string) {\n    if (conf === '*') {\n      return\n    }\n    const codes = conf.split(',').map(Number)\n    return [codes]\n  }\n\n\n  public constructor(\n    private readonly codes: number[]\n  ) {\n    super()\n  }\n\n  public onResponse(resArgs: ResponseArgs, fileLoader: FileLoader, rawRes: Response) {\n    if (!this.codes.includes(rawRes.status)) {\n      throw new ParamError('invalid http status: ' + rawRes.status)\n    }\n  }\n}\n","class ParamXor extends ParamBase {\n  public static reuse = true\n\n  public static parseConf(conf: string) {\n    const key = +conf | 0\n    if (key < 0 || key > 255) {\n      return 'invalid value'\n    }\n    return [key]\n  }\n\n\n  public constructor(\n    private readonly key: number\n  ) {\n    super()\n  }\n\n  public onData(chunk: Uint8Array) {\n    // TODO: u32 optimize\n    for (let i = 0; i < chunk.length; i++) {\n      chunk[i] ^= this.key\n    }\n    return chunk\n  }\n\n  public onEnd(chunk: Uint8Array) {\n    return this.onData(chunk)\n  }\n}\n","namespace CacheManager {\n  let mCache: Cache\n\n  // TODO: LRU\n\n  export async function init() {\n    if (!mCache) {\n      mCache = await caches.open('.freecdn')\n    }\n  }\n\n  export async function findHash(hash: string) {\n    const res = await findCache('/' + hash)\n    if (!res) {\n      return\n    }\n    const buf = await res.clone().arrayBuffer()\n    const bin = new Uint8Array(buf)\n    const hashGot = await sha256(bin)\n    const hashExp = base64Decode(hash)\n    if (!hashExp) {\n      return\n    }\n    if (!isArrayEqual(hashGot, hashExp)) {\n      console.warn('[FreeCDN/CacheManager] bad cache:', hash)\n      delCache('/' + hash)\n      return\n    }\n    return res\n  }\n\n  export async function addHash(hash: string, res: Response) {\n    await addCache('/' + hash, res)\n  }\n\n  export function findCache(reqInfo: RequestInfo) {\n    return mCache.match(reqInfo)\n  }\n\n  export async function addCache(reqInfo: RequestInfo, res: Response) {\n    try {\n      await mCache.put(reqInfo, res)\n    } catch {\n    }\n  }\n\n  export function delCache(reqInfo: RequestInfo) {\n    return mCache.delete(reqInfo)\n  }\n}\n","namespace Network {\n  const enum Conf {\n    DEFAULT_MAX_AGE = 300,\n  }\n\n  const mDatabase = new Database('.freecdn')\n\n  interface UrlInfo {\n    url: string,\n    status: number,\n    expire: number,\n  }\n  const mUrlInfoMap = new Map<string, UrlInfo>()\n\n  function addUrlInfo(url: string, status: number, expire: number) {\n    if (mUrlInfoMap.has(url)) {\n      return\n    }\n    const info: UrlInfo = {url, status, expire}\n    mUrlInfoMap.set(url, info)\n\n    mDatabase.put('cache', info)\n  }\n\n\n  class HostInfo {\n    public lastDoneTime = 0\n    public lastErrTime = 0\n\n    public pending = 0\n    // public protocol = 1\n\n    public errNum = 0\n    public reqNum = 0\n    public reqTimeAvg = -1\n    public reqTimeSum = 0\n    // public speedAvg = 0\n    // public speedSum = 0\n  }\n  const mHostInfoMap = new Map<string, HostInfo>()\n\n  function getHostInfo(host: string) {\n    let info = mHostInfoMap.get(host)\n    if (!info) {\n      info = new HostInfo()\n      mHostInfoMap.set(host, info)\n    }\n    return info\n  }\n\n  function getHostWeight(hostInfo: HostInfo, now: number) {\n    // TODO: ...\n    if (hostInfo.reqTimeAvg !== -1) {\n      const delayScore = 100 - hostInfo.reqTimeAvg * 0.2\n      return Math.max(delayScore, 10)\n    }\n    return 50\n  }\n\n  export function getUrlWeight(url: string, now: number, hostWeightMap: Map<string, number>) {\n    const urlInfo = mUrlInfoMap.get(url)\n    if (urlInfo && urlInfo.expire < now) {\n      if (urlInfo.status !== 200) {\n        return -2\n      }\n      // 该 URL 之前加载过\n      // expire 值越大，已过期的概率越小，权重越高\n      return 100 + urlInfo.expire\n    }\n\n    // 当前站点默认权重 -1，低于免费站点，减少流量成本\n    if (url[0] === '/') {\n      return hostWeightMap.get(MY_HOST) ?? -1\n    }\n    const host = getHostFromUrl(url)\n    const hostInfo = mHostInfoMap.get(host)\n    if (!hostInfo) {\n      return hostWeightMap.get(host) ?? 50\n    }\n    return getHostWeight(hostInfo, now)\n  }\n\n  export async function fetch(req: Request) {\n    const host = getHostFromUrl(req.url)\n    const hostInfo = getHostInfo(host)\n    hostInfo.pending++\n\n    const t0 = getTimeSec()\n\n    let res: Response\n    try {\n      res = await NATIVE_FETCH(req)\n    } catch (err: any) {\n      parseFetchError(err, req, hostInfo, t0)\n      throw err\n    } finally {\n      hostInfo.pending--\n    }\n\n    const maxAge = parseMaxAge(res.headers, t0)\n\n    switch (res.status) {\n    case 200:\n      if (req.cache !== 'no-store') {\n        if (maxAge > 60) {\n          addUrlInfo(res.url, 200, t0 + maxAge)\n        }\n      }\n      break\n    case 404:\n      addUrlInfo(res.url, 404, t0 + maxAge)\n      break\n    }\n\n    // 过期时间会在 expires 参数中会用到，避免重复分析\n    (res as any)._maxage = maxAge\n\n    return res\n  }\n\n  const REG_NET_ERR = /^Failed to fetch|^NetworkError|^Could not connect/\n\n  function parseFetchError(err: Error, req: Request, hostInfo: HostInfo, t0: number) {\n    if (!navigator.onLine) {\n      return\n    }\n    if (!REG_NET_ERR.test(err.message)) {\n      return\n    }\n    if (req.cache === 'only-if-cached') {\n      return\n    }\n    hostInfo.errNum++\n    hostInfo.lastErrTime = t0\n  }\n\n  function parseMaxAge(headers: Headers, t0: number) {\n    const cacheControl = headers.get('cache-control')\n    if (cacheControl !== null) {\n      if (cacheControl.includes('no-cache')) {\n        return 0\n      }\n      const m = cacheControl.match(/max-age=\"?(\\d+)\"?/)\n      if (m) {\n        return +m[1]\n      }\n    }\n    const expires = headers.get('expires')\n    if (expires !== null) {\n      const t1 = Date.parse(expires) / 1000\n      if (t1) {\n        return (t1 - t0) | 0\n      }\n    }\n    return Conf.DEFAULT_MAX_AGE\n  }\n\n\n  function parseEntries(list: PerformanceEntryList) {\n    const timeBase = performance.timeOrigin\n\n    for (const record of list as PerformanceResourceTiming[]) {\n      const host = getHostFromUrl(record.name)\n      const info = getHostInfo(host)\n\n      info.reqNum++\n      info.lastDoneTime = timeBase + record.responseEnd\n\n      // time-allow-origin\n      if (record.responseStart > 0) {\n        const reqTime = record.responseStart - record.requestStart\n        info.reqTimeSum += reqTime\n        info.reqTimeAvg = info.reqTimeSum / info.reqNum\n      }\n    }\n  }\n\n\n  export async function init() {\n    await mDatabase.open({\n      'cache': {\n        keyPath: 'url'\n      },\n    })\n\n    const now = getTimeSec()\n\n    // 读取 URL 历史信息\n    await mDatabase.enum('cache', (item: UrlInfo) => {\n      if (item.expire < now) {\n        mDatabase.delete('cache', item.url)\n        return\n      }\n      mUrlInfoMap.set(item.url, item)\n    })\n\n    // 跟踪每个 URL 的性能指标\n    const entries = performance.getEntriesByType('resource')\n    parseEntries(entries)\n\n    const observer = new PerformanceObserver(entryList => {\n      const entries = entryList.getEntries()\n      parseEntries(entries)\n    })\n    observer.observe({\n      entryTypes: ['resource']\n    })\n  }\n\n\n  export function parseWeightConf(manifest: Manifest) {\n    const zone = navigator.language.toLowerCase()\n    const zone0 = zone.split('-')[0]\n    const weightParams =\n      manifest.getParams('@weight ' + zone) ||\n      manifest.getParams('@weight ' + zone0) ||\n      manifest.getParams('@weight')\n\n    if (!weightParams) {\n      const obj = ZONE_HOST_SCORE[zone] || ZONE_HOST_SCORE['*']\n      return new Map(Object.entries(obj))\n    }\n\n    const map = new Map<string, number>()\n    for (const [k, v] of weightParams) {\n      const num = +v\n      if (isNaN(num)) {\n        continue\n      }\n      map.set(k, num)\n    }\n    return map\n  }\n}\n","class ParamMime extends ParamBase {\n  public static reuse = true\n\n  private static extTypeMap: ReadonlyMap<string, string>\n  static {\n    const map = new Map<string, string>()\n\n    for (const item of MIME_DATA.split(';')) {\n      const [mime, exts] = getPair(item, ':') as string[]\n\n      for (const ext of exts.split(',')) {\n        map.set(ext, mime)\n      }\n    }\n    this.extTypeMap = map\n  }\n\n  public static parseConf(conf: string) {\n    if (conf === 'auto') {\n      // likely\n      return ['']\n    }\n    return [conf]\n  }\n\n\n  public constructor(\n    private readonly mime: string\n  ) {\n    super()\n  }\n\n  public onResponse(resArgs: ResponseArgs, fileLoader: FileLoader, rawRes: Response) {\n    let type: string | undefined\n\n    if (this.mime === '') {\n      const url = fileLoader.getFileConfUrl()\n      if (!url.includes('?')) {\n        const m = url.match(/\\.(\\w+)$/)\n        if (m) {\n          const ext = m[1].toLowerCase()\n          type = ParamMime.extTypeMap.get(ext)\n        }\n      }\n      if (!type) {\n        const rawType = rawRes.headers.get('content-type')\n        if (rawType) {\n          type = getPair(rawType, ';')[0]\n        } else {\n          type = 'application/octet-stream'\n        }\n      }\n    } else {\n      type = this.mime\n    }\n    resArgs.headers.set('content-type', type)\n  }\n}\n","const MIME_DATA = 'application/andrew-inset:ez;application/applixware:aw;application/atom+xml:atom;application/atomcat+xml:atomcat;application/atomdeleted+xml:atomdeleted;application/atomsvc+xml:atomsvc;application/atsc-dwd+xml:dwd;application/atsc-held+xml:held;application/atsc-rsat+xml:rsat;application/bdoc:bdoc;application/calendar+xml:xcs;application/ccxml+xml:ccxml;application/cdfx+xml:cdfx;application/cdmi-capability:cdmia;application/cdmi-container:cdmic;application/cdmi-domain:cdmid;application/cdmi-object:cdmio;application/cdmi-queue:cdmiq;application/cu-seeme:cu;application/dash+xml:mpd;application/davmount+xml:davmount;application/docbook+xml:dbk;application/dssc+der:dssc;application/dssc+xml:xdssc;application/ecmascript:ecma,es;application/emma+xml:emma;application/emotionml+xml:emotionml;application/epub+zip:epub;application/exi:exi;application/fdt+xml:fdt;application/font-tdpfr:pfr;application/geo+json:geojson;application/gml+xml:gml;application/gpx+xml:gpx;application/gxf:gxf;application/gzip:gz;application/hjson:hjson;application/hyperstudio:stk;application/inkml+xml:ink,inkml;application/ipfix:ipfix;application/its+xml:its;application/java-archive:jar,war,ear;application/java-serialized-object:ser;application/java-vm:class;application/javascript:js,mjs;application/json:json,map;application/json5:json5;application/jsonml+json:jsonml;application/ld+json:jsonld;application/lgr+xml:lgr;application/lost+xml:lostxml;application/mac-binhex40:hqx;application/mac-compactpro:cpt;application/mads+xml:mads;application/manifest+json:webmanifest;application/marc:mrc;application/marcxml+xml:mrcx;application/mathematica:ma,nb,mb;application/mathml+xml:mathml;application/mbox:mbox;application/mediaservercontrol+xml:mscml;application/metalink+xml:metalink;application/metalink4+xml:meta4;application/mets+xml:mets;application/mmt-aei+xml:maei;application/mmt-usd+xml:musd;application/mods+xml:mods;application/mp21:m21,mp21;application/mp4:mp4s,m4p;application/mrb-consumer+xml:xdf;application/mrb-publish+xml:xdf;application/msword:doc,dot;application/mxf:mxf;application/n-quads:nq;application/n-triples:nt;application/node:cjs;application/octet-stream:bin,dms,lrf,mar,so,dist,distz,pkg,bpk,dump,elc,deploy,exe,dll,deb,dmg,iso,img,msi,msp,msm,buffer;application/oda:oda;application/oebps-package+xml:opf;application/ogg:ogx;application/omdoc+xml:omdoc;application/onenote:onetoc,onetoc2,onetmp,onepkg;application/oxps:oxps;application/p2p-overlay+xml:relo;application/patch-ops-error+xml:xer;application/pdf:pdf;application/pgp-encrypted:pgp;application/pgp-signature:asc,sig;application/pics-rules:prf;application/pkcs10:p10;application/pkcs7-mime:p7m,p7c;application/pkcs7-signature:p7s;application/pkcs8:p8;application/pkix-attr-cert:ac;application/pkix-cert:cer;application/pkix-crl:crl;application/pkix-pkipath:pkipath;application/pkixcmp:pki;application/pls+xml:pls;application/postscript:ai,eps,ps;application/provenance+xml:provx;application/pskc+xml:pskcxml;application/raml+yaml:raml;application/rdf+xml:rdf,owl;application/reginfo+xml:rif;application/relax-ng-compact-syntax:rnc;application/resource-lists+xml:rl;application/resource-lists-diff+xml:rld;application/rls-services+xml:rs;application/route-apd+xml:rapd;application/route-s-tsid+xml:sls;application/route-usd+xml:rusd;application/rpki-ghostbusters:gbr;application/rpki-manifest:mft;application/rpki-roa:roa;application/rsd+xml:rsd;application/rss+xml:rss;application/rtf:rtf;application/sbml+xml:sbml;application/scvp-cv-request:scq;application/scvp-cv-response:scs;application/scvp-vp-request:spq;application/scvp-vp-response:spp;application/sdp:sdp;application/senml+xml:senmlx;application/sensml+xml:sensmlx;application/set-payment-initiation:setpay;application/set-registration-initiation:setreg;application/shf+xml:shf;application/sieve:siv,sieve;application/smil+xml:smi,smil;application/sparql-query:rq;application/sparql-results+xml:srx;application/srgs:gram;application/srgs+xml:grxml;application/sru+xml:sru;application/ssdl+xml:ssdl;application/ssml+xml:ssml;application/swid+xml:swidtag;application/tei+xml:tei,teicorpus;application/thraud+xml:tfi;application/timestamped-data:tsd;application/toml:toml;application/ttml+xml:ttml;application/ubjson:ubj;application/urc-ressheet+xml:rsheet;application/urc-targetdesc+xml:td;application/voicexml+xml:vxml;application/wasm:wasm;application/widget:wgt;application/winhlp:hlp;application/wsdl+xml:wsdl;application/wspolicy+xml:wspolicy;application/xaml+xml:xaml;application/xcap-att+xml:xav;application/xcap-caps+xml:xca;application/xcap-diff+xml:xdf;application/xcap-el+xml:xel;application/xcap-error+xml:xer;application/xcap-ns+xml:xns;application/xenc+xml:xenc;application/xhtml+xml:xhtml,xht;application/xliff+xml:xlf;application/xml:xml,xsl,xsd,rng;application/xml-dtd:dtd;application/xop+xml:xop;application/xproc+xml:xpl;application/xslt+xml:xsl,xslt;application/xspf+xml:xspf;application/xv+xml:mxml,xhvml,xvml,xvm;application/yang:yang;application/yin+xml:yin;application/zip:zip;audio/3gpp:3gpp;audio/adpcm:adp;audio/amr:amr;audio/basic:au,snd;audio/midi:mid,midi,kar,rmi;audio/mobile-xmf:mxmf;audio/mp3:mp3;audio/mp4:m4a,mp4a;audio/mpeg:mpga,mp2,mp2a,mp3,m2a,m3a;audio/ogg:oga,ogg,spx,opus;audio/s3m:s3m;audio/silk:sil;audio/wav:wav;audio/wave:wav;audio/webm:weba;audio/xm:xm;font/collection:ttc;font/otf:otf;font/ttf:ttf;font/woff:woff;font/woff2:woff2;image/aces:exr;image/apng:apng;image/avif:avif;image/bmp:bmp;image/cgm:cgm;image/dicom-rle:drle;image/emf:emf;image/fits:fits;image/g3fax:g3;image/gif:gif;image/heic:heic;image/heic-sequence:heics;image/heif:heif;image/heif-sequence:heifs;image/hej2k:hej2;image/hsj2:hsj2;image/ief:ief;image/jls:jls;image/jp2:jp2,jpg2;image/jpeg:jpeg,jpg,jpe;image/jph:jph;image/jphc:jhc;image/jpm:jpm;image/jpx:jpx,jpf;image/jxr:jxr;image/jxra:jxra;image/jxrs:jxrs;image/jxs:jxs;image/jxsc:jxsc;image/jxsi:jxsi;image/jxss:jxss;image/ktx:ktx;image/ktx2:ktx2;image/png:png;image/sgi:sgi;image/svg+xml:svg,svgz;image/t38:t38;image/tiff:tif,tiff;image/tiff-fx:tfx;image/webp:webp;image/wmf:wmf;message/disposition-notification:disposition-notification;message/global:u8msg;message/global-delivery-status:u8dsn;message/global-disposition-notification:u8mdn;message/global-headers:u8hdr;message/rfc822:eml,mime;model/3mf:3mf;model/gltf+json:gltf;model/gltf-binary:glb;model/iges:igs,iges;model/mesh:msh,mesh,silo;model/mtl:mtl;model/obj:obj;model/stl:stl;model/vrml:wrl,vrml;model/x3d+binary:x3db,x3dbz;model/x3d+fastinfoset:x3db;model/x3d+vrml:x3dv,x3dvz;model/x3d+xml:x3d,x3dz;model/x3d-vrml:x3dv;text/cache-manifest:appcache,manifest;text/calendar:ics,ifb;text/coffeescript:coffee,litcoffee;text/css:css;text/csv:csv;text/html:html,htm,shtml;text/jade:jade;text/jsx:jsx;text/less:less;text/markdown:markdown,md;text/mathml:mml;text/mdx:mdx;text/n3:n3;text/plain:txt,text,conf,def,list,log,in,ini;text/richtext:rtx;text/rtf:rtf;text/sgml:sgml,sgm;text/shex:shex;text/slim:slim,slm;text/spdx:spdx;text/stylus:stylus,styl;text/tab-separated-values:tsv;text/troff:t,tr,roff,man,me,ms;text/turtle:ttl;text/uri-list:uri,uris,urls;text/vcard:vcard;text/vtt:vtt;text/xml:xml;text/yaml:yaml,yml;video/3gpp:3gp,3gpp;video/3gpp2:3g2;video/h261:h261;video/h263:h263;video/h264:h264;video/iso.segment:m4s;video/jpeg:jpgv;video/jpm:jpm,jpgm;video/mj2:mj2,mjp2;video/mp2t:ts;video/mp4:mp4,mp4v,mpg4;video/mpeg:mpeg,mpg,mpe,m1v,m2v;video/ogg:ogv;video/quicktime:qt,mov;video/webm:webm'\n","class Database {\n  private db!: IDBDatabase\n\n\n  public constructor(\n    private readonly name: string\n  ) {\n  }\n\n  public open(opts: {\n    [table: string] : IDBObjectStoreParameters\n  }) {\n    const s = promisex()\n    const req = indexedDB.open(this.name)\n\n    req.onsuccess = () => {\n      const idb = req.result\n      this.db = idb\n\n      idb.onclose = () => {\n        console.warn('[FreeCDN/Database] indexedDB disconnected, reopen...')\n        this.open(opts)\n      }\n      s.resolve()\n    }\n    req.onerror = (e) => {\n      console.warn('[FreeCDN/Database] indexedDB open error:', e)\n      s.reject(req.error)\n    }\n    req.onupgradeneeded = () => {\n      const idb = req.result\n      for (const [k, v] of Object.entries(opts)) {\n        idb.createObjectStore(k, v)\n      }\n    }\n    return s\n  }\n\n  public close() {\n    this.db.close()\n  }\n\n  public get(table: string, key: any) {\n    const s = promisex<any>()\n    const obj = this.getStore(table, 'readonly')\n    const req = obj.get(key)\n\n    req.onsuccess = () => {\n      s.resolve(req.result)\n    }\n    req.onerror = () => {\n      s.reject(req.error)\n    }\n    return s\n  }\n\n  public put(table: string, record: any) {\n    const s = promisex()\n    const obj = this.getStore(table, 'readwrite')\n    const req = obj.put(record)\n\n    req.onsuccess = () => {\n      s.resolve()\n    }\n    req.onerror = () => {\n      s.reject(req.error)\n    }\n    return s\n  }\n\n  public delete(table: string, key: any) {\n    const s = promisex()\n    const obj = this.getStore(table, 'readwrite')\n    const req = obj.delete(key)\n\n    req.onsuccess = () => {\n      s.resolve()\n    }\n    req.onerror = () => {\n      s.reject(req.error)\n    }\n    return s\n  }\n\n  public enum(\n    table: string,\n    callback: (result: any) => boolean | void,\n    ...args: Parameters<typeof IDBObjectStore.prototype.openCursor>\n  ) {\n    const s = promisex()\n    const obj = this.getStore(table, 'readonly')\n    const req = obj.openCursor(...args)\n\n    req.onsuccess = () => {\n      const {result} = req\n      if (!result) {\n        s.resolve()\n        return\n      }\n      const ret = callback(result.value)\n      if (ret !== false) {\n        result.continue()\n      }\n    }\n    req.onerror = () => {\n      s.reject(req.error)\n    }\n    return s\n  }\n\n  private getStore(table: string, mode: IDBTransactionMode) {\n    return this.db\n      .transaction(table, mode)\n      .objectStore(table)\n  }\n}\n","const TEXT_ENCODER = new TextEncoder()\nconst TEXT_DECODER = new TextDecoder()\n\nfunction utf8ToBytes(str: string) : Uint8Array {\n  return TEXT_ENCODER.encode(str)\n}\n\nfunction bytesToUtf8(bytes: Uint8Array) : string {\n  return TEXT_DECODER.decode(bytes)\n}\n\nfunction bytesToAsc(bytes: Uint8Array) : string {\n  return bytes.reduce((s, v) => s + String.fromCharCode(v), '')\n}\n\nfunction base64Encode(bytes: Uint8Array) : string {\n  return btoa(bytesToAsc(bytes))\n}\n\nfunction base64Decode(str: string) : Uint8Array | undefined {\n  try {\n    str = atob(str)\n  } catch {\n    return\n  }\n  const bin = new Uint8Array(str.length)\n  for (let i = 0; i < bin.length; i++) {\n    bin[i] = str.charCodeAt(i)\n  }\n  return bin\n}\n\nfunction parseJson(str: string) {\n  try {\n    return JSON.parse(str)\n  } catch {\n  }\n}\n\nfunction splitList(str: string) : string[] {\n  str = str.trim()\n  if (!str) {\n    return []\n  }\n  return str.split(/\\s+/)\n}\n\nfunction parseStrOrB64(str: string) : Uint8Array | undefined {\n  // json string\n  if (str[0] === '\"') {\n    str = parseJson(str)\n    if (str === undefined) {\n      return\n    }\n    return utf8ToBytes(str)\n  }\n  // base64\n  return base64Decode(str)\n}\n\nconst TIME_UNIT: {[key: string] : number} = {\n  ''   : 1,\n  'ms' : 1,\n  's'  : 1000,\n  'min': 1000 * 60,\n  'h'  : 1000 * 3600,\n  'd'  : 1000 * 3600 * 24,\n  'y'  : 1000 * 3600 * 24 * 365,\n}\n\nfunction parseTime(str: string) : number {\n  const m = str.match(/^([\\d.]{1,9})(y|d|h|min|s|ms|)$/)\n  if (!m) {\n    return NaN\n  }\n  const [, num, unit] = m\n  return +num * TIME_UNIT[unit]\n}\n\nfunction parseByteUnit(str: string) : number {\n  const m = str.match(/^([\\d.]{1,9})(k|K|M|G|)(i|)(b|B|)$/)\n  if (!m) {\n    return NaN\n  }\n  const [, num, kMG, i, bB] = m\n  const exponent =\n    kMG === 'k' ? 1 :\n    kMG === 'K' ? 1 :\n    kMG === 'M' ? 2 :\n    kMG === 'G' ? 3 : 0\n\n  const base = i ? 1024 : 1000\n  const unit = bB === 'b' ? 8 : 1\n  return +num * base ** exponent / unit\n}\n\nfunction getTimeSec() : number {\n  return Date.now() / 1000 | 0\n}\n\nfunction concatBufs(bufs: Uint8Array[], size = 0) : Uint8Array {\n  if (size === 0) {\n    for (const v of bufs) {\n      size += v.length\n    }\n  }\n  const ret = new Uint8Array(size)\n  let pos = 0\n  for (const v of bufs) {\n    ret.set(v, pos)\n    pos += v.length\n  }\n  return ret\n}\n\n\nfunction isArrayEqual<T>(b1: ArrayLike<T>, b2: ArrayLike<T>) : boolean {\n  if (b1.length !== b2.length) {\n    return false\n  }\n  for (let i = 0; i < b1.length; i++) {\n    if (b1[i] !== b2[i]) {\n      return false\n    }\n  }\n  return true\n}\n\n\nfunction getPair(str: string, delim: string) : [string, string?] {\n  const pos = str.indexOf(delim)\n  if (pos === -1) {\n    return [str]\n  }\n  return [\n    str.substring(0, pos),\n    str.substring(pos + delim.length)\n  ]\n}\n\nfunction mergeMap<K, V>(dst: Map<K, V>, src: Iterable<[K, V]>) : void {\n  for (const [k, v] of src) {\n    dst.set(k, v)\n  }\n}\n\n/**\n * @param url absolute or relative url\n */\nfunction stripUrlQuery(url: string) : string {\n  const pos = url.indexOf('?')\n  if (pos === -1) {\n    return url\n  }\n  return url.substring(0, pos)\n}\n\n/**\n * @param url absolute url\n */\nfunction getHostFromUrl(url: string) : string {\n  const m = url.match(/^https?:\\/\\/([^/]+)/) as string[]\n  return m[1]\n}\n\n/**\n * @param url absolute or relative url\n */\nfunction toRelUrl(url: string) : string {\n  if (url.startsWith(ROOT_PATH)) {\n    return url.substring(MY_ORIGIN.length)\n  }\n  return url\n}\n\nasync function sha256(buf: Uint8Array) : Promise<Uint8Array> {\n  const ret = await CRYPTO.digest('SHA-256', buf)\n  return new Uint8Array(ret)\n}\n","const ZONE_HOST_SCORE: {\n  [zone: string]: {\n    [host: string]: number\n  }\n} = {\n  'zh-cn': {\n    'ajax.cdnjs.com': 50,\n    'cdnjs.cloudflare.com': 50,\n    'cdn.jsdelivr.net': 80,\n    'raw.githubusercontent.com': 10,\n    'cdnjs.loli.net': 70,\n    'lib.baomitu.com': 80,\n    'lf6-cdn-tos.bytecdntp.com': 90,\n    'cdn.staticfile.org': 90,\n    'cdn.bootcss.com': 10,\n    'cdn.bootcdn.net': 80,\n    'unpkg.com': 50,\n    'g.alicdn.com': 90,\n    'pagecdn.io': 20,\n    'ajax.aspnetcdn.com': 60,\n    'ajax.googleapis.com': 10,\n    'code.jquery.com': 20,\n    'stackpath.bootstrapcdn.com': 30,\n    'maxcdn.bootstrapcdn.com': 30,\n    'cdn.datatables.net': 40,\n    'twemoji.maxcdn.com': 40,\n  },\n  '*': {\n    'ajax.cdnjs.com': 90,\n    'cdnjs.cloudflare.com': 90,\n    'cdn.jsdelivr.net': 40,\n    'raw.githubusercontent.com': 10,\n    'cdnjs.loli.net': 40,\n    'lib.baomitu.com': 20,\n    'lf6-cdn-tos.bytecdntp.com': 40,\n    'cdn.staticfile.org': 20,\n    'cdn.bootcss.com': 10,\n    'cdn.bootcdn.net': 20,\n    'unpkg.com': 40,\n    'g.alicdn.com': 30,\n    'pagecdn.io': 40,\n    'ajax.aspnetcdn.com': 70,\n    'ajax.googleapis.com': 90,\n    'code.jquery.com': 50,\n    'stackpath.bootstrapcdn.com': 40,\n    'maxcdn.bootstrapcdn.com': 50,\n    'cdn.datatables.net': 50,\n    'twemoji.maxcdn.com': 50,\n  },\n}"]}
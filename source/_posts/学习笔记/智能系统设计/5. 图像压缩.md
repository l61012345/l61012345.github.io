---
title: 05.图像压缩
category_bar: true
date: 2022/12/13
categories: 
- 学习笔记
- 智能系统和数字图像处理应用
---
# 图像压缩
## 概述
### 问题动机
使用图像压缩的动机有两点：  
- 如果不使用图像压缩技术，那么图像和视频文件所包含的信息量是相当巨大的。  
  以一部分辨率为720P(1280px × 720px)，24fps，时长1小时的彩色8bit电影计算，其包含的信息量为：$1280px × 720px×3×8bit×24fps×3600s=1,911,029,760,000bit=1,779.78515625MB$  
- 图像本身可能有较多的冗余信息。  
  下面三个例子说明了三种图像常见的冗余信息：  
  a. **编码冗余**(encoding redundancy)：这张256px × 256px的图像中仅存在四种不同值的像素。如果选用通用的8bit编码方式，那么有251个灰度值都从未使用过。  
  <img src= https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20221213163613.png width=20%>  
  b. **空间冗余**(spatial redundancy)：这张256px × 256px的图像中每一竖列所使用的像素都是相同的，这意味着相同的灰度值序列被重复使用了256次。  
  <img src= https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20221213163935.png width=20%>  
  c. **无关信息**(irrelevant information)：下图中的所使用的像素其灰度值差别仅有±1，肉眼很难分辨出它们之间的差别。  
  <img src= https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20221213164224.png width=20%>  

基于上述的两点原因，图像处理中需要图像压缩技术通过减少图像的冗余信息来降低图像文件的信息量。  

### 压缩过程
如果将图像表示为一个灰度值函数，自变量为空间位置$f(x,y)$，图像压缩(compression)技术可以通过对图像编码和解码来实现对信息的压缩，以便将图像信息发送给接收方。接收方利用解压缩过程(decompression)将比特流解码为图像，再使用反映射将图像进行复原。整个过程如下图所示。  
<img src= https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20221213164630.png width=50%>  

可以发现复原后的图像$\hat{f}(x,y)$并非和原图像$f(x,y)$一模一样，这两者之间的差异可以通过均方差(mean square error, MSE)来衡量：  
$$MSE=\frac{1}{N_{Pixels}}∑_{(x,y)}(\hat{f}-f)^2$$
其中$N_{Pixels}$表示像素个数。  

在量化阶段，量化将灰度值转换为可以传输的比特信息，这个过程中通过引入量化误差来实现对于图像的压缩。   
量化之前的映射过程的**目的是通过使用一些变换函数尽可能地减小原图和复原图像之间的均方差**。经过映射后的图像通过量化和传输时的信息损失更少。    

## JPEG
图像压缩的编码方式需要形成全球通用的标准，如此各种图像和视频才可以在全球范围内传播和接收。下图展示了目前较为常用的图像和视频压缩标准：  
<img src= https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20221213200850.png width=50%>  

JPEG(Joint Photographic Experts Group)是其中的一种国际标准，其图像压缩和解压缩的过程如下图所示：  
<img src= https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20221213201714.png width=50%>  
JPEG会首先将一整个图片分为8px × 8px的子图，然后再分别对每一张子图做相应的处理。对于彩图，JPEG会将图像拆分为$[R,G,B]$三通道，然后映射为$[Y,CB,CR]$三通道。  
{% note info %}  
$[Y,CB,CR]$色彩空间中，$Y$为颜色的亮度(luma)成分、而$CB$和$CR$则为蓝色和红色的浓度偏移量成份。  
{% endnote %}  
子图通过前向变换(Forward transform)(主要是离散余弦变换)实现映射，每一张8px × 8px进行量化后会生成仅生成一个元素，然后进行编码。  
<img src= https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20221213210907.png width=70%>  

{% note info %}  
JPEG标准中子图采用8px × 8px大小与JPEG中采用的离散余弦变换的性质（见后文）有关：  
使用更小的子图会导致离散余弦变换的图像质量下降。越大的子图越不容易满足马尔科夫条件，同时更大的子图计算量也更多。  

{% endnote %}  

### 前向变换
#### K-L变换
K-L变换(Karhunen-Loève Transform)是一种图像处理常用的变换。  
K-L变换以矢量信号$X$的协方差矩阵$Ф$的归一化正交特征矢量$q$所构成的正交矩阵$Q$，来对该矢量信号$X$做正交变换:
$$Y=QX$$
其中$Q^TQ=I$。  
经过K-L变换后提取出来的一个元素经过复原后的图像相比于直接从子图上提取一个像素得到的均方差要小的多。  
此外，从定义上可以看出K-L变换的算子$Q$是由原图$X$决定的，这样的缺点是对于每一张图片都需要生成一个特定的K-L变换算子$Q$。很显然这样的变换并不是通用的解决方案。  

#### 离散余弦变换
离散余弦变换(discret cosine transformation,DST)是JPEG标准中采用的前向变换方法。相比于K-L变换，离散余弦变换的算子是通用算子，与原图独立。但是复原图像的均方差相比于使用K-L变换得到的复原图像较大，不过仍然在可以接收的范围。  
离散余弦变换的公式可以表示为：  
$$T(u,v)=∑_{x=0}^{n-1}∑_{y=0}^{n-1}f(x,y)r(x,y,u,v)$$
其中$f(x,y)$是原图像，$r(x,y,u,v)$称为变换系数(transformation coeffients)。  
相应的，反离散余弦变换(inverse discret cosine transformation)公式为：  
$$F(x,y)=∑_{u=0}^{n-1}∑_{v=0}^{n-1}T(u,v)S(u,v,x,y)$$
对于离散余弦变换及其反变换，它们的变换系数是相同的：  
$$r(x,y,u,v)=S(u,v,x,y)$$
这个变换系数的具体表达式为：  
$$r(x,y,u,v)=α(u)α(v)cos\left[\frac{(2x+1)uπ}{2n}\right]cos\left[\frac{(2y+1)vπ}{2n}\right]$$
其中，  
$$α(u)=\begin{cases}
  \sqrt{\frac{1}{n}},u=0\\
  \sqrt{\frac{2}{n}},u≠0\\
\end{cases}$$

需要注意的是当信号具有接近马尔科夫过程(Markov processes)的统计特性时（这样的条件又被称为马尔科夫条件），离散余弦变换的去相关性接近于K-L变换。**此时离散余项变换的作用相当于K-L变换。**  
另外，相比于快速傅里叶变换(fast fourier transformation, FFT)，离散余弦变换可以通过反转信号达到变换后信号是原信号周期的两倍，如此避免了快速傅里叶变换中可能出现的间断点。离散余弦变换后子图之间的间隔更加平滑。  
<img src= https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20221219202507.png width=50%>   

### 量化
### 霍夫曼编码



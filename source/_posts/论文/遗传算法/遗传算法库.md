---
title: 经典遗传算法的Python实现
date: 2022/11/25
category_bar: true
categories: 
- 论文
- 遗传算法
---

# 经典遗传算法的Python实现
## 理论
遗传算法(Genetic Algorithm, GA)由Prof.Holland 提出，是一种模拟生物染色体遗传行为结合达尔文生物进化理论的进化算法。它可以在给定的有限的搜索空间中找到全局最优解。   
其运行过程如下图所示：  
<img src= https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20221125133029.png width=80%>  

其运行的主要过程分为：种群初始化(population initialization)、评估(evaluation)、复制/选择(production)、遗传操作(genetic operation)四个模块，在Holland提出的经典遗传算法中遗传操作包括单点交叉(single point crossover)和突变(mutation)两步。   

### 概念
遗传算法中一个问题的可能解是目标函数包括的所有自变量的对应的一个特定值的集合，称为个体(individual)。在遗传算法中，这些值被线性排列，称为一条染色体(chromosome)。一个个体对应一条染色体，所有个体的染色体长度应当是相等的。染色体上描述某个变量对应值的区域被称为该变量在这个染色体上对应的基因(gene)。    
遗传算法中，个体的集合被称为种群(population)，所有可能个体的集合是遗传算法的搜索空间(searching space)。  

### 运行遗传算法前的准备：搜索空间的确定
搜索空间主要是通过为目标问题的所有可能解决方案确定一种通用的编码方式来实现。在经典遗传算法中，这一编码机制为二进制字符串，称为位串(string)。每一个个体都通过某种方式转化为唯一的一个位串。  
这种转化的方式要求：  
- 搜索空间内的个体数量是有限的。  
- 编码后所有个体在搜索空间中都是均匀分布的。  
- 对位串中对每个基因的一次改变的对搜索进度的影响程度是相同的。  

### 种群初始化
由于实际问题中遗传算法要面临的状态编码数量非常庞大，算法需要给定一些个体以便从它们开始查找最优解。通常，这些个体通过随机抽样的方式被确定，随机抽样得到的个体集合称为初始种群(initial population)。  

### 评估
评估是量化个体优劣性的方式。所谓个体的优劣性即个体对应的目标问题的一个解对目标问题解决程度的描述。评估是通过将编码后的个体进行解码，然后送入一个可以量化个体优劣性的函数中实现的。这个函数被称为适应度函数(fitness function)。每个个体经过适应度函数后会得到一个表征其性能的值，称为适应度(fitness)，$f$。  
种群中个体$i$的正规化适应度(normalized fitness)定义为：  
$$\frac{f_i}{\overline{f}}$$  
其中，$f_i$表示评估函数对第$i$个个体的评估结果，$\overline{f}$表示种群的平均评估。  
个体的适应度越高，表明这个状态对应的系统结果越能够符合我们的要求。  

### 复制·选择（轮盘赌选择）
选择后的每个个体的适应度格式为x.xx，即有小数部分和整数部分。适应度的整数部分表示该个体会被复制多少次。
复制中的选择机制：  
这样就能直接地让优秀的个体获得更多被复制的机会，而适应度整数部分为0的个体因为不会被复制而被淘汰。  
但是，那些适应度比较低的个体中仍然可能有对系统有益的部分，为了尽可能地保留这些部分，遗传算法在选择阶段还规定：  
对所有的个体，适应度的小数部分表示额外被复制的概率。  
如此，每一个个体中对系统有益的部分都能够被尽可能地复制。  
比如，适应度2.3的个体能够获得2次复制，并且有0.3的概率能获得第三次复制的机会。  
这样的机制能够用数学表示为：   
$$M(H,t+1)=M(H,t)\frac{f(H,t)}{\overline{f}}$$  
其中M表示的是种群中的一个亚种(Sub-populations)。  

总结：  
选择的过程即为有概率地对种群中的个体进行复制，可以发现，适应度越高的个体被复制的概率就越大。  

原始种群经过复制后形成**中间种**（Intermediate Generation）。  

### 重组（单点交叉）
**遗传算法中重组的本质是杂交（Crossover）**，其过程主要有两步： 
1. 随机地使得个体间两两配对。  
2. 随机地选取一对个体，两者在某个随机且相同的比特位处断开，前后的两段基因型进行交叉互换。  

![](https://img-blog.csdnimg.cn/20191202151959116.gif#pic_center)

新生成的两个个体称为后代（Offspring），后代能够插入到下一代的概率计作$p_c$。  

### 突变（反转突变）
重组之后利用突变算子对后代作突变处理，对于种群中的所有比特位，其有$p_m$的概率发生比特反转。同遗传学一样，突变概率一个非常小的概率，通常小于1%。  
中间种经过重组和突变，最终能称为新的种群。
<div align="center">  
<img src=https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20210718132905.png width=50% />  
</div>

## Python 代码实现
在Python中，设计每一个只含有0和1的列表(list)表示一个个体，一个种群对应一个二维列表。  

### 初始种群生成
初始种群生成的函数能够完成的功能是：对于给定的初始种群数量和染色体长度，可以随机地生成一些个体。  
基本思路是利用嵌套的`for`循环实现这一功能：内层的`for`循环用于为每一个个体列表随机填满0和1（`random.randint(0, 1)`），外层的`for`循环用于将生成好的个体放入种群中。  

```python
def initia_population(population_size: 'int>0',
                      chromosome_length: 'int>0') -> 'list':
    population = [[]] # 初始化二维列表，用于存放个体
    print('initializing the population')
    for i in range(population_size):
        indiv = [] # 初始化一维列表，代表一个个体
        # 随机生成一个个体
        for j in range(chromosome_length):
            indiv.append(random.randint(0, 1))

        print('indiv:*', i, '   chromesome:', indiv)
        population.append(indiv)  # append to the population
    return population[1:]
```

### 转义和评估
#### 转义
要想评估每一个个体的优劣性，需要按照模板将位串对应区域的比特转换为十进制数，如下图所示，这一步称为转义(translation)。  
<img src= https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20221125141729.png width=70%>  

转义的基因模板可以通过给定一个数组`gene_pattern`，其中标有每个基因的截断位置实现。例如：`gene_pattern = [3,6]`表示`indiv[1]`到`indiv[3]`视为一个基因；`indiv[4]`到`indiv[6]`视为另一个基因。  
使用`for`循环和列表切片将位串按照`gene_pattern`给定的位置进行划分，并手动去除掉[]，','和空格。  
```python
# 根据gene_pattern划分基因
for k in range(len(gene_pattern)):
    string.append((''.join(
        str(population[i][gene_pattern[k - 1]:gene_pattern[k]]))
        ).replace('[', '').replace(']', '').replace(
            ',', '').replace(' ', ''))
```
此外，由于`gene_pattern[k - 1]:gene_pattern[k]`对`k=0`不适用，因此还需要手动将第一个基因替换为`0：gene_pattern[0]`的切片。  
```python
# 第一个基因转义后为'[]'，需要手动替换为0：gene_pattern[0]的切片
string[0] = ''.join(str(population[i][0:gene_pattern[0]])
                    .replace('[', '').replace(
                    ']', '').replace(',', '').replace(' ', ''))
```

最后使用`int`函数将每个基因转化为对应的十进制。  
```python
gene_trans = int(string[m], 2)
```


```python
def translation(population: 'list', gene_pattern: 'list') -> 'list':
    population_trans = [[]]
    print('translation')
    for i in range(len(population)):
        indiv_trans = []
        string = []
        gene_trans = 0

        # 根据gene_pattern划分基因
        for k in range(len(gene_pattern)):
            string.append((''.join(
                str(population[i][gene_pattern[k - 1]:gene_pattern[k]]))
                           ).replace('[', '').replace(']', '').replace(
                               ',', '').replace(' ', ''))  
                # 划分好的基因字符串形如'[1 , 0]'，
                # 还需要手动去除掉[]，','和空格
        # 第一个基因转义后为'[]'，需要手动替换为0：gene_pattern[0]的切片
        string[0] = ''.join(
            str(population[i][0:gene_pattern[0]]).replace('[', '').replace(
                ']', '').replace(',', '').replace(' ', ''))

        # 将划分好的基因位串转换为十进制
        for m in range(len(string)):
            gene_trans = int(string[m], 2)
            indiv_trans.append(gene_trans)
        print('indiv:', i, '   chromosome:', indiv_trans)
        population_trans.append(indiv_trans)
    return population_trans[1:]
```

#### 评估
将转义后的个体带入到适应度函数中就可以得到该个体所对应的适应度。 
其中，适应度函数使用`fitness_func`进行定义，并保存在`/fitness_func.py`中。  
传入该函数的是一个列表，函数中各变量的值通过访问列表中对应的元素获取。下面给出了一个适应度函数$f(x_0,x_1,x_2,x_3)=x_0+x_1+(2x_2+3x_3)^2$的例子：  
```python
# fitness_function.py
def fitness_func(x):
    y= x[0] + x[1]+ pow((2*(x[2]))+(3*(x[3])),2)
    return float(y)
```
将获得的个体适应度存入一个列表`fitness`，该列表的序号和种群中`population`个体对应的序号相同，因此可以根据序号查询到每个个体对应的适应度。  
获得适应度后，需要对每个个体适应度除以当前种群适应度的均值以正规化每个个体的适应度：`indiv_fitness_norm = fitness[j] / avg_fitness`.  
其中`avg_fitness = sum(fitness) / float(len(fitness))`是当前种群的适应度的平均值，该值也会被该函数返回以便在主函数中观察进化过程。  


```python
def evaluation(population_tran: 'list') -> ['list', 'float']:
    print('evaluation')
    from fitness_func import fitness_func as fitness_func 
    # 从 fitness_func.py中加载适应度函数
    print('successfully load fitness function ')

    fitness = []
    fitness_norm = []
    for i in range(len(population_tran)):
        indiv_fitness = fitness_func(
            population_tran[i])  # 对每个个体计算适应度
        print('indiv:', i, '   fitness:', indiv_fitness)
        fitness.append(indiv_fitness)  # 得到对应的适应度列表

    avg_fitness = sum(fitness) / float(len(fitness))  # 计算当前种群的平均适应度
    print('average fitness:', avg_fitness)

    for j in range(len(fitness)):
        indiv_fitness_norm = fitness[j] / avg_fitness  # 正规化适应度
        print('indiv:', j, '   normal fitness:', indiv_fitness_norm)
        fitness_norm.append(indiv_fitness_norm)
    return fitness_norm, avg_fitness
```

### 选择
根据经典遗传算法提到的理论，每个个体正规化后的适应度的整数部分代表个体出现在下一轮的种群中的次数。  
```python
for j in range(int(fitness_norm[i])):
    population_inter.append(population[i])
    copy_times = copy_times + 1
```
个体适应度的小数部分代表个体在下一轮的种群中额外出现一次的概率。  
概率以随机生成一个$[0,1]$的随机数与其小数部分比较来表示。  

```python
if random.random() < (fitness_norm[i] - int(fitness_norm[i])):
    population_inter.append(population[i])
    copy_times = copy_times + 1
    print('indiv:*', i, '   normal fitness:', fitness_norm[i],
            '   Copy times:', copy_times, '   extra')
    else:
    print('indiv:*', i, '   normal fitness:', fitness_norm[i],
            '   No extra copy')
```

```python
def selection(population: 'list', fitness_norm: 'list') -> 'list':
    population_inter = [[]]
    print('selection')

    for i in range(len(population)):
        # 基于适应度的整数部分，复制多次
        copy_times = 0
        for j in range(int(fitness_norm[i])):
            population_inter.append(population[i])
            copy_times = copy_times + 1
            print('indiv:*', i, '   normal fitness:', fitness_norm[i],
                  '   Copy times:', copy_times)
        # 基于适应度的小数部分，额外复制一次
        if random.random() < (fitness_norm[i] - int(fitness_norm[i])):
            population_inter.append(population[i])
            copy_times = copy_times + 1
            print('indiv:*', i, '   normal fitness:', fitness_norm[i],
                  '   Copy times:', copy_times, '   extra')
        else:
            print('indiv:*', i, '   normal fitness:', fitness_norm[i],
                  '   No extra copy')
    return population_inter[1:]
```

### 单点交叉
在进行单点交叉之前，首先需要检查当前种群中的个体数是否大于1，如果当前种群里面只有1个个体，那么交叉将不会进行，并且返回一个布尔值`False`以便让主程序终止进化过程。  
```python
if population_size == 1:  # 检查当前种群中是否只有一个个体
        # 输出告警
        print('【Warning】only one indiv in current population')
        return population, False
    else:
        print('single crossover   crossover rate:', crossover_rate)
```

然后对当前种群中的所有个体两两配对，这个概念通过`shuffle`打乱所有个体的序号和在`for`循环处设置`range(0, population_size - 1, 2)`以每两个一组实现。  
对于每一组个体，使用`cross_point = random.randint(0,chromesome_length - 1)`随机选择一个交叉点。  
然后进行单点交叉，其基本思路是创建两个列表`parent1`和`parent2`，对于每个列表，分别放入其中一个个体交叉点前的位串和另一个个体交叉点后的位串。  
```python
parent1 = []
parent2 = []

# parent 1
parent1.extend(population[i][0:cross_point])
parent1.extend(population[i +1][cross_point:chromesome_length])

# parent2
parent2.extend(population[i + 1][0:cross_point])
parent2.extend(population[i][cross_point:chromesome_length])
population[i] = parent1
population[i + 1] = parent2
```

```python
def single_crossover(population: 'list',
                     crossover_rate: '0<= float<= 1') -> ['list', 'bool']:
    chromesome_length = len(population[0])
    population_size = len(population)
    if population_size == 1:  # 检查当前种群中是否只有一个个体
        # 输出告警
        print('【Warning】only one indiv in current population')
        return population, False
    else:
        print('single crossover   crossover rate:', crossover_rate)

        random.shuffle(population)
        print('shuffle')

        for i in range(0, population_size - 1, 2):
            if random.random(
            ) < crossover_rate:  # 遍历每个个体
                print('========')
                print('indiv:', i, '   chromosome:', population[i],
                      '   crossovered: yes')
                print('indiv:', i + 1, '   chromosome:', population[i + 1],
                      '   crossovered: yes')
                cross_point = random.randint(
                    0,
                    chromesome_length - 1)  # 随机选择交叉点
                parent1 = []
                parent2 = []

                # parent1
                parent1.extend(population[i][0:cross_point])
                parent1.extend(population[i +
                                          1][cross_point:chromesome_length])

                # parent2
                parent2.extend(population[i + 1][0:cross_point])
                parent2.extend(population[i][cross_point:chromesome_length])
                population[i] = parent1
                population[i + 1] = parent2

                print('---after crossover---')
                print('indiv:', i, '   chromosome:', population[i],
                      '   crossovered: yes')
                print('indiv:', i + 1, '   chromosome:', population[i + 1],
                      '   crossovered: yes')

            else:
                # 保持不变
                population[i] = population[i]
                population[i + 1] = population[i + 1]
                print('========')
                print('indiv:', i, '   chromosome:', population[i],
                      '   crossovered: not')
                print('indiv:', i + 1, '   chromosome:', population[i + 1],
                      '   crossovered: not')
        return population, True
```

### 突变


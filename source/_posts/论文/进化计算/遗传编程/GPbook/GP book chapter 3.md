---
title: 03. 控制器的自动综合
date: 2023/12/19
category_bar: true
categories: 
- 论文
- 进化计算
- 遗传编程
- 遗传编程 IV： 例程化的可比拟人类的机器智能
---

# 控制器的自动综合

{% note info %}  
这是对《Genetic Programming IV: Routine Human-Competitive Machine Intelligence》的笔记，本页对应第三章： Chapter 3： Automatic Synthesis of Controllers.   
这一章讲述了如何使用遗传编程完成控制器的自动设计。  
  
  
原书的免费公开版本在作者Koza本人的Research gate主页上：https://www.researchgate.net/publication/243776894_Genetic_Programming_IV_Routine_Human-Competitive_Machine_Intelligence  
这本书也可以在Springer 购买电子版： https://link.springer.com/book/10.1007/b137549  
或者在亚马逊英国购买纸质版：  https://www.amazon.co.uk/Genetic-Programming-IV-Human-Competitive-Intelligence/dp/0387250670  
{% endnote %}  

人类工程师进行设计的过程涉及到对各种考量的权衡，因此可以说设计的过程是需要使用到人类的智能的。这一章讲自动设计控制器(controller)作为例子讲述遗传编程在设计领域的应用，这一章包括了使用遗传编程设计如下的控制器：  
- 二阶滞后补偿器  
- 三阶滞后补偿器  
  - 带有时延的三阶滞后补偿器  
- 非最小相位系统  

## 控制器背景
### 控制器原理
使用控制器的目的是为了让系统原型(plant)、也就是控制器控制的目标系统的响应能够与一个设计者所期望的响应尽可能的匹配。此后作者举了一个控制车速的巡航控制器(cruise control device)的例子来说明控制器是如何工作来控制系统的。简单来说，控制器对系统的作用不是一蹴而就的，而是需要时间让整个系统不断调整自己的输出。在控制器控制系统原型的过程中，控制器需要通过监控系统原型的输出，并且比较和参考信号(reference signal)之间的误差(error signal)来调整原型系统的输入，从而让整个系统的输出你能够更加贴近参考信号。这样通过接收输出、改进输出、再将改进后的输出作为输入的控制方法称为反馈控制(feedback control)。如果反馈控制通过误差信号作为原型的下一次输入，那么这样的反馈控制称为负反馈控制(negative feedback control)。  
含有反馈的控制系统也称为闭环控制系统（closed-loop control system），输入与反馈信号比较后的差值（即误差信号）加给控制器，然后再调节受控对象的输出，从而形成闭环控制回路。所以，闭环系统又称为反馈控制系统，这种反馈称为负反馈。与开环系统相比，闭环系统具有突出的优点，包括精度高、动态性能好、抗干扰能力强等。它的缺点是结构比较复杂，价格比较贵，对维修人员要求较高。   
<img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220301095016.png width=60%>  

{% note info %}  
更多关于控制论的内容请参考学习笔记中的控制系统课程。  
{% endnote %}  

现实世界当中大部分的控制器都是手动的（比如阀门、手动控制的开关等等），但是这本书中强调的控制器都是自动控制器，也就是自动根据反馈输入调整系统输出的控制器。  

### 控制器的设计指标  
在设计时需要考虑的控制器的特征非常多，下面列出了常见的一些控制器的设计指标，这些指标都和系统的阶跃响应有关(step response，指系统输入为单位阶跃信号时系统的时域输出变化)。  

- 上升时间和调节时间  
设计控制器的过程中最常见的考虑因素是让系统响应表现为理想响应的时间尽可能小。这一设计指标通常被诠释为上升时间$t_r$（rise time）或者是调节时间$t_s$(settling time)。  
上升时间是指定义为阶跃响应曲线从稳态值的10%第一次上升到90%所需的时间。  
调节时间是指阶跃响应达到并永远保持在一个允许误差范围(误差带：通常取±5%或±2%)内，所需的最短时间。  

- ITAE  
控制工程中喜欢使用参考信号和系统原型的响应之差的绝对值在时间上的积分(the integral of the time-weighted absolute error)来衡量控制器的性能。由于按照时间的加权中会对比较晚出现的误差有更大的惩罚、应用ITAE作为适应度有助于迅速减小误差。  

- 过冲率  
过冲率$M_p$(overshoot)是指的系统原型的响应超出参考信号的最大百分比。过冲会消耗大量能量，设计时需要尽可能的考虑减小过冲。  

- 鲁棒性  
在现实中还会出现干扰（disturbance）。这种干扰对系统的影响通常被建模为在系统原型输出端的加性噪声。鲁棒性可以表示为系统对于噪声的灵敏度，即系统输出对噪声的偏微分：   
  $$\frac{∂S_{output}}{∂N}$$  
  好的控制系统可以对噪声表现出高鲁棒性，也就是输出对噪声的灵敏度不高。  

- 稳定性  
稳定性(stability)是指系统随着输入信号微小变化的响应程度。如果整个系统的性能随着系统原型的微小变化而变化很大，那么这个系统可能毫无用处甚至会有危险。


这些设计指标在系统的阶跃响应图上表现如下：  
<img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20220301212556.png width=80%>  

### 控制器的基本组成
一个控制器电路通常可能会用到如下的器件：  
放大器(gain)、积分器(integrator)、差分器(differentiator)、加法器(adder)、减法器(substractor)、超前补偿(laed)、滞后补偿(lag)、延时器(delay)、翻转器(invertor)、取绝对值(absolute)、限制器(limitor)、乘法器(multiplier)、分配器(divider)、开关(switch)。  

控制器的拓扑结构可以描述为：  
- 控制器内部用到的器件数
- 用到的器件类型
- 控制器内部器件的输入和输出的连接方式
- 控制器的外部输入和外部输出

### PID控制器
PID控制器是控制系统中最常用的控制器类型，它由基本的三个控制器：P控制器、I控制器、D控制器组成。  
<img src=https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20231220105903.png width=60%>    

三个部分都对PID控制器整体的输出有对应的贡献。  
- P控制器(proportional controller)，又称为比例段，它的作用是将参考信号和原型系统的输出之间的误差直接反馈给系统。  
- I控制器(integral controller)，又被称为积分段，它的作用是使得控制器在稳态时候的误差更小。  
- D控制器(derivative controller)，又被称为微分段。由于比例段提供的误差补偿总是滞后的，利用这一点P控制器可以通过求误差信号的斜率来预测未来误差信号的变化情况。  

PID控制器的作用用PID控制器的发明者Callender和Stenvenson的说法是：  
“本发明的一个具体目的是提供一种系统，该系统将产生一种补偿效果，该补偿效果受与偏差的总范围、偏差率和给定期间内偏差的总和成比例的因素所支配。”   
> A specific object of the invention is to provide a system which will produce a compensating effect governed by factors proportional to the totoal extent of the deviation, the rate of the deviation, and the summation of the deviation during a given period.  

尽管PID控制器在现在的工业界应用非常广泛，但是对更好的控制器的需求从来没有停止过。在Astrom和Hagglund(1995)的论文中提到，只有20%的控制器工作的比较好。  

## 控制器的智能设计方法论
### 智能设计方法总述
对控制器的智能设计，或者说智能综合需要设同时计控制器的拓扑结构和相应的参数的值，来满足用户指定的高阶的设计需求。下面列出了一些常见的对设计需求的高阶表达：  
- 优化要求  
  比如最小化ITAE  
- 时域要求  
  比如最小化过冲、最大化抗噪性等等  
- 频域要求  
  比如系统带宽、随着噪声的衰减等等
- 稳定性要求  
- 鲁棒性要求  
- 对特定信号的值的限制  

用传统的设计方法（比如说状态空间设计、根据波特图的设计等等）很难同时满足上述几个设计要求的任意组合，因此需要使用到智能算法来进行优化。下面的几种启发式的方法可能可以解决这样的设计要求：  
- 爬山算法 (hill climbing)和基于梯度的算法(gradient methods)
- 模拟退火算法(simulated annealing)
- 进化计算(\*这本书写作之时还没有进化计算这个概念，原书中写的是evolutionary methods)  

上述的这些方法都是启发式学习的方法，这些方法的迭代操作都类似，高层级的语言表示如下：  
1. 从搜索空间中的一个或者几个点上开始搜索，衡量这一个或者几个点的表现  
2. 通过改变现有的搜索点的结构来创建新的备选点  
3. 衡量新的备选点的表现，并得到一个指标  
4. 用这个指标对备选点进行选择  
5. 重复上述操作

{% note info %}  
整个人工智能算法大致可以分为两类：启发式学习（又分为构造算法和改进算法，改进算法中包括了贪心算法和非贪心算法）和精确方法(比如专家系统、统计回归等等)。  
{% endnote %}  

不管是何种搜索算法，搜索行为的主要动力来源于对个体表现的衡量，用于衡量的函数以代价的形式（越低越好）或者以适应度的形式（越高越好）出现。并且通常新的个体是基于现有的个体产生的，下面将详述这几种算法的搜索行为。  

#### 爬山算法和基于梯度的算法
爬山算法开始于整个搜索空间的一个个体，对这个个体指定适应度后再创建新的个体，指定这个新的个体的适应度，然后通过适应度的衡量决定选择原来的个体还是新创建的个体。新个体的创建方式依照问题的不同而不同。  
梯度下降可以看做是使用梯度作为适应度衡量的爬山算法。  
爬山算法是一种点对点的贪心算法。在每一个循环中，爬山算法会无条件拒绝没有任何改进的个体，同时也会无条件接受具有改进的个体。(\*形象的形容为：猴子搬玉米)在单次尝试当中，爬山算法容易陷入局部最优。如果问题允许多次尝试，那么多次尝试可能会找到全局最优。但是每一次尝试都是独立的，新一次的搜索并不会继承原来的搜索(\*找不找得到全凭运气)。  
爬山算法的另一个问题是并行化，虽然有并行化的爬山算法，但是并行线程之间的工作是独立的，并没有信息交流。  
{% note info %}  
遗传算法并行化过程的信息交流参考[并行遗传算法](https://l61012345.top/2023/04/13/%E8%AE%BA%E6%96%87/%E8%BF%9B%E5%8C%96%E8%AE%A1%E7%AE%97/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/%E5%B9%B6%E8%A1%8C%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/)  
{% endnote %}  

#### 模拟退火算法
模拟退火算法也是一种点对点的搜索算法。这种算法也使用了一种特定问题的修改操作来基于现有个体产生新的个体，但是与爬山算法和梯度下降算法不同的是，模拟退火算法中使用了Metropolis算法和玻尔兹曼算法来来决定是否保留那些没有任何改进的个体。  
此外，模拟退火运用了一个变量温度(temperature)$T$来控制算法的运行过程和收敛情况，$T$在运行过程中指数单调递减，并且影响Metropolis算法和玻尔兹曼算法对个体是否保留的抉择。在$T$很高的时候，算法更倾向于接收那些没有任何改进的个体，随着算法迭代次数的增加，$T$很低的时候，算法更倾向于拒绝那些没有任何改进的个体，以加快算法的收敛，但是为了保证全局性，算法也不会完全拒绝任何个体。  

#### 进化计算
进化计算的搜索方法并不是贪心的，而是一种全局的搜索方式。并且，进化计算的操纵对象是群，因此是一种群智能搜索方法，而非点对点的搜索方法。在运行过程中，进化计算会在一开始会产生大量的个体，但是在趋于收敛时只有一小部分的个体生成。  
遗传编程对于控制器的设计方法会在之后详述。  

### 使用遗传编程的自动控制器综合方法
这本书中的控制器设计方法包含对拓扑和器件参数两方面的设计，包括：  
- 建立一种可以被遗传编程逐步解读的个体表示的方法  
- 设计一种可以诠释高层级设计需求的适应度评估方法 

#### 遗传编程中树的进化方法
本书的作者想出了三种针对控制器设计用树形结构来表达个体的方法。  
- 第一种方法是每个个体代表一种指示构建的方法，也就是说个体并不直接操纵电路，而是将个体编写为操纵电路的指令或者程序，由翻译好的程序对电路进行搭建。在这种方法下，程序的不同部分的运行顺序需要有先后：ADF需要先运行，然后再运行主程序。  
- 第二种方法是首先考虑设计出一个基板电路(embryo，\*这里作者用了生物学的胚胎指代基板电路，那么个体的操作可以认为是对这个胚胎的发育过程，从而将胚胎发育成完全发育的结构)，这个基板电路上有一些可以被指令操纵的结点。遗传编程中的每个个体代表一种修改这个基板电路的方式。通过将程序树中的函数逐步应用于基板电路结构，从而将基板电路变成完整的可以实现功能的控制器电路。与第一种方法一样，程序中的函数按照指定的评估顺序分别执行。  
- 第三种方法是每一个树代表一种控制器电路的连接方式，函数节点为各种电路器件，从而直接将树转化为整个控制器电路。这种方法没有先后运行的顺序。  

本书在设计中用到的是第三种方法。如此，进化过程中个体会被直接翻译为控制器电路，然后带入仿真软件中运行，最后将仿真的特性作为个体的适应度。  

#### 基函数集
设计中用到的基函数及其功能如下表所示：   

| 器件 | 功能 | 数学表达 | 参数 |
|:-|:-|:-:|:-|
|`GAIN`|用一个常数放大时域信号|$Asin(ωt)$| 1. 常数 <br> 2.时域信号 |
|`INTEGRATOR`|时域上对一个信号进行积分<br>在频域上对信号乘$1/s$ | $\int Asin(ωt) ⇔\frac{1}{s}[S]_s$ | 1.时域信号 |
| `DIFFERENTIATOR` | 对时域信号作差分<br>为表示简便，在频域上对信号乘$s$ |$s[f]_s$ | 1.时域信号 |
| `ADD_SIGNAL` <br> `SUB_SIGNAL` <br> `MULT_SIGNAL` | 分别对应对信号的加减乘一个常数 |$f_1 [·] f_2$<br>$[·]∈\{+,-,×\}$| 1. 时域信号 <br> 2. 时域信号 |
| `ADD_3_SIGNAL` | 三个时域信号相加 | $f_1+f_2+f_3$ | 1. 时域信号 <br> 2. 时域信号 <br> 3.时域信号 |
| `DIFFERENTIAL_INPUT_INTEGRATOR` | 时域上对两个信号的误差积分 | $∫(f_1-f_2)dt$| 1. 时域信号 <br> 2. 时域信号 |
|`INVERTER`| 反转信号 | $-f$ | 1.时域信号 |
|`LEAD` | 频域上与$1+τs$相乘 | $(1+τs)[f]_S$ |1.时域信号 <br> 2.常数$τ$|
| `LAG` |频域上与$1/1+τs$相乘 | $\frac{1}{1+τs}[f]_S$ |1.时域信号 <br> 2.常数$τ$|
|`LAG2` |频域上与$ω_0^2/s^2+2ζω_0s+ω_0^2$相乘 | $\frac{ω_0^2}{s^2+2ζω_0s+ω_0^2}[f]_S$ |1.时域信号 <br> 2.常数$ω$<br>3.常数$ζ$|
|`ABS`|对时域信号取绝对值 |$\lvert f \rvert$ |1.时域信号 |
|`LIMITER` | 限制信号在某一区间 | $[f]_{capped}$ | 1.时域信号 <br> 2.下界 <br> 3.上界 |
|`DIV`|两个时域信号相除并限制 | $[\frac{f_1}{f_2}]_{capped}$ | 1.时域信号 <br> 2.时域信号 <br> 3下界 <br> 4.上界 |
|`DELAY`|对信号进行时延|$[f]_se^{-sT}$|1.时域信号 <br> 2.时延$T$|
|`IF_POSITIVE` |开关，运算结果为正时输出某个声明，反之输出另一个声明 | $\begin{cases} f_1, f_0>0 \\ f_2,f_0 ≤0\end{cases}$ |1. 时域信号 <br> 2. 时域信号 <br> 3.时域信号 |
|`+,-,×,÷`| 数值运算 | - | 1.常数<br>2.常数|

此外还有ADF。  

#### 端点集
端点集中包括了如下的端点：  

| 标识 | 意义 | 类型 |
|:-:|:-:|:-:|
|`REFERENCE_SIGNAL`|参考信号 | 信号 |
|`PLANT_OUTPUT`|系统原型的输出|信号|
|`CONTROLLER_OUTPUT`|控制器的输出信号|信号|
|`STATE_0`,`STATE_1`,...|系统的内部状态 | 信号|
|`CONSTANT_0`|恒定为0的信号，用于干扰遗传编程，展示用|信号|
|$\mathfrak{R}$|实数|实数|

#### 系统原型的表示
如果系统原型的结构是设计者可以了解到的，那么控制器的行为和特点可以通过仿真系统原型和控制器一并得到。如果原型结构无法被了解（\*黑盒），那么遗传编程可以根据原型的输入输出生成一个符合的系统原型，再与控制器一并仿真。  

#### 自动定义函数在设置控制器上的使用
在这个设计任务中，ADF不止可以通过重用函数来节省计算量，更重要的是ADF可以表示电路的两种结构：  
- 并联结构  
  ADF可以视作是打包好的字电路。由于重用，ADF函数的输出信号可以传递到不同的模块中，这就相当于是电路的并联。  
  <img src=https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20231220145437.png width=40%> 

  {% note info %}  
  如果不使用ADF的话，可以在函数集中添加一个表示并联的函数来实现并联。  
  {% endnote %}  

- 反馈结构  
  ADF的递归结构可以视为是将上一次ADF的输出又重新返回到ADF的输入中，这样的操作在电路中是一种内部反馈。  
  <img src=https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20231220151633.png width=40%>   

#### 调试器件参数的方法
如之前所说，对控制器的设计包括拓扑结构的设计和器件参数调试两方面。器件之间的拓扑结构可以通过树内部的端点和函数的连接来表示，但是在进化过程中演化器件拓扑结构的同时调整器件参数却并没有那么容易做到。这本书中介绍了三种进化过程中同时达成这两个目标的方法。需要注意的是，这三种方法都需要借助强类型实现。  
- 第一种方法是：使用一种专门进行算术演算的子树结构，书中称为算术子树(arithmetic-performing subtree)，这种子树结构包含多个数值运算的函数并以自然常数作为端点。

- 第二种方法是，子树中直接将可扰数值(perturbable numberical value)作为一个节点。  

- 第三种方法是算术子树中的端点都为可扰数值。

书中还提到了一种称为非线性映射(NLM,none-linear mapping)的方法来表示算术子树的结果。对数形式的非线性映射可使相差几个数量级的常数得到有效进化。除非另有说明，本书中使用的非线性映射将-5到5之间的数值转换为超过 10 个数量级的数字。  
一个非线性映射函数的例子如下：  
$$NLM(x)=\begin{cases}
  10^0,\text{ if }x<-100\\
  10^{-\frac{100}{19}-\frac{1}{19}x},\text{ if }-100≤x<-5\\
  10^x,\text{ if }-5≤x≤5\\
  10^{\frac{100}{19}-\frac{1}{19}x},\text{ if }5<x≤100\\
  10^0,\text{ if }x>100\\
\end{cases}$$
从图像上可以看出，这个函数的作用是成倍放大-5到5之间的$x$的值。  
<img src=https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20231220155339.png width=40%> 


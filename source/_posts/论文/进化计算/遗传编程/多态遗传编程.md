---
title: PolyGP：一种多态遗传编程
date: 2024/02/7
category_bar: true
categories: 
- 论文
- 进化计算
- 遗传编程
---
# PolyGP：一种多态遗传编程
PolyGP是由Tina Yu和Chris Clack[^1]共同设计的一种遗传编程算法。PolyGP借用了STGP[^2]中的参数多态的思想并进一步延伸，并使用了Robinson的合一算法(Unification Algorithm)[^3]改进了STGP中创建个体为了符合类型合法而导致的链表式结构的问题。PolyGP中最大的改动是将Koza的标准遗传算法中的个体表示从LISP语言的S-expression迁移到了Lambda演算(λ-calculus)中，并依据科里化(Currying)的个体结构将交叉迁移到了新的表现形式中。这些改动使得遗传编程可以真正学习程序的结构而不受变量和变量类型的限制。  
[^1]: Tina Yu, Chris Clack., PolyGP: A Polymorphic Genetic Programming System in Haskell, 1998.  
[^2]: David J. Montana, Strongly Typed Genetic Programming, 1995.  
[^3]: Robinson, J. A. (1965). A machine-oriented logic based on the resolution principle. Journal of the ACM (JACM), 12(1), 23-41.  

## 背景知识
### 多态
多态(Polymorphism)是编程的一种程序特性，是指为不同的数据类型实体提供统一的接口，或者用单一的符号来表示不同的类型。多态有特设多态、参数多态和子类型三种。此处PolyGP和前身STGP使用的是参数多态(Parametric Polymorphism)，指的是一个类型或者多个类型不靠名字而是靠可以标志任何类型的抽象符号。在PolyGP中，多态指的是一个函数可以接受多种类型作为函数的输入(声明)或者接受多种类型作为函数的输出。  
传统的模块化遗传编程的方法比如Koza的ADF及其后续的EDF、ARL都是单态的，每一个封装好的模块函数中的每一个声明或者返回只能支持一种特定的类型，比如`void mono_func_demo(int,char)`。而PolyGP和STGP中的函数中每一个声明或者返回都支持多种可能的类型，比如`{int, char} poly_func_demo({str,int},{float,str,int})`。


### Lambda演算[^4]
Lambda演算(λ-calculus)是一种在结构上极其简单的编程语言。  
[^4]: Rual Rojas, A Tutorial Introduction to the Lambda Calculus, 2015.  

Lambda演算由变换规则(transformation rule)和单函数定义(single function defination)两部分组成，任何可计算的函数都可以用这种方法进行表示，其类似于图灵机(Turing machine)，但是相比于图灵机更强调变换规则的使用。变换规则利用了编程中替换(substitution)的思想。  

#### 表示
要解释变换规则，首先需要了解Lambda演算中的表示(expression)。表示是Lambda演算中的计算实体，它可以是一个变量或者是函数。Lambda演算的表示可以通过如下的递归进行定义：    

```
<expression> := <name>|<function>|<application>
<function> := λ<name>.<expression>
<application> := <expression><expression>
```
在Lambda演算中，称变量为`name`——它只是一个用于描述的名字，没有任何作用能力。  
Lambda演算中不同成员之间的交互依赖于函数`function`，任何感兴趣的单位都可以被视为函数，如此这些单位将具有使用变换规则的能力。函数表示为`λ<name>.<expression>`，其中`.`之前的是函数的声明变量，由`λ`限定表示这个变量是该函数的“自变量”，后面的表示`expression`则是函数体的body部分，描述函数的行为。  
应用`application`是变换规则的具体化，`<application> := <expression1><expression2>`的表示相当于是把`expression2`的结果带入`expression1`中。  
比如下面的例子：  
$$(λx.x)y$$
实际上相当于是将变量$y$带入到以$x$作为自变量的函数中，因此这个应用的结果是将$y$替换$x$，得到最后的函数结果为$x$。有时候，这样的替换也可以简单表示为$[y/x]x$。  
函数的推演过程用$→$表示，因此上述应用的计算过程可以表示为：
$$(λx.x)y→λy.y→y$$

#### 自由变量
Lambda演算中所有的`<name>`对函数而言都是本地变量，函数中那些没有被`λ`限制的变量称为自由变量(free variable)，例如：$(λx.xy)$中$y$是自由变量。  
在如下的情况中`<name>`是一个自由变量：  
- `<name>`单独存在，比如$a$在$a$中是自由变量。  
- `<function>`中没有被$λ$固定。  
- 对于`<application>`，如果一个变量在前后任意一个`<expression>`中是自由变量，那么其在`<application>`中也是自由变量。  

#### 替换
替换是应用的化简原则，其规则是：  
对于`<application> := <expression1><expression2>`，将`<expression1>`中所有的自由变量用`<expression2>`替换。如果`<expression1>`中用`λ`固定的部分与`<expression2>`重名，那么则需要改名。  
下面举了一个推演`<application>`的例子：  
$$(λx.(λy.xy))y→(λy.(λy.xy))→(λy.(λt.xt))→(λt.yt)$$
<img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20240207133137.png width=50%>  

### 科里化
柯里化(Currying)是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。 在直觉上，柯里化声称「如果你固定某些参数，你将得到接受余下参数的一个函数」。所以对于有两个变量的函数，如果固定了一个变量，就得到有一个变量的函数。 柯里化在理论计算机科学中提供了一种研究带有多个参数的函数的方式，尤其在只接受一个单一参数的lambda演算中。
例如，以下是一个柯里化的示例函数：

```javascript
var foo = function(a) {
    return function(b) {
        return a * a + b * b;
    }
}

// 调用上述函数：
var result = foo(3)(4); // 结果为 25
```

<img src=https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20240207183428.png width=60%>  


### 有类型的Lambda演算
标准的Lambda演算是没有数据类型的，但是后续有若干学者用各种方式实现了有类型的Lambda演算(Typed Lambda calculus)。PolyGP中使用的是Milner的有类型的Lambda演算方式[^5]。  
[^5]: R.Milner. A Theory of Type Polymorphism in Programming. Journal of Computer and System Sciences, 1978.  

在这种方法中，`name`、`function`和`expression`都具有类型，`function`和`expression`的类型表示为：  
$$F1^{σ1→σ2}$$
其中，$σ1$表示的是函数的声明类型；$σ2$表示的是函数的返回类型。  
PolyGP的论文中使用了科里化的表示方法：  
$$(F1^{σ1→σ2} ARG1^{σ1})^{σ2}$$
其中$ARG1$是函数$F1$的声明。  
使用科里化的表示方法的目的是为了更好的表示有多个声明的函数，如下面的函数$F2$拥有两个声明$ARG1$和$ARG2$，其类型分别为$σ1$和$σ2$，函数的返回类型为$σ3$，简单表示为：  
$$F2^{σ1→σ2→σ3}$$
展开表示为：  
$$((F2^{σ1→σ2→σ3} ARG1^{σ1})^{σ2→σ3} ARG2^{σ2})^{σ3}$$

函数的嵌套需要满足**子函数的返回类型应该是父函数的声明类型，如此才满足合法性**。比如上面的函数$F1$的返回类型正好满足$F2$中$ARG2$的类型，因此可以实现$F2$中嵌套$F1$：  
$$((F2^{σ1→σ2→σ3} ARG1^{σ1})^{σ2→σ3} (F1^{σ1→σ2} ARG1^{σ1})^{σ2})^{σ3}$$

这种表示方法可以被转换为树形结构，下图展示了上面的三个例子是如何被树形结构化的：  

<img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20240207141506.png width=50%>  


## 算法结构
PolyGP相比于标准GP最大的改进在于引入了类型系统(type system)，在种群初始化和遗传操作（下图中的evolvor和creator）两个阶段中用于保证所有的个体都是类型合法的。  
<img src=https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20240207162313.png width=40%>   

### 种群初始化与个体表示
PolyGP中的个体表示为有类型的lambda演算的函数。种群初始化的过程中调用了类型系统来检查类的合法性，简单来说，和STGP一样，个体要求其父函数的声明的类型与子函数的返回的类型相同。  



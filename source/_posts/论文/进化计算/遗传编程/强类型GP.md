---
title: 强类型遗传编程
date: 2024/01/30
category_bar: true
categories: 
- 论文
- 进化计算
- 遗传编程
---
# 强类型遗传编程
> D. J. Montana, "Strongly Typed Genetic Programming," in Evolutionary Computation, vol. 3, no. 2, pp. 199-230, June 1995, doi: 10.1162/evco.1995.3.2.199.  

强类型遗传编程(Strongly Typed Genetic Programming, STGP)是一种改进的遗传编程算法。它对遗传编程的改进有两点：  
- STGP中对函数的声明和返回进行了类型限制
- 引入了泛化类型（Generic Type，简称泛型）和泛化函数(Generic Function, 简称泛函)  

## 问题动机
在标准的遗传编程中，其假设了一种封闭性(closure)：任何函数都可以处理来自其他函数和端点的返回值类型。这种封闭性的设计让遗传编程并不适合处理混合的数据类型，且会损害遗传编程的性能。  
- 函数集和端点集的设计  
在过去，Koza非常小心的定义了函数集和端点集，以减少这种限制性。比如在布尔函数的设计上，为了避免返回产生布尔类型的数值，Koza直接将判断语句整合进了函数，使用了类似IF-LESS-THAN来替代LESS-THAN之类的函数，如此判断语句并不会单独返回布尔类型。但是这种方式的使用条件比较局限，并不是所有的函数都可以通过很小心的设计来绕开使用或者返回多种数据类型。  
- 动态类型  
第二种方式是使用动态类型(dynamic type)，让函数强制兼容不同的类型。这种动态类型的实现方式有两种，第一是参数多态(parametric polymorphism)，也就是同一个函数根据不同的参数类型执行不同的操作并且返回不同的类型的值；第二种方法是当函数出现类型错误时，让函数返回Flag标识并在评估个体时给予高惩罚。  
第一种方法在问题符合自然逻辑的情况下表现较好，比如让函数同时支持复数和实数的计算，可以将实数看做是虚部为0的复数。但是对于那些不符合自然逻辑的函数设计，有时候即便是可行，也不太可能将不同类型的变量泛化为新的数据类型的一部分。（比如上面例子中将实数泛化为复数）  
此外，设置错误标识是保证动态类型的函数可以强制兼容非法的类型，但是这样做会花费过多额外的开销在那些类型非法的个体上。  
- 强类型  
第三种解决标准遗传编程封闭性的方法是使用强类型(constrained types)，限制突变操作始终生成合法的树。在Koza版本的遗传编程的“高级功能”中，Koza指定了每一个函数所支持使用的端点集。  

STGP借用了强类型这一思想，但是和Koza的版本不同的是，STGP中并非为每一个函数指定适合的端点集，而是指定了每一个函数的声明和返回的类型，通过指定类型来限制语法合规。这样做的好处是面对更加复杂的问题时无需为每一个函数都分别指定端点集，免去了这部分所需要的先验知识。  
<img src=https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20240130144137.png width=60%>   
(左：Koza的强类型，右：STGP的强类型)  

与之出现的新问题是，有一些函数的表现相同，但是需要支持的输入或者返回的类型不同。比如VECTOR_ADD_3表示1×3的向量相加，而VECTOR_ADD_4表示1×4的向量相加，同样是向量加法，但是因为输入的数据类型不同而需要反复定义功能类似的函数。为了避免这个问题，改进的STGP中引入了泛型和泛函。引入泛型和泛函的另一个动机是为了让程序可以通过创造小的程序逐步累计来创造足够大和复杂的程序。泛函可以作用于相对广泛的类型上，这样有利于代码重用。  

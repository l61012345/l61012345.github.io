---
title: 遗传编程中的自动定义函数
date: 2023/12/07
category_bar: true
categories: 
- 论文
- 进化计算
---

# 遗传编程中的自动定义函数

{% note info %}  
参考资料：  
John R Koza *et al*., Non-linear Genetic Process for Data Encoding and for Solving Problems Using Automatically Defined Functions, 1994.  
John R Koza, Genetic Programming IV: Routine Human-Competitive Machine Intelligence, 2002.   
John R Koza, Genetic programming III: Darwinian invention and problem solving, 1999.  
John R Koza *et al*., Resue, Parameterized Resue, and Hierarchical Reuse of Substructures in Evolving Electrical Circuits Using Genetic Programming, 1996.  
Cândida Ferreira, Gene Expression Programming: Mathematical Modeling by an Artificial Intelligence, 2006.  
{% endnote %}  

{% note info %}  
GP和GEP中都有自动定义函数的机制，此处介绍的是Koza等人最初在遗传编程中提出的自动定义函数机制。  
{% endnote %}  
{% note info %}  
此处用“自动定义函数”表示这种机制，用“ADF”表示用这种机制产生的函数。  
{% endnote %}

## 简介
许多计算机程序中都会有重复使用的程序结构，这些反复出现的结构可以被定义为一些包含形式参数(formal parameter)的函数，并在程序主函数中被调用，如此可以减少代码的长度。基于这样的思想，遗传编程(Genetic Programming, GP)中提出了自动定义函数(Automatically Defined Function, ADF)的机制，以减少不必要的计算量。  
自动定义函数是一种参数化的、可以被层级结构组织并且反复使用的函数，它在进化的过程中随着整个种群共同进化。ADF作为一种特殊的函数被添加到构成种群个体的函数集(function set)中，和其他函数集中的函数一样被随机选择形成个体。在进化的评估(evaluation)阶段，含有ADF的个体会通过在树形结构被转义为计算机程序时通过调用函数(calling function)在相应的位置调用自动定义函数，并将ADF下层的端点和函数作为ADF的实际参数(practical parameter)引入到ADF中。  
实验证明，引入自动定义函数机制后，计算量显著减少，并且个体的大小得到控制。  

## ADF的组织方式
### 含有ADF的个体结构
Koza等人在[^1]中定义了外部调用实体(external invoked entity)和内部调用实体(internal invoked entity)。外部调用实体指的是整个个体转义后得到的程序，它由若干个基函数(primitive function)，也就是用于生成初始种群的函数集中的函数、内部调用函数和端点组成，并且在使用内部调用函数的前提下，函数之间还具有一定的层级关系。  
内部调用函数在这里指ADF，包括了基函数，形式参数(这里称之为dummy vairable)和可能的其他（或者自己，如此将形成递归）的内部调用函数。  
按照功能划分，Koza等人在[^1]中由把含有ADF的个体结构分为两个部分：  
第一段是结果生成部件(result-producing component)，这个部分可以看做是一个计算机程序的主函数，运行之后会产生相应的结果。一个个体需要产生多少个结果就需要拥有多少个结果生成部件，且至少需要一个结果生成部件以便进行评估。  
第二段是函数定义部件(function-defining component)，这个部件用于生成ADF。  
这两个部分通过连接函数进行连接，使得它们形成一个整体。由于最早的遗传编程的目的是为了自动生成LISP语言的程序，因此最早Koza等人使用的连接函数是LISP语言中的`PROGN` 函数，它的作用是将若干个函数一并运行。  

{% note info %}  
需要注意的是，连接函数(linking function)这个概念是在GEP中被正式提出的，此处Koza等人使用`PROGN`函数组织个体的想法基本接近连接函数这个概念。  
{% endnote %}  

> LISP语言中`PROGN`函数的使用可以参考：[Blasting the PROG feature in Common LISP](https://www.cs.drexel.edu/~popyack/Courses/AI/Su12/extras/LISP/PROG_LISP.html)


[^1]: John R Koza *et al*., Non-linear Genetic Process for Data Encoding and for Solving Problems Using Automatically Defined Functions, 1994.  

在使用带有自动定义函数机制的遗传编程算法时，**个体的拓扑结构需要被提前确定**。具体而言，一个个体转义出来的程序中有几个结果生成部件和函数定义部件，以及彼此内部的层级关系是需要被提前确定的。  
{% note info %}    
在结构变换操作(Architecture-altering Operation)加入之后，还可以用结构变换操作自动决定ADF的个数（也就是进化中会自我淘汰一部分ADF的子树结构）。   
{% endnote %}

### ADF的结构
由于ADF具有强类型(constrained type)特点，因此不同的ADF可能由不同的函数集和端点集生成。每一个ADF的结构包括三个部分：  
- ADF的函数名
- 形式参数集合，这个集合用于替代端点集生成ADF树形结构的端点。形式参数集合中形式参数的个数和具体哪一个形式参数会被用于生成某个特定的ADF都需要在运行前被提前指定。  
- ADF具体的内容，表征为树形结构。  

三个部分在LISP语言中通过`DEFUN`这个函数作为连接函数进行连接。  

下图展示了一个使用ADF函数的个体的树形结构（左）和程序框架（右）的例子。  
<img src = https://cdn.jsdelivr.net/gh/l61012345/Pic/img/20231207193952.png width=80%>    

### ADF的生成
尽管无需对生成的ADF的大小和结构做提前定义，但是在使用ADF机制时需要提前定义每个ADF中包含的形式参数数量和具体所使用的形式参数。  
需要注意的是，**指定的形式参数未必会真的被使用到某个ADF结构中**，某个形式参数使用与否是由进化过程真正决定的。   

## ADF的进化
### 个体评估中ADF的调用

### 类保护的交叉和变异

## ADF的实现
### 避免递归的实现方式

## 评价

